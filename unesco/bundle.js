(function() {
    function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    }
    return e
})()({
    1: [function(require, module, exports) {
        (function(global) {
            "use strict";
            require("core-js/shim");
            require("regenerator-runtime/runtime");
            require("core-js/fn/regexp/escape");
            if (global._babelPolyfill) {
                throw new Error("only one instance of babel-polyfill is allowed")
            }
            global._babelPolyfill = true;
            var DEFINE_PROPERTY = "defineProperty";

            function define(O, key, value) {
                O[key] || Object[DEFINE_PROPERTY](O, key, {
                    writable: true,
                    configurable: true,
                    value: value
                })
            }
            define(String.prototype, "padLeft", "".padStart);
            define(String.prototype, "padRight", "".padEnd);
            "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(key) {
                [][key] && define(Array, key, Function.call.bind([][key]))
            })
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
        "core-js/fn/regexp/escape": 2,
        "core-js/shim": 325,
        "regenerator-runtime/runtime": 328
    }],
    2: [function(require, module, exports) {
        require("../../modules/core.regexp.escape");
        module.exports = require("../../modules/_core").RegExp.escape
    }, {
        "../../modules/_core": 23,
        "../../modules/core.regexp.escape": 128
    }],
    3: [function(require, module, exports) {
        module.exports = function(it) {
            if (typeof it != "function") throw TypeError(it + " is not a function!");
            return it
        }
    }, {}],
    4: [function(require, module, exports) {
        var cof = require("./_cof");
        module.exports = function(it, msg) {
            if (typeof it != "number" && cof(it) != "Number") throw TypeError(msg);
            return +it
        }
    }, {
        "./_cof": 18
    }],
    5: [function(require, module, exports) {
        var UNSCOPABLES = require("./_wks")("unscopables");
        var ArrayProto = Array.prototype;
        if (ArrayProto[UNSCOPABLES] == undefined) require("./_hide")(ArrayProto, UNSCOPABLES, {});
        module.exports = function(key) {
            ArrayProto[UNSCOPABLES][key] = true
        }
    }, {
        "./_hide": 42,
        "./_wks": 126
    }],
    6: [function(require, module, exports) {
        module.exports = function(it, Constructor, name, forbiddenField) {
            if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
                throw TypeError(name + ": incorrect invocation!")
            }
            return it
        }
    }, {}],
    7: [function(require, module, exports) {
        var isObject = require("./_is-object");
        module.exports = function(it) {
            if (!isObject(it)) throw TypeError(it + " is not an object!");
            return it
        }
    }, {
        "./_is-object": 51
    }],
    8: [function(require, module, exports) {
        "use strict";
        var toObject = require("./_to-object");
        var toAbsoluteIndex = require("./_to-absolute-index");
        var toLength = require("./_to-length");
        module.exports = [].copyWithin || function copyWithin(target, start) {
            var O = toObject(this);
            var len = toLength(O.length);
            var to = toAbsoluteIndex(target, len);
            var from = toAbsoluteIndex(start, len);
            var end = arguments.length > 2 ? arguments[2] : undefined;
            var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
            var inc = 1;
            if (from < to && to < from + count) {
                inc = -1;
                from += count - 1;
                to += count - 1
            }
            while (count-- > 0) {
                if (from in O) O[to] = O[from];
                else delete O[to];
                to += inc;
                from += inc
            }
            return O
        }
    }, {
        "./_to-absolute-index": 111,
        "./_to-length": 115,
        "./_to-object": 116
    }],
    9: [function(require, module, exports) {
        "use strict";
        var toObject = require("./_to-object");
        var toAbsoluteIndex = require("./_to-absolute-index");
        var toLength = require("./_to-length");
        module.exports = function fill(value) {
            var O = toObject(this);
            var length = toLength(O.length);
            var aLen = arguments.length;
            var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
            var end = aLen > 2 ? arguments[2] : undefined;
            var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
            while (endPos > index) O[index++] = value;
            return O
        }
    }, {
        "./_to-absolute-index": 111,
        "./_to-length": 115,
        "./_to-object": 116
    }],
    10: [function(require, module, exports) {
        var forOf = require("./_for-of");
        module.exports = function(iter, ITERATOR) {
            var result = [];
            forOf(iter, false, result.push, result, ITERATOR);
            return result
        }
    }, {
        "./_for-of": 39
    }],
    11: [function(require, module, exports) {
        var toIObject = require("./_to-iobject");
        var toLength = require("./_to-length");
        var toAbsoluteIndex = require("./_to-absolute-index");
        module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
                var O = toIObject($this);
                var length = toLength(O.length);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                    while (length > index) {
                        value = O[index++];
                        if (value != value) return true
                    } else
                        for (; length > index; index++)
                            if (IS_INCLUDES || index in O) {
                                if (O[index] === el) return IS_INCLUDES || index || 0
                            }
                return !IS_INCLUDES && -1
            }
        }
    }, {
        "./_to-absolute-index": 111,
        "./_to-iobject": 114,
        "./_to-length": 115
    }],
    12: [function(require, module, exports) {
        var ctx = require("./_ctx");
        var IObject = require("./_iobject");
        var toObject = require("./_to-object");
        var toLength = require("./_to-length");
        var asc = require("./_array-species-create");
        module.exports = function(TYPE, $create) {
            var IS_MAP = TYPE == 1;
            var IS_FILTER = TYPE == 2;
            var IS_SOME = TYPE == 3;
            var IS_EVERY = TYPE == 4;
            var IS_FIND_INDEX = TYPE == 6;
            var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
            var create = $create || asc;
            return function($this, callbackfn, that) {
                var O = toObject($this);
                var self = IObject(O);
                var f = ctx(callbackfn, that, 3);
                var length = toLength(self.length);
                var index = 0;
                var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
                var val, res;
                for (; length > index; index++)
                    if (NO_HOLES || index in self) {
                        val = self[index];
                        res = f(val, index, O);
                        if (TYPE) {
                            if (IS_MAP) result[index] = res;
                            else if (res) switch (TYPE) {
                                case 3:
                                    return true;
                                case 5:
                                    return val;
                                case 6:
                                    return index;
                                case 2:
                                    result.push(val)
                            } else if (IS_EVERY) return false
                        }
                    }
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result
            }
        }
    }, {
        "./_array-species-create": 15,
        "./_ctx": 25,
        "./_iobject": 47,
        "./_to-length": 115,
        "./_to-object": 116
    }],
    13: [function(require, module, exports) {
        var aFunction = require("./_a-function");
        var toObject = require("./_to-object");
        var IObject = require("./_iobject");
        var toLength = require("./_to-length");
        module.exports = function(that, callbackfn, aLen, memo, isRight) {
            aFunction(callbackfn);
            var O = toObject(that);
            var self = IObject(O);
            var length = toLength(O.length);
            var index = isRight ? length - 1 : 0;
            var i = isRight ? -1 : 1;
            if (aLen < 2)
                for (;;) {
                    if (index in self) {
                        memo = self[index];
                        index += i;
                        break
                    }
                    index += i;
                    if (isRight ? index < 0 : length <= index) {
                        throw TypeError("Reduce of empty array with no initial value")
                    }
                }
            for (; isRight ? index >= 0 : length > index; index += i)
                if (index in self) {
                    memo = callbackfn(memo, self[index], index, O)
                }
            return memo
        }
    }, {
        "./_a-function": 3,
        "./_iobject": 47,
        "./_to-length": 115,
        "./_to-object": 116
    }],
    14: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var isArray = require("./_is-array");
        var SPECIES = require("./_wks")("species");
        module.exports = function(original) {
            var C;
            if (isArray(original)) {
                C = original.constructor;
                if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = undefined;
                if (isObject(C)) {
                    C = C[SPECIES];
                    if (C === null) C = undefined
                }
            }
            return C === undefined ? Array : C
        }
    }, {
        "./_is-array": 49,
        "./_is-object": 51,
        "./_wks": 126
    }],
    15: [function(require, module, exports) {
        var speciesConstructor = require("./_array-species-constructor");
        module.exports = function(original, length) {
            return new(speciesConstructor(original))(length)
        }
    }, {
        "./_array-species-constructor": 14
    }],
    16: [function(require, module, exports) {
        "use strict";
        var aFunction = require("./_a-function");
        var isObject = require("./_is-object");
        var invoke = require("./_invoke");
        var arraySlice = [].slice;
        var factories = {};
        var construct = function(F, len, args) {
            if (!(len in factories)) {
                for (var n = [], i = 0; i < len; i++) n[i] = "a[" + i + "]";
                factories[len] = Function("F,a", "return new F(" + n.join(",") + ")")
            }
            return factories[len](F, args)
        };
        module.exports = Function.bind || function bind(that) {
            var fn = aFunction(this);
            var partArgs = arraySlice.call(arguments, 1);
            var bound = function() {
                var args = partArgs.concat(arraySlice.call(arguments));
                return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that)
            };
            if (isObject(fn.prototype)) bound.prototype = fn.prototype;
            return bound
        }
    }, {
        "./_a-function": 3,
        "./_invoke": 46,
        "./_is-object": 51
    }],
    17: [function(require, module, exports) {
        var cof = require("./_cof");
        var TAG = require("./_wks")("toStringTag");
        var ARG = cof(function() {
            return arguments
        }()) == "Arguments";
        var tryGet = function(it, key) {
            try {
                return it[key]
            } catch (e) {}
        };
        module.exports = function(it) {
            var O, T, B;
            return it === undefined ? "Undefined" : it === null ? "Null" : typeof(T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B
        }
    }, {
        "./_cof": 18,
        "./_wks": 126
    }],
    18: [function(require, module, exports) {
        var toString = {}.toString;
        module.exports = function(it) {
            return toString.call(it).slice(8, -1)
        }
    }, {}],
    19: [function(require, module, exports) {
        "use strict";
        var dP = require("./_object-dp").f;
        var create = require("./_object-create");
        var redefineAll = require("./_redefine-all");
        var ctx = require("./_ctx");
        var anInstance = require("./_an-instance");
        var forOf = require("./_for-of");
        var $iterDefine = require("./_iter-define");
        var step = require("./_iter-step");
        var setSpecies = require("./_set-species");
        var DESCRIPTORS = require("./_descriptors");
        var fastKey = require("./_meta").fastKey;
        var validate = require("./_validate-collection");
        var SIZE = DESCRIPTORS ? "_s" : "size";
        var getEntry = function(that, key) {
            var index = fastKey(key);
            var entry;
            if (index !== "F") return that._i[index];
            for (entry = that._f; entry; entry = entry.n) {
                if (entry.k == key) return entry
            }
        };
        module.exports = {
            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                var C = wrapper(function(that, iterable) {
                    anInstance(that, C, NAME, "_i");
                    that._t = NAME;
                    that._i = create(null);
                    that._f = undefined;
                    that._l = undefined;
                    that[SIZE] = 0;
                    if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that)
                });
                redefineAll(C.prototype, {
                    clear: function clear() {
                        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
                            entry.r = true;
                            if (entry.p) entry.p = entry.p.n = undefined;
                            delete data[entry.i]
                        }
                        that._f = that._l = undefined;
                        that[SIZE] = 0
                    },
                    delete: function(key) {
                        var that = validate(this, NAME);
                        var entry = getEntry(that, key);
                        if (entry) {
                            var next = entry.n;
                            var prev = entry.p;
                            delete that._i[entry.i];
                            entry.r = true;
                            if (prev) prev.n = next;
                            if (next) next.p = prev;
                            if (that._f == entry) that._f = next;
                            if (that._l == entry) that._l = prev;
                            that[SIZE]--
                        }
                        return !!entry
                    },
                    forEach: function forEach(callbackfn) {
                        validate(this, NAME);
                        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
                        var entry;
                        while (entry = entry ? entry.n : this._f) {
                            f(entry.v, entry.k, this);
                            while (entry && entry.r) entry = entry.p
                        }
                    },
                    has: function has(key) {
                        return !!getEntry(validate(this, NAME), key)
                    }
                });
                if (DESCRIPTORS) dP(C.prototype, "size", {
                    get: function() {
                        return validate(this, NAME)[SIZE]
                    }
                });
                return C
            },
            def: function(that, key, value) {
                var entry = getEntry(that, key);
                var prev, index;
                if (entry) {
                    entry.v = value
                } else {
                    that._l = entry = {
                        i: index = fastKey(key, true),
                        k: key,
                        v: value,
                        p: prev = that._l,
                        n: undefined,
                        r: false
                    };
                    if (!that._f) that._f = entry;
                    if (prev) prev.n = entry;
                    that[SIZE]++;
                    if (index !== "F") that._i[index] = entry
                }
                return that
            },
            getEntry: getEntry,
            setStrong: function(C, NAME, IS_MAP) {
                $iterDefine(C, NAME, function(iterated, kind) {
                    this._t = validate(iterated, NAME);
                    this._k = kind;
                    this._l = undefined
                }, function() {
                    var that = this;
                    var kind = that._k;
                    var entry = that._l;
                    while (entry && entry.r) entry = entry.p;
                    if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
                        that._t = undefined;
                        return step(1)
                    }
                    if (kind == "keys") return step(0, entry.k);
                    if (kind == "values") return step(0, entry.v);
                    return step(0, [entry.k, entry.v])
                }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                setSpecies(NAME)
            }
        }
    }, {
        "./_an-instance": 6,
        "./_ctx": 25,
        "./_descriptors": 29,
        "./_for-of": 39,
        "./_iter-define": 55,
        "./_iter-step": 57,
        "./_meta": 65,
        "./_object-create": 70,
        "./_object-dp": 71,
        "./_redefine-all": 90,
        "./_set-species": 97,
        "./_validate-collection": 123
    }],
    20: [function(require, module, exports) {
        var classof = require("./_classof");
        var from = require("./_array-from-iterable");
        module.exports = function(NAME) {
            return function toJSON() {
                if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
                return from(this)
            }
        }
    }, {
        "./_array-from-iterable": 10,
        "./_classof": 17
    }],
    21: [function(require, module, exports) {
        "use strict";
        var redefineAll = require("./_redefine-all");
        var getWeak = require("./_meta").getWeak;
        var anObject = require("./_an-object");
        var isObject = require("./_is-object");
        var anInstance = require("./_an-instance");
        var forOf = require("./_for-of");
        var createArrayMethod = require("./_array-methods");
        var $has = require("./_has");
        var validate = require("./_validate-collection");
        var arrayFind = createArrayMethod(5);
        var arrayFindIndex = createArrayMethod(6);
        var id = 0;
        var uncaughtFrozenStore = function(that) {
            return that._l || (that._l = new UncaughtFrozenStore)
        };
        var UncaughtFrozenStore = function() {
            this.a = []
        };
        var findUncaughtFrozen = function(store, key) {
            return arrayFind(store.a, function(it) {
                return it[0] === key
            })
        };
        UncaughtFrozenStore.prototype = {
            get: function(key) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) return entry[1]
            },
            has: function(key) {
                return !!findUncaughtFrozen(this, key)
            },
            set: function(key, value) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) entry[1] = value;
                else this.a.push([key, value])
            },
            delete: function(key) {
                var index = arrayFindIndex(this.a, function(it) {
                    return it[0] === key
                });
                if (~index) this.a.splice(index, 1);
                return !!~index
            }
        };
        module.exports = {
            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                var C = wrapper(function(that, iterable) {
                    anInstance(that, C, NAME, "_i");
                    that._t = NAME;
                    that._i = id++;
                    that._l = undefined;
                    if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that)
                });
                redefineAll(C.prototype, {
                    delete: function(key) {
                        if (!isObject(key)) return false;
                        var data = getWeak(key);
                        if (data === true) return uncaughtFrozenStore(validate(this, NAME))["delete"](key);
                        return data && $has(data, this._i) && delete data[this._i]
                    },
                    has: function has(key) {
                        if (!isObject(key)) return false;
                        var data = getWeak(key);
                        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
                        return data && $has(data, this._i)
                    }
                });
                return C
            },
            def: function(that, key, value) {
                var data = getWeak(anObject(key), true);
                if (data === true) uncaughtFrozenStore(that).set(key, value);
                else data[that._i] = value;
                return that
            },
            ufstore: uncaughtFrozenStore
        }
    }, {
        "./_an-instance": 6,
        "./_an-object": 7,
        "./_array-methods": 12,
        "./_for-of": 39,
        "./_has": 41,
        "./_is-object": 51,
        "./_meta": 65,
        "./_redefine-all": 90,
        "./_validate-collection": 123
    }],
    22: [function(require, module, exports) {
        "use strict";
        var global = require("./_global");
        var $export = require("./_export");
        var redefine = require("./_redefine");
        var redefineAll = require("./_redefine-all");
        var meta = require("./_meta");
        var forOf = require("./_for-of");
        var anInstance = require("./_an-instance");
        var isObject = require("./_is-object");
        var fails = require("./_fails");
        var $iterDetect = require("./_iter-detect");
        var setToStringTag = require("./_set-to-string-tag");
        var inheritIfRequired = require("./_inherit-if-required");
        module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
            var Base = global[NAME];
            var C = Base;
            var ADDER = IS_MAP ? "set" : "add";
            var proto = C && C.prototype;
            var O = {};
            var fixMethod = function(KEY) {
                var fn = proto[KEY];
                redefine(proto, KEY, KEY == "delete" ? function(a) {
                    return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a)
                } : KEY == "has" ? function has(a) {
                    return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a)
                } : KEY == "get" ? function get(a) {
                    return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a)
                } : KEY == "add" ? function add(a) {
                    fn.call(this, a === 0 ? 0 : a);
                    return this
                } : function set(a, b) {
                    fn.call(this, a === 0 ? 0 : a, b);
                    return this
                })
            };
            if (typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function() {
                    (new C).entries().next()
                }))) {
                C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
                redefineAll(C.prototype, methods);
                meta.NEED = true
            } else {
                var instance = new C;
                var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                var THROWS_ON_PRIMITIVES = fails(function() {
                    instance.has(1)
                });
                var ACCEPT_ITERABLES = $iterDetect(function(iter) {
                    new C(iter)
                });
                var BUGGY_ZERO = !IS_WEAK && fails(function() {
                    var $instance = new C;
                    var index = 5;
                    while (index--) $instance[ADDER](index, index);
                    return !$instance.has(-0)
                });
                if (!ACCEPT_ITERABLES) {
                    C = wrapper(function(target, iterable) {
                        anInstance(target, C, NAME);
                        var that = inheritIfRequired(new Base, target, C);
                        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
                        return that
                    });
                    C.prototype = proto;
                    proto.constructor = C
                }
                if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                    fixMethod("delete");
                    fixMethod("has");
                    IS_MAP && fixMethod("get")
                }
                if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
                if (IS_WEAK && proto.clear) delete proto.clear
            }
            setToStringTag(C, NAME);
            O[NAME] = C;
            $export($export.G + $export.W + $export.F * (C != Base), O);
            if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
            return C
        }
    }, {
        "./_an-instance": 6,
        "./_export": 33,
        "./_fails": 35,
        "./_for-of": 39,
        "./_global": 40,
        "./_inherit-if-required": 45,
        "./_is-object": 51,
        "./_iter-detect": 56,
        "./_meta": 65,
        "./_redefine": 91,
        "./_redefine-all": 90,
        "./_set-to-string-tag": 98
    }],
    23: [function(require, module, exports) {
        var core = module.exports = {
            version: "2.5.3"
        };
        if (typeof __e == "number") __e = core
    }, {}],
    24: [function(require, module, exports) {
        "use strict";
        var $defineProperty = require("./_object-dp");
        var createDesc = require("./_property-desc");
        module.exports = function(object, index, value) {
            if (index in object) $defineProperty.f(object, index, createDesc(0, value));
            else object[index] = value
        }
    }, {
        "./_object-dp": 71,
        "./_property-desc": 89
    }],
    25: [function(require, module, exports) {
        var aFunction = require("./_a-function");
        module.exports = function(fn, that, length) {
            aFunction(fn);
            if (that === undefined) return fn;
            switch (length) {
                case 1:
                    return function(a) {
                        return fn.call(that, a)
                    };
                case 2:
                    return function(a, b) {
                        return fn.call(that, a, b)
                    };
                case 3:
                    return function(a, b, c) {
                        return fn.call(that, a, b, c)
                    }
            }
            return function() {
                return fn.apply(that, arguments)
            }
        }
    }, {
        "./_a-function": 3
    }],
    26: [function(require, module, exports) {
        "use strict";
        var fails = require("./_fails");
        var getTime = Date.prototype.getTime;
        var $toISOString = Date.prototype.toISOString;
        var lz = function(num) {
            return num > 9 ? num : "0" + num
        };
        module.exports = fails(function() {
            return $toISOString.call(new Date(-5e13 - 1)) != "0385-07-25T07:06:39.999Z"
        }) || !fails(function() {
            $toISOString.call(new Date(NaN))
        }) ? function toISOString() {
            if (!isFinite(getTime.call(this))) throw RangeError("Invalid time value");
            var d = this;
            var y = d.getUTCFullYear();
            var m = d.getUTCMilliseconds();
            var s = y < 0 ? "-" : y > 9999 ? "+" : "";
            return s + ("00000" + Math.abs(y)).slice(s ? -6 : -4) + "-" + lz(d.getUTCMonth() + 1) + "-" + lz(d.getUTCDate()) + "T" + lz(d.getUTCHours()) + ":" + lz(d.getUTCMinutes()) + ":" + lz(d.getUTCSeconds()) + "." + (m > 99 ? m : "0" + lz(m)) + "Z"
        } : $toISOString
    }, {
        "./_fails": 35
    }],
    27: [function(require, module, exports) {
        "use strict";
        var anObject = require("./_an-object");
        var toPrimitive = require("./_to-primitive");
        var NUMBER = "number";
        module.exports = function(hint) {
            if (hint !== "string" && hint !== NUMBER && hint !== "default") throw TypeError("Incorrect hint");
            return toPrimitive(anObject(this), hint != NUMBER)
        }
    }, {
        "./_an-object": 7,
        "./_to-primitive": 117
    }],
    28: [function(require, module, exports) {
        module.exports = function(it) {
            if (it == undefined) throw TypeError("Can't call method on  " + it);
            return it
        }
    }, {}],
    29: [function(require, module, exports) {
        module.exports = !require("./_fails")(function() {
            return Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a != 7
        })
    }, {
        "./_fails": 35
    }],
    30: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var document = require("./_global").document;
        var is = isObject(document) && isObject(document.createElement);
        module.exports = function(it) {
            return is ? document.createElement(it) : {}
        }
    }, {
        "./_global": 40,
        "./_is-object": 51
    }],
    31: [function(require, module, exports) {
        module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    }, {}],
    32: [function(require, module, exports) {
        var getKeys = require("./_object-keys");
        var gOPS = require("./_object-gops");
        var pIE = require("./_object-pie");
        module.exports = function(it) {
            var result = getKeys(it);
            var getSymbols = gOPS.f;
            if (getSymbols) {
                var symbols = getSymbols(it);
                var isEnum = pIE.f;
                var i = 0;
                var key;
                while (symbols.length > i)
                    if (isEnum.call(it, key = symbols[i++])) result.push(key)
            }
            return result
        }
    }, {
        "./_object-gops": 77,
        "./_object-keys": 80,
        "./_object-pie": 81
    }],
    33: [function(require, module, exports) {
        var global = require("./_global");
        var core = require("./_core");
        var hide = require("./_hide");
        var redefine = require("./_redefine");
        var ctx = require("./_ctx");
        var PROTOTYPE = "prototype";
        var $export = function(type, name, source) {
            var IS_FORCED = type & $export.F;
            var IS_GLOBAL = type & $export.G;
            var IS_STATIC = type & $export.S;
            var IS_PROTO = type & $export.P;
            var IS_BIND = type & $export.B;
            var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
            var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
            var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
            var key, own, out, exp;
            if (IS_GLOBAL) source = name;
            for (key in source) {
                own = !IS_FORCED && target && target[key] !== undefined;
                out = (own ? target : source)[key];
                exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (target) redefine(target, key, out, type & $export.U);
                if (exports[key] != out) hide(exports, key, exp);
                if (IS_PROTO && expProto[key] != out) expProto[key] = out
            }
        };
        global.core = core;
        $export.F = 1;
        $export.G = 2;
        $export.S = 4;
        $export.P = 8;
        $export.B = 16;
        $export.W = 32;
        $export.U = 64;
        $export.R = 128;
        module.exports = $export
    }, {
        "./_core": 23,
        "./_ctx": 25,
        "./_global": 40,
        "./_hide": 42,
        "./_redefine": 91
    }],
    34: [function(require, module, exports) {
        var MATCH = require("./_wks")("match");
        module.exports = function(KEY) {
            var re = /./;
            try {
                "/./" [KEY](re)
            } catch (e) {
                try {
                    re[MATCH] = false;
                    return !"/./" [KEY](re)
                } catch (f) {}
            }
            return true
        }
    }, {
        "./_wks": 126
    }],
    35: [function(require, module, exports) {
        module.exports = function(exec) {
            try {
                return !!exec()
            } catch (e) {
                return true
            }
        }
    }, {}],
    36: [function(require, module, exports) {
        "use strict";
        var hide = require("./_hide");
        var redefine = require("./_redefine");
        var fails = require("./_fails");
        var defined = require("./_defined");
        var wks = require("./_wks");
        module.exports = function(KEY, length, exec) {
            var SYMBOL = wks(KEY);
            var fns = exec(defined, SYMBOL, "" [KEY]);
            var strfn = fns[0];
            var rxfn = fns[1];
            if (fails(function() {
                    var O = {};
                    O[SYMBOL] = function() {
                        return 7
                    };
                    return "" [KEY](O) != 7
                })) {
                redefine(String.prototype, KEY, strfn);
                hide(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
                    return rxfn.call(string, this, arg)
                } : function(string) {
                    return rxfn.call(string, this)
                })
            }
        }
    }, {
        "./_defined": 28,
        "./_fails": 35,
        "./_hide": 42,
        "./_redefine": 91,
        "./_wks": 126
    }],
    37: [function(require, module, exports) {
        "use strict";
        var anObject = require("./_an-object");
        module.exports = function() {
            var that = anObject(this);
            var result = "";
            if (that.global) result += "g";
            if (that.ignoreCase) result += "i";
            if (that.multiline) result += "m";
            if (that.unicode) result += "u";
            if (that.sticky) result += "y";
            return result
        }
    }, {
        "./_an-object": 7
    }],
    38: [function(require, module, exports) {
        "use strict";
        var isArray = require("./_is-array");
        var isObject = require("./_is-object");
        var toLength = require("./_to-length");
        var ctx = require("./_ctx");
        var IS_CONCAT_SPREADABLE = require("./_wks")("isConcatSpreadable");

        function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
            var targetIndex = start;
            var sourceIndex = 0;
            var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
            var element, spreadable;
            while (sourceIndex < sourceLen) {
                if (sourceIndex in source) {
                    element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
                    spreadable = false;
                    if (isObject(element)) {
                        spreadable = element[IS_CONCAT_SPREADABLE];
                        spreadable = spreadable !== undefined ? !!spreadable : isArray(element)
                    }
                    if (spreadable && depth > 0) {
                        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1
                    } else {
                        if (targetIndex >= 9007199254740991) throw TypeError();
                        target[targetIndex] = element
                    }
                    targetIndex++
                }
                sourceIndex++
            }
            return targetIndex
        }
        module.exports = flattenIntoArray
    }, {
        "./_ctx": 25,
        "./_is-array": 49,
        "./_is-object": 51,
        "./_to-length": 115,
        "./_wks": 126
    }],
    39: [function(require, module, exports) {
        var ctx = require("./_ctx");
        var call = require("./_iter-call");
        var isArrayIter = require("./_is-array-iter");
        var anObject = require("./_an-object");
        var toLength = require("./_to-length");
        var getIterFn = require("./core.get-iterator-method");
        var BREAK = {};
        var RETURN = {};
        var exports = module.exports = function(iterable, entries, fn, that, ITERATOR) {
            var iterFn = ITERATOR ? function() {
                return iterable
            } : getIterFn(iterable);
            var f = ctx(fn, that, entries ? 2 : 1);
            var index = 0;
            var length, step, iterator, result;
            if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
            if (isArrayIter(iterFn))
                for (length = toLength(iterable.length); length > index; index++) {
                    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                    if (result === BREAK || result === RETURN) return result
                } else
                    for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
                        result = call(iterator, f, step.value, entries);
                        if (result === BREAK || result === RETURN) return result
                    }
        };
        exports.BREAK = BREAK;
        exports.RETURN = RETURN
    }, {
        "./_an-object": 7,
        "./_ctx": 25,
        "./_is-array-iter": 48,
        "./_iter-call": 53,
        "./_to-length": 115,
        "./core.get-iterator-method": 127
    }],
    40: [function(require, module, exports) {
        var global = module.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
        if (typeof __g == "number") __g = global
    }, {}],
    41: [function(require, module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function(it, key) {
            return hasOwnProperty.call(it, key)
        }
    }, {}],
    42: [function(require, module, exports) {
        var dP = require("./_object-dp");
        var createDesc = require("./_property-desc");
        module.exports = require("./_descriptors") ? function(object, key, value) {
            return dP.f(object, key, createDesc(1, value))
        } : function(object, key, value) {
            object[key] = value;
            return object
        }
    }, {
        "./_descriptors": 29,
        "./_object-dp": 71,
        "./_property-desc": 89
    }],
    43: [function(require, module, exports) {
        var document = require("./_global").document;
        module.exports = document && document.documentElement
    }, {
        "./_global": 40
    }],
    44: [function(require, module, exports) {
        module.exports = !require("./_descriptors") && !require("./_fails")(function() {
            return Object.defineProperty(require("./_dom-create")("div"), "a", {
                get: function() {
                    return 7
                }
            }).a != 7
        })
    }, {
        "./_descriptors": 29,
        "./_dom-create": 30,
        "./_fails": 35
    }],
    45: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var setPrototypeOf = require("./_set-proto").set;
        module.exports = function(that, target, C) {
            var S = target.constructor;
            var P;
            if (S !== C && typeof S == "function" && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
                setPrototypeOf(that, P)
            }
            return that
        }
    }, {
        "./_is-object": 51,
        "./_set-proto": 96
    }],
    46: [function(require, module, exports) {
        module.exports = function(fn, args, that) {
            var un = that === undefined;
            switch (args.length) {
                case 0:
                    return un ? fn() : fn.call(that);
                case 1:
                    return un ? fn(args[0]) : fn.call(that, args[0]);
                case 2:
                    return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                case 3:
                    return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                case 4:
                    return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3])
            }
            return fn.apply(that, args)
        }
    }, {}],
    47: [function(require, module, exports) {
        var cof = require("./_cof");
        module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return cof(it) == "String" ? it.split("") : Object(it)
        }
    }, {
        "./_cof": 18
    }],
    48: [function(require, module, exports) {
        var Iterators = require("./_iterators");
        var ITERATOR = require("./_wks")("iterator");
        var ArrayProto = Array.prototype;
        module.exports = function(it) {
            return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it)
        }
    }, {
        "./_iterators": 58,
        "./_wks": 126
    }],
    49: [function(require, module, exports) {
        var cof = require("./_cof");
        module.exports = Array.isArray || function isArray(arg) {
            return cof(arg) == "Array"
        }
    }, {
        "./_cof": 18
    }],
    50: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var floor = Math.floor;
        module.exports = function isInteger(it) {
            return !isObject(it) && isFinite(it) && floor(it) === it
        }
    }, {
        "./_is-object": 51
    }],
    51: [function(require, module, exports) {
        module.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function"
        }
    }, {}],
    52: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var cof = require("./_cof");
        var MATCH = require("./_wks")("match");
        module.exports = function(it) {
            var isRegExp;
            return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == "RegExp")
        }
    }, {
        "./_cof": 18,
        "./_is-object": 51,
        "./_wks": 126
    }],
    53: [function(require, module, exports) {
        var anObject = require("./_an-object");
        module.exports = function(iterator, fn, value, entries) {
            try {
                return entries ? fn(anObject(value)[0], value[1]) : fn(value)
            } catch (e) {
                var ret = iterator["return"];
                if (ret !== undefined) anObject(ret.call(iterator));
                throw e
            }
        }
    }, {
        "./_an-object": 7
    }],
    54: [function(require, module, exports) {
        "use strict";
        var create = require("./_object-create");
        var descriptor = require("./_property-desc");
        var setToStringTag = require("./_set-to-string-tag");
        var IteratorPrototype = {};
        require("./_hide")(IteratorPrototype, require("./_wks")("iterator"), function() {
            return this
        });
        module.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create(IteratorPrototype, {
                next: descriptor(1, next)
            });
            setToStringTag(Constructor, NAME + " Iterator")
        }
    }, {
        "./_hide": 42,
        "./_object-create": 70,
        "./_property-desc": 89,
        "./_set-to-string-tag": 98,
        "./_wks": 126
    }],
    55: [function(require, module, exports) {
        "use strict";
        var LIBRARY = require("./_library");
        var $export = require("./_export");
        var redefine = require("./_redefine");
        var hide = require("./_hide");
        var has = require("./_has");
        var Iterators = require("./_iterators");
        var $iterCreate = require("./_iter-create");
        var setToStringTag = require("./_set-to-string-tag");
        var getPrototypeOf = require("./_object-gpo");
        var ITERATOR = require("./_wks")("iterator");
        var BUGGY = !([].keys && "next" in [].keys());
        var FF_ITERATOR = "@@iterator";
        var KEYS = "keys";
        var VALUES = "values";
        var returnThis = function() {
            return this
        };
        module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                    case KEYS:
                        return function keys() {
                            return new Constructor(this, kind)
                        };
                    case VALUES:
                        return function values() {
                            return new Constructor(this, kind)
                        }
                }
                return function entries() {
                    return new Constructor(this, kind)
                }
            };
            var TAG = NAME + " Iterator";
            var DEF_VALUES = DEFAULT == VALUES;
            var VALUES_BUG = false;
            var proto = Base.prototype;
            var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
            var $default = !BUGGY && $native || getMethod(DEFAULT);
            var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : undefined;
            var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
            var methods, key, IteratorPrototype;
            if ($anyNative) {
                IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                    setToStringTag(IteratorPrototype, TAG, true);
                    if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis)
                }
            }
            if (DEF_VALUES && $native && $native.name !== VALUES) {
                VALUES_BUG = true;
                $default = function values() {
                    return $native.call(this)
                }
            }
            if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                hide(proto, ITERATOR, $default)
            }
            Iterators[NAME] = $default;
            Iterators[TAG] = returnThis;
            if (DEFAULT) {
                methods = {
                    values: DEF_VALUES ? $default : getMethod(VALUES),
                    keys: IS_SET ? $default : getMethod(KEYS),
                    entries: $entries
                };
                if (FORCED)
                    for (key in methods) {
                        if (!(key in proto)) redefine(proto, key, methods[key])
                    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods)
            }
            return methods
        }
    }, {
        "./_export": 33,
        "./_has": 41,
        "./_hide": 42,
        "./_iter-create": 54,
        "./_iterators": 58,
        "./_library": 59,
        "./_object-gpo": 78,
        "./_redefine": 91,
        "./_set-to-string-tag": 98,
        "./_wks": 126
    }],
    56: [function(require, module, exports) {
        var ITERATOR = require("./_wks")("iterator");
        var SAFE_CLOSING = false;
        try {
            var riter = [7][ITERATOR]();
            riter["return"] = function() {
                SAFE_CLOSING = true
            };
            Array.from(riter, function() {
                throw 2
            })
        } catch (e) {}
        module.exports = function(exec, skipClosing) {
            if (!skipClosing && !SAFE_CLOSING) return false;
            var safe = false;
            try {
                var arr = [7];
                var iter = arr[ITERATOR]();
                iter.next = function() {
                    return {
                        done: safe = true
                    }
                };
                arr[ITERATOR] = function() {
                    return iter
                };
                exec(arr)
            } catch (e) {}
            return safe
        }
    }, {
        "./_wks": 126
    }],
    57: [function(require, module, exports) {
        module.exports = function(done, value) {
            return {
                value: value,
                done: !!done
            }
        }
    }, {}],
    58: [function(require, module, exports) {
        module.exports = {}
    }, {}],
    59: [function(require, module, exports) {
        module.exports = false
    }, {}],
    60: [function(require, module, exports) {
        var $expm1 = Math.expm1;
        module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) != -2e-17 ? function expm1(x) {
            return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1
        } : $expm1
    }, {}],
    61: [function(require, module, exports) {
        var sign = require("./_math-sign");
        var pow = Math.pow;
        var EPSILON = pow(2, -52);
        var EPSILON32 = pow(2, -23);
        var MAX32 = pow(2, 127) * (2 - EPSILON32);
        var MIN32 = pow(2, -126);
        var roundTiesToEven = function(n) {
            return n + 1 / EPSILON - 1 / EPSILON
        };
        module.exports = Math.fround || function fround(x) {
            var $abs = Math.abs(x);
            var $sign = sign(x);
            var a, result;
            if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
            a = (1 + EPSILON32 / EPSILON) * $abs;
            result = a - (a - $abs);
            if (result > MAX32 || result != result) return $sign * Infinity;
            return $sign * result
        }
    }, {
        "./_math-sign": 64
    }],
    62: [function(require, module, exports) {
        module.exports = Math.log1p || function log1p(x) {
            return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x)
        }
    }, {}],
    63: [function(require, module, exports) {
        module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
            if (arguments.length === 0 || x != x || inLow != inLow || inHigh != inHigh || outLow != outLow || outHigh != outHigh) return NaN;
            if (x === Infinity || x === -Infinity) return x;
            return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow
        }
    }, {}],
    64: [function(require, module, exports) {
        module.exports = Math.sign || function sign(x) {
            return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1
        }
    }, {}],
    65: [function(require, module, exports) {
        var META = require("./_uid")("meta");
        var isObject = require("./_is-object");
        var has = require("./_has");
        var setDesc = require("./_object-dp").f;
        var id = 0;
        var isExtensible = Object.isExtensible || function() {
            return true
        };
        var FREEZE = !require("./_fails")(function() {
            return isExtensible(Object.preventExtensions({}))
        });
        var setMeta = function(it) {
            setDesc(it, META, {
                value: {
                    i: "O" + ++id,
                    w: {}
                }
            })
        };
        var fastKey = function(it, create) {
            if (!isObject(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
            if (!has(it, META)) {
                if (!isExtensible(it)) return "F";
                if (!create) return "E";
                setMeta(it)
            }
            return it[META].i
        };
        var getWeak = function(it, create) {
            if (!has(it, META)) {
                if (!isExtensible(it)) return true;
                if (!create) return false;
                setMeta(it)
            }
            return it[META].w
        };
        var onFreeze = function(it) {
            if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
            return it
        };
        var meta = module.exports = {
            KEY: META,
            NEED: false,
            fastKey: fastKey,
            getWeak: getWeak,
            onFreeze: onFreeze
        }
    }, {
        "./_fails": 35,
        "./_has": 41,
        "./_is-object": 51,
        "./_object-dp": 71,
        "./_uid": 121
    }],
    66: [function(require, module, exports) {
        var Map = require("./es6.map");
        var $export = require("./_export");
        var shared = require("./_shared")("metadata");
        var store = shared.store || (shared.store = new(require("./es6.weak-map")));
        var getOrCreateMetadataMap = function(target, targetKey, create) {
            var targetMetadata = store.get(target);
            if (!targetMetadata) {
                if (!create) return undefined;
                store.set(target, targetMetadata = new Map)
            }
            var keyMetadata = targetMetadata.get(targetKey);
            if (!keyMetadata) {
                if (!create) return undefined;
                targetMetadata.set(targetKey, keyMetadata = new Map)
            }
            return keyMetadata
        };
        var ordinaryHasOwnMetadata = function(MetadataKey, O, P) {
            var metadataMap = getOrCreateMetadataMap(O, P, false);
            return metadataMap === undefined ? false : metadataMap.has(MetadataKey)
        };
        var ordinaryGetOwnMetadata = function(MetadataKey, O, P) {
            var metadataMap = getOrCreateMetadataMap(O, P, false);
            return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey)
        };
        var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P) {
            getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue)
        };
        var ordinaryOwnMetadataKeys = function(target, targetKey) {
            var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
            var keys = [];
            if (metadataMap) metadataMap.forEach(function(_, key) {
                keys.push(key)
            });
            return keys
        };
        var toMetaKey = function(it) {
            return it === undefined || typeof it == "symbol" ? it : String(it)
        };
        var exp = function(O) {
            $export($export.S, "Reflect", O)
        };
        module.exports = {
            store: store,
            map: getOrCreateMetadataMap,
            has: ordinaryHasOwnMetadata,
            get: ordinaryGetOwnMetadata,
            set: ordinaryDefineOwnMetadata,
            keys: ordinaryOwnMetadataKeys,
            key: toMetaKey,
            exp: exp
        }
    }, {
        "./_export": 33,
        "./_shared": 100,
        "./es6.map": 158,
        "./es6.weak-map": 264
    }],
    67: [function(require, module, exports) {
        var global = require("./_global");
        var macrotask = require("./_task").set;
        var Observer = global.MutationObserver || global.WebKitMutationObserver;
        var process = global.process;
        var Promise = global.Promise;
        var isNode = require("./_cof")(process) == "process";
        module.exports = function() {
            var head, last, notify;
            var flush = function() {
                var parent, fn;
                if (isNode && (parent = process.domain)) parent.exit();
                while (head) {
                    fn = head.fn;
                    head = head.next;
                    try {
                        fn()
                    } catch (e) {
                        if (head) notify();
                        else last = undefined;
                        throw e
                    }
                }
                last = undefined;
                if (parent) parent.enter()
            };
            if (isNode) {
                notify = function() {
                    process.nextTick(flush)
                }
            } else if (Observer && !(global.navigator && global.navigator.standalone)) {
                var toggle = true;
                var node = document.createTextNode("");
                new Observer(flush).observe(node, {
                    characterData: true
                });
                notify = function() {
                    node.data = toggle = !toggle
                }
            } else if (Promise && Promise.resolve) {
                var promise = Promise.resolve();
                notify = function() {
                    promise.then(flush)
                }
            } else {
                notify = function() {
                    macrotask.call(global, flush)
                }
            }
            return function(fn) {
                var task = {
                    fn: fn,
                    next: undefined
                };
                if (last) last.next = task;
                if (!head) {
                    head = task;
                    notify()
                }
                last = task
            }
        }
    }, {
        "./_cof": 18,
        "./_global": 40,
        "./_task": 110
    }],
    68: [function(require, module, exports) {
        "use strict";
        var aFunction = require("./_a-function");

        function PromiseCapability(C) {
            var resolve, reject;
            this.promise = new C(function($$resolve, $$reject) {
                if (resolve !== undefined || reject !== undefined) throw TypeError("Bad Promise constructor");
                resolve = $$resolve;
                reject = $$reject
            });
            this.resolve = aFunction(resolve);
            this.reject = aFunction(reject)
        }
        module.exports.f = function(C) {
            return new PromiseCapability(C)
        }
    }, {
        "./_a-function": 3
    }],
    69: [function(require, module, exports) {
        "use strict";
        var getKeys = require("./_object-keys");
        var gOPS = require("./_object-gops");
        var pIE = require("./_object-pie");
        var toObject = require("./_to-object");
        var IObject = require("./_iobject");
        var $assign = Object.assign;
        module.exports = !$assign || require("./_fails")(function() {
            var A = {};
            var B = {};
            var S = Symbol();
            var K = "abcdefghijklmnopqrst";
            A[S] = 7;
            K.split("").forEach(function(k) {
                B[k] = k
            });
            return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K
        }) ? function assign(target, source) {
            var T = toObject(target);
            var aLen = arguments.length;
            var index = 1;
            var getSymbols = gOPS.f;
            var isEnum = pIE.f;
            while (aLen > index) {
                var S = IObject(arguments[index++]);
                var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
                var length = keys.length;
                var j = 0;
                var key;
                while (length > j)
                    if (isEnum.call(S, key = keys[j++])) T[key] = S[key]
            }
            return T
        } : $assign
    }, {
        "./_fails": 35,
        "./_iobject": 47,
        "./_object-gops": 77,
        "./_object-keys": 80,
        "./_object-pie": 81,
        "./_to-object": 116
    }],
    70: [function(require, module, exports) {
        var anObject = require("./_an-object");
        var dPs = require("./_object-dps");
        var enumBugKeys = require("./_enum-bug-keys");
        var IE_PROTO = require("./_shared-key")("IE_PROTO");
        var Empty = function() {};
        var PROTOTYPE = "prototype";
        var createDict = function() {
            var iframe = require("./_dom-create")("iframe");
            var i = enumBugKeys.length;
            var lt = "<";
            var gt = ">";
            var iframeDocument;
            iframe.style.display = "none";
            require("./_html").appendChild(iframe);
            iframe.src = "javascript:";
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
            iframeDocument.close();
            createDict = iframeDocument.F;
            while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
            return createDict()
        };
        module.exports = Object.create || function create(O, Properties) {
            var result;
            if (O !== null) {
                Empty[PROTOTYPE] = anObject(O);
                result = new Empty;
                Empty[PROTOTYPE] = null;
                result[IE_PROTO] = O
            } else result = createDict();
            return Properties === undefined ? result : dPs(result, Properties)
        }
    }, {
        "./_an-object": 7,
        "./_dom-create": 30,
        "./_enum-bug-keys": 31,
        "./_html": 43,
        "./_object-dps": 72,
        "./_shared-key": 99
    }],
    71: [function(require, module, exports) {
        var anObject = require("./_an-object");
        var IE8_DOM_DEFINE = require("./_ie8-dom-define");
        var toPrimitive = require("./_to-primitive");
        var dP = Object.defineProperty;
        exports.f = require("./_descriptors") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes)
            } catch (e) {}
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
            if ("value" in Attributes) O[P] = Attributes.value;
            return O
        }
    }, {
        "./_an-object": 7,
        "./_descriptors": 29,
        "./_ie8-dom-define": 44,
        "./_to-primitive": 117
    }],
    72: [function(require, module, exports) {
        var dP = require("./_object-dp");
        var anObject = require("./_an-object");
        var getKeys = require("./_object-keys");
        module.exports = require("./_descriptors") ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys = getKeys(Properties);
            var length = keys.length;
            var i = 0;
            var P;
            while (length > i) dP.f(O, P = keys[i++], Properties[P]);
            return O
        }
    }, {
        "./_an-object": 7,
        "./_descriptors": 29,
        "./_object-dp": 71,
        "./_object-keys": 80
    }],
    73: [function(require, module, exports) {
        "use strict";
        module.exports = require("./_library") || !require("./_fails")(function() {
            var K = Math.random();
            __defineSetter__.call(null, K, function() {});
            delete require("./_global")[K]
        })
    }, {
        "./_fails": 35,
        "./_global": 40,
        "./_library": 59
    }],
    74: [function(require, module, exports) {
        var pIE = require("./_object-pie");
        var createDesc = require("./_property-desc");
        var toIObject = require("./_to-iobject");
        var toPrimitive = require("./_to-primitive");
        var has = require("./_has");
        var IE8_DOM_DEFINE = require("./_ie8-dom-define");
        var gOPD = Object.getOwnPropertyDescriptor;
        exports.f = require("./_descriptors") ? gOPD : function getOwnPropertyDescriptor(O, P) {
            O = toIObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE) try {
                return gOPD(O, P)
            } catch (e) {}
            if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P])
        }
    }, {
        "./_descriptors": 29,
        "./_has": 41,
        "./_ie8-dom-define": 44,
        "./_object-pie": 81,
        "./_property-desc": 89,
        "./_to-iobject": 114,
        "./_to-primitive": 117
    }],
    75: [function(require, module, exports) {
        var toIObject = require("./_to-iobject");
        var gOPN = require("./_object-gopn").f;
        var toString = {}.toString;
        var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        var getWindowNames = function(it) {
            try {
                return gOPN(it)
            } catch (e) {
                return windowNames.slice()
            }
        };
        module.exports.f = function getOwnPropertyNames(it) {
            return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it))
        }
    }, {
        "./_object-gopn": 76,
        "./_to-iobject": 114
    }],
    76: [function(require, module, exports) {
        var $keys = require("./_object-keys-internal");
        var hiddenKeys = require("./_enum-bug-keys").concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return $keys(O, hiddenKeys)
        }
    }, {
        "./_enum-bug-keys": 31,
        "./_object-keys-internal": 79
    }],
    77: [function(require, module, exports) {
        exports.f = Object.getOwnPropertySymbols
    }, {}],
    78: [function(require, module, exports) {
        var has = require("./_has");
        var toObject = require("./_to-object");
        var IE_PROTO = require("./_shared-key")("IE_PROTO");
        var ObjectProto = Object.prototype;
        module.exports = Object.getPrototypeOf || function(O) {
            O = toObject(O);
            if (has(O, IE_PROTO)) return O[IE_PROTO];
            if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype
            }
            return O instanceof Object ? ObjectProto : null
        }
    }, {
        "./_has": 41,
        "./_shared-key": 99,
        "./_to-object": 116
    }],
    79: [function(require, module, exports) {
        var has = require("./_has");
        var toIObject = require("./_to-iobject");
        var arrayIndexOf = require("./_array-includes")(false);
        var IE_PROTO = require("./_shared-key")("IE_PROTO");
        module.exports = function(object, names) {
            var O = toIObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O)
                if (key != IE_PROTO) has(O, key) && result.push(key);
            while (names.length > i)
                if (has(O, key = names[i++])) {
                    ~arrayIndexOf(result, key) || result.push(key)
                }
            return result
        }
    }, {
        "./_array-includes": 11,
        "./_has": 41,
        "./_shared-key": 99,
        "./_to-iobject": 114
    }],
    80: [function(require, module, exports) {
        var $keys = require("./_object-keys-internal");
        var enumBugKeys = require("./_enum-bug-keys");
        module.exports = Object.keys || function keys(O) {
            return $keys(O, enumBugKeys)
        }
    }, {
        "./_enum-bug-keys": 31,
        "./_object-keys-internal": 79
    }],
    81: [function(require, module, exports) {
        exports.f = {}.propertyIsEnumerable
    }, {}],
    82: [function(require, module, exports) {
        var $export = require("./_export");
        var core = require("./_core");
        var fails = require("./_fails");
        module.exports = function(KEY, exec) {
            var fn = (core.Object || {})[KEY] || Object[KEY];
            var exp = {};
            exp[KEY] = exec(fn);
            $export($export.S + $export.F * fails(function() {
                fn(1)
            }), "Object", exp)
        }
    }, {
        "./_core": 23,
        "./_export": 33,
        "./_fails": 35
    }],
    83: [function(require, module, exports) {
        var getKeys = require("./_object-keys");
        var toIObject = require("./_to-iobject");
        var isEnum = require("./_object-pie").f;
        module.exports = function(isEntries) {
            return function(it) {
                var O = toIObject(it);
                var keys = getKeys(O);
                var length = keys.length;
                var i = 0;
                var result = [];
                var key;
                while (length > i)
                    if (isEnum.call(O, key = keys[i++])) {
                        result.push(isEntries ? [key, O[key]] : O[key])
                    }
                return result
            }
        }
    }, {
        "./_object-keys": 80,
        "./_object-pie": 81,
        "./_to-iobject": 114
    }],
    84: [function(require, module, exports) {
        var gOPN = require("./_object-gopn");
        var gOPS = require("./_object-gops");
        var anObject = require("./_an-object");
        var Reflect = require("./_global").Reflect;
        module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
            var keys = gOPN.f(anObject(it));
            var getSymbols = gOPS.f;
            return getSymbols ? keys.concat(getSymbols(it)) : keys
        }
    }, {
        "./_an-object": 7,
        "./_global": 40,
        "./_object-gopn": 76,
        "./_object-gops": 77
    }],
    85: [function(require, module, exports) {
        var $parseFloat = require("./_global").parseFloat;
        var $trim = require("./_string-trim").trim;
        module.exports = 1 / $parseFloat(require("./_string-ws") + "-0") !== -Infinity ? function parseFloat(str) {
            var string = $trim(String(str), 3);
            var result = $parseFloat(string);
            return result === 0 && string.charAt(0) == "-" ? -0 : result
        } : $parseFloat
    }, {
        "./_global": 40,
        "./_string-trim": 108,
        "./_string-ws": 109
    }],
    86: [function(require, module, exports) {
        var $parseInt = require("./_global").parseInt;
        var $trim = require("./_string-trim").trim;
        var ws = require("./_string-ws");
        var hex = /^[-+]?0[xX]/;
        module.exports = $parseInt(ws + "08") !== 8 || $parseInt(ws + "0x16") !== 22 ? function parseInt(str, radix) {
            var string = $trim(String(str), 3);
            return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10))
        } : $parseInt
    }, {
        "./_global": 40,
        "./_string-trim": 108,
        "./_string-ws": 109
    }],
    87: [function(require, module, exports) {
        module.exports = function(exec) {
            try {
                return {
                    e: false,
                    v: exec()
                }
            } catch (e) {
                return {
                    e: true,
                    v: e
                }
            }
        }
    }, {}],
    88: [function(require, module, exports) {
        var anObject = require("./_an-object");
        var isObject = require("./_is-object");
        var newPromiseCapability = require("./_new-promise-capability");
        module.exports = function(C, x) {
            anObject(C);
            if (isObject(x) && x.constructor === C) return x;
            var promiseCapability = newPromiseCapability.f(C);
            var resolve = promiseCapability.resolve;
            resolve(x);
            return promiseCapability.promise
        }
    }, {
        "./_an-object": 7,
        "./_is-object": 51,
        "./_new-promise-capability": 68
    }],
    89: [function(require, module, exports) {
        module.exports = function(bitmap, value) {
            return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value: value
            }
        }
    }, {}],
    90: [function(require, module, exports) {
        var redefine = require("./_redefine");
        module.exports = function(target, src, safe) {
            for (var key in src) redefine(target, key, src[key], safe);
            return target
        }
    }, {
        "./_redefine": 91
    }],
    91: [function(require, module, exports) {
        var global = require("./_global");
        var hide = require("./_hide");
        var has = require("./_has");
        var SRC = require("./_uid")("src");
        var TO_STRING = "toString";
        var $toString = Function[TO_STRING];
        var TPL = ("" + $toString).split(TO_STRING);
        require("./_core").inspectSource = function(it) {
            return $toString.call(it)
        };
        (module.exports = function(O, key, val, safe) {
            var isFunction = typeof val == "function";
            if (isFunction) has(val, "name") || hide(val, "name", key);
            if (O[key] === val) return;
            if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
            if (O === global) {
                O[key] = val
            } else if (!safe) {
                delete O[key];
                hide(O, key, val)
            } else if (O[key]) {
                O[key] = val
            } else {
                hide(O, key, val)
            }
        })(Function.prototype, TO_STRING, function toString() {
            return typeof this == "function" && this[SRC] || $toString.call(this)
        })
    }, {
        "./_core": 23,
        "./_global": 40,
        "./_has": 41,
        "./_hide": 42,
        "./_uid": 121
    }],
    92: [function(require, module, exports) {
        module.exports = function(regExp, replace) {
            var replacer = replace === Object(replace) ? function(part) {
                return replace[part]
            } : replace;
            return function(it) {
                return String(it).replace(regExp, replacer)
            }
        }
    }, {}],
    93: [function(require, module, exports) {
        module.exports = Object.is || function is(x, y) {
            return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y
        }
    }, {}],
    94: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var aFunction = require("./_a-function");
        var ctx = require("./_ctx");
        var forOf = require("./_for-of");
        module.exports = function(COLLECTION) {
            $export($export.S, COLLECTION, {
                from: function from(source) {
                    var mapFn = arguments[1];
                    var mapping, A, n, cb;
                    aFunction(this);
                    mapping = mapFn !== undefined;
                    if (mapping) aFunction(mapFn);
                    if (source == undefined) return new this;
                    A = [];
                    if (mapping) {
                        n = 0;
                        cb = ctx(mapFn, arguments[2], 2);
                        forOf(source, false, function(nextItem) {
                            A.push(cb(nextItem, n++))
                        })
                    } else {
                        forOf(source, false, A.push, A)
                    }
                    return new this(A)
                }
            })
        }
    }, {
        "./_a-function": 3,
        "./_ctx": 25,
        "./_export": 33,
        "./_for-of": 39
    }],
    95: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        module.exports = function(COLLECTION) {
            $export($export.S, COLLECTION, {
                of: function of() {
                    var length = arguments.length;
                    var A = new Array(length);
                    while (length--) A[length] = arguments[length];
                    return new this(A)
                }
            })
        }
    }, {
        "./_export": 33
    }],
    96: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var anObject = require("./_an-object");
        var check = function(O, proto) {
            anObject(O);
            if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!")
        };
        module.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? function(test, buggy, set) {
                try {
                    set = require("./_ctx")(Function.call, require("./_object-gopd").f(Object.prototype, "__proto__").set, 2);
                    set(test, []);
                    buggy = !(test instanceof Array)
                } catch (e) {
                    buggy = true
                }
                return function setPrototypeOf(O, proto) {
                    check(O, proto);
                    if (buggy) O.__proto__ = proto;
                    else set(O, proto);
                    return O
                }
            }({}, false) : undefined),
            check: check
        }
    }, {
        "./_an-object": 7,
        "./_ctx": 25,
        "./_is-object": 51,
        "./_object-gopd": 74
    }],
    97: [function(require, module, exports) {
        "use strict";
        var global = require("./_global");
        var dP = require("./_object-dp");
        var DESCRIPTORS = require("./_descriptors");
        var SPECIES = require("./_wks")("species");
        module.exports = function(KEY) {
            var C = global[KEY];
            if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
                configurable: true,
                get: function() {
                    return this
                }
            })
        }
    }, {
        "./_descriptors": 29,
        "./_global": 40,
        "./_object-dp": 71,
        "./_wks": 126
    }],
    98: [function(require, module, exports) {
        var def = require("./_object-dp").f;
        var has = require("./_has");
        var TAG = require("./_wks")("toStringTag");
        module.exports = function(it, tag, stat) {
            if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
                configurable: true,
                value: tag
            })
        }
    }, {
        "./_has": 41,
        "./_object-dp": 71,
        "./_wks": 126
    }],
    99: [function(require, module, exports) {
        var shared = require("./_shared")("keys");
        var uid = require("./_uid");
        module.exports = function(key) {
            return shared[key] || (shared[key] = uid(key))
        }
    }, {
        "./_shared": 100,
        "./_uid": 121
    }],
    100: [function(require, module, exports) {
        var global = require("./_global");
        var SHARED = "__core-js_shared__";
        var store = global[SHARED] || (global[SHARED] = {});
        module.exports = function(key) {
            return store[key] || (store[key] = {})
        }
    }, {
        "./_global": 40
    }],
    101: [function(require, module, exports) {
        var anObject = require("./_an-object");
        var aFunction = require("./_a-function");
        var SPECIES = require("./_wks")("species");
        module.exports = function(O, D) {
            var C = anObject(O).constructor;
            var S;
            return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S)
        }
    }, {
        "./_a-function": 3,
        "./_an-object": 7,
        "./_wks": 126
    }],
    102: [function(require, module, exports) {
        "use strict";
        var fails = require("./_fails");
        module.exports = function(method, arg) {
            return !!method && fails(function() {
                arg ? method.call(null, function() {}, 1) : method.call(null)
            })
        }
    }, {
        "./_fails": 35
    }],
    103: [function(require, module, exports) {
        var toInteger = require("./_to-integer");
        var defined = require("./_defined");
        module.exports = function(TO_STRING) {
            return function(that, pos) {
                var s = String(defined(that));
                var i = toInteger(pos);
                var l = s.length;
                var a, b;
                if (i < 0 || i >= l) return TO_STRING ? "" : undefined;
                a = s.charCodeAt(i);
                return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536
            }
        }
    }, {
        "./_defined": 28,
        "./_to-integer": 113
    }],
    104: [function(require, module, exports) {
        var isRegExp = require("./_is-regexp");
        var defined = require("./_defined");
        module.exports = function(that, searchString, NAME) {
            if (isRegExp(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
            return String(defined(that))
        }
    }, {
        "./_defined": 28,
        "./_is-regexp": 52
    }],
    105: [function(require, module, exports) {
        var $export = require("./_export");
        var fails = require("./_fails");
        var defined = require("./_defined");
        var quot = /"/g;
        var createHTML = function(string, tag, attribute, value) {
            var S = String(defined(string));
            var p1 = "<" + tag;
            if (attribute !== "") p1 += " " + attribute + '="' + String(value).replace(quot, "&quot;") + '"';
            return p1 + ">" + S + "</" + tag + ">"
        };
        module.exports = function(NAME, exec) {
            var O = {};
            O[NAME] = exec(createHTML);
            $export($export.P + $export.F * fails(function() {
                var test = "" [NAME]('"');
                return test !== test.toLowerCase() || test.split('"').length > 3
            }), "String", O)
        }
    }, {
        "./_defined": 28,
        "./_export": 33,
        "./_fails": 35
    }],
    106: [function(require, module, exports) {
        var toLength = require("./_to-length");
        var repeat = require("./_string-repeat");
        var defined = require("./_defined");
        module.exports = function(that, maxLength, fillString, left) {
            var S = String(defined(that));
            var stringLength = S.length;
            var fillStr = fillString === undefined ? " " : String(fillString);
            var intMaxLength = toLength(maxLength);
            if (intMaxLength <= stringLength || fillStr == "") return S;
            var fillLen = intMaxLength - stringLength;
            var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
            if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
            return left ? stringFiller + S : S + stringFiller
        }
    }, {
        "./_defined": 28,
        "./_string-repeat": 107,
        "./_to-length": 115
    }],
    107: [function(require, module, exports) {
        "use strict";
        var toInteger = require("./_to-integer");
        var defined = require("./_defined");
        module.exports = function repeat(count) {
            var str = String(defined(this));
            var res = "";
            var n = toInteger(count);
            if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
            for (; n > 0;
                (n >>>= 1) && (str += str))
                if (n & 1) res += str;
            return res
        }
    }, {
        "./_defined": 28,
        "./_to-integer": 113
    }],
    108: [function(require, module, exports) {
        var $export = require("./_export");
        var defined = require("./_defined");
        var fails = require("./_fails");
        var spaces = require("./_string-ws");
        var space = "[" + spaces + "]";
        var non = "â€‹Â…";
        var ltrim = RegExp("^" + space + space + "*");
        var rtrim = RegExp(space + space + "*$");
        var exporter = function(KEY, exec, ALIAS) {
            var exp = {};
            var FORCE = fails(function() {
                return !!spaces[KEY]() || non[KEY]() != non
            });
            var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
            if (ALIAS) exp[ALIAS] = fn;
            $export($export.P + $export.F * FORCE, "String", exp)
        };
        var trim = exporter.trim = function(string, TYPE) {
            string = String(defined(string));
            if (TYPE & 1) string = string.replace(ltrim, "");
            if (TYPE & 2) string = string.replace(rtrim, "");
            return string
        };
        module.exports = exporter
    }, {
        "./_defined": 28,
        "./_export": 33,
        "./_fails": 35,
        "./_string-ws": 109
    }],
    109: [function(require, module, exports) {
        module.exports = "\t\n\v\f\r Â áš€á Žâ€€â€â€‚â€ƒ" + "â€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\u2028\u2029\ufeff"
    }, {}],
    110: [function(require, module, exports) {
        var ctx = require("./_ctx");
        var invoke = require("./_invoke");
        var html = require("./_html");
        var cel = require("./_dom-create");
        var global = require("./_global");
        var process = global.process;
        var setTask = global.setImmediate;
        var clearTask = global.clearImmediate;
        var MessageChannel = global.MessageChannel;
        var Dispatch = global.Dispatch;
        var counter = 0;
        var queue = {};
        var ONREADYSTATECHANGE = "onreadystatechange";
        var defer, channel, port;
        var run = function() {
            var id = +this;
            if (queue.hasOwnProperty(id)) {
                var fn = queue[id];
                delete queue[id];
                fn()
            }
        };
        var listener = function(event) {
            run.call(event.data)
        };
        if (!setTask || !clearTask) {
            setTask = function setImmediate(fn) {
                var args = [];
                var i = 1;
                while (arguments.length > i) args.push(arguments[i++]);
                queue[++counter] = function() {
                    invoke(typeof fn == "function" ? fn : Function(fn), args)
                };
                defer(counter);
                return counter
            };
            clearTask = function clearImmediate(id) {
                delete queue[id]
            };
            if (require("./_cof")(process) == "process") {
                defer = function(id) {
                    process.nextTick(ctx(run, id, 1))
                }
            } else if (Dispatch && Dispatch.now) {
                defer = function(id) {
                    Dispatch.now(ctx(run, id, 1))
                }
            } else if (MessageChannel) {
                channel = new MessageChannel;
                port = channel.port2;
                channel.port1.onmessage = listener;
                defer = ctx(port.postMessage, port, 1)
            } else if (global.addEventListener && typeof postMessage == "function" && !global.importScripts) {
                defer = function(id) {
                    global.postMessage(id + "", "*")
                };
                global.addEventListener("message", listener, false)
            } else if (ONREADYSTATECHANGE in cel("script")) {
                defer = function(id) {
                    html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                        html.removeChild(this);
                        run.call(id)
                    }
                }
            } else {
                defer = function(id) {
                    setTimeout(ctx(run, id, 1), 0)
                }
            }
        }
        module.exports = {
            set: setTask,
            clear: clearTask
        }
    }, {
        "./_cof": 18,
        "./_ctx": 25,
        "./_dom-create": 30,
        "./_global": 40,
        "./_html": 43,
        "./_invoke": 46
    }],
    111: [function(require, module, exports) {
        var toInteger = require("./_to-integer");
        var max = Math.max;
        var min = Math.min;
        module.exports = function(index, length) {
            index = toInteger(index);
            return index < 0 ? max(index + length, 0) : min(index, length)
        }
    }, {
        "./_to-integer": 113
    }],
    112: [function(require, module, exports) {
        var toInteger = require("./_to-integer");
        var toLength = require("./_to-length");
        module.exports = function(it) {
            if (it === undefined) return 0;
            var number = toInteger(it);
            var length = toLength(number);
            if (number !== length) throw RangeError("Wrong length!");
            return length
        }
    }, {
        "./_to-integer": 113,
        "./_to-length": 115
    }],
    113: [function(require, module, exports) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it)
        }
    }, {}],
    114: [function(require, module, exports) {
        var IObject = require("./_iobject");
        var defined = require("./_defined");
        module.exports = function(it) {
            return IObject(defined(it))
        }
    }, {
        "./_defined": 28,
        "./_iobject": 47
    }],
    115: [function(require, module, exports) {
        var toInteger = require("./_to-integer");
        var min = Math.min;
        module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 9007199254740991) : 0
        }
    }, {
        "./_to-integer": 113
    }],
    116: [function(require, module, exports) {
        var defined = require("./_defined");
        module.exports = function(it) {
            return Object(defined(it))
        }
    }, {
        "./_defined": 28
    }],
    117: [function(require, module, exports) {
        var isObject = require("./_is-object");
        module.exports = function(it, S) {
            if (!isObject(it)) return it;
            var fn, val;
            if (S && typeof(fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
            if (typeof(fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
            if (!S && typeof(fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
            throw TypeError("Can't convert object to primitive value")
        }
    }, {
        "./_is-object": 51
    }],
    118: [function(require, module, exports) {
        "use strict";
        if (require("./_descriptors")) {
            var LIBRARY = require("./_library");
            var global = require("./_global");
            var fails = require("./_fails");
            var $export = require("./_export");
            var $typed = require("./_typed");
            var $buffer = require("./_typed-buffer");
            var ctx = require("./_ctx");
            var anInstance = require("./_an-instance");
            var propertyDesc = require("./_property-desc");
            var hide = require("./_hide");
            var redefineAll = require("./_redefine-all");
            var toInteger = require("./_to-integer");
            var toLength = require("./_to-length");
            var toIndex = require("./_to-index");
            var toAbsoluteIndex = require("./_to-absolute-index");
            var toPrimitive = require("./_to-primitive");
            var has = require("./_has");
            var classof = require("./_classof");
            var isObject = require("./_is-object");
            var toObject = require("./_to-object");
            var isArrayIter = require("./_is-array-iter");
            var create = require("./_object-create");
            var getPrototypeOf = require("./_object-gpo");
            var gOPN = require("./_object-gopn").f;
            var getIterFn = require("./core.get-iterator-method");
            var uid = require("./_uid");
            var wks = require("./_wks");
            var createArrayMethod = require("./_array-methods");
            var createArrayIncludes = require("./_array-includes");
            var speciesConstructor = require("./_species-constructor");
            var ArrayIterators = require("./es6.array.iterator");
            var Iterators = require("./_iterators");
            var $iterDetect = require("./_iter-detect");
            var setSpecies = require("./_set-species");
            var arrayFill = require("./_array-fill");
            var arrayCopyWithin = require("./_array-copy-within");
            var $DP = require("./_object-dp");
            var $GOPD = require("./_object-gopd");
            var dP = $DP.f;
            var gOPD = $GOPD.f;
            var RangeError = global.RangeError;
            var TypeError = global.TypeError;
            var Uint8Array = global.Uint8Array;
            var ARRAY_BUFFER = "ArrayBuffer";
            var SHARED_BUFFER = "Shared" + ARRAY_BUFFER;
            var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
            var PROTOTYPE = "prototype";
            var ArrayProto = Array[PROTOTYPE];
            var $ArrayBuffer = $buffer.ArrayBuffer;
            var $DataView = $buffer.DataView;
            var arrayForEach = createArrayMethod(0);
            var arrayFilter = createArrayMethod(2);
            var arraySome = createArrayMethod(3);
            var arrayEvery = createArrayMethod(4);
            var arrayFind = createArrayMethod(5);
            var arrayFindIndex = createArrayMethod(6);
            var arrayIncludes = createArrayIncludes(true);
            var arrayIndexOf = createArrayIncludes(false);
            var arrayValues = ArrayIterators.values;
            var arrayKeys = ArrayIterators.keys;
            var arrayEntries = ArrayIterators.entries;
            var arrayLastIndexOf = ArrayProto.lastIndexOf;
            var arrayReduce = ArrayProto.reduce;
            var arrayReduceRight = ArrayProto.reduceRight;
            var arrayJoin = ArrayProto.join;
            var arraySort = ArrayProto.sort;
            var arraySlice = ArrayProto.slice;
            var arrayToString = ArrayProto.toString;
            var arrayToLocaleString = ArrayProto.toLocaleString;
            var ITERATOR = wks("iterator");
            var TAG = wks("toStringTag");
            var TYPED_CONSTRUCTOR = uid("typed_constructor");
            var DEF_CONSTRUCTOR = uid("def_constructor");
            var ALL_CONSTRUCTORS = $typed.CONSTR;
            var TYPED_ARRAY = $typed.TYPED;
            var VIEW = $typed.VIEW;
            var WRONG_LENGTH = "Wrong length!";
            var $map = createArrayMethod(1, function(O, length) {
                return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length)
            });
            var LITTLE_ENDIAN = fails(function() {
                return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1
            });
            var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function() {
                new Uint8Array(1).set({})
            });
            var toOffset = function(it, BYTES) {
                var offset = toInteger(it);
                if (offset < 0 || offset % BYTES) throw RangeError("Wrong offset!");
                return offset
            };
            var validate = function(it) {
                if (isObject(it) && TYPED_ARRAY in it) return it;
                throw TypeError(it + " is not a typed array!")
            };
            var allocate = function(C, length) {
                if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
                    throw TypeError("It is not a typed array constructor!")
                }
                return new C(length)
            };
            var speciesFromList = function(O, list) {
                return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list)
            };
            var fromList = function(C, list) {
                var index = 0;
                var length = list.length;
                var result = allocate(C, length);
                while (length > index) result[index] = list[index++];
                return result
            };
            var addGetter = function(it, key, internal) {
                dP(it, key, {
                    get: function() {
                        return this._d[internal]
                    }
                })
            };
            var $from = function from(source) {
                var O = toObject(source);
                var aLen = arguments.length;
                var mapfn = aLen > 1 ? arguments[1] : undefined;
                var mapping = mapfn !== undefined;
                var iterFn = getIterFn(O);
                var i, length, values, result, step, iterator;
                if (iterFn != undefined && !isArrayIter(iterFn)) {
                    for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
                        values.push(step.value)
                    }
                    O = values
                }
                if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
                for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
                    result[i] = mapping ? mapfn(O[i], i) : O[i]
                }
                return result
            };
            var $of = function of() {
                var index = 0;
                var length = arguments.length;
                var result = allocate(this, length);
                while (length > index) result[index] = arguments[index++];
                return result
            };
            var TO_LOCALE_BUG = !!Uint8Array && fails(function() {
                arrayToLocaleString.call(new Uint8Array(1))
            });
            var $toLocaleString = function toLocaleString() {
                return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments)
            };
            var proto = {
                copyWithin: function copyWithin(target, start) {
                    return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined)
                },
                every: function every(callbackfn) {
                    return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)
                },
                fill: function fill(value) {
                    return arrayFill.apply(validate(this), arguments)
                },
                filter: function filter(callbackfn) {
                    return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined))
                },
                find: function find(predicate) {
                    return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined)
                },
                findIndex: function findIndex(predicate) {
                    return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined)
                },
                forEach: function forEach(callbackfn) {
                    arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)
                },
                indexOf: function indexOf(searchElement) {
                    return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined)
                },
                includes: function includes(searchElement) {
                    return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined)
                },
                join: function join(separator) {
                    return arrayJoin.apply(validate(this), arguments)
                },
                lastIndexOf: function lastIndexOf(searchElement) {
                    return arrayLastIndexOf.apply(validate(this), arguments)
                },
                map: function map(mapfn) {
                    return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined)
                },
                reduce: function reduce(callbackfn) {
                    return arrayReduce.apply(validate(this), arguments)
                },
                reduceRight: function reduceRight(callbackfn) {
                    return arrayReduceRight.apply(validate(this), arguments)
                },
                reverse: function reverse() {
                    var that = this;
                    var length = validate(that).length;
                    var middle = Math.floor(length / 2);
                    var index = 0;
                    var value;
                    while (index < middle) {
                        value = that[index];
                        that[index++] = that[--length];
                        that[length] = value
                    }
                    return that
                },
                some: function some(callbackfn) {
                    return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)
                },
                sort: function sort(comparefn) {
                    return arraySort.call(validate(this), comparefn)
                },
                subarray: function subarray(begin, end) {
                    var O = validate(this);
                    var length = O.length;
                    var $begin = toAbsoluteIndex(begin, length);
                    return new(speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin))
                }
            };
            var $slice = function slice(start, end) {
                return speciesFromList(this, arraySlice.call(validate(this), start, end))
            };
            var $set = function set(arrayLike) {
                validate(this);
                var offset = toOffset(arguments[1], 1);
                var length = this.length;
                var src = toObject(arrayLike);
                var len = toLength(src.length);
                var index = 0;
                if (len + offset > length) throw RangeError(WRONG_LENGTH);
                while (index < len) this[offset + index] = src[index++]
            };
            var $iterators = {
                entries: function entries() {
                    return arrayEntries.call(validate(this))
                },
                keys: function keys() {
                    return arrayKeys.call(validate(this))
                },
                values: function values() {
                    return arrayValues.call(validate(this))
                }
            };
            var isTAIndex = function(target, key) {
                return isObject(target) && target[TYPED_ARRAY] && typeof key != "symbol" && key in target && String(+key) == String(key)
            };
            var $getDesc = function getOwnPropertyDescriptor(target, key) {
                return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key)
            };
            var $setDesc = function defineProperty(target, key, desc) {
                if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, "value") && !has(desc, "get") && !has(desc, "set") && !desc.configurable && (!has(desc, "writable") || desc.writable) && (!has(desc, "enumerable") || desc.enumerable)) {
                    target[key] = desc.value;
                    return target
                }
                return dP(target, key, desc)
            };
            if (!ALL_CONSTRUCTORS) {
                $GOPD.f = $getDesc;
                $DP.f = $setDesc
            }
            $export($export.S + $export.F * !ALL_CONSTRUCTORS, "Object", {
                getOwnPropertyDescriptor: $getDesc,
                defineProperty: $setDesc
            });
            if (fails(function() {
                    arrayToString.call({})
                })) {
                arrayToString = arrayToLocaleString = function toString() {
                    return arrayJoin.call(this)
                }
            }
            var $TypedArrayPrototype$ = redefineAll({}, proto);
            redefineAll($TypedArrayPrototype$, $iterators);
            hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
            redefineAll($TypedArrayPrototype$, {
                slice: $slice,
                set: $set,
                constructor: function() {},
                toString: arrayToString,
                toLocaleString: $toLocaleString
            });
            addGetter($TypedArrayPrototype$, "buffer", "b");
            addGetter($TypedArrayPrototype$, "byteOffset", "o");
            addGetter($TypedArrayPrototype$, "byteLength", "l");
            addGetter($TypedArrayPrototype$, "length", "e");
            dP($TypedArrayPrototype$, TAG, {
                get: function() {
                    return this[TYPED_ARRAY]
                }
            });
            module.exports = function(KEY, BYTES, wrapper, CLAMPED) {
                CLAMPED = !!CLAMPED;
                var NAME = KEY + (CLAMPED ? "Clamped" : "") + "Array";
                var GETTER = "get" + KEY;
                var SETTER = "set" + KEY;
                var TypedArray = global[NAME];
                var Base = TypedArray || {};
                var TAC = TypedArray && getPrototypeOf(TypedArray);
                var FORCED = !TypedArray || !$typed.ABV;
                var O = {};
                var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
                var getter = function(that, index) {
                    var data = that._d;
                    return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN)
                };
                var setter = function(that, index, value) {
                    var data = that._d;
                    if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
                    data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN)
                };
                var addElement = function(that, index) {
                    dP(that, index, {
                        get: function() {
                            return getter(this, index)
                        },
                        set: function(value) {
                            return setter(this, index, value)
                        },
                        enumerable: true
                    })
                };
                if (FORCED) {
                    TypedArray = wrapper(function(that, data, $offset, $length) {
                        anInstance(that, TypedArray, NAME, "_d");
                        var index = 0;
                        var offset = 0;
                        var buffer, byteLength, length, klass;
                        if (!isObject(data)) {
                            length = toIndex(data);
                            byteLength = length * BYTES;
                            buffer = new $ArrayBuffer(byteLength)
                        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                            buffer = data;
                            offset = toOffset($offset, BYTES);
                            var $len = data.byteLength;
                            if ($length === undefined) {
                                if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                                byteLength = $len - offset;
                                if (byteLength < 0) throw RangeError(WRONG_LENGTH)
                            } else {
                                byteLength = toLength($length) * BYTES;
                                if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH)
                            }
                            length = byteLength / BYTES
                        } else if (TYPED_ARRAY in data) {
                            return fromList(TypedArray, data)
                        } else {
                            return $from.call(TypedArray, data)
                        }
                        hide(that, "_d", {
                            b: buffer,
                            o: offset,
                            l: byteLength,
                            e: length,
                            v: new $DataView(buffer)
                        });
                        while (index < length) addElement(that, index++)
                    });
                    TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
                    hide(TypedArrayPrototype, "constructor", TypedArray)
                } else if (!fails(function() {
                        TypedArray(1)
                    }) || !fails(function() {
                        new TypedArray(-1)
                    }) || !$iterDetect(function(iter) {
                        new TypedArray;
                        new TypedArray(null);
                        new TypedArray(1.5);
                        new TypedArray(iter)
                    }, true)) {
                    TypedArray = wrapper(function(that, data, $offset, $length) {
                        anInstance(that, TypedArray, NAME);
                        var klass;
                        if (!isObject(data)) return new Base(toIndex(data));
                        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                            return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data)
                        }
                        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
                        return $from.call(TypedArray, data)
                    });
                    arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key) {
                        if (!(key in TypedArray)) hide(TypedArray, key, Base[key])
                    });
                    TypedArray[PROTOTYPE] = TypedArrayPrototype;
                    if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray
                }
                var $nativeIterator = TypedArrayPrototype[ITERATOR];
                var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == "values" || $nativeIterator.name == undefined);
                var $iterator = $iterators.values;
                hide(TypedArray, TYPED_CONSTRUCTOR, true);
                hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
                hide(TypedArrayPrototype, VIEW, true);
                hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
                if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
                    dP(TypedArrayPrototype, TAG, {
                        get: function() {
                            return NAME
                        }
                    })
                }
                O[NAME] = TypedArray;
                $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
                $export($export.S, NAME, {
                    BYTES_PER_ELEMENT: BYTES
                });
                $export($export.S + $export.F * fails(function() {
                    Base.of.call(TypedArray, 1)
                }), NAME, {
                    from: $from,
                    of: $of
                });
                if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
                $export($export.P, NAME, proto);
                setSpecies(NAME);
                $export($export.P + $export.F * FORCED_SET, NAME, {
                    set: $set
                });
                $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
                if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
                $export($export.P + $export.F * fails(function() {
                    new TypedArray(1).slice()
                }), NAME, {
                    slice: $slice
                });
                $export($export.P + $export.F * (fails(function() {
                    return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
                }) || !fails(function() {
                    TypedArrayPrototype.toLocaleString.call([1, 2])
                })), NAME, {
                    toLocaleString: $toLocaleString
                });
                Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
                if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator)
            }
        } else module.exports = function() {}
    }, {
        "./_an-instance": 6,
        "./_array-copy-within": 8,
        "./_array-fill": 9,
        "./_array-includes": 11,
        "./_array-methods": 12,
        "./_classof": 17,
        "./_ctx": 25,
        "./_descriptors": 29,
        "./_export": 33,
        "./_fails": 35,
        "./_global": 40,
        "./_has": 41,
        "./_hide": 42,
        "./_is-array-iter": 48,
        "./_is-object": 51,
        "./_iter-detect": 56,
        "./_iterators": 58,
        "./_library": 59,
        "./_object-create": 70,
        "./_object-dp": 71,
        "./_object-gopd": 74,
        "./_object-gopn": 76,
        "./_object-gpo": 78,
        "./_property-desc": 89,
        "./_redefine-all": 90,
        "./_set-species": 97,
        "./_species-constructor": 101,
        "./_to-absolute-index": 111,
        "./_to-index": 112,
        "./_to-integer": 113,
        "./_to-length": 115,
        "./_to-object": 116,
        "./_to-primitive": 117,
        "./_typed": 120,
        "./_typed-buffer": 119,
        "./_uid": 121,
        "./_wks": 126,
        "./core.get-iterator-method": 127,
        "./es6.array.iterator": 139
    }],
    119: [function(require, module, exports) {
        "use strict";
        var global = require("./_global");
        var DESCRIPTORS = require("./_descriptors");
        var LIBRARY = require("./_library");
        var $typed = require("./_typed");
        var hide = require("./_hide");
        var redefineAll = require("./_redefine-all");
        var fails = require("./_fails");
        var anInstance = require("./_an-instance");
        var toInteger = require("./_to-integer");
        var toLength = require("./_to-length");
        var toIndex = require("./_to-index");
        var gOPN = require("./_object-gopn").f;
        var dP = require("./_object-dp").f;
        var arrayFill = require("./_array-fill");
        var setToStringTag = require("./_set-to-string-tag");
        var ARRAY_BUFFER = "ArrayBuffer";
        var DATA_VIEW = "DataView";
        var PROTOTYPE = "prototype";
        var WRONG_LENGTH = "Wrong length!";
        var WRONG_INDEX = "Wrong index!";
        var $ArrayBuffer = global[ARRAY_BUFFER];
        var $DataView = global[DATA_VIEW];
        var Math = global.Math;
        var RangeError = global.RangeError;
        var Infinity = global.Infinity;
        var BaseBuffer = $ArrayBuffer;
        var abs = Math.abs;
        var pow = Math.pow;
        var floor = Math.floor;
        var log = Math.log;
        var LN2 = Math.LN2;
        var BUFFER = "buffer";
        var BYTE_LENGTH = "byteLength";
        var BYTE_OFFSET = "byteOffset";
        var $BUFFER = DESCRIPTORS ? "_b" : BUFFER;
        var $LENGTH = DESCRIPTORS ? "_l" : BYTE_LENGTH;
        var $OFFSET = DESCRIPTORS ? "_o" : BYTE_OFFSET;

        function packIEEE754(value, mLen, nBytes) {
            var buffer = new Array(nBytes);
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
            var i = 0;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            var e, m, c;
            value = abs(value);
            if (value != value || value === Infinity) {
                m = value != value ? 1 : 0;
                e = eMax
            } else {
                e = floor(log(value) / LN2);
                if (value * (c = pow(2, -e)) < 1) {
                    e--;
                    c *= 2
                }
                if (e + eBias >= 1) {
                    value += rt / c
                } else {
                    value += rt * pow(2, 1 - eBias)
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2
                }
                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * pow(2, mLen);
                    e = e + eBias
                } else {
                    m = value * pow(2, eBias - 1) * pow(2, mLen);
                    e = 0
                }
            }
            for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
            e = e << mLen | m;
            eLen += mLen;
            for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
            buffer[--i] |= s * 128;
            return buffer
        }

        function unpackIEEE754(buffer, mLen, nBytes) {
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = eLen - 7;
            var i = nBytes - 1;
            var s = buffer[i--];
            var e = s & 127;
            var m;
            s >>= 7;
            for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
            if (e === 0) {
                e = 1 - eBias
            } else if (e === eMax) {
                return m ? NaN : s ? -Infinity : Infinity
            } else {
                m = m + pow(2, mLen);
                e = e - eBias
            }
            return (s ? -1 : 1) * m * pow(2, e - mLen)
        }

        function unpackI32(bytes) {
            return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0]
        }

        function packI8(it) {
            return [it & 255]
        }

        function packI16(it) {
            return [it & 255, it >> 8 & 255]
        }

        function packI32(it) {
            return [it & 255, it >> 8 & 255, it >> 16 & 255, it >> 24 & 255]
        }

        function packF64(it) {
            return packIEEE754(it, 52, 8)
        }

        function packF32(it) {
            return packIEEE754(it, 23, 4)
        }

        function addGetter(C, key, internal) {
            dP(C[PROTOTYPE], key, {
                get: function() {
                    return this[internal]
                }
            })
        }

        function get(view, bytes, index, isLittleEndian) {
            var numIndex = +index;
            var intIndex = toIndex(numIndex);
            if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
            var store = view[$BUFFER]._b;
            var start = intIndex + view[$OFFSET];
            var pack = store.slice(start, start + bytes);
            return isLittleEndian ? pack : pack.reverse()
        }

        function set(view, bytes, index, conversion, value, isLittleEndian) {
            var numIndex = +index;
            var intIndex = toIndex(numIndex);
            if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
            var store = view[$BUFFER]._b;
            var start = intIndex + view[$OFFSET];
            var pack = conversion(+value);
            for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]
        }
        if (!$typed.ABV) {
            $ArrayBuffer = function ArrayBuffer(length) {
                anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
                var byteLength = toIndex(length);
                this._b = arrayFill.call(new Array(byteLength), 0);
                this[$LENGTH] = byteLength
            };
            $DataView = function DataView(buffer, byteOffset, byteLength) {
                anInstance(this, $DataView, DATA_VIEW);
                anInstance(buffer, $ArrayBuffer, DATA_VIEW);
                var bufferLength = buffer[$LENGTH];
                var offset = toInteger(byteOffset);
                if (offset < 0 || offset > bufferLength) throw RangeError("Wrong offset!");
                byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
                if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
                this[$BUFFER] = buffer;
                this[$OFFSET] = offset;
                this[$LENGTH] = byteLength
            };
            if (DESCRIPTORS) {
                addGetter($ArrayBuffer, BYTE_LENGTH, "_l");
                addGetter($DataView, BUFFER, "_b");
                addGetter($DataView, BYTE_LENGTH, "_l");
                addGetter($DataView, BYTE_OFFSET, "_o")
            }
            redefineAll($DataView[PROTOTYPE], {
                getInt8: function getInt8(byteOffset) {
                    return get(this, 1, byteOffset)[0] << 24 >> 24
                },
                getUint8: function getUint8(byteOffset) {
                    return get(this, 1, byteOffset)[0]
                },
                getInt16: function getInt16(byteOffset) {
                    var bytes = get(this, 2, byteOffset, arguments[1]);
                    return (bytes[1] << 8 | bytes[0]) << 16 >> 16
                },
                getUint16: function getUint16(byteOffset) {
                    var bytes = get(this, 2, byteOffset, arguments[1]);
                    return bytes[1] << 8 | bytes[0]
                },
                getInt32: function getInt32(byteOffset) {
                    return unpackI32(get(this, 4, byteOffset, arguments[1]))
                },
                getUint32: function getUint32(byteOffset) {
                    return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0
                },
                getFloat32: function getFloat32(byteOffset) {
                    return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4)
                },
                getFloat64: function getFloat64(byteOffset) {
                    return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8)
                },
                setInt8: function setInt8(byteOffset, value) {
                    set(this, 1, byteOffset, packI8, value)
                },
                setUint8: function setUint8(byteOffset, value) {
                    set(this, 1, byteOffset, packI8, value)
                },
                setInt16: function setInt16(byteOffset, value) {
                    set(this, 2, byteOffset, packI16, value, arguments[2])
                },
                setUint16: function setUint16(byteOffset, value) {
                    set(this, 2, byteOffset, packI16, value, arguments[2])
                },
                setInt32: function setInt32(byteOffset, value) {
                    set(this, 4, byteOffset, packI32, value, arguments[2])
                },
                setUint32: function setUint32(byteOffset, value) {
                    set(this, 4, byteOffset, packI32, value, arguments[2])
                },
                setFloat32: function setFloat32(byteOffset, value) {
                    set(this, 4, byteOffset, packF32, value, arguments[2])
                },
                setFloat64: function setFloat64(byteOffset, value) {
                    set(this, 8, byteOffset, packF64, value, arguments[2])
                }
            })
        } else {
            if (!fails(function() {
                    $ArrayBuffer(1)
                }) || !fails(function() {
                    new $ArrayBuffer(-1)
                }) || fails(function() {
                    new $ArrayBuffer;
                    new $ArrayBuffer(1.5);
                    new $ArrayBuffer(NaN);
                    return $ArrayBuffer.name != ARRAY_BUFFER
                })) {
                $ArrayBuffer = function ArrayBuffer(length) {
                    anInstance(this, $ArrayBuffer);
                    return new BaseBuffer(toIndex(length))
                };
                var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
                for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
                    if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key])
                }
                if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer
            }
            var view = new $DataView(new $ArrayBuffer(2));
            var $setInt8 = $DataView[PROTOTYPE].setInt8;
            view.setInt8(0, 2147483648);
            view.setInt8(1, 2147483649);
            if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
                setInt8: function setInt8(byteOffset, value) {
                    $setInt8.call(this, byteOffset, value << 24 >> 24)
                },
                setUint8: function setUint8(byteOffset, value) {
                    $setInt8.call(this, byteOffset, value << 24 >> 24)
                }
            }, true)
        }
        setToStringTag($ArrayBuffer, ARRAY_BUFFER);
        setToStringTag($DataView, DATA_VIEW);
        hide($DataView[PROTOTYPE], $typed.VIEW, true);
        exports[ARRAY_BUFFER] = $ArrayBuffer;
        exports[DATA_VIEW] = $DataView
    }, {
        "./_an-instance": 6,
        "./_array-fill": 9,
        "./_descriptors": 29,
        "./_fails": 35,
        "./_global": 40,
        "./_hide": 42,
        "./_library": 59,
        "./_object-dp": 71,
        "./_object-gopn": 76,
        "./_redefine-all": 90,
        "./_set-to-string-tag": 98,
        "./_to-index": 112,
        "./_to-integer": 113,
        "./_to-length": 115,
        "./_typed": 120
    }],
    120: [function(require, module, exports) {
        var global = require("./_global");
        var hide = require("./_hide");
        var uid = require("./_uid");
        var TYPED = uid("typed_array");
        var VIEW = uid("view");
        var ABV = !!(global.ArrayBuffer && global.DataView);
        var CONSTR = ABV;
        var i = 0;
        var l = 9;
        var Typed;
        var TypedArrayConstructors = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");
        while (i < l) {
            if (Typed = global[TypedArrayConstructors[i++]]) {
                hide(Typed.prototype, TYPED, true);
                hide(Typed.prototype, VIEW, true)
            } else CONSTR = false
        }
        module.exports = {
            ABV: ABV,
            CONSTR: CONSTR,
            TYPED: TYPED,
            VIEW: VIEW
        }
    }, {
        "./_global": 40,
        "./_hide": 42,
        "./_uid": 121
    }],
    121: [function(require, module, exports) {
        var id = 0;
        var px = Math.random();
        module.exports = function(key) {
            return "Symbol(".concat(key === undefined ? "" : key, ")_", (++id + px).toString(36))
        }
    }, {}],
    122: [function(require, module, exports) {
        var global = require("./_global");
        var navigator = global.navigator;
        module.exports = navigator && navigator.userAgent || ""
    }, {
        "./_global": 40
    }],
    123: [function(require, module, exports) {
        var isObject = require("./_is-object");
        module.exports = function(it, TYPE) {
            if (!isObject(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
            return it
        }
    }, {
        "./_is-object": 51
    }],
    124: [function(require, module, exports) {
        var global = require("./_global");
        var core = require("./_core");
        var LIBRARY = require("./_library");
        var wksExt = require("./_wks-ext");
        var defineProperty = require("./_object-dp").f;
        module.exports = function(name) {
            var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
            if (name.charAt(0) != "_" && !(name in $Symbol)) defineProperty($Symbol, name, {
                value: wksExt.f(name)
            })
        }
    }, {
        "./_core": 23,
        "./_global": 40,
        "./_library": 59,
        "./_object-dp": 71,
        "./_wks-ext": 125
    }],
    125: [function(require, module, exports) {
        exports.f = require("./_wks")
    }, {
        "./_wks": 126
    }],
    126: [function(require, module, exports) {
        var store = require("./_shared")("wks");
        var uid = require("./_uid");
        var Symbol = require("./_global").Symbol;
        var USE_SYMBOL = typeof Symbol == "function";
        var $exports = module.exports = function(name) {
            return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name))
        };
        $exports.store = store
    }, {
        "./_global": 40,
        "./_shared": 100,
        "./_uid": 121
    }],
    127: [function(require, module, exports) {
        var classof = require("./_classof");
        var ITERATOR = require("./_wks")("iterator");
        var Iterators = require("./_iterators");
        module.exports = require("./_core").getIteratorMethod = function(it) {
            if (it != undefined) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)]
        }
    }, {
        "./_classof": 17,
        "./_core": 23,
        "./_iterators": 58,
        "./_wks": 126
    }],
    128: [function(require, module, exports) {
        var $export = require("./_export");
        var $re = require("./_replacer")(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        $export($export.S, "RegExp", {
            escape: function escape(it) {
                return $re(it)
            }
        })
    }, {
        "./_export": 33,
        "./_replacer": 92
    }],
    129: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.P, "Array", {
            copyWithin: require("./_array-copy-within")
        });
        require("./_add-to-unscopables")("copyWithin")
    }, {
        "./_add-to-unscopables": 5,
        "./_array-copy-within": 8,
        "./_export": 33
    }],
    130: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $every = require("./_array-methods")(4);
        $export($export.P + $export.F * !require("./_strict-method")([].every, true), "Array", {
            every: function every(callbackfn) {
                return $every(this, callbackfn, arguments[1])
            }
        })
    }, {
        "./_array-methods": 12,
        "./_export": 33,
        "./_strict-method": 102
    }],
    131: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.P, "Array", {
            fill: require("./_array-fill")
        });
        require("./_add-to-unscopables")("fill")
    }, {
        "./_add-to-unscopables": 5,
        "./_array-fill": 9,
        "./_export": 33
    }],
    132: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $filter = require("./_array-methods")(2);
        $export($export.P + $export.F * !require("./_strict-method")([].filter, true), "Array", {
            filter: function filter(callbackfn) {
                return $filter(this, callbackfn, arguments[1])
            }
        })
    }, {
        "./_array-methods": 12,
        "./_export": 33,
        "./_strict-method": 102
    }],
    133: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $find = require("./_array-methods")(6);
        var KEY = "findIndex";
        var forced = true;
        if (KEY in []) Array(1)[KEY](function() {
            forced = false
        });
        $export($export.P + $export.F * forced, "Array", {
            findIndex: function findIndex(callbackfn) {
                return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined)
            }
        });
        require("./_add-to-unscopables")(KEY)
    }, {
        "./_add-to-unscopables": 5,
        "./_array-methods": 12,
        "./_export": 33
    }],
    134: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $find = require("./_array-methods")(5);
        var KEY = "find";
        var forced = true;
        if (KEY in []) Array(1)[KEY](function() {
            forced = false
        });
        $export($export.P + $export.F * forced, "Array", {
            find: function find(callbackfn) {
                return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined)
            }
        });
        require("./_add-to-unscopables")(KEY)
    }, {
        "./_add-to-unscopables": 5,
        "./_array-methods": 12,
        "./_export": 33
    }],
    135: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $forEach = require("./_array-methods")(0);
        var STRICT = require("./_strict-method")([].forEach, true);
        $export($export.P + $export.F * !STRICT, "Array", {
            forEach: function forEach(callbackfn) {
                return $forEach(this, callbackfn, arguments[1])
            }
        })
    }, {
        "./_array-methods": 12,
        "./_export": 33,
        "./_strict-method": 102
    }],
    136: [function(require, module, exports) {
        "use strict";
        var ctx = require("./_ctx");
        var $export = require("./_export");
        var toObject = require("./_to-object");
        var call = require("./_iter-call");
        var isArrayIter = require("./_is-array-iter");
        var toLength = require("./_to-length");
        var createProperty = require("./_create-property");
        var getIterFn = require("./core.get-iterator-method");
        $export($export.S + $export.F * !require("./_iter-detect")(function(iter) {
            Array.from(iter)
        }), "Array", {
            from: function from(arrayLike) {
                var O = toObject(arrayLike);
                var C = typeof this == "function" ? this : Array;
                var aLen = arguments.length;
                var mapfn = aLen > 1 ? arguments[1] : undefined;
                var mapping = mapfn !== undefined;
                var index = 0;
                var iterFn = getIterFn(O);
                var length, result, step, iterator;
                if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
                if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
                    for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
                        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value)
                    }
                } else {
                    length = toLength(O.length);
                    for (result = new C(length); length > index; index++) {
                        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index])
                    }
                }
                result.length = index;
                return result
            }
        })
    }, {
        "./_create-property": 24,
        "./_ctx": 25,
        "./_export": 33,
        "./_is-array-iter": 48,
        "./_iter-call": 53,
        "./_iter-detect": 56,
        "./_to-length": 115,
        "./_to-object": 116,
        "./core.get-iterator-method": 127
    }],
    137: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $indexOf = require("./_array-includes")(false);
        var $native = [].indexOf;
        var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
        $export($export.P + $export.F * (NEGATIVE_ZERO || !require("./_strict-method")($native)), "Array", {
            indexOf: function indexOf(searchElement) {
                return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1])
            }
        })
    }, {
        "./_array-includes": 11,
        "./_export": 33,
        "./_strict-method": 102
    }],
    138: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Array", {
            isArray: require("./_is-array")
        })
    }, {
        "./_export": 33,
        "./_is-array": 49
    }],
    139: [function(require, module, exports) {
        "use strict";
        var addToUnscopables = require("./_add-to-unscopables");
        var step = require("./_iter-step");
        var Iterators = require("./_iterators");
        var toIObject = require("./_to-iobject");
        module.exports = require("./_iter-define")(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated);
            this._i = 0;
            this._k = kind
        }, function() {
            var O = this._t;
            var kind = this._k;
            var index = this._i++;
            if (!O || index >= O.length) {
                this._t = undefined;
                return step(1)
            }
            if (kind == "keys") return step(0, index);
            if (kind == "values") return step(0, O[index]);
            return step(0, [index, O[index]])
        }, "values");
        Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries")
    }, {
        "./_add-to-unscopables": 5,
        "./_iter-define": 55,
        "./_iter-step": 57,
        "./_iterators": 58,
        "./_to-iobject": 114
    }],
    140: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toIObject = require("./_to-iobject");
        var arrayJoin = [].join;
        $export($export.P + $export.F * (require("./_iobject") != Object || !require("./_strict-method")(arrayJoin)), "Array", {
            join: function join(separator) {
                return arrayJoin.call(toIObject(this), separator === undefined ? "," : separator)
            }
        })
    }, {
        "./_export": 33,
        "./_iobject": 47,
        "./_strict-method": 102,
        "./_to-iobject": 114
    }],
    141: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toIObject = require("./_to-iobject");
        var toInteger = require("./_to-integer");
        var toLength = require("./_to-length");
        var $native = [].lastIndexOf;
        var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
        $export($export.P + $export.F * (NEGATIVE_ZERO || !require("./_strict-method")($native)), "Array", {
            lastIndexOf: function lastIndexOf(searchElement) {
                if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
                var O = toIObject(this);
                var length = toLength(O.length);
                var index = length - 1;
                if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
                if (index < 0) index = length + index;
                for (; index >= 0; index--)
                    if (index in O)
                        if (O[index] === searchElement) return index || 0;
                return -1
            }
        })
    }, {
        "./_export": 33,
        "./_strict-method": 102,
        "./_to-integer": 113,
        "./_to-iobject": 114,
        "./_to-length": 115
    }],
    142: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $map = require("./_array-methods")(1);
        $export($export.P + $export.F * !require("./_strict-method")([].map, true), "Array", {
            map: function map(callbackfn) {
                return $map(this, callbackfn, arguments[1])
            }
        })
    }, {
        "./_array-methods": 12,
        "./_export": 33,
        "./_strict-method": 102
    }],
    143: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var createProperty = require("./_create-property");
        $export($export.S + $export.F * require("./_fails")(function() {
            function F() {}
            return !(Array.of.call(F) instanceof F)
        }), "Array", {
            of: function of() {
                var index = 0;
                var aLen = arguments.length;
                var result = new(typeof this == "function" ? this : Array)(aLen);
                while (aLen > index) createProperty(result, index, arguments[index++]);
                result.length = aLen;
                return result
            }
        })
    }, {
        "./_create-property": 24,
        "./_export": 33,
        "./_fails": 35
    }],
    144: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $reduce = require("./_array-reduce");
        $export($export.P + $export.F * !require("./_strict-method")([].reduceRight, true), "Array", {
            reduceRight: function reduceRight(callbackfn) {
                return $reduce(this, callbackfn, arguments.length, arguments[1], true)
            }
        })
    }, {
        "./_array-reduce": 13,
        "./_export": 33,
        "./_strict-method": 102
    }],
    145: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $reduce = require("./_array-reduce");
        $export($export.P + $export.F * !require("./_strict-method")([].reduce, true), "Array", {
            reduce: function reduce(callbackfn) {
                return $reduce(this, callbackfn, arguments.length, arguments[1], false)
            }
        })
    }, {
        "./_array-reduce": 13,
        "./_export": 33,
        "./_strict-method": 102
    }],
    146: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var html = require("./_html");
        var cof = require("./_cof");
        var toAbsoluteIndex = require("./_to-absolute-index");
        var toLength = require("./_to-length");
        var arraySlice = [].slice;
        $export($export.P + $export.F * require("./_fails")(function() {
            if (html) arraySlice.call(html)
        }), "Array", {
            slice: function slice(begin, end) {
                var len = toLength(this.length);
                var klass = cof(this);
                end = end === undefined ? len : end;
                if (klass == "Array") return arraySlice.call(this, begin, end);
                var start = toAbsoluteIndex(begin, len);
                var upTo = toAbsoluteIndex(end, len);
                var size = toLength(upTo - start);
                var cloned = new Array(size);
                var i = 0;
                for (; i < size; i++) cloned[i] = klass == "String" ? this.charAt(start + i) : this[start + i];
                return cloned
            }
        })
    }, {
        "./_cof": 18,
        "./_export": 33,
        "./_fails": 35,
        "./_html": 43,
        "./_to-absolute-index": 111,
        "./_to-length": 115
    }],
    147: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $some = require("./_array-methods")(3);
        $export($export.P + $export.F * !require("./_strict-method")([].some, true), "Array", {
            some: function some(callbackfn) {
                return $some(this, callbackfn, arguments[1])
            }
        })
    }, {
        "./_array-methods": 12,
        "./_export": 33,
        "./_strict-method": 102
    }],
    148: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var aFunction = require("./_a-function");
        var toObject = require("./_to-object");
        var fails = require("./_fails");
        var $sort = [].sort;
        var test = [1, 2, 3];
        $export($export.P + $export.F * (fails(function() {
            test.sort(undefined)
        }) || !fails(function() {
            test.sort(null)
        }) || !require("./_strict-method")($sort)), "Array", {
            sort: function sort(comparefn) {
                return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn))
            }
        })
    }, {
        "./_a-function": 3,
        "./_export": 33,
        "./_fails": 35,
        "./_strict-method": 102,
        "./_to-object": 116
    }],
    149: [function(require, module, exports) {
        require("./_set-species")("Array")
    }, {
        "./_set-species": 97
    }],
    150: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Date", {
            now: function() {
                return (new Date).getTime()
            }
        })
    }, {
        "./_export": 33
    }],
    151: [function(require, module, exports) {
        var $export = require("./_export");
        var toISOString = require("./_date-to-iso-string");
        $export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), "Date", {
            toISOString: toISOString
        })
    }, {
        "./_date-to-iso-string": 26,
        "./_export": 33
    }],
    152: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toObject = require("./_to-object");
        var toPrimitive = require("./_to-primitive");
        $export($export.P + $export.F * require("./_fails")(function() {
            return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
                toISOString: function() {
                    return 1
                }
            }) !== 1
        }), "Date", {
            toJSON: function toJSON(key) {
                var O = toObject(this);
                var pv = toPrimitive(O);
                return typeof pv == "number" && !isFinite(pv) ? null : O.toISOString()
            }
        })
    }, {
        "./_export": 33,
        "./_fails": 35,
        "./_to-object": 116,
        "./_to-primitive": 117
    }],
    153: [function(require, module, exports) {
        var TO_PRIMITIVE = require("./_wks")("toPrimitive");
        var proto = Date.prototype;
        if (!(TO_PRIMITIVE in proto)) require("./_hide")(proto, TO_PRIMITIVE, require("./_date-to-primitive"))
    }, {
        "./_date-to-primitive": 27,
        "./_hide": 42,
        "./_wks": 126
    }],
    154: [function(require, module, exports) {
        var DateProto = Date.prototype;
        var INVALID_DATE = "Invalid Date";
        var TO_STRING = "toString";
        var $toString = DateProto[TO_STRING];
        var getTime = DateProto.getTime;
        if (new Date(NaN) + "" != INVALID_DATE) {
            require("./_redefine")(DateProto, TO_STRING, function toString() {
                var value = getTime.call(this);
                return value === value ? $toString.call(this) : INVALID_DATE
            })
        }
    }, {
        "./_redefine": 91
    }],
    155: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.P, "Function", {
            bind: require("./_bind")
        })
    }, {
        "./_bind": 16,
        "./_export": 33
    }],
    156: [function(require, module, exports) {
        "use strict";
        var isObject = require("./_is-object");
        var getPrototypeOf = require("./_object-gpo");
        var HAS_INSTANCE = require("./_wks")("hasInstance");
        var FunctionProto = Function.prototype;
        if (!(HAS_INSTANCE in FunctionProto)) require("./_object-dp").f(FunctionProto, HAS_INSTANCE, {
            value: function(O) {
                if (typeof this != "function" || !isObject(O)) return false;
                if (!isObject(this.prototype)) return O instanceof this;
                while (O = getPrototypeOf(O))
                    if (this.prototype === O) return true;
                return false
            }
        })
    }, {
        "./_is-object": 51,
        "./_object-dp": 71,
        "./_object-gpo": 78,
        "./_wks": 126
    }],
    157: [function(require, module, exports) {
        var dP = require("./_object-dp").f;
        var FProto = Function.prototype;
        var nameRE = /^\s*function ([^ (]*)/;
        var NAME = "name";
        NAME in FProto || require("./_descriptors") && dP(FProto, NAME, {
            configurable: true,
            get: function() {
                try {
                    return ("" + this).match(nameRE)[1]
                } catch (e) {
                    return ""
                }
            }
        })
    }, {
        "./_descriptors": 29,
        "./_object-dp": 71
    }],
    158: [function(require, module, exports) {
        "use strict";
        var strong = require("./_collection-strong");
        var validate = require("./_validate-collection");
        var MAP = "Map";
        module.exports = require("./_collection")(MAP, function(get) {
            return function Map() {
                return get(this, arguments.length > 0 ? arguments[0] : undefined)
            }
        }, {
            get: function get(key) {
                var entry = strong.getEntry(validate(this, MAP), key);
                return entry && entry.v
            },
            set: function set(key, value) {
                return strong.def(validate(this, MAP), key === 0 ? 0 : key, value)
            }
        }, strong, true)
    }, {
        "./_collection": 22,
        "./_collection-strong": 19,
        "./_validate-collection": 123
    }],
    159: [function(require, module, exports) {
        var $export = require("./_export");
        var log1p = require("./_math-log1p");
        var sqrt = Math.sqrt;
        var $acosh = Math.acosh;
        $export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710 && $acosh(Infinity) == Infinity), "Math", {
            acosh: function acosh(x) {
                return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1))
            }
        })
    }, {
        "./_export": 33,
        "./_math-log1p": 62
    }],
    160: [function(require, module, exports) {
        var $export = require("./_export");
        var $asinh = Math.asinh;

        function asinh(x) {
            return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1))
        }
        $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), "Math", {
            asinh: asinh
        })
    }, {
        "./_export": 33
    }],
    161: [function(require, module, exports) {
        var $export = require("./_export");
        var $atanh = Math.atanh;
        $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), "Math", {
            atanh: function atanh(x) {
                return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2
            }
        })
    }, {
        "./_export": 33
    }],
    162: [function(require, module, exports) {
        var $export = require("./_export");
        var sign = require("./_math-sign");
        $export($export.S, "Math", {
            cbrt: function cbrt(x) {
                return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3)
            }
        })
    }, {
        "./_export": 33,
        "./_math-sign": 64
    }],
    163: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            clz32: function clz32(x) {
                return (x >>>= 0) ? 31 - Math.floor(Math.log(x + .5) * Math.LOG2E) : 32
            }
        })
    }, {
        "./_export": 33
    }],
    164: [function(require, module, exports) {
        var $export = require("./_export");
        var exp = Math.exp;
        $export($export.S, "Math", {
            cosh: function cosh(x) {
                return (exp(x = +x) + exp(-x)) / 2
            }
        })
    }, {
        "./_export": 33
    }],
    165: [function(require, module, exports) {
        var $export = require("./_export");
        var $expm1 = require("./_math-expm1");
        $export($export.S + $export.F * ($expm1 != Math.expm1), "Math", {
            expm1: $expm1
        })
    }, {
        "./_export": 33,
        "./_math-expm1": 60
    }],
    166: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            fround: require("./_math-fround")
        })
    }, {
        "./_export": 33,
        "./_math-fround": 61
    }],
    167: [function(require, module, exports) {
        var $export = require("./_export");
        var abs = Math.abs;
        $export($export.S, "Math", {
            hypot: function hypot(value1, value2) {
                var sum = 0;
                var i = 0;
                var aLen = arguments.length;
                var larg = 0;
                var arg, div;
                while (i < aLen) {
                    arg = abs(arguments[i++]);
                    if (larg < arg) {
                        div = larg / arg;
                        sum = sum * div * div + 1;
                        larg = arg
                    } else if (arg > 0) {
                        div = arg / larg;
                        sum += div * div
                    } else sum += arg
                }
                return larg === Infinity ? Infinity : larg * Math.sqrt(sum)
            }
        })
    }, {
        "./_export": 33
    }],
    168: [function(require, module, exports) {
        var $export = require("./_export");
        var $imul = Math.imul;
        $export($export.S + $export.F * require("./_fails")(function() {
            return $imul(4294967295, 5) != -5 || $imul.length != 2
        }), "Math", {
            imul: function imul(x, y) {
                var UINT16 = 65535;
                var xn = +x;
                var yn = +y;
                var xl = UINT16 & xn;
                var yl = UINT16 & yn;
                return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0)
            }
        })
    }, {
        "./_export": 33,
        "./_fails": 35
    }],
    169: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            log10: function log10(x) {
                return Math.log(x) * Math.LOG10E
            }
        })
    }, {
        "./_export": 33
    }],
    170: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            log1p: require("./_math-log1p")
        })
    }, {
        "./_export": 33,
        "./_math-log1p": 62
    }],
    171: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            log2: function log2(x) {
                return Math.log(x) / Math.LN2
            }
        })
    }, {
        "./_export": 33
    }],
    172: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            sign: require("./_math-sign")
        })
    }, {
        "./_export": 33,
        "./_math-sign": 64
    }],
    173: [function(require, module, exports) {
        var $export = require("./_export");
        var expm1 = require("./_math-expm1");
        var exp = Math.exp;
        $export($export.S + $export.F * require("./_fails")(function() {
            return !Math.sinh(-2e-17) != -2e-17
        }), "Math", {
            sinh: function sinh(x) {
                return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2)
            }
        })
    }, {
        "./_export": 33,
        "./_fails": 35,
        "./_math-expm1": 60
    }],
    174: [function(require, module, exports) {
        var $export = require("./_export");
        var expm1 = require("./_math-expm1");
        var exp = Math.exp;
        $export($export.S, "Math", {
            tanh: function tanh(x) {
                var a = expm1(x = +x);
                var b = expm1(-x);
                return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x))
            }
        })
    }, {
        "./_export": 33,
        "./_math-expm1": 60
    }],
    175: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            trunc: function trunc(it) {
                return (it > 0 ? Math.floor : Math.ceil)(it)
            }
        })
    }, {
        "./_export": 33
    }],
    176: [function(require, module, exports) {
        "use strict";
        var global = require("./_global");
        var has = require("./_has");
        var cof = require("./_cof");
        var inheritIfRequired = require("./_inherit-if-required");
        var toPrimitive = require("./_to-primitive");
        var fails = require("./_fails");
        var gOPN = require("./_object-gopn").f;
        var gOPD = require("./_object-gopd").f;
        var dP = require("./_object-dp").f;
        var $trim = require("./_string-trim").trim;
        var NUMBER = "Number";
        var $Number = global[NUMBER];
        var Base = $Number;
        var proto = $Number.prototype;
        var BROKEN_COF = cof(require("./_object-create")(proto)) == NUMBER;
        var TRIM = "trim" in String.prototype;
        var toNumber = function(argument) {
            var it = toPrimitive(argument, false);
            if (typeof it == "string" && it.length > 2) {
                it = TRIM ? it.trim() : $trim(it, 3);
                var first = it.charCodeAt(0);
                var third, radix, maxCode;
                if (first === 43 || first === 45) {
                    third = it.charCodeAt(2);
                    if (third === 88 || third === 120) return NaN
                } else if (first === 48) {
                    switch (it.charCodeAt(1)) {
                        case 66:
                        case 98:
                            radix = 2;
                            maxCode = 49;
                            break;
                        case 79:
                        case 111:
                            radix = 8;
                            maxCode = 55;
                            break;
                        default:
                            return +it
                    }
                    for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
                        code = digits.charCodeAt(i);
                        if (code < 48 || code > maxCode) return NaN
                    }
                    return parseInt(digits, radix)
                }
            }
            return +it
        };
        if (!$Number(" 0o1") || !$Number("0b1") || $Number("+0x1")) {
            $Number = function Number(value) {
                var it = arguments.length < 1 ? 0 : value;
                var that = this;
                return that instanceof $Number && (BROKEN_COF ? fails(function() {
                    proto.valueOf.call(that)
                }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it)
            };
            for (var keys = require("./_descriptors") ? gOPN(Base) : ("MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY," + "EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER," + "MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger").split(","), j = 0, key; keys.length > j; j++) {
                if (has(Base, key = keys[j]) && !has($Number, key)) {
                    dP($Number, key, gOPD(Base, key))
                }
            }
            $Number.prototype = proto;
            proto.constructor = $Number;
            require("./_redefine")(global, NUMBER, $Number)
        }
    }, {
        "./_cof": 18,
        "./_descriptors": 29,
        "./_fails": 35,
        "./_global": 40,
        "./_has": 41,
        "./_inherit-if-required": 45,
        "./_object-create": 70,
        "./_object-dp": 71,
        "./_object-gopd": 74,
        "./_object-gopn": 76,
        "./_redefine": 91,
        "./_string-trim": 108,
        "./_to-primitive": 117
    }],
    177: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Number", {
            EPSILON: Math.pow(2, -52)
        })
    }, {
        "./_export": 33
    }],
    178: [function(require, module, exports) {
        var $export = require("./_export");
        var _isFinite = require("./_global").isFinite;
        $export($export.S, "Number", {
            isFinite: function isFinite(it) {
                return typeof it == "number" && _isFinite(it)
            }
        })
    }, {
        "./_export": 33,
        "./_global": 40
    }],
    179: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Number", {
            isInteger: require("./_is-integer")
        })
    }, {
        "./_export": 33,
        "./_is-integer": 50
    }],
    180: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Number", {
            isNaN: function isNaN(number) {
                return number != number
            }
        })
    }, {
        "./_export": 33
    }],
    181: [function(require, module, exports) {
        var $export = require("./_export");
        var isInteger = require("./_is-integer");
        var abs = Math.abs;
        $export($export.S, "Number", {
            isSafeInteger: function isSafeInteger(number) {
                return isInteger(number) && abs(number) <= 9007199254740991
            }
        })
    }, {
        "./_export": 33,
        "./_is-integer": 50
    }],
    182: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Number", {
            MAX_SAFE_INTEGER: 9007199254740991
        })
    }, {
        "./_export": 33
    }],
    183: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Number", {
            MIN_SAFE_INTEGER: -9007199254740991
        })
    }, {
        "./_export": 33
    }],
    184: [function(require, module, exports) {
        var $export = require("./_export");
        var $parseFloat = require("./_parse-float");
        $export($export.S + $export.F * (Number.parseFloat != $parseFloat), "Number", {
            parseFloat: $parseFloat
        })
    }, {
        "./_export": 33,
        "./_parse-float": 85
    }],
    185: [function(require, module, exports) {
        var $export = require("./_export");
        var $parseInt = require("./_parse-int");
        $export($export.S + $export.F * (Number.parseInt != $parseInt), "Number", {
            parseInt: $parseInt
        })
    }, {
        "./_export": 33,
        "./_parse-int": 86
    }],
    186: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toInteger = require("./_to-integer");
        var aNumberValue = require("./_a-number-value");
        var repeat = require("./_string-repeat");
        var $toFixed = 1..toFixed;
        var floor = Math.floor;
        var data = [0, 0, 0, 0, 0, 0];
        var ERROR = "Number.toFixed: incorrect invocation!";
        var ZERO = "0";
        var multiply = function(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < 6) {
                c2 += n * data[i];
                data[i] = c2 % 1e7;
                c2 = floor(c2 / 1e7)
            }
        };
        var divide = function(n) {
            var i = 6;
            var c = 0;
            while (--i >= 0) {
                c += data[i];
                data[i] = floor(c / n);
                c = c % n * 1e7
            }
        };
        var numToString = function() {
            var i = 6;
            var s = "";
            while (--i >= 0) {
                if (s !== "" || i === 0 || data[i] !== 0) {
                    var t = String(data[i]);
                    s = s === "" ? t : s + repeat.call(ZERO, 7 - t.length) + t
                }
            }
            return s
        };
        var pow = function(x, n, acc) {
            return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)
        };
        var log = function(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2
            }
            return n
        };
        $export($export.P + $export.F * (!!$toFixed && (8e-5.toFixed(3) !== "0.000" || .9.toFixed(0) !== "1" || 1.255.toFixed(2) !== "1.25" || (0xde0b6b3a7640080).toFixed(0) !== "1000000000000000128") || !require("./_fails")(function() {
            $toFixed.call({})
        })), "Number", {
            toFixed: function toFixed(fractionDigits) {
                var x = aNumberValue(this, ERROR);
                var f = toInteger(fractionDigits);
                var s = "";
                var m = ZERO;
                var e, z, j, k;
                if (f < 0 || f > 20) throw RangeError(ERROR);
                if (x != x) return "NaN";
                if (x <= -1e21 || x >= 1e21) return String(x);
                if (x < 0) {
                    s = "-";
                    x = -x
                }
                if (x > 1e-21) {
                    e = log(x * pow(2, 69, 1)) - 69;
                    z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
                    z *= 4503599627370496;
                    e = 52 - e;
                    if (e > 0) {
                        multiply(0, z);
                        j = f;
                        while (j >= 7) {
                            multiply(1e7, 0);
                            j -= 7
                        }
                        multiply(pow(10, j, 1), 0);
                        j = e - 1;
                        while (j >= 23) {
                            divide(1 << 23);
                            j -= 23
                        }
                        divide(1 << j);
                        multiply(1, 1);
                        divide(2);
                        m = numToString()
                    } else {
                        multiply(0, z);
                        multiply(1 << -e, 0);
                        m = numToString() + repeat.call(ZERO, f)
                    }
                }
                if (f > 0) {
                    k = m.length;
                    m = s + (k <= f ? "0." + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + "." + m.slice(k - f))
                } else {
                    m = s + m
                }
                return m
            }
        })
    }, {
        "./_a-number-value": 4,
        "./_export": 33,
        "./_fails": 35,
        "./_string-repeat": 107,
        "./_to-integer": 113
    }],
    187: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $fails = require("./_fails");
        var aNumberValue = require("./_a-number-value");
        var $toPrecision = 1..toPrecision;
        $export($export.P + $export.F * ($fails(function() {
            return $toPrecision.call(1, undefined) !== "1"
        }) || !$fails(function() {
            $toPrecision.call({})
        })), "Number", {
            toPrecision: function toPrecision(precision) {
                var that = aNumberValue(this, "Number#toPrecision: incorrect invocation!");
                return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision)
            }
        })
    }, {
        "./_a-number-value": 4,
        "./_export": 33,
        "./_fails": 35
    }],
    188: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S + $export.F, "Object", {
            assign: require("./_object-assign")
        })
    }, {
        "./_export": 33,
        "./_object-assign": 69
    }],
    189: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Object", {
            create: require("./_object-create")
        })
    }, {
        "./_export": 33,
        "./_object-create": 70
    }],
    190: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S + $export.F * !require("./_descriptors"), "Object", {
            defineProperties: require("./_object-dps")
        })
    }, {
        "./_descriptors": 29,
        "./_export": 33,
        "./_object-dps": 72
    }],
    191: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S + $export.F * !require("./_descriptors"), "Object", {
            defineProperty: require("./_object-dp").f
        })
    }, {
        "./_descriptors": 29,
        "./_export": 33,
        "./_object-dp": 71
    }],
    192: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var meta = require("./_meta").onFreeze;
        require("./_object-sap")("freeze", function($freeze) {
            return function freeze(it) {
                return $freeze && isObject(it) ? $freeze(meta(it)) : it
            }
        })
    }, {
        "./_is-object": 51,
        "./_meta": 65,
        "./_object-sap": 82
    }],
    193: [function(require, module, exports) {
        var toIObject = require("./_to-iobject");
        var $getOwnPropertyDescriptor = require("./_object-gopd").f;
        require("./_object-sap")("getOwnPropertyDescriptor", function() {
            return function getOwnPropertyDescriptor(it, key) {
                return $getOwnPropertyDescriptor(toIObject(it), key)
            }
        })
    }, {
        "./_object-gopd": 74,
        "./_object-sap": 82,
        "./_to-iobject": 114
    }],
    194: [function(require, module, exports) {
        require("./_object-sap")("getOwnPropertyNames", function() {
            return require("./_object-gopn-ext").f
        })
    }, {
        "./_object-gopn-ext": 75,
        "./_object-sap": 82
    }],
    195: [function(require, module, exports) {
        var toObject = require("./_to-object");
        var $getPrototypeOf = require("./_object-gpo");
        require("./_object-sap")("getPrototypeOf", function() {
            return function getPrototypeOf(it) {
                return $getPrototypeOf(toObject(it))
            }
        })
    }, {
        "./_object-gpo": 78,
        "./_object-sap": 82,
        "./_to-object": 116
    }],
    196: [function(require, module, exports) {
        var isObject = require("./_is-object");
        require("./_object-sap")("isExtensible", function($isExtensible) {
            return function isExtensible(it) {
                return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false
            }
        })
    }, {
        "./_is-object": 51,
        "./_object-sap": 82
    }],
    197: [function(require, module, exports) {
        var isObject = require("./_is-object");
        require("./_object-sap")("isFrozen", function($isFrozen) {
            return function isFrozen(it) {
                return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true
            }
        })
    }, {
        "./_is-object": 51,
        "./_object-sap": 82
    }],
    198: [function(require, module, exports) {
        var isObject = require("./_is-object");
        require("./_object-sap")("isSealed", function($isSealed) {
            return function isSealed(it) {
                return isObject(it) ? $isSealed ? $isSealed(it) : false : true
            }
        })
    }, {
        "./_is-object": 51,
        "./_object-sap": 82
    }],
    199: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Object", {
            is: require("./_same-value")
        })
    }, {
        "./_export": 33,
        "./_same-value": 93
    }],
    200: [function(require, module, exports) {
        var toObject = require("./_to-object");
        var $keys = require("./_object-keys");
        require("./_object-sap")("keys", function() {
            return function keys(it) {
                return $keys(toObject(it))
            }
        })
    }, {
        "./_object-keys": 80,
        "./_object-sap": 82,
        "./_to-object": 116
    }],
    201: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var meta = require("./_meta").onFreeze;
        require("./_object-sap")("preventExtensions", function($preventExtensions) {
            return function preventExtensions(it) {
                return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it
            }
        })
    }, {
        "./_is-object": 51,
        "./_meta": 65,
        "./_object-sap": 82
    }],
    202: [function(require, module, exports) {
        var isObject = require("./_is-object");
        var meta = require("./_meta").onFreeze;
        require("./_object-sap")("seal", function($seal) {
            return function seal(it) {
                return $seal && isObject(it) ? $seal(meta(it)) : it
            }
        })
    }, {
        "./_is-object": 51,
        "./_meta": 65,
        "./_object-sap": 82
    }],
    203: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Object", {
            setPrototypeOf: require("./_set-proto").set
        })
    }, {
        "./_export": 33,
        "./_set-proto": 96
    }],
    204: [function(require, module, exports) {
        "use strict";
        var classof = require("./_classof");
        var test = {};
        test[require("./_wks")("toStringTag")] = "z";
        if (test + "" != "[object z]") {
            require("./_redefine")(Object.prototype, "toString", function toString() {
                return "[object " + classof(this) + "]"
            }, true)
        }
    }, {
        "./_classof": 17,
        "./_redefine": 91,
        "./_wks": 126
    }],
    205: [function(require, module, exports) {
        var $export = require("./_export");
        var $parseFloat = require("./_parse-float");
        $export($export.G + $export.F * (parseFloat != $parseFloat), {
            parseFloat: $parseFloat
        })
    }, {
        "./_export": 33,
        "./_parse-float": 85
    }],
    206: [function(require, module, exports) {
        var $export = require("./_export");
        var $parseInt = require("./_parse-int");
        $export($export.G + $export.F * (parseInt != $parseInt), {
            parseInt: $parseInt
        })
    }, {
        "./_export": 33,
        "./_parse-int": 86
    }],
    207: [function(require, module, exports) {
        "use strict";
        var LIBRARY = require("./_library");
        var global = require("./_global");
        var ctx = require("./_ctx");
        var classof = require("./_classof");
        var $export = require("./_export");
        var isObject = require("./_is-object");
        var aFunction = require("./_a-function");
        var anInstance = require("./_an-instance");
        var forOf = require("./_for-of");
        var speciesConstructor = require("./_species-constructor");
        var task = require("./_task").set;
        var microtask = require("./_microtask")();
        var newPromiseCapabilityModule = require("./_new-promise-capability");
        var perform = require("./_perform");
        var promiseResolve = require("./_promise-resolve");
        var PROMISE = "Promise";
        var TypeError = global.TypeError;
        var process = global.process;
        var $Promise = global[PROMISE];
        var isNode = classof(process) == "process";
        var empty = function() {};
        var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
        var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
        var USE_NATIVE = !! function() {
            try {
                var promise = $Promise.resolve(1);
                var FakePromise = (promise.constructor = {})[require("./_wks")("species")] = function(exec) {
                    exec(empty, empty)
                };
                return (isNode || typeof PromiseRejectionEvent == "function") && promise.then(empty) instanceof FakePromise
            } catch (e) {}
        }();
        var isThenable = function(it) {
            var then;
            return isObject(it) && typeof(then = it.then) == "function" ? then : false
        };
        var notify = function(promise, isReject) {
            if (promise._n) return;
            promise._n = true;
            var chain = promise._c;
            microtask(function() {
                var value = promise._v;
                var ok = promise._s == 1;
                var i = 0;
                var run = function(reaction) {
                    var handler = ok ? reaction.ok : reaction.fail;
                    var resolve = reaction.resolve;
                    var reject = reaction.reject;
                    var domain = reaction.domain;
                    var result, then;
                    try {
                        if (handler) {
                            if (!ok) {
                                if (promise._h == 2) onHandleUnhandled(promise);
                                promise._h = 1
                            }
                            if (handler === true) result = value;
                            else {
                                if (domain) domain.enter();
                                result = handler(value);
                                if (domain) domain.exit()
                            }
                            if (result === reaction.promise) {
                                reject(TypeError("Promise-chain cycle"))
                            } else if (then = isThenable(result)) {
                                then.call(result, resolve, reject)
                            } else resolve(result)
                        } else reject(value)
                    } catch (e) {
                        reject(e)
                    }
                };
                while (chain.length > i) run(chain[i++]);
                promise._c = [];
                promise._n = false;
                if (isReject && !promise._h) onUnhandled(promise)
            })
        };
        var onUnhandled = function(promise) {
            task.call(global, function() {
                var value = promise._v;
                var unhandled = isUnhandled(promise);
                var result, handler, console;
                if (unhandled) {
                    result = perform(function() {
                        if (isNode) {
                            process.emit("unhandledRejection", value, promise)
                        } else if (handler = global.onunhandledrejection) {
                            handler({
                                promise: promise,
                                reason: value
                            })
                        } else if ((console = global.console) && console.error) {
                            console.error("Unhandled promise rejection", value)
                        }
                    });
                    promise._h = isNode || isUnhandled(promise) ? 2 : 1
                }
                promise._a = undefined;
                if (unhandled && result.e) throw result.v
            })
        };
        var isUnhandled = function(promise) {
            return promise._h !== 1 && (promise._a || promise._c).length === 0
        };
        var onHandleUnhandled = function(promise) {
            task.call(global, function() {
                var handler;
                if (isNode) {
                    process.emit("rejectionHandled", promise)
                } else if (handler = global.onrejectionhandled) {
                    handler({
                        promise: promise,
                        reason: promise._v
                    })
                }
            })
        };
        var $reject = function(value) {
            var promise = this;
            if (promise._d) return;
            promise._d = true;
            promise = promise._w || promise;
            promise._v = value;
            promise._s = 2;
            if (!promise._a) promise._a = promise._c.slice();
            notify(promise, true)
        };
        var $resolve = function(value) {
            var promise = this;
            var then;
            if (promise._d) return;
            promise._d = true;
            promise = promise._w || promise;
            try {
                if (promise === value) throw TypeError("Promise can't be resolved itself");
                if (then = isThenable(value)) {
                    microtask(function() {
                        var wrapper = {
                            _w: promise,
                            _d: false
                        };
                        try {
                            then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1))
                        } catch (e) {
                            $reject.call(wrapper, e)
                        }
                    })
                } else {
                    promise._v = value;
                    promise._s = 1;
                    notify(promise, false)
                }
            } catch (e) {
                $reject.call({
                    _w: promise,
                    _d: false
                }, e)
            }
        };
        if (!USE_NATIVE) {
            $Promise = function Promise(executor) {
                anInstance(this, $Promise, PROMISE, "_h");
                aFunction(executor);
                Internal.call(this);
                try {
                    executor(ctx($resolve, this, 1), ctx($reject, this, 1))
                } catch (err) {
                    $reject.call(this, err)
                }
            };
            Internal = function Promise(executor) {
                this._c = [];
                this._a = undefined;
                this._s = 0;
                this._d = false;
                this._v = undefined;
                this._h = 0;
                this._n = false
            };
            Internal.prototype = require("./_redefine-all")($Promise.prototype, {
                then: function then(onFulfilled, onRejected) {
                    var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
                    reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
                    reaction.fail = typeof onRejected == "function" && onRejected;
                    reaction.domain = isNode ? process.domain : undefined;
                    this._c.push(reaction);
                    if (this._a) this._a.push(reaction);
                    if (this._s) notify(this, false);
                    return reaction.promise
                },
                catch: function(onRejected) {
                    return this.then(undefined, onRejected)
                }
            });
            OwnPromiseCapability = function() {
                var promise = new Internal;
                this.promise = promise;
                this.resolve = ctx($resolve, promise, 1);
                this.reject = ctx($reject, promise, 1)
            };
            newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
                return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C)
            }
        }
        $export($export.G + $export.W + $export.F * !USE_NATIVE, {
            Promise: $Promise
        });
        require("./_set-to-string-tag")($Promise, PROMISE);
        require("./_set-species")(PROMISE);
        Wrapper = require("./_core")[PROMISE];
        $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
            reject: function reject(r) {
                var capability = newPromiseCapability(this);
                var $$reject = capability.reject;
                $$reject(r);
                return capability.promise
            }
        });
        $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
            resolve: function resolve(x) {
                return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x)
            }
        });
        $export($export.S + $export.F * !(USE_NATIVE && require("./_iter-detect")(function(iter) {
            $Promise.all(iter)["catch"](empty)
        })), PROMISE, {
            all: function all(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var resolve = capability.resolve;
                var reject = capability.reject;
                var result = perform(function() {
                    var values = [];
                    var index = 0;
                    var remaining = 1;
                    forOf(iterable, false, function(promise) {
                        var $index = index++;
                        var alreadyCalled = false;
                        values.push(undefined);
                        remaining++;
                        C.resolve(promise).then(function(value) {
                            if (alreadyCalled) return;
                            alreadyCalled = true;
                            values[$index] = value;
                            --remaining || resolve(values)
                        }, reject)
                    });
                    --remaining || resolve(values)
                });
                if (result.e) reject(result.v);
                return capability.promise
            },
            race: function race(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var reject = capability.reject;
                var result = perform(function() {
                    forOf(iterable, false, function(promise) {
                        C.resolve(promise).then(capability.resolve, reject)
                    })
                });
                if (result.e) reject(result.v);
                return capability.promise
            }
        })
    }, {
        "./_a-function": 3,
        "./_an-instance": 6,
        "./_classof": 17,
        "./_core": 23,
        "./_ctx": 25,
        "./_export": 33,
        "./_for-of": 39,
        "./_global": 40,
        "./_is-object": 51,
        "./_iter-detect": 56,
        "./_library": 59,
        "./_microtask": 67,
        "./_new-promise-capability": 68,
        "./_perform": 87,
        "./_promise-resolve": 88,
        "./_redefine-all": 90,
        "./_set-species": 97,
        "./_set-to-string-tag": 98,
        "./_species-constructor": 101,
        "./_task": 110,
        "./_wks": 126
    }],
    208: [function(require, module, exports) {
        var $export = require("./_export");
        var aFunction = require("./_a-function");
        var anObject = require("./_an-object");
        var rApply = (require("./_global").Reflect || {}).apply;
        var fApply = Function.apply;
        $export($export.S + $export.F * !require("./_fails")(function() {
            rApply(function() {})
        }), "Reflect", {
            apply: function apply(target, thisArgument, argumentsList) {
                var T = aFunction(target);
                var L = anObject(argumentsList);
                return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L)
            }
        })
    }, {
        "./_a-function": 3,
        "./_an-object": 7,
        "./_export": 33,
        "./_fails": 35,
        "./_global": 40
    }],
    209: [function(require, module, exports) {
        var $export = require("./_export");
        var create = require("./_object-create");
        var aFunction = require("./_a-function");
        var anObject = require("./_an-object");
        var isObject = require("./_is-object");
        var fails = require("./_fails");
        var bind = require("./_bind");
        var rConstruct = (require("./_global").Reflect || {}).construct;
        var NEW_TARGET_BUG = fails(function() {
            function F() {}
            return !(rConstruct(function() {}, [], F) instanceof F)
        });
        var ARGS_BUG = !fails(function() {
            rConstruct(function() {})
        });
        $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), "Reflect", {
            construct: function construct(Target, args) {
                aFunction(Target);
                anObject(args);
                var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
                if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
                if (Target == newTarget) {
                    switch (args.length) {
                        case 0:
                            return new Target;
                        case 1:
                            return new Target(args[0]);
                        case 2:
                            return new Target(args[0], args[1]);
                        case 3:
                            return new Target(args[0], args[1], args[2]);
                        case 4:
                            return new Target(args[0], args[1], args[2], args[3])
                    }
                    var $args = [null];
                    $args.push.apply($args, args);
                    return new(bind.apply(Target, $args))
                }
                var proto = newTarget.prototype;
                var instance = create(isObject(proto) ? proto : Object.prototype);
                var result = Function.apply.call(Target, instance, args);
                return isObject(result) ? result : instance
            }
        })
    }, {
        "./_a-function": 3,
        "./_an-object": 7,
        "./_bind": 16,
        "./_export": 33,
        "./_fails": 35,
        "./_global": 40,
        "./_is-object": 51,
        "./_object-create": 70
    }],
    210: [function(require, module, exports) {
        var dP = require("./_object-dp");
        var $export = require("./_export");
        var anObject = require("./_an-object");
        var toPrimitive = require("./_to-primitive");
        $export($export.S + $export.F * require("./_fails")(function() {
            Reflect.defineProperty(dP.f({}, 1, {
                value: 1
            }), 1, {
                value: 2
            })
        }), "Reflect", {
            defineProperty: function defineProperty(target, propertyKey, attributes) {
                anObject(target);
                propertyKey = toPrimitive(propertyKey, true);
                anObject(attributes);
                try {
                    dP.f(target, propertyKey, attributes);
                    return true
                } catch (e) {
                    return false
                }
            }
        })
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_fails": 35,
        "./_object-dp": 71,
        "./_to-primitive": 117
    }],
    211: [function(require, module, exports) {
        var $export = require("./_export");
        var gOPD = require("./_object-gopd").f;
        var anObject = require("./_an-object");
        $export($export.S, "Reflect", {
            deleteProperty: function deleteProperty(target, propertyKey) {
                var desc = gOPD(anObject(target), propertyKey);
                return desc && !desc.configurable ? false : delete target[propertyKey]
            }
        })
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_object-gopd": 74
    }],
    212: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var anObject = require("./_an-object");
        var Enumerate = function(iterated) {
            this._t = anObject(iterated);
            this._i = 0;
            var keys = this._k = [];
            var key;
            for (key in iterated) keys.push(key)
        };
        require("./_iter-create")(Enumerate, "Object", function() {
            var that = this;
            var keys = that._k;
            var key;
            do {
                if (that._i >= keys.length) return {
                    value: undefined,
                    done: true
                }
            } while (!((key = keys[that._i++]) in that._t));
            return {
                value: key,
                done: false
            }
        });
        $export($export.S, "Reflect", {
            enumerate: function enumerate(target) {
                return new Enumerate(target)
            }
        })
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_iter-create": 54
    }],
    213: [function(require, module, exports) {
        var gOPD = require("./_object-gopd");
        var $export = require("./_export");
        var anObject = require("./_an-object");
        $export($export.S, "Reflect", {
            getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
                return gOPD.f(anObject(target), propertyKey)
            }
        })
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_object-gopd": 74
    }],
    214: [function(require, module, exports) {
        var $export = require("./_export");
        var getProto = require("./_object-gpo");
        var anObject = require("./_an-object");
        $export($export.S, "Reflect", {
            getPrototypeOf: function getPrototypeOf(target) {
                return getProto(anObject(target))
            }
        })
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_object-gpo": 78
    }],
    215: [function(require, module, exports) {
        var gOPD = require("./_object-gopd");
        var getPrototypeOf = require("./_object-gpo");
        var has = require("./_has");
        var $export = require("./_export");
        var isObject = require("./_is-object");
        var anObject = require("./_an-object");

        function get(target, propertyKey) {
            var receiver = arguments.length < 3 ? target : arguments[2];
            var desc, proto;
            if (anObject(target) === receiver) return target[propertyKey];
            if (desc = gOPD.f(target, propertyKey)) return has(desc, "value") ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
            if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver)
        }
        $export($export.S, "Reflect", {
            get: get
        })
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_has": 41,
        "./_is-object": 51,
        "./_object-gopd": 74,
        "./_object-gpo": 78
    }],
    216: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Reflect", {
            has: function has(target, propertyKey) {
                return propertyKey in target
            }
        })
    }, {
        "./_export": 33
    }],
    217: [function(require, module, exports) {
        var $export = require("./_export");
        var anObject = require("./_an-object");
        var $isExtensible = Object.isExtensible;
        $export($export.S, "Reflect", {
            isExtensible: function isExtensible(target) {
                anObject(target);
                return $isExtensible ? $isExtensible(target) : true
            }
        })
    }, {
        "./_an-object": 7,
        "./_export": 33
    }],
    218: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Reflect", {
            ownKeys: require("./_own-keys")
        })
    }, {
        "./_export": 33,
        "./_own-keys": 84
    }],
    219: [function(require, module, exports) {
        var $export = require("./_export");
        var anObject = require("./_an-object");
        var $preventExtensions = Object.preventExtensions;
        $export($export.S, "Reflect", {
            preventExtensions: function preventExtensions(target) {
                anObject(target);
                try {
                    if ($preventExtensions) $preventExtensions(target);
                    return true
                } catch (e) {
                    return false
                }
            }
        })
    }, {
        "./_an-object": 7,
        "./_export": 33
    }],
    220: [function(require, module, exports) {
        var $export = require("./_export");
        var setProto = require("./_set-proto");
        if (setProto) $export($export.S, "Reflect", {
            setPrototypeOf: function setPrototypeOf(target, proto) {
                setProto.check(target, proto);
                try {
                    setProto.set(target, proto);
                    return true
                } catch (e) {
                    return false
                }
            }
        })
    }, {
        "./_export": 33,
        "./_set-proto": 96
    }],
    221: [function(require, module, exports) {
        var dP = require("./_object-dp");
        var gOPD = require("./_object-gopd");
        var getPrototypeOf = require("./_object-gpo");
        var has = require("./_has");
        var $export = require("./_export");
        var createDesc = require("./_property-desc");
        var anObject = require("./_an-object");
        var isObject = require("./_is-object");

        function set(target, propertyKey, V) {
            var receiver = arguments.length < 4 ? target : arguments[3];
            var ownDesc = gOPD.f(anObject(target), propertyKey);
            var existingDescriptor, proto;
            if (!ownDesc) {
                if (isObject(proto = getPrototypeOf(target))) {
                    return set(proto, propertyKey, V, receiver)
                }
                ownDesc = createDesc(0)
            }
            if (has(ownDesc, "value")) {
                if (ownDesc.writable === false || !isObject(receiver)) return false;
                existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
                existingDescriptor.value = V;
                dP.f(receiver, propertyKey, existingDescriptor);
                return true
            }
            return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true)
        }
        $export($export.S, "Reflect", {
            set: set
        })
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_has": 41,
        "./_is-object": 51,
        "./_object-dp": 71,
        "./_object-gopd": 74,
        "./_object-gpo": 78,
        "./_property-desc": 89
    }],
    222: [function(require, module, exports) {
        var global = require("./_global");
        var inheritIfRequired = require("./_inherit-if-required");
        var dP = require("./_object-dp").f;
        var gOPN = require("./_object-gopn").f;
        var isRegExp = require("./_is-regexp");
        var $flags = require("./_flags");
        var $RegExp = global.RegExp;
        var Base = $RegExp;
        var proto = $RegExp.prototype;
        var re1 = /a/g;
        var re2 = /a/g;
        var CORRECT_NEW = new $RegExp(re1) !== re1;
        if (require("./_descriptors") && (!CORRECT_NEW || require("./_fails")(function() {
                re2[require("./_wks")("match")] = false;
                return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, "i") != "/a/i"
            }))) {
            $RegExp = function RegExp(p, f) {
                var tiRE = this instanceof $RegExp;
                var piRE = isRegExp(p);
                var fiU = f === undefined;
                return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp)
            };
            var proxy = function(key) {
                key in $RegExp || dP($RegExp, key, {
                    configurable: true,
                    get: function() {
                        return Base[key]
                    },
                    set: function(it) {
                        Base[key] = it
                    }
                })
            };
            for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
            proto.constructor = $RegExp;
            $RegExp.prototype = proto;
            require("./_redefine")(global, "RegExp", $RegExp)
        }
        require("./_set-species")("RegExp")
    }, {
        "./_descriptors": 29,
        "./_fails": 35,
        "./_flags": 37,
        "./_global": 40,
        "./_inherit-if-required": 45,
        "./_is-regexp": 52,
        "./_object-dp": 71,
        "./_object-gopn": 76,
        "./_redefine": 91,
        "./_set-species": 97,
        "./_wks": 126
    }],
    223: [function(require, module, exports) {
        if (require("./_descriptors") && /./g.flags != "g") require("./_object-dp").f(RegExp.prototype, "flags", {
            configurable: true,
            get: require("./_flags")
        })
    }, {
        "./_descriptors": 29,
        "./_flags": 37,
        "./_object-dp": 71
    }],
    224: [function(require, module, exports) {
        require("./_fix-re-wks")("match", 1, function(defined, MATCH, $match) {
            return [function match(regexp) {
                "use strict";
                var O = defined(this);
                var fn = regexp == undefined ? undefined : regexp[MATCH];
                return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O))
            }, $match]
        })
    }, {
        "./_fix-re-wks": 36
    }],
    225: [function(require, module, exports) {
        require("./_fix-re-wks")("replace", 2, function(defined, REPLACE, $replace) {
            return [function replace(searchValue, replaceValue) {
                "use strict";
                var O = defined(this);
                var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
                return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue)
            }, $replace]
        })
    }, {
        "./_fix-re-wks": 36
    }],
    226: [function(require, module, exports) {
        require("./_fix-re-wks")("search", 1, function(defined, SEARCH, $search) {
            return [function search(regexp) {
                "use strict";
                var O = defined(this);
                var fn = regexp == undefined ? undefined : regexp[SEARCH];
                return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O))
            }, $search]
        })
    }, {
        "./_fix-re-wks": 36
    }],
    227: [function(require, module, exports) {
        require("./_fix-re-wks")("split", 2, function(defined, SPLIT, $split) {
            "use strict";
            var isRegExp = require("./_is-regexp");
            var _split = $split;
            var $push = [].push;
            var $SPLIT = "split";
            var LENGTH = "length";
            var LAST_INDEX = "lastIndex";
            if ("abbc" [$SPLIT](/(b)*/)[1] == "c" || "test" [$SPLIT](/(?:)/, -1)[LENGTH] != 4 || "ab" [$SPLIT](/(?:ab)*/)[LENGTH] != 2 || "." [$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || "." [$SPLIT](/()()/)[LENGTH] > 1 || "" [$SPLIT](/.?/)[LENGTH]) {
                var NPCG = /()??/.exec("")[1] === undefined;
                $split = function(separator, limit) {
                    var string = String(this);
                    if (separator === undefined && limit === 0) return [];
                    if (!isRegExp(separator)) return _split.call(string, separator, limit);
                    var output = [];
                    var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
                    var lastLastIndex = 0;
                    var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
                    var separatorCopy = new RegExp(separator.source, flags + "g");
                    var separator2, match, lastIndex, lastLength, i;
                    if (!NPCG) separator2 = new RegExp("^" + separatorCopy.source + "$(?!\\s)", flags);
                    while (match = separatorCopy.exec(string)) {
                        lastIndex = match.index + match[0][LENGTH];
                        if (lastIndex > lastLastIndex) {
                            output.push(string.slice(lastLastIndex, match.index));
                            if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function() {
                                for (i = 1; i < arguments[LENGTH] - 2; i++)
                                    if (arguments[i] === undefined) match[i] = undefined
                            });
                            if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
                            lastLength = match[0][LENGTH];
                            lastLastIndex = lastIndex;
                            if (output[LENGTH] >= splitLimit) break
                        }
                        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++
                    }
                    if (lastLastIndex === string[LENGTH]) {
                        if (lastLength || !separatorCopy.test("")) output.push("")
                    } else output.push(string.slice(lastLastIndex));
                    return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output
                }
            } else if ("0" [$SPLIT](undefined, 0)[LENGTH]) {
                $split = function(separator, limit) {
                    return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit)
                }
            }
            return [function split(separator, limit) {
                var O = defined(this);
                var fn = separator == undefined ? undefined : separator[SPLIT];
                return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit)
            }, $split]
        })
    }, {
        "./_fix-re-wks": 36,
        "./_is-regexp": 52
    }],
    228: [function(require, module, exports) {
        "use strict";
        require("./es6.regexp.flags");
        var anObject = require("./_an-object");
        var $flags = require("./_flags");
        var DESCRIPTORS = require("./_descriptors");
        var TO_STRING = "toString";
        var $toString = /./ [TO_STRING];
        var define = function(fn) {
            require("./_redefine")(RegExp.prototype, TO_STRING, fn, true)
        };
        if (require("./_fails")(function() {
                return $toString.call({
                    source: "a",
                    flags: "b"
                }) != "/a/b"
            })) {
            define(function toString() {
                var R = anObject(this);
                return "/".concat(R.source, "/", "flags" in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined)
            })
        } else if ($toString.name != TO_STRING) {
            define(function toString() {
                return $toString.call(this)
            })
        }
    }, {
        "./_an-object": 7,
        "./_descriptors": 29,
        "./_fails": 35,
        "./_flags": 37,
        "./_redefine": 91,
        "./es6.regexp.flags": 223
    }],
    229: [function(require, module, exports) {
        "use strict";
        var strong = require("./_collection-strong");
        var validate = require("./_validate-collection");
        var SET = "Set";
        module.exports = require("./_collection")(SET, function(get) {
            return function Set() {
                return get(this, arguments.length > 0 ? arguments[0] : undefined)
            }
        }, {
            add: function add(value) {
                return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value)
            }
        }, strong)
    }, {
        "./_collection": 22,
        "./_collection-strong": 19,
        "./_validate-collection": 123
    }],
    230: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("anchor", function(createHTML) {
            return function anchor(name) {
                return createHTML(this, "a", "name", name)
            }
        })
    }, {
        "./_string-html": 105
    }],
    231: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("big", function(createHTML) {
            return function big() {
                return createHTML(this, "big", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    232: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("blink", function(createHTML) {
            return function blink() {
                return createHTML(this, "blink", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    233: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("bold", function(createHTML) {
            return function bold() {
                return createHTML(this, "b", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    234: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $at = require("./_string-at")(false);
        $export($export.P, "String", {
            codePointAt: function codePointAt(pos) {
                return $at(this, pos)
            }
        })
    }, {
        "./_export": 33,
        "./_string-at": 103
    }],
    235: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toLength = require("./_to-length");
        var context = require("./_string-context");
        var ENDS_WITH = "endsWith";
        var $endsWith = "" [ENDS_WITH];
        $export($export.P + $export.F * require("./_fails-is-regexp")(ENDS_WITH), "String", {
            endsWith: function endsWith(searchString) {
                var that = context(this, searchString, ENDS_WITH);
                var endPosition = arguments.length > 1 ? arguments[1] : undefined;
                var len = toLength(that.length);
                var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
                var search = String(searchString);
                return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search
            }
        })
    }, {
        "./_export": 33,
        "./_fails-is-regexp": 34,
        "./_string-context": 104,
        "./_to-length": 115
    }],
    236: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("fixed", function(createHTML) {
            return function fixed() {
                return createHTML(this, "tt", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    237: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("fontcolor", function(createHTML) {
            return function fontcolor(color) {
                return createHTML(this, "font", "color", color)
            }
        })
    }, {
        "./_string-html": 105
    }],
    238: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("fontsize", function(createHTML) {
            return function fontsize(size) {
                return createHTML(this, "font", "size", size)
            }
        })
    }, {
        "./_string-html": 105
    }],
    239: [function(require, module, exports) {
        var $export = require("./_export");
        var toAbsoluteIndex = require("./_to-absolute-index");
        var fromCharCode = String.fromCharCode;
        var $fromCodePoint = String.fromCodePoint;
        $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), "String", {
            fromCodePoint: function fromCodePoint(x) {
                var res = [];
                var aLen = arguments.length;
                var i = 0;
                var code;
                while (aLen > i) {
                    code = +arguments[i++];
                    if (toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + " is not a valid code point");
                    res.push(code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320))
                }
                return res.join("")
            }
        })
    }, {
        "./_export": 33,
        "./_to-absolute-index": 111
    }],
    240: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var context = require("./_string-context");
        var INCLUDES = "includes";
        $export($export.P + $export.F * require("./_fails-is-regexp")(INCLUDES), "String", {
            includes: function includes(searchString) {
                return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined)
            }
        })
    }, {
        "./_export": 33,
        "./_fails-is-regexp": 34,
        "./_string-context": 104
    }],
    241: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("italics", function(createHTML) {
            return function italics() {
                return createHTML(this, "i", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    242: [function(require, module, exports) {
        "use strict";
        var $at = require("./_string-at")(true);
        require("./_iter-define")(String, "String", function(iterated) {
            this._t = String(iterated);
            this._i = 0
        }, function() {
            var O = this._t;
            var index = this._i;
            var point;
            if (index >= O.length) return {
                value: undefined,
                done: true
            };
            point = $at(O, index);
            this._i += point.length;
            return {
                value: point,
                done: false
            }
        })
    }, {
        "./_iter-define": 55,
        "./_string-at": 103
    }],
    243: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("link", function(createHTML) {
            return function link(url) {
                return createHTML(this, "a", "href", url)
            }
        })
    }, {
        "./_string-html": 105
    }],
    244: [function(require, module, exports) {
        var $export = require("./_export");
        var toIObject = require("./_to-iobject");
        var toLength = require("./_to-length");
        $export($export.S, "String", {
            raw: function raw(callSite) {
                var tpl = toIObject(callSite.raw);
                var len = toLength(tpl.length);
                var aLen = arguments.length;
                var res = [];
                var i = 0;
                while (len > i) {
                    res.push(String(tpl[i++]));
                    if (i < aLen) res.push(String(arguments[i]))
                }
                return res.join("")
            }
        })
    }, {
        "./_export": 33,
        "./_to-iobject": 114,
        "./_to-length": 115
    }],
    245: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.P, "String", {
            repeat: require("./_string-repeat")
        })
    }, {
        "./_export": 33,
        "./_string-repeat": 107
    }],
    246: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("small", function(createHTML) {
            return function small() {
                return createHTML(this, "small", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    247: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toLength = require("./_to-length");
        var context = require("./_string-context");
        var STARTS_WITH = "startsWith";
        var $startsWith = "" [STARTS_WITH];
        $export($export.P + $export.F * require("./_fails-is-regexp")(STARTS_WITH), "String", {
            startsWith: function startsWith(searchString) {
                var that = context(this, searchString, STARTS_WITH);
                var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
                var search = String(searchString);
                return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search
            }
        })
    }, {
        "./_export": 33,
        "./_fails-is-regexp": 34,
        "./_string-context": 104,
        "./_to-length": 115
    }],
    248: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("strike", function(createHTML) {
            return function strike() {
                return createHTML(this, "strike", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    249: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("sub", function(createHTML) {
            return function sub() {
                return createHTML(this, "sub", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    250: [function(require, module, exports) {
        "use strict";
        require("./_string-html")("sup", function(createHTML) {
            return function sup() {
                return createHTML(this, "sup", "", "")
            }
        })
    }, {
        "./_string-html": 105
    }],
    251: [function(require, module, exports) {
        "use strict";
        require("./_string-trim")("trim", function($trim) {
            return function trim() {
                return $trim(this, 3)
            }
        })
    }, {
        "./_string-trim": 108
    }],
    252: [function(require, module, exports) {
        "use strict";
        var global = require("./_global");
        var has = require("./_has");
        var DESCRIPTORS = require("./_descriptors");
        var $export = require("./_export");
        var redefine = require("./_redefine");
        var META = require("./_meta").KEY;
        var $fails = require("./_fails");
        var shared = require("./_shared");
        var setToStringTag = require("./_set-to-string-tag");
        var uid = require("./_uid");
        var wks = require("./_wks");
        var wksExt = require("./_wks-ext");
        var wksDefine = require("./_wks-define");
        var enumKeys = require("./_enum-keys");
        var isArray = require("./_is-array");
        var anObject = require("./_an-object");
        var isObject = require("./_is-object");
        var toIObject = require("./_to-iobject");
        var toPrimitive = require("./_to-primitive");
        var createDesc = require("./_property-desc");
        var _create = require("./_object-create");
        var gOPNExt = require("./_object-gopn-ext");
        var $GOPD = require("./_object-gopd");
        var $DP = require("./_object-dp");
        var $keys = require("./_object-keys");
        var gOPD = $GOPD.f;
        var dP = $DP.f;
        var gOPN = gOPNExt.f;
        var $Symbol = global.Symbol;
        var $JSON = global.JSON;
        var _stringify = $JSON && $JSON.stringify;
        var PROTOTYPE = "prototype";
        var HIDDEN = wks("_hidden");
        var TO_PRIMITIVE = wks("toPrimitive");
        var isEnum = {}.propertyIsEnumerable;
        var SymbolRegistry = shared("symbol-registry");
        var AllSymbols = shared("symbols");
        var OPSymbols = shared("op-symbols");
        var ObjectProto = Object[PROTOTYPE];
        var USE_NATIVE = typeof $Symbol == "function";
        var QObject = global.QObject;
        var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
        var setSymbolDesc = DESCRIPTORS && $fails(function() {
            return _create(dP({}, "a", {
                get: function() {
                    return dP(this, "a", {
                        value: 7
                    }).a
                }
            })).a != 7
        }) ? function(it, key, D) {
            var protoDesc = gOPD(ObjectProto, key);
            if (protoDesc) delete ObjectProto[key];
            dP(it, key, D);
            if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc)
        } : dP;
        var wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
            sym._k = tag;
            return sym
        };
        var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
            return typeof it == "symbol"
        } : function(it) {
            return it instanceof $Symbol
        };
        var $defineProperty = function defineProperty(it, key, D) {
            if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
            anObject(it);
            key = toPrimitive(key, true);
            anObject(D);
            if (has(AllSymbols, key)) {
                if (!D.enumerable) {
                    if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
                    it[HIDDEN][key] = true
                } else {
                    if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
                    D = _create(D, {
                        enumerable: createDesc(0, false)
                    })
                }
                return setSymbolDesc(it, key, D)
            }
            return dP(it, key, D)
        };
        var $defineProperties = function defineProperties(it, P) {
            anObject(it);
            var keys = enumKeys(P = toIObject(P));
            var i = 0;
            var l = keys.length;
            var key;
            while (l > i) $defineProperty(it, key = keys[i++], P[key]);
            return it
        };
        var $create = function create(it, P) {
            return P === undefined ? _create(it) : $defineProperties(_create(it), P)
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(key) {
            var E = isEnum.call(this, key = toPrimitive(key, true));
            if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
            return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
            it = toIObject(it);
            key = toPrimitive(key, true);
            if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
            var D = gOPD(it, key);
            if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
            return D
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(it) {
            var names = gOPN(toIObject(it));
            var result = [];
            var i = 0;
            var key;
            while (names.length > i) {
                if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key)
            }
            return result
        };
        var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
            var IS_OP = it === ObjectProto;
            var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
            var result = [];
            var i = 0;
            var key;
            while (names.length > i) {
                if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key])
            }
            return result
        };
        if (!USE_NATIVE) {
            $Symbol = function Symbol() {
                if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
                var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
                var $set = function(value) {
                    if (this === ObjectProto) $set.call(OPSymbols, value);
                    if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                    setSymbolDesc(this, tag, createDesc(1, value))
                };
                if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
                    configurable: true,
                    set: $set
                });
                return wrap(tag)
            };
            redefine($Symbol[PROTOTYPE], "toString", function toString() {
                return this._k
            });
            $GOPD.f = $getOwnPropertyDescriptor;
            $DP.f = $defineProperty;
            require("./_object-gopn").f = gOPNExt.f = $getOwnPropertyNames;
            require("./_object-pie").f = $propertyIsEnumerable;
            require("./_object-gops").f = $getOwnPropertySymbols;
            if (DESCRIPTORS && !require("./_library")) {
                redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true)
            }
            wksExt.f = function(name) {
                return wrap(wks(name))
            }
        }
        $export($export.G + $export.W + $export.F * !USE_NATIVE, {
            Symbol: $Symbol
        });
        for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);
        for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
            for: function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key)
            },
            keyFor: function keyFor(sym) {
                if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
                for (var key in SymbolRegistry)
                    if (SymbolRegistry[key] === sym) return key
            },
            useSetter: function() {
                setter = true
            },
            useSimple: function() {
                setter = false
            }
        });
        $export($export.S + $export.F * !USE_NATIVE, "Object", {
            create: $create,
            defineProperty: $defineProperty,
            defineProperties: $defineProperties,
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            getOwnPropertyNames: $getOwnPropertyNames,
            getOwnPropertySymbols: $getOwnPropertySymbols
        });
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
            var S = $Symbol();
            return _stringify([S]) != "[null]" || _stringify({
                a: S
            }) != "{}" || _stringify(Object(S)) != "{}"
        })), "JSON", {
            stringify: function stringify(it) {
                var args = [it];
                var i = 1;
                var replacer, $replacer;
                while (arguments.length > i) args.push(arguments[i++]);
                $replacer = replacer = args[1];
                if (!isObject(replacer) && it === undefined || isSymbol(it)) return;
                if (!isArray(replacer)) replacer = function(key, value) {
                    if (typeof $replacer == "function") value = $replacer.call(this, key, value);
                    if (!isSymbol(value)) return value
                };
                args[1] = replacer;
                return _stringify.apply($JSON, args)
            }
        });
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || require("./_hide")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
        setToStringTag($Symbol, "Symbol");
        setToStringTag(Math, "Math", true);
        setToStringTag(global.JSON, "JSON", true)
    }, {
        "./_an-object": 7,
        "./_descriptors": 29,
        "./_enum-keys": 32,
        "./_export": 33,
        "./_fails": 35,
        "./_global": 40,
        "./_has": 41,
        "./_hide": 42,
        "./_is-array": 49,
        "./_is-object": 51,
        "./_library": 59,
        "./_meta": 65,
        "./_object-create": 70,
        "./_object-dp": 71,
        "./_object-gopd": 74,
        "./_object-gopn": 76,
        "./_object-gopn-ext": 75,
        "./_object-gops": 77,
        "./_object-keys": 80,
        "./_object-pie": 81,
        "./_property-desc": 89,
        "./_redefine": 91,
        "./_set-to-string-tag": 98,
        "./_shared": 100,
        "./_to-iobject": 114,
        "./_to-primitive": 117,
        "./_uid": 121,
        "./_wks": 126,
        "./_wks-define": 124,
        "./_wks-ext": 125
    }],
    253: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $typed = require("./_typed");
        var buffer = require("./_typed-buffer");
        var anObject = require("./_an-object");
        var toAbsoluteIndex = require("./_to-absolute-index");
        var toLength = require("./_to-length");
        var isObject = require("./_is-object");
        var ArrayBuffer = require("./_global").ArrayBuffer;
        var speciesConstructor = require("./_species-constructor");
        var $ArrayBuffer = buffer.ArrayBuffer;
        var $DataView = buffer.DataView;
        var $isView = $typed.ABV && ArrayBuffer.isView;
        var $slice = $ArrayBuffer.prototype.slice;
        var VIEW = $typed.VIEW;
        var ARRAY_BUFFER = "ArrayBuffer";
        $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
            ArrayBuffer: $ArrayBuffer
        });
        $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
            isView: function isView(it) {
                return $isView && $isView(it) || isObject(it) && VIEW in it
            }
        });
        $export($export.P + $export.U + $export.F * require("./_fails")(function() {
            return !new $ArrayBuffer(2).slice(1, undefined).byteLength
        }), ARRAY_BUFFER, {
            slice: function slice(start, end) {
                if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start);
                var len = anObject(this).byteLength;
                var first = toAbsoluteIndex(start, len);
                var final = toAbsoluteIndex(end === undefined ? len : end, len);
                var result = new(speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
                var viewS = new $DataView(this);
                var viewT = new $DataView(result);
                var index = 0;
                while (first < final) {
                    viewT.setUint8(index++, viewS.getUint8(first++))
                }
                return result
            }
        });
        require("./_set-species")(ARRAY_BUFFER)
    }, {
        "./_an-object": 7,
        "./_export": 33,
        "./_fails": 35,
        "./_global": 40,
        "./_is-object": 51,
        "./_set-species": 97,
        "./_species-constructor": 101,
        "./_to-absolute-index": 111,
        "./_to-length": 115,
        "./_typed": 120,
        "./_typed-buffer": 119
    }],
    254: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.G + $export.W + $export.F * !require("./_typed").ABV, {
            DataView: require("./_typed-buffer").DataView
        })
    }, {
        "./_export": 33,
        "./_typed": 120,
        "./_typed-buffer": 119
    }],
    255: [function(require, module, exports) {
        require("./_typed-array")("Float32", 4, function(init) {
            return function Float32Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    256: [function(require, module, exports) {
        require("./_typed-array")("Float64", 8, function(init) {
            return function Float64Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    257: [function(require, module, exports) {
        require("./_typed-array")("Int16", 2, function(init) {
            return function Int16Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    258: [function(require, module, exports) {
        require("./_typed-array")("Int32", 4, function(init) {
            return function Int32Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    259: [function(require, module, exports) {
        require("./_typed-array")("Int8", 1, function(init) {
            return function Int8Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    260: [function(require, module, exports) {
        require("./_typed-array")("Uint16", 2, function(init) {
            return function Uint16Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    261: [function(require, module, exports) {
        require("./_typed-array")("Uint32", 4, function(init) {
            return function Uint32Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    262: [function(require, module, exports) {
        require("./_typed-array")("Uint8", 1, function(init) {
            return function Uint8Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        })
    }, {
        "./_typed-array": 118
    }],
    263: [function(require, module, exports) {
        require("./_typed-array")("Uint8", 1, function(init) {
            return function Uint8ClampedArray(data, byteOffset, length) {
                return init(this, data, byteOffset, length)
            }
        }, true)
    }, {
        "./_typed-array": 118
    }],
    264: [function(require, module, exports) {
        "use strict";
        var each = require("./_array-methods")(0);
        var redefine = require("./_redefine");
        var meta = require("./_meta");
        var assign = require("./_object-assign");
        var weak = require("./_collection-weak");
        var isObject = require("./_is-object");
        var fails = require("./_fails");
        var validate = require("./_validate-collection");
        var WEAK_MAP = "WeakMap";
        var getWeak = meta.getWeak;
        var isExtensible = Object.isExtensible;
        var uncaughtFrozenStore = weak.ufstore;
        var tmp = {};
        var InternalMap;
        var wrapper = function(get) {
            return function WeakMap() {
                return get(this, arguments.length > 0 ? arguments[0] : undefined)
            }
        };
        var methods = {
            get: function get(key) {
                if (isObject(key)) {
                    var data = getWeak(key);
                    if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
                    return data ? data[this._i] : undefined
                }
            },
            set: function set(key, value) {
                return weak.def(validate(this, WEAK_MAP), key, value)
            }
        };
        var $WeakMap = module.exports = require("./_collection")(WEAK_MAP, wrapper, methods, weak, true, true);
        if (fails(function() {
                return (new $WeakMap).set((Object.freeze || Object)(tmp), 7).get(tmp) != 7
            })) {
            InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
            assign(InternalMap.prototype, methods);
            meta.NEED = true;
            each(["delete", "has", "get", "set"], function(key) {
                var proto = $WeakMap.prototype;
                var method = proto[key];
                redefine(proto, key, function(a, b) {
                    if (isObject(a) && !isExtensible(a)) {
                        if (!this._f) this._f = new InternalMap;
                        var result = this._f[key](a, b);
                        return key == "set" ? this : result
                    }
                    return method.call(this, a, b)
                })
            })
        }
    }, {
        "./_array-methods": 12,
        "./_collection": 22,
        "./_collection-weak": 21,
        "./_fails": 35,
        "./_is-object": 51,
        "./_meta": 65,
        "./_object-assign": 69,
        "./_redefine": 91,
        "./_validate-collection": 123
    }],
    265: [function(require, module, exports) {
        "use strict";
        var weak = require("./_collection-weak");
        var validate = require("./_validate-collection");
        var WEAK_SET = "WeakSet";
        require("./_collection")(WEAK_SET, function(get) {
            return function WeakSet() {
                return get(this, arguments.length > 0 ? arguments[0] : undefined)
            }
        }, {
            add: function add(value) {
                return weak.def(validate(this, WEAK_SET), value, true)
            }
        }, weak, false, true)
    }, {
        "./_collection": 22,
        "./_collection-weak": 21,
        "./_validate-collection": 123
    }],
    266: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var flattenIntoArray = require("./_flatten-into-array");
        var toObject = require("./_to-object");
        var toLength = require("./_to-length");
        var aFunction = require("./_a-function");
        var arraySpeciesCreate = require("./_array-species-create");
        $export($export.P, "Array", {
            flatMap: function flatMap(callbackfn) {
                var O = toObject(this);
                var sourceLen, A;
                aFunction(callbackfn);
                sourceLen = toLength(O.length);
                A = arraySpeciesCreate(O, 0);
                flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
                return A
            }
        });
        require("./_add-to-unscopables")("flatMap")
    }, {
        "./_a-function": 3,
        "./_add-to-unscopables": 5,
        "./_array-species-create": 15,
        "./_export": 33,
        "./_flatten-into-array": 38,
        "./_to-length": 115,
        "./_to-object": 116
    }],
    267: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var flattenIntoArray = require("./_flatten-into-array");
        var toObject = require("./_to-object");
        var toLength = require("./_to-length");
        var toInteger = require("./_to-integer");
        var arraySpeciesCreate = require("./_array-species-create");
        $export($export.P, "Array", {
            flatten: function flatten() {
                var depthArg = arguments[0];
                var O = toObject(this);
                var sourceLen = toLength(O.length);
                var A = arraySpeciesCreate(O, 0);
                flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
                return A
            }
        });
        require("./_add-to-unscopables")("flatten")
    }, {
        "./_add-to-unscopables": 5,
        "./_array-species-create": 15,
        "./_export": 33,
        "./_flatten-into-array": 38,
        "./_to-integer": 113,
        "./_to-length": 115,
        "./_to-object": 116
    }],
    268: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $includes = require("./_array-includes")(true);
        $export($export.P, "Array", {
            includes: function includes(el) {
                return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined)
            }
        });
        require("./_add-to-unscopables")("includes")
    }, {
        "./_add-to-unscopables": 5,
        "./_array-includes": 11,
        "./_export": 33
    }],
    269: [function(require, module, exports) {
        var $export = require("./_export");
        var microtask = require("./_microtask")();
        var process = require("./_global").process;
        var isNode = require("./_cof")(process) == "process";
        $export($export.G, {
            asap: function asap(fn) {
                var domain = isNode && process.domain;
                microtask(domain ? domain.bind(fn) : fn)
            }
        })
    }, {
        "./_cof": 18,
        "./_export": 33,
        "./_global": 40,
        "./_microtask": 67
    }],
    270: [function(require, module, exports) {
        var $export = require("./_export");
        var cof = require("./_cof");
        $export($export.S, "Error", {
            isError: function isError(it) {
                return cof(it) === "Error"
            }
        })
    }, {
        "./_cof": 18,
        "./_export": 33
    }],
    271: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.G, {
            global: require("./_global")
        })
    }, {
        "./_export": 33,
        "./_global": 40
    }],
    272: [function(require, module, exports) {
        require("./_set-collection-from")("Map")
    }, {
        "./_set-collection-from": 94
    }],
    273: [function(require, module, exports) {
        require("./_set-collection-of")("Map")
    }, {
        "./_set-collection-of": 95
    }],
    274: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.P + $export.R, "Map", {
            toJSON: require("./_collection-to-json")("Map")
        })
    }, {
        "./_collection-to-json": 20,
        "./_export": 33
    }],
    275: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            clamp: function clamp(x, lower, upper) {
                return Math.min(upper, Math.max(lower, x))
            }
        })
    }, {
        "./_export": 33
    }],
    276: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            DEG_PER_RAD: Math.PI / 180
        })
    }, {
        "./_export": 33
    }],
    277: [function(require, module, exports) {
        var $export = require("./_export");
        var RAD_PER_DEG = 180 / Math.PI;
        $export($export.S, "Math", {
            degrees: function degrees(radians) {
                return radians * RAD_PER_DEG
            }
        })
    }, {
        "./_export": 33
    }],
    278: [function(require, module, exports) {
        var $export = require("./_export");
        var scale = require("./_math-scale");
        var fround = require("./_math-fround");
        $export($export.S, "Math", {
            fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
                return fround(scale(x, inLow, inHigh, outLow, outHigh))
            }
        })
    }, {
        "./_export": 33,
        "./_math-fround": 61,
        "./_math-scale": 63
    }],
    279: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            iaddh: function iaddh(x0, x1, y0, y1) {
                var $x0 = x0 >>> 0;
                var $x1 = x1 >>> 0;
                var $y0 = y0 >>> 0;
                return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0
            }
        })
    }, {
        "./_export": 33
    }],
    280: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            imulh: function imulh(u, v) {
                var UINT16 = 65535;
                var $u = +u;
                var $v = +v;
                var u0 = $u & UINT16;
                var v0 = $v & UINT16;
                var u1 = $u >> 16;
                var v1 = $v >> 16;
                var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
                return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16)
            }
        })
    }, {
        "./_export": 33
    }],
    281: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            isubh: function isubh(x0, x1, y0, y1) {
                var $x0 = x0 >>> 0;
                var $x1 = x1 >>> 0;
                var $y0 = y0 >>> 0;
                return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0
            }
        })
    }, {
        "./_export": 33
    }],
    282: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            RAD_PER_DEG: 180 / Math.PI
        })
    }, {
        "./_export": 33
    }],
    283: [function(require, module, exports) {
        var $export = require("./_export");
        var DEG_PER_RAD = Math.PI / 180;
        $export($export.S, "Math", {
            radians: function radians(degrees) {
                return degrees * DEG_PER_RAD
            }
        })
    }, {
        "./_export": 33
    }],
    284: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            scale: require("./_math-scale")
        })
    }, {
        "./_export": 33,
        "./_math-scale": 63
    }],
    285: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            signbit: function signbit(x) {
                return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0
            }
        })
    }, {
        "./_export": 33
    }],
    286: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "Math", {
            umulh: function umulh(u, v) {
                var UINT16 = 65535;
                var $u = +u;
                var $v = +v;
                var u0 = $u & UINT16;
                var v0 = $v & UINT16;
                var u1 = $u >>> 16;
                var v1 = $v >>> 16;
                var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
                return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16)
            }
        })
    }, {
        "./_export": 33
    }],
    287: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toObject = require("./_to-object");
        var aFunction = require("./_a-function");
        var $defineProperty = require("./_object-dp");
        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
            __defineGetter__: function __defineGetter__(P, getter) {
                $defineProperty.f(toObject(this), P, {
                    get: aFunction(getter),
                    enumerable: true,
                    configurable: true
                })
            }
        })
    }, {
        "./_a-function": 3,
        "./_descriptors": 29,
        "./_export": 33,
        "./_object-dp": 71,
        "./_object-forced-pam": 73,
        "./_to-object": 116
    }],
    288: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toObject = require("./_to-object");
        var aFunction = require("./_a-function");
        var $defineProperty = require("./_object-dp");
        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
            __defineSetter__: function __defineSetter__(P, setter) {
                $defineProperty.f(toObject(this), P, {
                    set: aFunction(setter),
                    enumerable: true,
                    configurable: true
                })
            }
        })
    }, {
        "./_a-function": 3,
        "./_descriptors": 29,
        "./_export": 33,
        "./_object-dp": 71,
        "./_object-forced-pam": 73,
        "./_to-object": 116
    }],
    289: [function(require, module, exports) {
        var $export = require("./_export");
        var $entries = require("./_object-to-array")(true);
        $export($export.S, "Object", {
            entries: function entries(it) {
                return $entries(it)
            }
        })
    }, {
        "./_export": 33,
        "./_object-to-array": 83
    }],
    290: [function(require, module, exports) {
        var $export = require("./_export");
        var ownKeys = require("./_own-keys");
        var toIObject = require("./_to-iobject");
        var gOPD = require("./_object-gopd");
        var createProperty = require("./_create-property");
        $export($export.S, "Object", {
            getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                var O = toIObject(object);
                var getDesc = gOPD.f;
                var keys = ownKeys(O);
                var result = {};
                var i = 0;
                var key, desc;
                while (keys.length > i) {
                    desc = getDesc(O, key = keys[i++]);
                    if (desc !== undefined) createProperty(result, key, desc)
                }
                return result
            }
        })
    }, {
        "./_create-property": 24,
        "./_export": 33,
        "./_object-gopd": 74,
        "./_own-keys": 84,
        "./_to-iobject": 114
    }],
    291: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toObject = require("./_to-object");
        var toPrimitive = require("./_to-primitive");
        var getPrototypeOf = require("./_object-gpo");
        var getOwnPropertyDescriptor = require("./_object-gopd").f;
        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
            __lookupGetter__: function __lookupGetter__(P) {
                var O = toObject(this);
                var K = toPrimitive(P, true);
                var D;
                do {
                    if (D = getOwnPropertyDescriptor(O, K)) return D.get
                } while (O = getPrototypeOf(O))
            }
        })
    }, {
        "./_descriptors": 29,
        "./_export": 33,
        "./_object-forced-pam": 73,
        "./_object-gopd": 74,
        "./_object-gpo": 78,
        "./_to-object": 116,
        "./_to-primitive": 117
    }],
    292: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var toObject = require("./_to-object");
        var toPrimitive = require("./_to-primitive");
        var getPrototypeOf = require("./_object-gpo");
        var getOwnPropertyDescriptor = require("./_object-gopd").f;
        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
            __lookupSetter__: function __lookupSetter__(P) {
                var O = toObject(this);
                var K = toPrimitive(P, true);
                var D;
                do {
                    if (D = getOwnPropertyDescriptor(O, K)) return D.set
                } while (O = getPrototypeOf(O))
            }
        })
    }, {
        "./_descriptors": 29,
        "./_export": 33,
        "./_object-forced-pam": 73,
        "./_object-gopd": 74,
        "./_object-gpo": 78,
        "./_to-object": 116,
        "./_to-primitive": 117
    }],
    293: [function(require, module, exports) {
        var $export = require("./_export");
        var $values = require("./_object-to-array")(false);
        $export($export.S, "Object", {
            values: function values(it) {
                return $values(it)
            }
        })
    }, {
        "./_export": 33,
        "./_object-to-array": 83
    }],
    294: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var global = require("./_global");
        var core = require("./_core");
        var microtask = require("./_microtask")();
        var OBSERVABLE = require("./_wks")("observable");
        var aFunction = require("./_a-function");
        var anObject = require("./_an-object");
        var anInstance = require("./_an-instance");
        var redefineAll = require("./_redefine-all");
        var hide = require("./_hide");
        var forOf = require("./_for-of");
        var RETURN = forOf.RETURN;
        var getMethod = function(fn) {
            return fn == null ? undefined : aFunction(fn)
        };
        var cleanupSubscription = function(subscription) {
            var cleanup = subscription._c;
            if (cleanup) {
                subscription._c = undefined;
                cleanup()
            }
        };
        var subscriptionClosed = function(subscription) {
            return subscription._o === undefined
        };
        var closeSubscription = function(subscription) {
            if (!subscriptionClosed(subscription)) {
                subscription._o = undefined;
                cleanupSubscription(subscription)
            }
        };
        var Subscription = function(observer, subscriber) {
            anObject(observer);
            this._c = undefined;
            this._o = observer;
            observer = new SubscriptionObserver(this);
            try {
                var cleanup = subscriber(observer);
                var subscription = cleanup;
                if (cleanup != null) {
                    if (typeof cleanup.unsubscribe === "function") cleanup = function() {
                        subscription.unsubscribe()
                    };
                    else aFunction(cleanup);
                    this._c = cleanup
                }
            } catch (e) {
                observer.error(e);
                return
            }
            if (subscriptionClosed(this)) cleanupSubscription(this)
        };
        Subscription.prototype = redefineAll({}, {
            unsubscribe: function unsubscribe() {
                closeSubscription(this)
            }
        });
        var SubscriptionObserver = function(subscription) {
            this._s = subscription
        };
        SubscriptionObserver.prototype = redefineAll({}, {
            next: function next(value) {
                var subscription = this._s;
                if (!subscriptionClosed(subscription)) {
                    var observer = subscription._o;
                    try {
                        var m = getMethod(observer.next);
                        if (m) return m.call(observer, value)
                    } catch (e) {
                        try {
                            closeSubscription(subscription)
                        } finally {
                            throw e
                        }
                    }
                }
            },
            error: function error(value) {
                var subscription = this._s;
                if (subscriptionClosed(subscription)) throw value;
                var observer = subscription._o;
                subscription._o = undefined;
                try {
                    var m = getMethod(observer.error);
                    if (!m) throw value;
                    value = m.call(observer, value)
                } catch (e) {
                    try {
                        cleanupSubscription(subscription)
                    } finally {
                        throw e
                    }
                }
                cleanupSubscription(subscription);
                return value
            },
            complete: function complete(value) {
                var subscription = this._s;
                if (!subscriptionClosed(subscription)) {
                    var observer = subscription._o;
                    subscription._o = undefined;
                    try {
                        var m = getMethod(observer.complete);
                        value = m ? m.call(observer, value) : undefined
                    } catch (e) {
                        try {
                            cleanupSubscription(subscription)
                        } finally {
                            throw e
                        }
                    }
                    cleanupSubscription(subscription);
                    return value
                }
            }
        });
        var $Observable = function Observable(subscriber) {
            anInstance(this, $Observable, "Observable", "_f")._f = aFunction(subscriber)
        };
        redefineAll($Observable.prototype, {
            subscribe: function subscribe(observer) {
                return new Subscription(observer, this._f)
            },
            forEach: function forEach(fn) {
                var that = this;
                return new(core.Promise || global.Promise)(function(resolve, reject) {
                    aFunction(fn);
                    var subscription = that.subscribe({
                        next: function(value) {
                            try {
                                return fn(value)
                            } catch (e) {
                                reject(e);
                                subscription.unsubscribe()
                            }
                        },
                        error: reject,
                        complete: resolve
                    })
                })
            }
        });
        redefineAll($Observable, {
            from: function from(x) {
                var C = typeof this === "function" ? this : $Observable;
                var method = getMethod(anObject(x)[OBSERVABLE]);
                if (method) {
                    var observable = anObject(method.call(x));
                    return observable.constructor === C ? observable : new C(function(observer) {
                        return observable.subscribe(observer)
                    })
                }
                return new C(function(observer) {
                    var done = false;
                    microtask(function() {
                        if (!done) {
                            try {
                                if (forOf(x, false, function(it) {
                                        observer.next(it);
                                        if (done) return RETURN
                                    }) === RETURN) return
                            } catch (e) {
                                if (done) throw e;
                                observer.error(e);
                                return
                            }
                            observer.complete()
                        }
                    });
                    return function() {
                        done = true
                    }
                })
            },
            of: function of() {
                for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
                return new(typeof this === "function" ? this : $Observable)(function(observer) {
                    var done = false;
                    microtask(function() {
                        if (!done) {
                            for (var j = 0; j < items.length; ++j) {
                                observer.next(items[j]);
                                if (done) return
                            }
                            observer.complete()
                        }
                    });
                    return function() {
                        done = true
                    }
                })
            }
        });
        hide($Observable.prototype, OBSERVABLE, function() {
            return this
        });
        $export($export.G, {
            Observable: $Observable
        });
        require("./_set-species")("Observable")
    }, {
        "./_a-function": 3,
        "./_an-instance": 6,
        "./_an-object": 7,
        "./_core": 23,
        "./_export": 33,
        "./_for-of": 39,
        "./_global": 40,
        "./_hide": 42,
        "./_microtask": 67,
        "./_redefine-all": 90,
        "./_set-species": 97,
        "./_wks": 126
    }],
    295: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var core = require("./_core");
        var global = require("./_global");
        var speciesConstructor = require("./_species-constructor");
        var promiseResolve = require("./_promise-resolve");
        $export($export.P + $export.R, "Promise", {
            finally: function(onFinally) {
                var C = speciesConstructor(this, core.Promise || global.Promise);
                var isFunction = typeof onFinally == "function";
                return this.then(isFunction ? function(x) {
                    return promiseResolve(C, onFinally()).then(function() {
                        return x
                    })
                } : onFinally, isFunction ? function(e) {
                    return promiseResolve(C, onFinally()).then(function() {
                        throw e
                    })
                } : onFinally)
            }
        })
    }, {
        "./_core": 23,
        "./_export": 33,
        "./_global": 40,
        "./_promise-resolve": 88,
        "./_species-constructor": 101
    }],
    296: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var newPromiseCapability = require("./_new-promise-capability");
        var perform = require("./_perform");
        $export($export.S, "Promise", {
            try: function(callbackfn) {
                var promiseCapability = newPromiseCapability.f(this);
                var result = perform(callbackfn);
                (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
                return promiseCapability.promise
            }
        })
    }, {
        "./_export": 33,
        "./_new-promise-capability": 68,
        "./_perform": 87
    }],
    297: [function(require, module, exports) {
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var toMetaKey = metadata.key;
        var ordinaryDefineOwnMetadata = metadata.set;
        metadata.exp({
            defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
                ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey))
            }
        })
    }, {
        "./_an-object": 7,
        "./_metadata": 66
    }],
    298: [function(require, module, exports) {
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var toMetaKey = metadata.key;
        var getOrCreateMetadataMap = metadata.map;
        var store = metadata.store;
        metadata.exp({
            deleteMetadata: function deleteMetadata(metadataKey, target) {
                var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
                var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
                if (metadataMap === undefined || !metadataMap["delete"](metadataKey)) return false;
                if (metadataMap.size) return true;
                var targetMetadata = store.get(target);
                targetMetadata["delete"](targetKey);
                return !!targetMetadata.size || store["delete"](target)
            }
        })
    }, {
        "./_an-object": 7,
        "./_metadata": 66
    }],
    299: [function(require, module, exports) {
        var Set = require("./es6.set");
        var from = require("./_array-from-iterable");
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var getPrototypeOf = require("./_object-gpo");
        var ordinaryOwnMetadataKeys = metadata.keys;
        var toMetaKey = metadata.key;
        var ordinaryMetadataKeys = function(O, P) {
            var oKeys = ordinaryOwnMetadataKeys(O, P);
            var parent = getPrototypeOf(O);
            if (parent === null) return oKeys;
            var pKeys = ordinaryMetadataKeys(parent, P);
            return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys
        };
        metadata.exp({
            getMetadataKeys: function getMetadataKeys(target) {
                return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]))
            }
        })
    }, {
        "./_an-object": 7,
        "./_array-from-iterable": 10,
        "./_metadata": 66,
        "./_object-gpo": 78,
        "./es6.set": 229
    }],
    300: [function(require, module, exports) {
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var getPrototypeOf = require("./_object-gpo");
        var ordinaryHasOwnMetadata = metadata.has;
        var ordinaryGetOwnMetadata = metadata.get;
        var toMetaKey = metadata.key;
        var ordinaryGetMetadata = function(MetadataKey, O, P) {
            var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = getPrototypeOf(O);
            return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined
        };
        metadata.exp({
            getMetadata: function getMetadata(metadataKey, target) {
                return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
            }
        })
    }, {
        "./_an-object": 7,
        "./_metadata": 66,
        "./_object-gpo": 78
    }],
    301: [function(require, module, exports) {
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var ordinaryOwnMetadataKeys = metadata.keys;
        var toMetaKey = metadata.key;
        metadata.exp({
            getOwnMetadataKeys: function getOwnMetadataKeys(target) {
                return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]))
            }
        })
    }, {
        "./_an-object": 7,
        "./_metadata": 66
    }],
    302: [function(require, module, exports) {
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var ordinaryGetOwnMetadata = metadata.get;
        var toMetaKey = metadata.key;
        metadata.exp({
            getOwnMetadata: function getOwnMetadata(metadataKey, target) {
                return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
            }
        })
    }, {
        "./_an-object": 7,
        "./_metadata": 66
    }],
    303: [function(require, module, exports) {
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var getPrototypeOf = require("./_object-gpo");
        var ordinaryHasOwnMetadata = metadata.has;
        var toMetaKey = metadata.key;
        var ordinaryHasMetadata = function(MetadataKey, O, P) {
            var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn) return true;
            var parent = getPrototypeOf(O);
            return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false
        };
        metadata.exp({
            hasMetadata: function hasMetadata(metadataKey, target) {
                return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
            }
        })
    }, {
        "./_an-object": 7,
        "./_metadata": 66,
        "./_object-gpo": 78
    }],
    304: [function(require, module, exports) {
        var metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var ordinaryHasOwnMetadata = metadata.has;
        var toMetaKey = metadata.key;
        metadata.exp({
            hasOwnMetadata: function hasOwnMetadata(metadataKey, target) {
                return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
            }
        })
    }, {
        "./_an-object": 7,
        "./_metadata": 66
    }],
    305: [function(require, module, exports) {
        var $metadata = require("./_metadata");
        var anObject = require("./_an-object");
        var aFunction = require("./_a-function");
        var toMetaKey = $metadata.key;
        var ordinaryDefineOwnMetadata = $metadata.set;
        $metadata.exp({
            metadata: function metadata(metadataKey, metadataValue) {
                return function decorator(target, targetKey) {
                    ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey))
                }
            }
        })
    }, {
        "./_a-function": 3,
        "./_an-object": 7,
        "./_metadata": 66
    }],
    306: [function(require, module, exports) {
        require("./_set-collection-from")("Set")
    }, {
        "./_set-collection-from": 94
    }],
    307: [function(require, module, exports) {
        require("./_set-collection-of")("Set")
    }, {
        "./_set-collection-of": 95
    }],
    308: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.P + $export.R, "Set", {
            toJSON: require("./_collection-to-json")("Set")
        })
    }, {
        "./_collection-to-json": 20,
        "./_export": 33
    }],
    309: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $at = require("./_string-at")(true);
        $export($export.P, "String", {
            at: function at(pos) {
                return $at(this, pos)
            }
        })
    }, {
        "./_export": 33,
        "./_string-at": 103
    }],
    310: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var defined = require("./_defined");
        var toLength = require("./_to-length");
        var isRegExp = require("./_is-regexp");
        var getFlags = require("./_flags");
        var RegExpProto = RegExp.prototype;
        var $RegExpStringIterator = function(regexp, string) {
            this._r = regexp;
            this._s = string
        };
        require("./_iter-create")($RegExpStringIterator, "RegExp String", function next() {
            var match = this._r.exec(this._s);
            return {
                value: match,
                done: match === null
            }
        });
        $export($export.P, "String", {
            matchAll: function matchAll(regexp) {
                defined(this);
                if (!isRegExp(regexp)) throw TypeError(regexp + " is not a regexp!");
                var S = String(this);
                var flags = "flags" in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
                var rx = new RegExp(regexp.source, ~flags.indexOf("g") ? flags : "g" + flags);
                rx.lastIndex = toLength(regexp.lastIndex);
                return new $RegExpStringIterator(rx, S)
            }
        })
    }, {
        "./_defined": 28,
        "./_export": 33,
        "./_flags": 37,
        "./_is-regexp": 52,
        "./_iter-create": 54,
        "./_to-length": 115
    }],
    311: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $pad = require("./_string-pad");
        var userAgent = require("./_user-agent");
        $export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), "String", {
            padEnd: function padEnd(maxLength) {
                return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false)
            }
        })
    }, {
        "./_export": 33,
        "./_string-pad": 106,
        "./_user-agent": 122
    }],
    312: [function(require, module, exports) {
        "use strict";
        var $export = require("./_export");
        var $pad = require("./_string-pad");
        var userAgent = require("./_user-agent");
        $export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), "String", {
            padStart: function padStart(maxLength) {
                return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true)
            }
        })
    }, {
        "./_export": 33,
        "./_string-pad": 106,
        "./_user-agent": 122
    }],
    313: [function(require, module, exports) {
        "use strict";
        require("./_string-trim")("trimLeft", function($trim) {
            return function trimLeft() {
                return $trim(this, 1)
            }
        }, "trimStart")
    }, {
        "./_string-trim": 108
    }],
    314: [function(require, module, exports) {
        "use strict";
        require("./_string-trim")("trimRight", function($trim) {
            return function trimRight() {
                return $trim(this, 2)
            }
        }, "trimEnd")
    }, {
        "./_string-trim": 108
    }],
    315: [function(require, module, exports) {
        require("./_wks-define")("asyncIterator")
    }, {
        "./_wks-define": 124
    }],
    316: [function(require, module, exports) {
        require("./_wks-define")("observable")
    }, {
        "./_wks-define": 124
    }],
    317: [function(require, module, exports) {
        var $export = require("./_export");
        $export($export.S, "System", {
            global: require("./_global")
        })
    }, {
        "./_export": 33,
        "./_global": 40
    }],
    318: [function(require, module, exports) {
        require("./_set-collection-from")("WeakMap")
    }, {
        "./_set-collection-from": 94
    }],
    319: [function(require, module, exports) {
        require("./_set-collection-of")("WeakMap")
    }, {
        "./_set-collection-of": 95
    }],
    320: [function(require, module, exports) {
        require("./_set-collection-from")("WeakSet")
    }, {
        "./_set-collection-from": 94
    }],
    321: [function(require, module, exports) {
        require("./_set-collection-of")("WeakSet")
    }, {
        "./_set-collection-of": 95
    }],
    322: [function(require, module, exports) {
        var $iterators = require("./es6.array.iterator");
        var getKeys = require("./_object-keys");
        var redefine = require("./_redefine");
        var global = require("./_global");
        var hide = require("./_hide");
        var Iterators = require("./_iterators");
        var wks = require("./_wks");
        var ITERATOR = wks("iterator");
        var TO_STRING_TAG = wks("toStringTag");
        var ArrayValues = Iterators.Array;
        var DOMIterables = {
            CSSRuleList: true,
            CSSStyleDeclaration: false,
            CSSValueList: false,
            ClientRectList: false,
            DOMRectList: false,
            DOMStringList: false,
            DOMTokenList: true,
            DataTransferItemList: false,
            FileList: false,
            HTMLAllCollection: false,
            HTMLCollection: false,
            HTMLFormElement: false,
            HTMLSelectElement: false,
            MediaList: true,
            MimeTypeArray: false,
            NamedNodeMap: false,
            NodeList: true,
            PaintRequestList: false,
            Plugin: false,
            PluginArray: false,
            SVGLengthList: false,
            SVGNumberList: false,
            SVGPathSegList: false,
            SVGPointList: false,
            SVGStringList: false,
            SVGTransformList: false,
            SourceBufferList: false,
            StyleSheetList: true,
            TextTrackCueList: false,
            TextTrackList: false,
            TouchList: false
        };
        for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
            var NAME = collections[i];
            var explicit = DOMIterables[NAME];
            var Collection = global[NAME];
            var proto = Collection && Collection.prototype;
            var key;
            if (proto) {
                if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
                if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
                Iterators[NAME] = ArrayValues;
                if (explicit)
                    for (key in $iterators)
                        if (!proto[key]) redefine(proto, key, $iterators[key], true)
            }
        }
    }, {
        "./_global": 40,
        "./_hide": 42,
        "./_iterators": 58,
        "./_object-keys": 80,
        "./_redefine": 91,
        "./_wks": 126,
        "./es6.array.iterator": 139
    }],
    323: [function(require, module, exports) {
        var $export = require("./_export");
        var $task = require("./_task");
        $export($export.G + $export.B, {
            setImmediate: $task.set,
            clearImmediate: $task.clear
        })
    }, {
        "./_export": 33,
        "./_task": 110
    }],
    324: [function(require, module, exports) {
        var global = require("./_global");
        var $export = require("./_export");
        var userAgent = require("./_user-agent");
        var slice = [].slice;
        var MSIE = /MSIE .\./.test(userAgent);
        var wrap = function(set) {
            return function(fn, time) {
                var boundArgs = arguments.length > 2;
                var args = boundArgs ? slice.call(arguments, 2) : false;
                return set(boundArgs ? function() {
                    (typeof fn == "function" ? fn : Function(fn)).apply(this, args)
                } : fn, time)
            }
        };
        $export($export.G + $export.B + $export.F * MSIE, {
            setTimeout: wrap(global.setTimeout),
            setInterval: wrap(global.setInterval)
        })
    }, {
        "./_export": 33,
        "./_global": 40,
        "./_user-agent": 122
    }],
    325: [function(require, module, exports) {
        require("./modules/es6.symbol");
        require("./modules/es6.object.create");
        require("./modules/es6.object.define-property");
        require("./modules/es6.object.define-properties");
        require("./modules/es6.object.get-own-property-descriptor");
        require("./modules/es6.object.get-prototype-of");
        require("./modules/es6.object.keys");
        require("./modules/es6.object.get-own-property-names");
        require("./modules/es6.object.freeze");
        require("./modules/es6.object.seal");
        require("./modules/es6.object.prevent-extensions");
        require("./modules/es6.object.is-frozen");
        require("./modules/es6.object.is-sealed");
        require("./modules/es6.object.is-extensible");
        require("./modules/es6.object.assign");
        require("./modules/es6.object.is");
        require("./modules/es6.object.set-prototype-of");
        require("./modules/es6.object.to-string");
        require("./modules/es6.function.bind");
        require("./modules/es6.function.name");
        require("./modules/es6.function.has-instance");
        require("./modules/es6.parse-int");
        require("./modules/es6.parse-float");
        require("./modules/es6.number.constructor");
        require("./modules/es6.number.to-fixed");
        require("./modules/es6.number.to-precision");
        require("./modules/es6.number.epsilon");
        require("./modules/es6.number.is-finite");
        require("./modules/es6.number.is-integer");
        require("./modules/es6.number.is-nan");
        require("./modules/es6.number.is-safe-integer");
        require("./modules/es6.number.max-safe-integer");
        require("./modules/es6.number.min-safe-integer");
        require("./modules/es6.number.parse-float");
        require("./modules/es6.number.parse-int");
        require("./modules/es6.math.acosh");
        require("./modules/es6.math.asinh");
        require("./modules/es6.math.atanh");
        require("./modules/es6.math.cbrt");
        require("./modules/es6.math.clz32");
        require("./modules/es6.math.cosh");
        require("./modules/es6.math.expm1");
        require("./modules/es6.math.fround");
        require("./modules/es6.math.hypot");
        require("./modules/es6.math.imul");
        require("./modules/es6.math.log10");
        require("./modules/es6.math.log1p");
        require("./modules/es6.math.log2");
        require("./modules/es6.math.sign");
        require("./modules/es6.math.sinh");
        require("./modules/es6.math.tanh");
        require("./modules/es6.math.trunc");
        require("./modules/es6.string.from-code-point");
        require("./modules/es6.string.raw");
        require("./modules/es6.string.trim");
        require("./modules/es6.string.iterator");
        require("./modules/es6.string.code-point-at");
        require("./modules/es6.string.ends-with");
        require("./modules/es6.string.includes");
        require("./modules/es6.string.repeat");
        require("./modules/es6.string.starts-with");
        require("./modules/es6.string.anchor");
        require("./modules/es6.string.big");
        require("./modules/es6.string.blink");
        require("./modules/es6.string.bold");
        require("./modules/es6.string.fixed");
        require("./modules/es6.string.fontcolor");
        require("./modules/es6.string.fontsize");
        require("./modules/es6.string.italics");
        require("./modules/es6.string.link");
        require("./modules/es6.string.small");
        require("./modules/es6.string.strike");
        require("./modules/es6.string.sub");
        require("./modules/es6.string.sup");
        require("./modules/es6.date.now");
        require("./modules/es6.date.to-json");
        require("./modules/es6.date.to-iso-string");
        require("./modules/es6.date.to-string");
        require("./modules/es6.date.to-primitive");
        require("./modules/es6.array.is-array");
        require("./modules/es6.array.from");
        require("./modules/es6.array.of");
        require("./modules/es6.array.join");
        require("./modules/es6.array.slice");
        require("./modules/es6.array.sort");
        require("./modules/es6.array.for-each");
        require("./modules/es6.array.map");
        require("./modules/es6.array.filter");
        require("./modules/es6.array.some");
        require("./modules/es6.array.every");
        require("./modules/es6.array.reduce");
        require("./modules/es6.array.reduce-right");
        require("./modules/es6.array.index-of");
        require("./modules/es6.array.last-index-of");
        require("./modules/es6.array.copy-within");
        require("./modules/es6.array.fill");
        require("./modules/es6.array.find");
        require("./modules/es6.array.find-index");
        require("./modules/es6.array.species");
        require("./modules/es6.array.iterator");
        require("./modules/es6.regexp.constructor");
        require("./modules/es6.regexp.to-string");
        require("./modules/es6.regexp.flags");
        require("./modules/es6.regexp.match");
        require("./modules/es6.regexp.replace");
        require("./modules/es6.regexp.search");
        require("./modules/es6.regexp.split");
        require("./modules/es6.promise");
        require("./modules/es6.map");
        require("./modules/es6.set");
        require("./modules/es6.weak-map");
        require("./modules/es6.weak-set");
        require("./modules/es6.typed.array-buffer");
        require("./modules/es6.typed.data-view");
        require("./modules/es6.typed.int8-array");
        require("./modules/es6.typed.uint8-array");
        require("./modules/es6.typed.uint8-clamped-array");
        require("./modules/es6.typed.int16-array");
        require("./modules/es6.typed.uint16-array");
        require("./modules/es6.typed.int32-array");
        require("./modules/es6.typed.uint32-array");
        require("./modules/es6.typed.float32-array");
        require("./modules/es6.typed.float64-array");
        require("./modules/es6.reflect.apply");
        require("./modules/es6.reflect.construct");
        require("./modules/es6.reflect.define-property");
        require("./modules/es6.reflect.delete-property");
        require("./modules/es6.reflect.enumerate");
        require("./modules/es6.reflect.get");
        require("./modules/es6.reflect.get-own-property-descriptor");
        require("./modules/es6.reflect.get-prototype-of");
        require("./modules/es6.reflect.has");
        require("./modules/es6.reflect.is-extensible");
        require("./modules/es6.reflect.own-keys");
        require("./modules/es6.reflect.prevent-extensions");
        require("./modules/es6.reflect.set");
        require("./modules/es6.reflect.set-prototype-of");
        require("./modules/es7.array.includes");
        require("./modules/es7.array.flat-map");
        require("./modules/es7.array.flatten");
        require("./modules/es7.string.at");
        require("./modules/es7.string.pad-start");
        require("./modules/es7.string.pad-end");
        require("./modules/es7.string.trim-left");
        require("./modules/es7.string.trim-right");
        require("./modules/es7.string.match-all");
        require("./modules/es7.symbol.async-iterator");
        require("./modules/es7.symbol.observable");
        require("./modules/es7.object.get-own-property-descriptors");
        require("./modules/es7.object.values");
        require("./modules/es7.object.entries");
        require("./modules/es7.object.define-getter");
        require("./modules/es7.object.define-setter");
        require("./modules/es7.object.lookup-getter");
        require("./modules/es7.object.lookup-setter");
        require("./modules/es7.map.to-json");
        require("./modules/es7.set.to-json");
        require("./modules/es7.map.of");
        require("./modules/es7.set.of");
        require("./modules/es7.weak-map.of");
        require("./modules/es7.weak-set.of");
        require("./modules/es7.map.from");
        require("./modules/es7.set.from");
        require("./modules/es7.weak-map.from");
        require("./modules/es7.weak-set.from");
        require("./modules/es7.global");
        require("./modules/es7.system.global");
        require("./modules/es7.error.is-error");
        require("./modules/es7.math.clamp");
        require("./modules/es7.math.deg-per-rad");
        require("./modules/es7.math.degrees");
        require("./modules/es7.math.fscale");
        require("./modules/es7.math.iaddh");
        require("./modules/es7.math.isubh");
        require("./modules/es7.math.imulh");
        require("./modules/es7.math.rad-per-deg");
        require("./modules/es7.math.radians");
        require("./modules/es7.math.scale");
        require("./modules/es7.math.umulh");
        require("./modules/es7.math.signbit");
        require("./modules/es7.promise.finally");
        require("./modules/es7.promise.try");
        require("./modules/es7.reflect.define-metadata");
        require("./modules/es7.reflect.delete-metadata");
        require("./modules/es7.reflect.get-metadata");
        require("./modules/es7.reflect.get-metadata-keys");
        require("./modules/es7.reflect.get-own-metadata");
        require("./modules/es7.reflect.get-own-metadata-keys");
        require("./modules/es7.reflect.has-metadata");
        require("./modules/es7.reflect.has-own-metadata");
        require("./modules/es7.reflect.metadata");
        require("./modules/es7.asap");
        require("./modules/es7.observable");
        require("./modules/web.timers");
        require("./modules/web.immediate");
        require("./modules/web.dom.iterable");
        module.exports = require("./modules/_core")
    }, {
        "./modules/_core": 23,
        "./modules/es6.array.copy-within": 129,
        "./modules/es6.array.every": 130,
        "./modules/es6.array.fill": 131,
        "./modules/es6.array.filter": 132,
        "./modules/es6.array.find": 134,
        "./modules/es6.array.find-index": 133,
        "./modules/es6.array.for-each": 135,
        "./modules/es6.array.from": 136,
        "./modules/es6.array.index-of": 137,
        "./modules/es6.array.is-array": 138,
        "./modules/es6.array.iterator": 139,
        "./modules/es6.array.join": 140,
        "./modules/es6.array.last-index-of": 141,
        "./modules/es6.array.map": 142,
        "./modules/es6.array.of": 143,
        "./modules/es6.array.reduce": 145,
        "./modules/es6.array.reduce-right": 144,
        "./modules/es6.array.slice": 146,
        "./modules/es6.array.some": 147,
        "./modules/es6.array.sort": 148,
        "./modules/es6.array.species": 149,
        "./modules/es6.date.now": 150,
        "./modules/es6.date.to-iso-string": 151,
        "./modules/es6.date.to-json": 152,
        "./modules/es6.date.to-primitive": 153,
        "./modules/es6.date.to-string": 154,
        "./modules/es6.function.bind": 155,
        "./modules/es6.function.has-instance": 156,
        "./modules/es6.function.name": 157,
        "./modules/es6.map": 158,
        "./modules/es6.math.acosh": 159,
        "./modules/es6.math.asinh": 160,
        "./modules/es6.math.atanh": 161,
        "./modules/es6.math.cbrt": 162,
        "./modules/es6.math.clz32": 163,
        "./modules/es6.math.cosh": 164,
        "./modules/es6.math.expm1": 165,
        "./modules/es6.math.fround": 166,
        "./modules/es6.math.hypot": 167,
        "./modules/es6.math.imul": 168,
        "./modules/es6.math.log10": 169,
        "./modules/es6.math.log1p": 170,
        "./modules/es6.math.log2": 171,
        "./modules/es6.math.sign": 172,
        "./modules/es6.math.sinh": 173,
        "./modules/es6.math.tanh": 174,
        "./modules/es6.math.trunc": 175,
        "./modules/es6.number.constructor": 176,
        "./modules/es6.number.epsilon": 177,
        "./modules/es6.number.is-finite": 178,
        "./modules/es6.number.is-integer": 179,
        "./modules/es6.number.is-nan": 180,
        "./modules/es6.number.is-safe-integer": 181,
        "./modules/es6.number.max-safe-integer": 182,
        "./modules/es6.number.min-safe-integer": 183,
        "./modules/es6.number.parse-float": 184,
        "./modules/es6.number.parse-int": 185,
        "./modules/es6.number.to-fixed": 186,
        "./modules/es6.number.to-precision": 187,
        "./modules/es6.object.assign": 188,
        "./modules/es6.object.create": 189,
        "./modules/es6.object.define-properties": 190,
        "./modules/es6.object.define-property": 191,
        "./modules/es6.object.freeze": 192,
        "./modules/es6.object.get-own-property-descriptor": 193,
        "./modules/es6.object.get-own-property-names": 194,
        "./modules/es6.object.get-prototype-of": 195,
        "./modules/es6.object.is": 199,
        "./modules/es6.object.is-extensible": 196,
        "./modules/es6.object.is-frozen": 197,
        "./modules/es6.object.is-sealed": 198,
        "./modules/es6.object.keys": 200,
        "./modules/es6.object.prevent-extensions": 201,
        "./modules/es6.object.seal": 202,
        "./modules/es6.object.set-prototype-of": 203,
        "./modules/es6.object.to-string": 204,
        "./modules/es6.parse-float": 205,
        "./modules/es6.parse-int": 206,
        "./modules/es6.promise": 207,
        "./modules/es6.reflect.apply": 208,
        "./modules/es6.reflect.construct": 209,
        "./modules/es6.reflect.define-property": 210,
        "./modules/es6.reflect.delete-property": 211,
        "./modules/es6.reflect.enumerate": 212,
        "./modules/es6.reflect.get": 215,
        "./modules/es6.reflect.get-own-property-descriptor": 213,
        "./modules/es6.reflect.get-prototype-of": 214,
        "./modules/es6.reflect.has": 216,
        "./modules/es6.reflect.is-extensible": 217,
        "./modules/es6.reflect.own-keys": 218,
        "./modules/es6.reflect.prevent-extensions": 219,
        "./modules/es6.reflect.set": 221,
        "./modules/es6.reflect.set-prototype-of": 220,
        "./modules/es6.regexp.constructor": 222,
        "./modules/es6.regexp.flags": 223,
        "./modules/es6.regexp.match": 224,
        "./modules/es6.regexp.replace": 225,
        "./modules/es6.regexp.search": 226,
        "./modules/es6.regexp.split": 227,
        "./modules/es6.regexp.to-string": 228,
        "./modules/es6.set": 229,
        "./modules/es6.string.anchor": 230,
        "./modules/es6.string.big": 231,
        "./modules/es6.string.blink": 232,
        "./modules/es6.string.bold": 233,
        "./modules/es6.string.code-point-at": 234,
        "./modules/es6.string.ends-with": 235,
        "./modules/es6.string.fixed": 236,
        "./modules/es6.string.fontcolor": 237,
        "./modules/es6.string.fontsize": 238,
        "./modules/es6.string.from-code-point": 239,
        "./modules/es6.string.includes": 240,
        "./modules/es6.string.italics": 241,
        "./modules/es6.string.iterator": 242,
        "./modules/es6.string.link": 243,
        "./modules/es6.string.raw": 244,
        "./modules/es6.string.repeat": 245,
        "./modules/es6.string.small": 246,
        "./modules/es6.string.starts-with": 247,
        "./modules/es6.string.strike": 248,
        "./modules/es6.string.sub": 249,
        "./modules/es6.string.sup": 250,
        "./modules/es6.string.trim": 251,
        "./modules/es6.symbol": 252,
        "./modules/es6.typed.array-buffer": 253,
        "./modules/es6.typed.data-view": 254,
        "./modules/es6.typed.float32-array": 255,
        "./modules/es6.typed.float64-array": 256,
        "./modules/es6.typed.int16-array": 257,
        "./modules/es6.typed.int32-array": 258,
        "./modules/es6.typed.int8-array": 259,
        "./modules/es6.typed.uint16-array": 260,
        "./modules/es6.typed.uint32-array": 261,
        "./modules/es6.typed.uint8-array": 262,
        "./modules/es6.typed.uint8-clamped-array": 263,
        "./modules/es6.weak-map": 264,
        "./modules/es6.weak-set": 265,
        "./modules/es7.array.flat-map": 266,
        "./modules/es7.array.flatten": 267,
        "./modules/es7.array.includes": 268,
        "./modules/es7.asap": 269,
        "./modules/es7.error.is-error": 270,
        "./modules/es7.global": 271,
        "./modules/es7.map.from": 272,
        "./modules/es7.map.of": 273,
        "./modules/es7.map.to-json": 274,
        "./modules/es7.math.clamp": 275,
        "./modules/es7.math.deg-per-rad": 276,
        "./modules/es7.math.degrees": 277,
        "./modules/es7.math.fscale": 278,
        "./modules/es7.math.iaddh": 279,
        "./modules/es7.math.imulh": 280,
        "./modules/es7.math.isubh": 281,
        "./modules/es7.math.rad-per-deg": 282,
        "./modules/es7.math.radians": 283,
        "./modules/es7.math.scale": 284,
        "./modules/es7.math.signbit": 285,
        "./modules/es7.math.umulh": 286,
        "./modules/es7.object.define-getter": 287,
        "./modules/es7.object.define-setter": 288,
        "./modules/es7.object.entries": 289,
        "./modules/es7.object.get-own-property-descriptors": 290,
        "./modules/es7.object.lookup-getter": 291,
        "./modules/es7.object.lookup-setter": 292,
        "./modules/es7.object.values": 293,
        "./modules/es7.observable": 294,
        "./modules/es7.promise.finally": 295,
        "./modules/es7.promise.try": 296,
        "./modules/es7.reflect.define-metadata": 297,
        "./modules/es7.reflect.delete-metadata": 298,
        "./modules/es7.reflect.get-metadata": 300,
        "./modules/es7.reflect.get-metadata-keys": 299,
        "./modules/es7.reflect.get-own-metadata": 302,
        "./modules/es7.reflect.get-own-metadata-keys": 301,
        "./modules/es7.reflect.has-metadata": 303,
        "./modules/es7.reflect.has-own-metadata": 304,
        "./modules/es7.reflect.metadata": 305,
        "./modules/es7.set.from": 306,
        "./modules/es7.set.of": 307,
        "./modules/es7.set.to-json": 308,
        "./modules/es7.string.at": 309,
        "./modules/es7.string.match-all": 310,
        "./modules/es7.string.pad-end": 311,
        "./modules/es7.string.pad-start": 312,
        "./modules/es7.string.trim-left": 313,
        "./modules/es7.string.trim-right": 314,
        "./modules/es7.symbol.async-iterator": 315,
        "./modules/es7.symbol.observable": 316,
        "./modules/es7.system.global": 317,
        "./modules/es7.weak-map.from": 318,
        "./modules/es7.weak-map.of": 319,
        "./modules/es7.weak-set.from": 320,
        "./modules/es7.weak-set.of": 321,
        "./modules/web.dom.iterable": 322,
        "./modules/web.immediate": 323,
        "./modules/web.timers": 324
    }],
    326: [function(require, module, exports) {
        var objectCreate = Object.create || objectCreatePolyfill;
        var objectKeys = Object.keys || objectKeysPolyfill;
        var bind = Function.prototype.bind || functionBindPolyfill;

        function EventEmitter() {
            if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
                this._events = objectCreate(null);
                this._eventsCount = 0
            }
            this._maxListeners = this._maxListeners || undefined
        }
        module.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        var defaultMaxListeners = 10;
        var hasDefineProperty;
        try {
            var o = {};
            if (Object.defineProperty) Object.defineProperty(o, "x", {
                value: 0
            });
            hasDefineProperty = o.x === 0
        } catch (err) {
            hasDefineProperty = false
        }
        if (hasDefineProperty) {
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                enumerable: true,
                get: function() {
                    return defaultMaxListeners
                },
                set: function(arg) {
                    if (typeof arg !== "number" || arg < 0 || arg !== arg) throw new TypeError('"defaultMaxListeners" must be a positive number');
                    defaultMaxListeners = arg
                }
            })
        } else {
            EventEmitter.defaultMaxListeners = defaultMaxListeners
        }
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== "number" || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
            this._maxListeners = n;
            return this
        };

        function $getMaxListeners(that) {
            if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
            return that._maxListeners
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return $getMaxListeners(this)
        };

        function emitNone(handler, isFn, self) {
            if (isFn) handler.call(self);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self)
            }
        }

        function emitOne(handler, isFn, self, arg1) {
            if (isFn) handler.call(self, arg1);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self, arg1)
            }
        }

        function emitTwo(handler, isFn, self, arg1, arg2) {
            if (isFn) handler.call(self, arg1, arg2);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2)
            }
        }

        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
            if (isFn) handler.call(self, arg1, arg2, arg3);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3)
            }
        }

        function emitMany(handler, isFn, self, args) {
            if (isFn) handler.apply(self, args);
            else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].apply(self, args)
            }
        }
        EventEmitter.prototype.emit = function emit(type) {
            var er, handler, len, args, i, events;
            var doError = type === "error";
            events = this._events;
            if (events) doError = doError && events.error == null;
            else if (!doError) return false;
            if (doError) {
                if (arguments.length > 1) er = arguments[1];
                if (er instanceof Error) {
                    throw er
                } else {
                    var err = new Error('Unhandled "error" event. (' + er + ")");
                    err.context = er;
                    throw err
                }
                return false
            }
            handler = events[type];
            if (!handler) return false;
            var isFn = typeof handler === "function";
            len = arguments.length;
            switch (len) {
                case 1:
                    emitNone(handler, isFn, this);
                    break;
                case 2:
                    emitOne(handler, isFn, this, arguments[1]);
                    break;
                case 3:
                    emitTwo(handler, isFn, this, arguments[1], arguments[2]);
                    break;
                case 4:
                    emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                    emitMany(handler, isFn, this, args)
            }
            return true
        };

        function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            events = target._events;
            if (!events) {
                events = target._events = objectCreate(null);
                target._eventsCount = 0
            } else {
                if (events.newListener) {
                    target.emit("newListener", type, listener.listener ? listener.listener : listener);
                    events = target._events
                }
                existing = events[type]
            }
            if (!existing) {
                existing = events[type] = listener;
                ++target._eventsCount
            } else {
                if (typeof existing === "function") {
                    existing = events[type] = prepend ? [listener, existing] : [existing, listener]
                } else {
                    if (prepend) {
                        existing.unshift(listener)
                    } else {
                        existing.push(listener)
                    }
                }
                if (!existing.warned) {
                    m = $getMaxListeners(target);
                    if (m && m > 0 && existing.length > m) {
                        existing.warned = true;
                        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners ' + "added. Use emitter.setMaxListeners() to " + "increase limit.");
                        w.name = "MaxListenersExceededWarning";
                        w.emitter = target;
                        w.type = type;
                        w.count = existing.length;
                        if (typeof console === "object" && console.warn) {
                            console.warn("%s: %s", w.name, w.message)
                        }
                    }
                }
            }
            return target
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
            return _addListener(this, type, listener, false)
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
            return _addListener(this, type, listener, true)
        };

        function onceWrapper() {
            if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                switch (arguments.length) {
                    case 0:
                        return this.listener.call(this.target);
                    case 1:
                        return this.listener.call(this.target, arguments[0]);
                    case 2:
                        return this.listener.call(this.target, arguments[0], arguments[1]);
                    case 3:
                        return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
                    default:
                        var args = new Array(arguments.length);
                        for (var i = 0; i < args.length; ++i) args[i] = arguments[i];
                        this.listener.apply(this.target, args)
                }
            }
        }

        function _onceWrap(target, type, listener) {
            var state = {
                fired: false,
                wrapFn: undefined,
                target: target,
                type: type,
                listener: listener
            };
            var wrapped = bind.call(onceWrapper, state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped
        }
        EventEmitter.prototype.once = function once(type, listener) {
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            this.on(type, _onceWrap(this, type, listener));
            return this
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            this.prependListener(type, _onceWrap(this, type, listener));
            return this
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
            var list, events, position, i, originalListener;
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            events = this._events;
            if (!events) return this;
            list = events[type];
            if (!list) return this;
            if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0) this._events = objectCreate(null);
                else {
                    delete events[type];
                    if (events.removeListener) this.emit("removeListener", type, list.listener || listener)
                }
            } else if (typeof list !== "function") {
                position = -1;
                for (i = list.length - 1; i >= 0; i--) {
                    if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break
                    }
                }
                if (position < 0) return this;
                if (position === 0) list.shift();
                else spliceOne(list, position);
                if (list.length === 1) events[type] = list[0];
                if (events.removeListener) this.emit("removeListener", type, originalListener || listener)
            }
            return this
        };
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
            var listeners, events, i;
            events = this._events;
            if (!events) return this;
            if (!events.removeListener) {
                if (arguments.length === 0) {
                    this._events = objectCreate(null);
                    this._eventsCount = 0
                } else if (events[type]) {
                    if (--this._eventsCount === 0) this._events = objectCreate(null);
                    else delete events[type]
                }
                return this
            }
            if (arguments.length === 0) {
                var keys = objectKeys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                    key = keys[i];
                    if (key === "removeListener") continue;
                    this.removeAllListeners(key)
                }
                this.removeAllListeners("removeListener");
                this._events = objectCreate(null);
                this._eventsCount = 0;
                return this
            }
            listeners = events[type];
            if (typeof listeners === "function") {
                this.removeListener(type, listeners)
            } else if (listeners) {
                for (i = listeners.length - 1; i >= 0; i--) {
                    this.removeListener(type, listeners[i])
                }
            }
            return this
        };
        EventEmitter.prototype.listeners = function listeners(type) {
            var evlistener;
            var ret;
            var events = this._events;
            if (!events) ret = [];
            else {
                evlistener = events[type];
                if (!evlistener) ret = [];
                else if (typeof evlistener === "function") ret = [evlistener.listener || evlistener];
                else ret = unwrapListeners(evlistener)
            }
            return ret
        };
        EventEmitter.listenerCount = function(emitter, type) {
            if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type)
            } else {
                return listenerCount.call(emitter, type)
            }
        };
        EventEmitter.prototype.listenerCount = listenerCount;

        function listenerCount(type) {
            var events = this._events;
            if (events) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                    return 1
                } else if (evlistener) {
                    return evlistener.length
                }
            }
            return 0
        }
        EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : []
        };

        function spliceOne(list, index) {
            for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
            list.pop()
        }

        function arrayClone(arr, n) {
            var copy = new Array(n);
            for (var i = 0; i < n; ++i) copy[i] = arr[i];
            return copy
        }

        function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i]
            }
            return ret
        }

        function objectCreatePolyfill(proto) {
            var F = function() {};
            F.prototype = proto;
            return new F
        }

        function objectKeysPolyfill(obj) {
            var keys = [];
            for (var k in obj)
                if (Object.prototype.hasOwnProperty.call(obj, k)) {
                    keys.push(k)
                }
            return k
        }

        function functionBindPolyfill(context) {
            var fn = this;
            return function() {
                return fn.apply(context, arguments)
            }
        }
    }, {}],
    327: [function(require, module, exports) {
        (function(global) {
            var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window;
            (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
                "use strict";
                _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
                    var _slice = function(a) {
                            var b = [],
                                l = a.length,
                                i;
                            for (i = 0; i !== l; b.push(a[i++]));
                            return b
                        },
                        _applyCycle = function(vars, targets, i) {
                            var alt = vars.cycle,
                                p, val;
                            for (p in alt) {
                                val = alt[p];
                                vars[p] = typeof val === "function" ? val(i, targets[i]) : val[i % val.length]
                            }
                            delete vars.cycle
                        },
                        TweenMax = function(target, duration, vars) {
                            TweenLite.call(this, target, duration, vars);
                            this._cycle = 0;
                            this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;
                            this._repeat = this.vars.repeat || 0;
                            this._repeatDelay = this.vars.repeatDelay || 0;
                            if (this._repeat) {
                                this._uncache(true)
                            }
                            this.render = TweenMax.prototype.render
                        },
                        _tinyNum = 1e-10,
                        TweenLiteInternals = TweenLite._internals,
                        _isSelector = TweenLiteInternals.isSelector,
                        _isArray = TweenLiteInternals.isArray,
                        p = TweenMax.prototype = TweenLite.to({}, .1, {}),
                        _blankArray = [];
                    TweenMax.version = "1.20.4";
                    p.constructor = TweenMax;
                    p.kill()._gc = false;
                    TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
                    TweenMax.getTweensOf = TweenLite.getTweensOf;
                    TweenMax.lagSmoothing = TweenLite.lagSmoothing;
                    TweenMax.ticker = TweenLite.ticker;
                    TweenMax.render = TweenLite.render;
                    p.invalidate = function() {
                        this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;
                        this._repeat = this.vars.repeat || 0;
                        this._repeatDelay = this.vars.repeatDelay || 0;
                        this._yoyoEase = null;
                        this._uncache(true);
                        return TweenLite.prototype.invalidate.call(this)
                    };
                    p.updateTo = function(vars, resetDuration) {
                        var curRatio = this.ratio,
                            immediate = this.vars.immediateRender || vars.immediateRender,
                            p;
                        if (resetDuration && this._startTime < this._timeline._time) {
                            this._startTime = this._timeline._time;
                            this._uncache(false);
                            if (this._gc) {
                                this._enabled(true, false)
                            } else {
                                this._timeline.insert(this, this._startTime - this._delay)
                            }
                        }
                        for (p in vars) {
                            this.vars[p] = vars[p]
                        }
                        if (this._initted || immediate) {
                            if (resetDuration) {
                                this._initted = false;
                                if (immediate) {
                                    this.render(0, true, true)
                                }
                            } else {
                                if (this._gc) {
                                    this._enabled(true, false)
                                }
                                if (this._notifyPluginsOfEnabled && this._firstPT) {
                                    TweenLite._onPluginEvent("_onDisable", this)
                                }
                                if (this._time / this._duration > .998) {
                                    var prevTime = this._totalTime;
                                    this.render(0, true, false);
                                    this._initted = false;
                                    this.render(prevTime, true, false)
                                } else {
                                    this._initted = false;
                                    this._init();
                                    if (this._time > 0 || immediate) {
                                        var inv = 1 / (1 - curRatio),
                                            pt = this._firstPT,
                                            endValue;
                                        while (pt) {
                                            endValue = pt.s + pt.c;
                                            pt.c *= inv;
                                            pt.s = endValue - pt.c;
                                            pt = pt._next
                                        }
                                    }
                                }
                            }
                        }
                        return this
                    };
                    p.render = function(time, suppressEvents, force) {
                        if (!this._initted)
                            if (this._duration === 0 && this.vars.repeat) {
                                this.invalidate()
                            }
                        var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
                            prevTime = this._time,
                            prevTotalTime = this._totalTime,
                            prevCycle = this._cycle,
                            duration = this._duration,
                            prevRawPrevTime = this._rawPrevTime,
                            isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, yoyoEase;
                        if (time >= totalDur - 1e-7 && time >= 0) {
                            this._totalTime = totalDur;
                            this._cycle = this._repeat;
                            if (this._yoyo && (this._cycle & 1) !== 0) {
                                this._time = 0;
                                this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0
                            } else {
                                this._time = duration;
                                this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1
                            }
                            if (!this._reversed) {
                                isComplete = true;
                                callback = "onComplete";
                                force = force || this._timeline.autoRemoveChildren
                            }
                            if (duration === 0)
                                if (this._initted || !this.vars.lazy || force) {
                                    if (this._startTime === this._timeline._duration) {
                                        time = 0
                                    }
                                    if (prevRawPrevTime < 0 || time <= 0 && time >= -1e-7 || prevRawPrevTime === _tinyNum && this.data !== "isPause")
                                        if (prevRawPrevTime !== time) {
                                            force = true;
                                            if (prevRawPrevTime > _tinyNum) {
                                                callback = "onReverseComplete"
                                            }
                                        }
                                    this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
                                }
                        } else if (time < 1e-7) {
                            this._totalTime = this._time = this._cycle = 0;
                            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
                            if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
                                callback = "onReverseComplete";
                                isComplete = this._reversed
                            }
                            if (time < 0) {
                                this._active = false;
                                if (duration === 0)
                                    if (this._initted || !this.vars.lazy || force) {
                                        if (prevRawPrevTime >= 0) {
                                            force = true
                                        }
                                        this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
                                    }
                            }
                            if (!this._initted) {
                                force = true
                            }
                        } else {
                            this._totalTime = this._time = time;
                            if (this._repeat !== 0) {
                                cycleDuration = duration + this._repeatDelay;
                                this._cycle = this._totalTime / cycleDuration >> 0;
                                if (this._cycle !== 0)
                                    if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
                                        this._cycle--
                                    }
                                this._time = this._totalTime - this._cycle * cycleDuration;
                                if (this._yoyo)
                                    if ((this._cycle & 1) !== 0) {
                                        this._time = duration - this._time;
                                        yoyoEase = this._yoyoEase || this.vars.yoyoEase;
                                        if (yoyoEase) {
                                            if (!this._yoyoEase) {
                                                if (yoyoEase === true && !this._initted) {
                                                    yoyoEase = this.vars.ease;
                                                    this._yoyoEase = yoyoEase = !yoyoEase ? TweenLite.defaultEase : yoyoEase instanceof Ease ? yoyoEase : typeof yoyoEase === "function" ? new Ease(yoyoEase, this.vars.easeParams) : Ease.map[yoyoEase] || TweenLite.defaultEase
                                                } else {
                                                    this._yoyoEase = yoyoEase = yoyoEase === true ? this._ease : yoyoEase instanceof Ease ? yoyoEase : Ease.map[yoyoEase]
                                                }
                                            }
                                            this.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - this._time) / duration) : 0
                                        }
                                    }
                                if (this._time > duration) {
                                    this._time = duration
                                } else if (this._time < 0) {
                                    this._time = 0
                                }
                            }
                            if (this._easeType && !yoyoEase) {
                                r = this._time / duration;
                                type = this._easeType;
                                pow = this._easePower;
                                if (type === 1 || type === 3 && r >= .5) {
                                    r = 1 - r
                                }
                                if (type === 3) {
                                    r *= 2
                                }
                                if (pow === 1) {
                                    r *= r
                                } else if (pow === 2) {
                                    r *= r * r
                                } else if (pow === 3) {
                                    r *= r * r * r
                                } else if (pow === 4) {
                                    r *= r * r * r * r
                                }
                                if (type === 1) {
                                    this.ratio = 1 - r
                                } else if (type === 2) {
                                    this.ratio = r
                                } else if (this._time / duration < .5) {
                                    this.ratio = r / 2
                                } else {
                                    this.ratio = 1 - r / 2
                                }
                            } else if (!yoyoEase) {
                                this.ratio = this._ease.getRatio(this._time / duration)
                            }
                        }
                        if (prevTime === this._time && !force && prevCycle === this._cycle) {
                            if (prevTotalTime !== this._totalTime)
                                if (this._onUpdate)
                                    if (!suppressEvents) {
                                        this._callback("onUpdate")
                                    }
                            return
                        } else if (!this._initted) {
                            this._init();
                            if (!this._initted || this._gc) {
                                return
                            } else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
                                this._time = prevTime;
                                this._totalTime = prevTotalTime;
                                this._rawPrevTime = prevRawPrevTime;
                                this._cycle = prevCycle;
                                TweenLiteInternals.lazyTweens.push(this);
                                this._lazy = [time, suppressEvents];
                                return
                            }
                            if (this._time && !isComplete && !yoyoEase) {
                                this.ratio = this._ease.getRatio(this._time / duration)
                            } else if (isComplete && this._ease._calcEnd && !yoyoEase) {
                                this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)
                            }
                        }
                        if (this._lazy !== false) {
                            this._lazy = false
                        }
                        if (!this._active)
                            if (!this._paused && this._time !== prevTime && time >= 0) {
                                this._active = true
                            }
                        if (prevTotalTime === 0) {
                            if (this._initted === 2 && time > 0) {
                                this._init()
                            }
                            if (this._startAt) {
                                if (time >= 0) {
                                    this._startAt.render(time, true, force)
                                } else if (!callback) {
                                    callback = "_dummyGS"
                                }
                            }
                            if (this.vars.onStart)
                                if (this._totalTime !== 0 || duration === 0)
                                    if (!suppressEvents) {
                                        this._callback("onStart")
                                    }
                        }
                        pt = this._firstPT;
                        while (pt) {
                            if (pt.f) {
                                pt.t[pt.p](pt.c * this.ratio + pt.s)
                            } else {
                                pt.t[pt.p] = pt.c * this.ratio + pt.s
                            }
                            pt = pt._next
                        }
                        if (this._onUpdate) {
                            if (time < 0)
                                if (this._startAt && this._startTime) {
                                    this._startAt.render(time, true, force)
                                }
                            if (!suppressEvents)
                                if (this._totalTime !== prevTotalTime || callback) {
                                    this._callback("onUpdate")
                                }
                        }
                        if (this._cycle !== prevCycle)
                            if (!suppressEvents)
                                if (!this._gc)
                                    if (this.vars.onRepeat) {
                                        this._callback("onRepeat")
                                    }
                        if (callback)
                            if (!this._gc || force) {
                                if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
                                    this._startAt.render(time, true, force)
                                }
                                if (isComplete) {
                                    if (this._timeline.autoRemoveChildren) {
                                        this._enabled(false, false)
                                    }
                                    this._active = false
                                }
                                if (!suppressEvents && this.vars[callback]) {
                                    this._callback(callback)
                                }
                                if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
                                    this._rawPrevTime = 0
                                }
                            }
                    };
                    TweenMax.to = function(target, duration, vars) {
                        return new TweenMax(target, duration, vars)
                    };
                    TweenMax.from = function(target, duration, vars) {
                        vars.runBackwards = true;
                        vars.immediateRender = vars.immediateRender != false;
                        return new TweenMax(target, duration, vars)
                    };
                    TweenMax.fromTo = function(target, duration, fromVars, toVars) {
                        toVars.startAt = fromVars;
                        toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
                        return new TweenMax(target, duration, toVars)
                    };
                    TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                        stagger = stagger || 0;
                        var delay = 0,
                            a = [],
                            finalComplete = function() {
                                if (vars.onComplete) {
                                    vars.onComplete.apply(vars.onCompleteScope || this, arguments)
                                }
                                onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray)
                            },
                            cycle = vars.cycle,
                            fromCycle = vars.startAt && vars.startAt.cycle,
                            l, copy, i, p;
                        if (!_isArray(targets)) {
                            if (typeof targets === "string") {
                                targets = TweenLite.selector(targets) || targets
                            }
                            if (_isSelector(targets)) {
                                targets = _slice(targets)
                            }
                        }
                        targets = targets || [];
                        if (stagger < 0) {
                            targets = _slice(targets);
                            targets.reverse();
                            stagger *= -1
                        }
                        l = targets.length - 1;
                        for (i = 0; i <= l; i++) {
                            copy = {};
                            for (p in vars) {
                                copy[p] = vars[p]
                            }
                            if (cycle) {
                                _applyCycle(copy, targets, i);
                                if (copy.duration != null) {
                                    duration = copy.duration;
                                    delete copy.duration
                                }
                            }
                            if (fromCycle) {
                                fromCycle = copy.startAt = {};
                                for (p in vars.startAt) {
                                    fromCycle[p] = vars.startAt[p]
                                }
                                _applyCycle(copy.startAt, targets, i)
                            }
                            copy.delay = delay + (copy.delay || 0);
                            if (i === l && onCompleteAll) {
                                copy.onComplete = finalComplete
                            }
                            a[i] = new TweenMax(targets[i], duration, copy);
                            delay += stagger
                        }
                        return a
                    };
                    TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                        vars.runBackwards = true;
                        vars.immediateRender = vars.immediateRender != false;
                        return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                    };
                    TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                        toVars.startAt = fromVars;
                        toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
                        return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                    };
                    TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
                        return new TweenMax(callback, 0, {
                            delay: delay,
                            onComplete: callback,
                            onCompleteParams: params,
                            callbackScope: scope,
                            onReverseComplete: callback,
                            onReverseCompleteParams: params,
                            immediateRender: false,
                            useFrames: useFrames,
                            overwrite: 0
                        })
                    };
                    TweenMax.set = function(target, vars) {
                        return new TweenMax(target, 0, vars)
                    };
                    TweenMax.isTweening = function(target) {
                        return TweenLite.getTweensOf(target, true).length > 0
                    };
                    var _getChildrenOf = function(timeline, includeTimelines) {
                            var a = [],
                                cnt = 0,
                                tween = timeline._first;
                            while (tween) {
                                if (tween instanceof TweenLite) {
                                    a[cnt++] = tween
                                } else {
                                    if (includeTimelines) {
                                        a[cnt++] = tween
                                    }
                                    a = a.concat(_getChildrenOf(tween, includeTimelines));
                                    cnt = a.length
                                }
                                tween = tween._next
                            }
                            return a
                        },
                        getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
                            return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines))
                        };
                    TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
                        if (tweens == null) {
                            tweens = true
                        }
                        if (delayedCalls == null) {
                            delayedCalls = true
                        }
                        var a = getAllTweens(timelines != false),
                            l = a.length,
                            allTrue = tweens && delayedCalls && timelines,
                            isDC, tween, i;
                        for (i = 0; i < l; i++) {
                            tween = a[i];
                            if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
                                if (complete) {
                                    tween.totalTime(tween._reversed ? 0 : tween.totalDuration())
                                } else {
                                    tween._enabled(false, false)
                                }
                            }
                        }
                    };
                    TweenMax.killChildTweensOf = function(parent, complete) {
                        if (parent == null) {
                            return
                        }
                        var tl = TweenLiteInternals.tweenLookup,
                            a, curParent, p, i, l;
                        if (typeof parent === "string") {
                            parent = TweenLite.selector(parent) || parent
                        }
                        if (_isSelector(parent)) {
                            parent = _slice(parent)
                        }
                        if (_isArray(parent)) {
                            i = parent.length;
                            while (--i > -1) {
                                TweenMax.killChildTweensOf(parent[i], complete)
                            }
                            return
                        }
                        a = [];
                        for (p in tl) {
                            curParent = tl[p].target.parentNode;
                            while (curParent) {
                                if (curParent === parent) {
                                    a = a.concat(tl[p].tweens)
                                }
                                curParent = curParent.parentNode
                            }
                        }
                        l = a.length;
                        for (i = 0; i < l; i++) {
                            if (complete) {
                                a[i].totalTime(a[i].totalDuration())
                            }
                            a[i]._enabled(false, false)
                        }
                    };
                    var _changePause = function(pause, tweens, delayedCalls, timelines) {
                        tweens = tweens !== false;
                        delayedCalls = delayedCalls !== false;
                        timelines = timelines !== false;
                        var a = getAllTweens(timelines),
                            allTrue = tweens && delayedCalls && timelines,
                            i = a.length,
                            isDC, tween;
                        while (--i > -1) {
                            tween = a[i];
                            if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
                                tween.paused(pause)
                            }
                        }
                    };
                    TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
                        _changePause(true, tweens, delayedCalls, timelines)
                    };
                    TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
                        _changePause(false, tweens, delayedCalls, timelines)
                    };
                    TweenMax.globalTimeScale = function(value) {
                        var tl = Animation._rootTimeline,
                            t = TweenLite.ticker.time;
                        if (!arguments.length) {
                            return tl._timeScale
                        }
                        value = value || _tinyNum;
                        tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
                        tl = Animation._rootFramesTimeline;
                        t = TweenLite.ticker.frame;
                        tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
                        tl._timeScale = Animation._rootTimeline._timeScale = value;
                        return value
                    };
                    p.progress = function(value, suppressEvents) {
                        return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents)
                    };
                    p.totalProgress = function(value, suppressEvents) {
                        return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents)
                    };
                    p.time = function(value, suppressEvents) {
                        if (!arguments.length) {
                            return this._time
                        }
                        if (this._dirty) {
                            this.totalDuration()
                        }
                        if (value > this._duration) {
                            value = this._duration
                        }
                        if (this._yoyo && (this._cycle & 1) !== 0) {
                            value = this._duration - value + this._cycle * (this._duration + this._repeatDelay)
                        } else if (this._repeat !== 0) {
                            value += this._cycle * (this._duration + this._repeatDelay)
                        }
                        return this.totalTime(value, suppressEvents)
                    };
                    p.duration = function(value) {
                        if (!arguments.length) {
                            return this._duration
                        }
                        return Animation.prototype.duration.call(this, value)
                    };
                    p.totalDuration = function(value) {
                        if (!arguments.length) {
                            if (this._dirty) {
                                this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
                                this._dirty = false
                            }
                            return this._totalDuration
                        }
                        return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1))
                    };
                    p.repeat = function(value) {
                        if (!arguments.length) {
                            return this._repeat
                        }
                        this._repeat = value;
                        return this._uncache(true)
                    };
                    p.repeatDelay = function(value) {
                        if (!arguments.length) {
                            return this._repeatDelay
                        }
                        this._repeatDelay = value;
                        return this._uncache(true)
                    };
                    p.yoyo = function(value) {
                        if (!arguments.length) {
                            return this._yoyo
                        }
                        this._yoyo = value;
                        return this
                    };
                    return TweenMax
                }, true);
                _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
                    var TimelineLite = function(vars) {
                            SimpleTimeline.call(this, vars);
                            this._labels = {};
                            this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
                            this.smoothChildTiming = this.vars.smoothChildTiming === true;
                            this._sortChildren = true;
                            this._onUpdate = this.vars.onUpdate;
                            var v = this.vars,
                                val, p;
                            for (p in v) {
                                val = v[p];
                                if (_isArray(val))
                                    if (val.join("").indexOf("{self}") !== -1) {
                                        v[p] = this._swapSelfInParams(val)
                                    }
                            }
                            if (_isArray(v.tweens)) {
                                this.add(v.tweens, 0, v.align, v.stagger)
                            }
                        },
                        _tinyNum = 1e-10,
                        TweenLiteInternals = TweenLite._internals,
                        _internals = TimelineLite._internals = {},
                        _isSelector = TweenLiteInternals.isSelector,
                        _isArray = TweenLiteInternals.isArray,
                        _lazyTweens = TweenLiteInternals.lazyTweens,
                        _lazyRender = TweenLiteInternals.lazyRender,
                        _globals = _gsScope._gsDefine.globals,
                        _copy = function(vars) {
                            var copy = {},
                                p;
                            for (p in vars) {
                                copy[p] = vars[p]
                            }
                            return copy
                        },
                        _applyCycle = function(vars, targets, i) {
                            var alt = vars.cycle,
                                p, val;
                            for (p in alt) {
                                val = alt[p];
                                vars[p] = typeof val === "function" ? val(i, targets[i]) : val[i % val.length]
                            }
                            delete vars.cycle
                        },
                        _pauseCallback = _internals.pauseCallback = function() {},
                        _slice = function(a) {
                            var b = [],
                                l = a.length,
                                i;
                            for (i = 0; i !== l; b.push(a[i++]));
                            return b
                        },
                        p = TimelineLite.prototype = new SimpleTimeline;
                    TimelineLite.version = "1.20.4";
                    p.constructor = TimelineLite;
                    p.kill()._gc = p._forcingPlayhead = p._hasPause = false;
                    p.to = function(target, duration, vars, position) {
                        var Engine = vars.repeat && _globals.TweenMax || TweenLite;
                        return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position)
                    };
                    p.from = function(target, duration, vars, position) {
                        return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position)
                    };
                    p.fromTo = function(target, duration, fromVars, toVars, position) {
                        var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
                        return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position)
                    };
                    p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                        var tl = new TimelineLite({
                                onComplete: onCompleteAll,
                                onCompleteParams: onCompleteAllParams,
                                callbackScope: onCompleteAllScope,
                                smoothChildTiming: this.smoothChildTiming
                            }),
                            cycle = vars.cycle,
                            copy, i;
                        if (typeof targets === "string") {
                            targets = TweenLite.selector(targets) || targets
                        }
                        targets = targets || [];
                        if (_isSelector(targets)) {
                            targets = _slice(targets)
                        }
                        stagger = stagger || 0;
                        if (stagger < 0) {
                            targets = _slice(targets);
                            targets.reverse();
                            stagger *= -1
                        }
                        for (i = 0; i < targets.length; i++) {
                            copy = _copy(vars);
                            if (copy.startAt) {
                                copy.startAt = _copy(copy.startAt);
                                if (copy.startAt.cycle) {
                                    _applyCycle(copy.startAt, targets, i)
                                }
                            }
                            if (cycle) {
                                _applyCycle(copy, targets, i);
                                if (copy.duration != null) {
                                    duration = copy.duration;
                                    delete copy.duration
                                }
                            }
                            tl.to(targets[i], duration, copy, i * stagger)
                        }
                        return this.add(tl, position)
                    };
                    p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                        vars.immediateRender = vars.immediateRender != false;
                        vars.runBackwards = true;
                        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                    };
                    p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
                        toVars.startAt = fromVars;
                        toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
                        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
                    };
                    p.call = function(callback, params, scope, position) {
                        return this.add(TweenLite.delayedCall(0, callback, params, scope), position)
                    };
                    p.set = function(target, vars, position) {
                        position = this._parseTimeOrLabel(position, 0, true);
                        if (vars.immediateRender == null) {
                            vars.immediateRender = position === this._time && !this._paused
                        }
                        return this.add(new TweenLite(target, 0, vars), position)
                    };
                    TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
                        vars = vars || {};
                        if (vars.smoothChildTiming == null) {
                            vars.smoothChildTiming = true
                        }
                        var tl = new TimelineLite(vars),
                            root = tl._timeline,
                            hasNegativeStart, time, tween, next;
                        if (ignoreDelayedCalls == null) {
                            ignoreDelayedCalls = true
                        }
                        root._remove(tl, true);
                        tl._startTime = 0;
                        tl._rawPrevTime = tl._time = tl._totalTime = root._time;
                        tween = root._first;
                        while (tween) {
                            next = tween._next;
                            if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
                                time = tween._startTime - tween._delay;
                                if (time < 0) {
                                    hasNegativeStart = 1
                                }
                                tl.add(tween, time)
                            }
                            tween = next
                        }
                        root.add(tl, 0);
                        if (hasNegativeStart) {
                            tl.totalDuration()
                        }
                        return tl
                    };
                    p.add = function(value, position, align, stagger) {
                        var curTime, l, i, child, tl, beforeRawTime;
                        if (typeof position !== "number") {
                            position = this._parseTimeOrLabel(position, 0, true, value)
                        }
                        if (!(value instanceof Animation)) {
                            if (value instanceof Array || value && value.push && _isArray(value)) {
                                align = align || "normal";
                                stagger = stagger || 0;
                                curTime = position;
                                l = value.length;
                                for (i = 0; i < l; i++) {
                                    if (_isArray(child = value[i])) {
                                        child = new TimelineLite({
                                            tweens: child
                                        })
                                    }
                                    this.add(child, curTime);
                                    if (typeof child !== "string" && typeof child !== "function") {
                                        if (align === "sequence") {
                                            curTime = child._startTime + child.totalDuration() / child._timeScale
                                        } else if (align === "start") {
                                            child._startTime -= child.delay()
                                        }
                                    }
                                    curTime += stagger
                                }
                                return this._uncache(true)
                            } else if (typeof value === "string") {
                                return this.addLabel(value, position)
                            } else if (typeof value === "function") {
                                value = TweenLite.delayedCall(0, value)
                            } else {
                                throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string."
                            }
                        }
                        SimpleTimeline.prototype.add.call(this, value, position);
                        if (value._time) {
                            value.render((this.rawTime() - value._startTime) * value._timeScale, false, false)
                        }
                        if (this._gc || this._time === this._duration)
                            if (!this._paused)
                                if (this._duration < this.duration()) {
                                    tl = this;
                                    beforeRawTime = tl.rawTime() > value._startTime;
                                    while (tl._timeline) {
                                        if (beforeRawTime && tl._timeline.smoothChildTiming) {
                                            tl.totalTime(tl._totalTime, true)
                                        } else if (tl._gc) {
                                            tl._enabled(true, false)
                                        }
                                        tl = tl._timeline
                                    }
                                }
                        return this
                    };
                    p.remove = function(value) {
                        if (value instanceof Animation) {
                            this._remove(value, false);
                            var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline;
                            value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale;
                            return this
                        } else if (value instanceof Array || value && value.push && _isArray(value)) {
                            var i = value.length;
                            while (--i > -1) {
                                this.remove(value[i])
                            }
                            return this
                        } else if (typeof value === "string") {
                            return this.removeLabel(value)
                        }
                        return this.kill(null, value)
                    };
                    p._remove = function(tween, skipDisable) {
                        SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
                        var last = this._last;
                        if (!last) {
                            this._time = this._totalTime = this._duration = this._totalDuration = 0
                        } else if (this._time > this.duration()) {
                            this._time = this._duration;
                            this._totalTime = this._totalDuration
                        }
                        return this
                    };
                    p.append = function(value, offsetOrLabel) {
                        return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value))
                    };
                    p.insert = p.insertMultiple = function(value, position, align, stagger) {
                        return this.add(value, position || 0, align, stagger)
                    };
                    p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
                        return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger)
                    };
                    p.addLabel = function(label, position) {
                        this._labels[label] = this._parseTimeOrLabel(position);
                        return this
                    };
                    p.addPause = function(position, callback, params, scope) {
                        var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
                        t.vars.onComplete = t.vars.onReverseComplete = callback;
                        t.data = "isPause";
                        this._hasPause = true;
                        return this.add(t, position)
                    };
                    p.removeLabel = function(label) {
                        delete this._labels[label];
                        return this
                    };
                    p.getLabelTime = function(label) {
                        return this._labels[label] != null ? this._labels[label] : -1
                    };
                    p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
                        var clippedDuration, i;
                        if (ignore instanceof Animation && ignore.timeline === this) {
                            this.remove(ignore)
                        } else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
                            i = ignore.length;
                            while (--i > -1) {
                                if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
                                    this.remove(ignore[i])
                                }
                            }
                        }
                        clippedDuration = typeof timeOrLabel === "number" && !offsetOrLabel ? 0 : this.duration() > 99999999999 ? this.recent().endTime(false) : this._duration;
                        if (typeof offsetOrLabel === "string") {
                            return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - clippedDuration : 0, appendIfAbsent)
                        }
                        offsetOrLabel = offsetOrLabel || 0;
                        if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
                            i = timeOrLabel.indexOf("=");
                            if (i === -1) {
                                if (this._labels[timeOrLabel] == null) {
                                    return appendIfAbsent ? this._labels[timeOrLabel] = clippedDuration + offsetOrLabel : offsetOrLabel
                                }
                                return this._labels[timeOrLabel] + offsetOrLabel
                            }
                            offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
                            timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : clippedDuration
                        } else if (timeOrLabel == null) {
                            timeOrLabel = clippedDuration
                        }
                        return Number(timeOrLabel) + offsetOrLabel
                    };
                    p.seek = function(position, suppressEvents) {
                        return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false)
                    };
                    p.stop = function() {
                        return this.paused(true)
                    };
                    p.gotoAndPlay = function(position, suppressEvents) {
                        return this.play(position, suppressEvents)
                    };
                    p.gotoAndStop = function(position, suppressEvents) {
                        return this.pause(position, suppressEvents)
                    };
                    p.render = function(time, suppressEvents, force) {
                        if (this._gc) {
                            this._enabled(true, false)
                        }
                        var prevTime = this._time,
                            totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
                            prevStart = this._startTime,
                            prevTimeScale = this._timeScale,
                            prevPaused = this._paused,
                            tween, isComplete, next, callback, internalForce, pauseTween, curTime;
                        if (prevTime !== this._time) {
                            time += this._time - prevTime
                        }
                        if (time >= totalDur - 1e-7 && time >= 0) {
                            this._totalTime = this._time = totalDur;
                            if (!this._reversed)
                                if (!this._hasPausedChild()) {
                                    isComplete = true;
                                    callback = "onComplete";
                                    internalForce = !!this._timeline.autoRemoveChildren;
                                    if (this._duration === 0)
                                        if (time <= 0 && time >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum)
                                            if (this._rawPrevTime !== time && this._first) {
                                                internalForce = true;
                                                if (this._rawPrevTime > _tinyNum) {
                                                    callback = "onReverseComplete"
                                                }
                                            }
                                }
                            this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
                            time = totalDur + 1e-4
                        } else if (time < 1e-7) {
                            this._totalTime = this._time = 0;
                            if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
                                callback = "onReverseComplete";
                                isComplete = this._reversed
                            }
                            if (time < 0) {
                                this._active = false;
                                if (this._timeline.autoRemoveChildren && this._reversed) {
                                    internalForce = isComplete = true;
                                    callback = "onReverseComplete"
                                } else if (this._rawPrevTime >= 0 && this._first) {
                                    internalForce = true
                                }
                                this._rawPrevTime = time
                            } else {
                                this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
                                if (time === 0 && isComplete) {
                                    tween = this._first;
                                    while (tween && tween._startTime === 0) {
                                        if (!tween._duration) {
                                            isComplete = false
                                        }
                                        tween = tween._next
                                    }
                                }
                                time = 0;
                                if (!this._initted) {
                                    internalForce = true
                                }
                            }
                        } else {
                            if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
                                if (time >= prevTime) {
                                    tween = this._first;
                                    while (tween && tween._startTime <= time && !pauseTween) {
                                        if (!tween._duration)
                                            if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                                                pauseTween = tween
                                            }
                                        tween = tween._next
                                    }
                                } else {
                                    tween = this._last;
                                    while (tween && tween._startTime >= time && !pauseTween) {
                                        if (!tween._duration)
                                            if (tween.data === "isPause" && tween._rawPrevTime > 0) {
                                                pauseTween = tween
                                            }
                                        tween = tween._prev
                                    }
                                }
                                if (pauseTween) {
                                    this._time = time = pauseTween._startTime;
                                    this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay)
                                }
                            }
                            this._totalTime = this._time = this._rawPrevTime = time
                        }
                        if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
                            return
                        } else if (!this._initted) {
                            this._initted = true
                        }
                        if (!this._active)
                            if (!this._paused && this._time !== prevTime && time > 0) {
                                this._active = true
                            }
                        if (prevTime === 0)
                            if (this.vars.onStart)
                                if (this._time !== 0 || !this._duration)
                                    if (!suppressEvents) {
                                        this._callback("onStart")
                                    }
                        curTime = this._time;
                        if (curTime >= prevTime) {
                            tween = this._first;
                            while (tween) {
                                next = tween._next;
                                if (curTime !== this._time || this._paused && !prevPaused) {
                                    break
                                } else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
                                    if (pauseTween === tween) {
                                        this.pause()
                                    }
                                    if (!tween._reversed) {
                                        tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    } else {
                                        tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    }
                                }
                                tween = next
                            }
                        } else {
                            tween = this._last;
                            while (tween) {
                                next = tween._prev;
                                if (curTime !== this._time || this._paused && !prevPaused) {
                                    break
                                } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
                                    if (pauseTween === tween) {
                                        pauseTween = tween._prev;
                                        while (pauseTween && pauseTween.endTime() > this._time) {
                                            pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
                                            pauseTween = pauseTween._prev
                                        }
                                        pauseTween = null;
                                        this.pause()
                                    }
                                    if (!tween._reversed) {
                                        tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    } else {
                                        tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    }
                                }
                                tween = next
                            }
                        }
                        if (this._onUpdate)
                            if (!suppressEvents) {
                                if (_lazyTweens.length) {
                                    _lazyRender()
                                }
                                this._callback("onUpdate")
                            }
                        if (callback)
                            if (!this._gc)
                                if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
                                    if (this._time === 0 || totalDur >= this.totalDuration()) {
                                        if (isComplete) {
                                            if (_lazyTweens.length) {
                                                _lazyRender()
                                            }
                                            if (this._timeline.autoRemoveChildren) {
                                                this._enabled(false, false)
                                            }
                                            this._active = false
                                        }
                                        if (!suppressEvents && this.vars[callback]) {
                                            this._callback(callback)
                                        }
                                    }
                    };
                    p._hasPausedChild = function() {
                        var tween = this._first;
                        while (tween) {
                            if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
                                return true
                            }
                            tween = tween._next
                        }
                        return false
                    };
                    p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
                        ignoreBeforeTime = ignoreBeforeTime || -9999999999;
                        var a = [],
                            tween = this._first,
                            cnt = 0;
                        while (tween) {
                            if (tween._startTime < ignoreBeforeTime) {} else if (tween instanceof TweenLite) {
                                if (tweens !== false) {
                                    a[cnt++] = tween
                                }
                            } else {
                                if (timelines !== false) {
                                    a[cnt++] = tween
                                }
                                if (nested !== false) {
                                    a = a.concat(tween.getChildren(true, tweens, timelines));
                                    cnt = a.length
                                }
                            }
                            tween = tween._next
                        }
                        return a
                    };
                    p.getTweensOf = function(target, nested) {
                        var disabled = this._gc,
                            a = [],
                            cnt = 0,
                            tweens, i;
                        if (disabled) {
                            this._enabled(true, true)
                        }
                        tweens = TweenLite.getTweensOf(target);
                        i = tweens.length;
                        while (--i > -1) {
                            if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
                                a[cnt++] = tweens[i]
                            }
                        }
                        if (disabled) {
                            this._enabled(false, true)
                        }
                        return a
                    };
                    p.recent = function() {
                        return this._recent
                    };
                    p._contains = function(tween) {
                        var tl = tween.timeline;
                        while (tl) {
                            if (tl === this) {
                                return true
                            }
                            tl = tl.timeline
                        }
                        return false
                    };
                    p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
                        ignoreBeforeTime = ignoreBeforeTime || 0;
                        var tween = this._first,
                            labels = this._labels,
                            p;
                        while (tween) {
                            if (tween._startTime >= ignoreBeforeTime) {
                                tween._startTime += amount
                            }
                            tween = tween._next
                        }
                        if (adjustLabels) {
                            for (p in labels) {
                                if (labels[p] >= ignoreBeforeTime) {
                                    labels[p] += amount
                                }
                            }
                        }
                        return this._uncache(true)
                    };
                    p._kill = function(vars, target) {
                        if (!vars && !target) {
                            return this._enabled(false, false)
                        }
                        var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
                            i = tweens.length,
                            changed = false;
                        while (--i > -1) {
                            if (tweens[i]._kill(vars, target)) {
                                changed = true
                            }
                        }
                        return changed
                    };
                    p.clear = function(labels) {
                        var tweens = this.getChildren(false, true, true),
                            i = tweens.length;
                        this._time = this._totalTime = 0;
                        while (--i > -1) {
                            tweens[i]._enabled(false, false)
                        }
                        if (labels !== false) {
                            this._labels = {}
                        }
                        return this._uncache(true)
                    };
                    p.invalidate = function() {
                        var tween = this._first;
                        while (tween) {
                            tween.invalidate();
                            tween = tween._next
                        }
                        return Animation.prototype.invalidate.call(this)
                    };
                    p._enabled = function(enabled, ignoreTimeline) {
                        if (enabled === this._gc) {
                            var tween = this._first;
                            while (tween) {
                                tween._enabled(enabled, true);
                                tween = tween._next
                            }
                        }
                        return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline)
                    };
                    p.totalTime = function(time, suppressEvents, uncapped) {
                        this._forcingPlayhead = true;
                        var val = Animation.prototype.totalTime.apply(this, arguments);
                        this._forcingPlayhead = false;
                        return val
                    };
                    p.duration = function(value) {
                        if (!arguments.length) {
                            if (this._dirty) {
                                this.totalDuration()
                            }
                            return this._duration
                        }
                        if (this.duration() !== 0 && value !== 0) {
                            this.timeScale(this._duration / value)
                        }
                        return this
                    };
                    p.totalDuration = function(value) {
                        if (!arguments.length) {
                            if (this._dirty) {
                                var max = 0,
                                    tween = this._last,
                                    prevStart = 999999999999,
                                    prev, end;
                                while (tween) {
                                    prev = tween._prev;
                                    if (tween._dirty) {
                                        tween.totalDuration()
                                    }
                                    if (tween._startTime > prevStart && this._sortChildren && !tween._paused && !this._calculatingDuration) {
                                        this._calculatingDuration = 1;
                                        this.add(tween, tween._startTime - tween._delay);
                                        this._calculatingDuration = 0
                                    } else {
                                        prevStart = tween._startTime
                                    }
                                    if (tween._startTime < 0 && !tween._paused) {
                                        max -= tween._startTime;
                                        if (this._timeline.smoothChildTiming) {
                                            this._startTime += tween._startTime / this._timeScale;
                                            this._time -= tween._startTime;
                                            this._totalTime -= tween._startTime;
                                            this._rawPrevTime -= tween._startTime
                                        }
                                        this.shiftChildren(-tween._startTime, false, -9999999999);
                                        prevStart = 0
                                    }
                                    end = tween._startTime + tween._totalDuration / tween._timeScale;
                                    if (end > max) {
                                        max = end
                                    }
                                    tween = prev
                                }
                                this._duration = this._totalDuration = max;
                                this._dirty = false
                            }
                            return this._totalDuration
                        }
                        return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this
                    };
                    p.paused = function(value) {
                        if (!value) {
                            var tween = this._first,
                                time = this._time;
                            while (tween) {
                                if (tween._startTime === time && tween.data === "isPause") {
                                    tween._rawPrevTime = 0
                                }
                                tween = tween._next
                            }
                        }
                        return Animation.prototype.paused.apply(this, arguments)
                    };
                    p.usesFrames = function() {
                        var tl = this._timeline;
                        while (tl._timeline) {
                            tl = tl._timeline
                        }
                        return tl === Animation._rootFramesTimeline
                    };
                    p.rawTime = function(wrapRepeats) {
                        return wrapRepeats && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale
                    };
                    return TimelineLite
                }, true);
                _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(TimelineLite, TweenLite, Ease) {
                    var TimelineMax = function(vars) {
                            TimelineLite.call(this, vars);
                            this._repeat = this.vars.repeat || 0;
                            this._repeatDelay = this.vars.repeatDelay || 0;
                            this._cycle = 0;
                            this._yoyo = this.vars.yoyo === true;
                            this._dirty = true
                        },
                        _tinyNum = 1e-10,
                        TweenLiteInternals = TweenLite._internals,
                        _lazyTweens = TweenLiteInternals.lazyTweens,
                        _lazyRender = TweenLiteInternals.lazyRender,
                        _globals = _gsScope._gsDefine.globals,
                        _easeNone = new Ease(null, null, 1, 0),
                        p = TimelineMax.prototype = new TimelineLite;
                    p.constructor = TimelineMax;
                    p.kill()._gc = false;
                    TimelineMax.version = "1.20.4";
                    p.invalidate = function() {
                        this._yoyo = this.vars.yoyo === true;
                        this._repeat = this.vars.repeat || 0;
                        this._repeatDelay = this.vars.repeatDelay || 0;
                        this._uncache(true);
                        return TimelineLite.prototype.invalidate.call(this)
                    };
                    p.addCallback = function(callback, position, params, scope) {
                        return this.add(TweenLite.delayedCall(0, callback, params, scope), position)
                    };
                    p.removeCallback = function(callback, position) {
                        if (callback) {
                            if (position == null) {
                                this._kill(null, callback)
                            } else {
                                var a = this.getTweensOf(callback, false),
                                    i = a.length,
                                    time = this._parseTimeOrLabel(position);
                                while (--i > -1) {
                                    if (a[i]._startTime === time) {
                                        a[i]._enabled(false, false)
                                    }
                                }
                            }
                        }
                        return this
                    };
                    p.removePause = function(position) {
                        return this.removeCallback(TimelineLite._internals.pauseCallback, position)
                    };
                    p.tweenTo = function(position, vars) {
                        vars = vars || {};
                        var copy = {
                                ease: _easeNone,
                                useFrames: this.usesFrames(),
                                immediateRender: false,
                                lazy: false
                            },
                            Engine = vars.repeat && _globals.TweenMax || TweenLite,
                            duration, p, t;
                        for (p in vars) {
                            copy[p] = vars[p]
                        }
                        copy.time = this._parseTimeOrLabel(position);
                        duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || .001;
                        t = new Engine(this, duration, copy);
                        copy.onStart = function() {
                            t.target.paused(true);
                            if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) {
                                t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale).render(t.time(), true, true)
                            }
                            if (vars.onStart) {
                                vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || [])
                            }
                        };
                        return t
                    };
                    p.tweenFromTo = function(fromPosition, toPosition, vars) {
                        vars = vars || {};
                        fromPosition = this._parseTimeOrLabel(fromPosition);
                        vars.startAt = {
                            onComplete: this.seek,
                            onCompleteParams: [fromPosition],
                            callbackScope: this
                        };
                        vars.immediateRender = vars.immediateRender !== false;
                        var t = this.tweenTo(toPosition, vars);
                        t.isFromTo = 1;
                        return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || .001)
                    };
                    p.render = function(time, suppressEvents, force) {
                        if (this._gc) {
                            this._enabled(true, false)
                        }
                        var prevTime = this._time,
                            totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
                            dur = this._duration,
                            prevTotalTime = this._totalTime,
                            prevStart = this._startTime,
                            prevTimeScale = this._timeScale,
                            prevRawPrevTime = this._rawPrevTime,
                            prevPaused = this._paused,
                            prevCycle = this._cycle,
                            tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
                        if (prevTime !== this._time) {
                            time += this._time - prevTime
                        }
                        if (time >= totalDur - 1e-7 && time >= 0) {
                            if (!this._locked) {
                                this._totalTime = totalDur;
                                this._cycle = this._repeat
                            }
                            if (!this._reversed)
                                if (!this._hasPausedChild()) {
                                    isComplete = true;
                                    callback = "onComplete";
                                    internalForce = !!this._timeline.autoRemoveChildren;
                                    if (this._duration === 0)
                                        if (time <= 0 && time >= -1e-7 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)
                                            if (prevRawPrevTime !== time && this._first) {
                                                internalForce = true;
                                                if (prevRawPrevTime > _tinyNum) {
                                                    callback = "onReverseComplete"
                                                }
                                            }
                                }
                            this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
                            if (this._yoyo && (this._cycle & 1) !== 0) {
                                this._time = time = 0
                            } else {
                                this._time = dur;
                                time = dur + 1e-4
                            }
                        } else if (time < 1e-7) {
                            if (!this._locked) {
                                this._totalTime = this._cycle = 0
                            }
                            this._time = 0;
                            if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
                                callback = "onReverseComplete";
                                isComplete = this._reversed
                            }
                            if (time < 0) {
                                this._active = false;
                                if (this._timeline.autoRemoveChildren && this._reversed) {
                                    internalForce = isComplete = true;
                                    callback = "onReverseComplete"
                                } else if (prevRawPrevTime >= 0 && this._first) {
                                    internalForce = true
                                }
                                this._rawPrevTime = time
                            } else {
                                this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
                                if (time === 0 && isComplete) {
                                    tween = this._first;
                                    while (tween && tween._startTime === 0) {
                                        if (!tween._duration) {
                                            isComplete = false
                                        }
                                        tween = tween._next
                                    }
                                }
                                time = 0;
                                if (!this._initted) {
                                    internalForce = true
                                }
                            }
                        } else {
                            if (dur === 0 && prevRawPrevTime < 0) {
                                internalForce = true
                            }
                            this._time = this._rawPrevTime = time;
                            if (!this._locked) {
                                this._totalTime = time;
                                if (this._repeat !== 0) {
                                    cycleDuration = dur + this._repeatDelay;
                                    this._cycle = this._totalTime / cycleDuration >> 0;
                                    if (this._cycle !== 0)
                                        if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
                                            this._cycle--
                                        }
                                    this._time = this._totalTime - this._cycle * cycleDuration;
                                    if (this._yoyo)
                                        if ((this._cycle & 1) !== 0) {
                                            this._time = dur - this._time
                                        }
                                    if (this._time > dur) {
                                        this._time = dur;
                                        time = dur + 1e-4
                                    } else if (this._time < 0) {
                                        this._time = time = 0
                                    } else {
                                        time = this._time
                                    }
                                }
                            }
                            if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
                                time = this._time;
                                if (time >= prevTime || this._repeat && prevCycle !== this._cycle) {
                                    tween = this._first;
                                    while (tween && tween._startTime <= time && !pauseTween) {
                                        if (!tween._duration)
                                            if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                                                pauseTween = tween
                                            }
                                        tween = tween._next
                                    }
                                } else {
                                    tween = this._last;
                                    while (tween && tween._startTime >= time && !pauseTween) {
                                        if (!tween._duration)
                                            if (tween.data === "isPause" && tween._rawPrevTime > 0) {
                                                pauseTween = tween
                                            }
                                        tween = tween._prev
                                    }
                                }
                                if (pauseTween && pauseTween._startTime < dur) {
                                    this._time = time = pauseTween._startTime;
                                    this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay)
                                }
                            }
                        }
                        if (this._cycle !== prevCycle)
                            if (!this._locked) {
                                var backwards = this._yoyo && (prevCycle & 1) !== 0,
                                    wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
                                    recTotalTime = this._totalTime,
                                    recCycle = this._cycle,
                                    recRawPrevTime = this._rawPrevTime,
                                    recTime = this._time;
                                this._totalTime = prevCycle * dur;
                                if (this._cycle < prevCycle) {
                                    backwards = !backwards
                                } else {
                                    this._totalTime += dur
                                }
                                this._time = prevTime;
                                this._rawPrevTime = dur === 0 ? prevRawPrevTime - 1e-4 : prevRawPrevTime;
                                this._cycle = prevCycle;
                                this._locked = true;
                                prevTime = backwards ? 0 : dur;
                                this.render(prevTime, suppressEvents, dur === 0);
                                if (!suppressEvents)
                                    if (!this._gc) {
                                        if (this.vars.onRepeat) {
                                            this._cycle = recCycle;
                                            this._locked = false;
                                            this._callback("onRepeat")
                                        }
                                    }
                                if (prevTime !== this._time) {
                                    return
                                }
                                if (wrap) {
                                    this._cycle = prevCycle;
                                    this._locked = true;
                                    prevTime = backwards ? dur + 1e-4 : -1e-4;
                                    this.render(prevTime, true, false)
                                }
                                this._locked = false;
                                if (this._paused && !prevPaused) {
                                    return
                                }
                                this._time = recTime;
                                this._totalTime = recTotalTime;
                                this._cycle = recCycle;
                                this._rawPrevTime = recRawPrevTime
                            }
                        if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
                            if (prevTotalTime !== this._totalTime)
                                if (this._onUpdate)
                                    if (!suppressEvents) {
                                        this._callback("onUpdate")
                                    }
                            return
                        } else if (!this._initted) {
                            this._initted = true
                        }
                        if (!this._active)
                            if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
                                this._active = true
                            }
                        if (prevTotalTime === 0)
                            if (this.vars.onStart)
                                if (this._totalTime !== 0 || !this._totalDuration)
                                    if (!suppressEvents) {
                                        this._callback("onStart")
                                    }
                        curTime = this._time;
                        if (curTime >= prevTime) {
                            tween = this._first;
                            while (tween) {
                                next = tween._next;
                                if (curTime !== this._time || this._paused && !prevPaused) {
                                    break
                                } else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
                                    if (pauseTween === tween) {
                                        this.pause()
                                    }
                                    if (!tween._reversed) {
                                        tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    } else {
                                        tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    }
                                }
                                tween = next
                            }
                        } else {
                            tween = this._last;
                            while (tween) {
                                next = tween._prev;
                                if (curTime !== this._time || this._paused && !prevPaused) {
                                    break
                                } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
                                    if (pauseTween === tween) {
                                        pauseTween = tween._prev;
                                        while (pauseTween && pauseTween.endTime() > this._time) {
                                            pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
                                            pauseTween = pauseTween._prev
                                        }
                                        pauseTween = null;
                                        this.pause()
                                    }
                                    if (!tween._reversed) {
                                        tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    } else {
                                        tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                                    }
                                }
                                tween = next
                            }
                        }
                        if (this._onUpdate)
                            if (!suppressEvents) {
                                if (_lazyTweens.length) {
                                    _lazyRender()
                                }
                                this._callback("onUpdate")
                            }
                        if (callback)
                            if (!this._locked)
                                if (!this._gc)
                                    if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
                                        if (this._time === 0 || totalDur >= this.totalDuration()) {
                                            if (isComplete) {
                                                if (_lazyTweens.length) {
                                                    _lazyRender()
                                                }
                                                if (this._timeline.autoRemoveChildren) {
                                                    this._enabled(false, false)
                                                }
                                                this._active = false
                                            }
                                            if (!suppressEvents && this.vars[callback]) {
                                                this._callback(callback)
                                            }
                                        }
                    };
                    p.getActive = function(nested, tweens, timelines) {
                        if (nested == null) {
                            nested = true
                        }
                        if (tweens == null) {
                            tweens = true
                        }
                        if (timelines == null) {
                            timelines = false
                        }
                        var a = [],
                            all = this.getChildren(nested, tweens, timelines),
                            cnt = 0,
                            l = all.length,
                            i, tween;
                        for (i = 0; i < l; i++) {
                            tween = all[i];
                            if (tween.isActive()) {
                                a[cnt++] = tween
                            }
                        }
                        return a
                    };
                    p.getLabelAfter = function(time) {
                        if (!time)
                            if (time !== 0) {
                                time = this._time
                            }
                        var labels = this.getLabelsArray(),
                            l = labels.length,
                            i;
                        for (i = 0; i < l; i++) {
                            if (labels[i].time > time) {
                                return labels[i].name
                            }
                        }
                        return null
                    };
                    p.getLabelBefore = function(time) {
                        if (time == null) {
                            time = this._time
                        }
                        var labels = this.getLabelsArray(),
                            i = labels.length;
                        while (--i > -1) {
                            if (labels[i].time < time) {
                                return labels[i].name
                            }
                        }
                        return null
                    };
                    p.getLabelsArray = function() {
                        var a = [],
                            cnt = 0,
                            p;
                        for (p in this._labels) {
                            a[cnt++] = {
                                time: this._labels[p],
                                name: p
                            }
                        }
                        a.sort(function(a, b) {
                            return a.time - b.time
                        });
                        return a
                    };
                    p.invalidate = function() {
                        this._locked = false;
                        return TimelineLite.prototype.invalidate.call(this)
                    };
                    p.progress = function(value, suppressEvents) {
                        return !arguments.length ? this._time / this.duration() || 0 : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents)
                    };
                    p.totalProgress = function(value, suppressEvents) {
                        return !arguments.length ? this._totalTime / this.totalDuration() || 0 : this.totalTime(this.totalDuration() * value, suppressEvents)
                    };
                    p.totalDuration = function(value) {
                        if (!arguments.length) {
                            if (this._dirty) {
                                TimelineLite.prototype.totalDuration.call(this);
                                this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat
                            }
                            return this._totalDuration
                        }
                        return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value)
                    };
                    p.time = function(value, suppressEvents) {
                        if (!arguments.length) {
                            return this._time
                        }
                        if (this._dirty) {
                            this.totalDuration()
                        }
                        if (value > this._duration) {
                            value = this._duration
                        }
                        if (this._yoyo && (this._cycle & 1) !== 0) {
                            value = this._duration - value + this._cycle * (this._duration + this._repeatDelay)
                        } else if (this._repeat !== 0) {
                            value += this._cycle * (this._duration + this._repeatDelay)
                        }
                        return this.totalTime(value, suppressEvents)
                    };
                    p.repeat = function(value) {
                        if (!arguments.length) {
                            return this._repeat
                        }
                        this._repeat = value;
                        return this._uncache(true)
                    };
                    p.repeatDelay = function(value) {
                        if (!arguments.length) {
                            return this._repeatDelay
                        }
                        this._repeatDelay = value;
                        return this._uncache(true)
                    };
                    p.yoyo = function(value) {
                        if (!arguments.length) {
                            return this._yoyo
                        }
                        this._yoyo = value;
                        return this
                    };
                    p.currentLabel = function(value) {
                        if (!arguments.length) {
                            return this.getLabelBefore(this._time + 1e-8)
                        }
                        return this.seek(value, true)
                    };
                    return TimelineMax
                }, true);
                (function() {
                    var _RAD2DEG = 180 / Math.PI,
                        _r1 = [],
                        _r2 = [],
                        _r3 = [],
                        _corProps = {},
                        _globals = _gsScope._gsDefine.globals,
                        Segment = function(a, b, c, d) {
                            if (c === d) {
                                c = d - (d - b) / 1e6
                            }
                            if (a === b) {
                                b = a + (c - a) / 1e6
                            }
                            this.a = a;
                            this.b = b;
                            this.c = c;
                            this.d = d;
                            this.da = d - a;
                            this.ca = c - a;
                            this.ba = b - a
                        },
                        _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                        cubicToQuadratic = function(a, b, c, d) {
                            var q1 = {
                                    a: a
                                },
                                q2 = {},
                                q3 = {},
                                q4 = {
                                    c: d
                                },
                                mab = (a + b) / 2,
                                mbc = (b + c) / 2,
                                mcd = (c + d) / 2,
                                mabc = (mab + mbc) / 2,
                                mbcd = (mbc + mcd) / 2,
                                m8 = (mbcd - mabc) / 8;
                            q1.b = mab + (a - mab) / 4;
                            q2.b = mabc + m8;
                            q1.c = q2.a = (q1.b + q2.b) / 2;
                            q2.c = q3.a = (mabc + mbcd) / 2;
                            q3.b = mbcd - m8;
                            q4.b = mcd + (d - mcd) / 4;
                            q3.c = q4.a = (q3.b + q4.b) / 2;
                            return [q1, q2, q3, q4]
                        },
                        _calculateControlPoints = function(a, curviness, quad, basic, correlate) {
                            var l = a.length - 1,
                                ii = 0,
                                cp1 = a[0].a,
                                i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
                            for (i = 0; i < l; i++) {
                                seg = a[ii];
                                p1 = seg.a;
                                p2 = seg.d;
                                p3 = a[ii + 1].d;
                                if (correlate) {
                                    r1 = _r1[i];
                                    r2 = _r2[i];
                                    tl = (r2 + r1) * curviness * .25 / (basic ? .5 : _r3[i] || .5);
                                    m1 = p2 - (p2 - p1) * (basic ? curviness * .5 : r1 !== 0 ? tl / r1 : 0);
                                    m2 = p2 + (p3 - p2) * (basic ? curviness * .5 : r2 !== 0 ? tl / r2 : 0);
                                    mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + .5) / 4 || 0))
                                } else {
                                    m1 = p2 - (p2 - p1) * curviness * .5;
                                    m2 = p2 + (p3 - p2) * curviness * .5;
                                    mm = p2 - (m1 + m2) / 2
                                }
                                m1 += mm;
                                m2 += mm;
                                seg.c = cp2 = m1;
                                if (i !== 0) {
                                    seg.b = cp1
                                } else {
                                    seg.b = cp1 = seg.a + (seg.c - seg.a) * .6
                                }
                                seg.da = p2 - p1;
                                seg.ca = cp2 - p1;
                                seg.ba = cp1 - p1;
                                if (quad) {
                                    qb = cubicToQuadratic(p1, cp1, cp2, p2);
                                    a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
                                    ii += 4
                                } else {
                                    ii++
                                }
                                cp1 = m2
                            }
                            seg = a[ii];
                            seg.b = cp1;
                            seg.c = cp1 + (seg.d - cp1) * .4;
                            seg.da = seg.d - seg.a;
                            seg.ca = seg.c - seg.a;
                            seg.ba = cp1 - seg.a;
                            if (quad) {
                                qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
                                a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3])
                            }
                        },
                        _parseAnchors = function(values, p, correlate, prepend) {
                            var a = [],
                                l, i, p1, p2, p3, tmp;
                            if (prepend) {
                                values = [prepend].concat(values);
                                i = values.length;
                                while (--i > -1) {
                                    if (typeof(tmp = values[i][p]) === "string")
                                        if (tmp.charAt(1) === "=") {
                                            values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2))
                                        }
                                }
                            }
                            l = values.length - 2;
                            if (l < 0) {
                                a[0] = new Segment(values[0][p], 0, 0, values[0][p]);
                                return a
                            }
                            for (i = 0; i < l; i++) {
                                p1 = values[i][p];
                                p2 = values[i + 1][p];
                                a[i] = new Segment(p1, 0, 0, p2);
                                if (correlate) {
                                    p3 = values[i + 2][p];
                                    _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
                                    _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2)
                                }
                            }
                            a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
                            return a
                        },
                        bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
                            var obj = {},
                                props = [],
                                first = prepend || values[0],
                                i, p, a, j, r, l, seamless, last;
                            correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;
                            if (curviness == null) {
                                curviness = 1
                            }
                            for (p in values[0]) {
                                props.push(p)
                            }
                            if (values.length > 1) {
                                last = values[values.length - 1];
                                seamless = true;
                                i = props.length;
                                while (--i > -1) {
                                    p = props[i];
                                    if (Math.abs(first[p] - last[p]) > .05) {
                                        seamless = false;
                                        break
                                    }
                                }
                                if (seamless) {
                                    values = values.concat();
                                    if (prepend) {
                                        values.unshift(prepend)
                                    }
                                    values.push(values[1]);
                                    prepend = values[values.length - 3]
                                }
                            }
                            _r1.length = _r2.length = _r3.length = 0;
                            i = props.length;
                            while (--i > -1) {
                                p = props[i];
                                _corProps[p] = correlate.indexOf("," + p + ",") !== -1;
                                obj[p] = _parseAnchors(values, p, _corProps[p], prepend)
                            }
                            i = _r1.length;
                            while (--i > -1) {
                                _r1[i] = Math.sqrt(_r1[i]);
                                _r2[i] = Math.sqrt(_r2[i])
                            }
                            if (!basic) {
                                i = props.length;
                                while (--i > -1) {
                                    if (_corProps[p]) {
                                        a = obj[props[i]];
                                        l = a.length - 1;
                                        for (j = 0; j < l; j++) {
                                            r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0;
                                            _r3[j] = (_r3[j] || 0) + r * r
                                        }
                                    }
                                }
                                i = _r3.length;
                                while (--i > -1) {
                                    _r3[i] = Math.sqrt(_r3[i])
                                }
                            }
                            i = props.length;
                            j = quadratic ? 4 : 1;
                            while (--i > -1) {
                                p = props[i];
                                a = obj[p];
                                _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]);
                                if (seamless) {
                                    a.splice(0, j);
                                    a.splice(a.length - j, j)
                                }
                            }
                            return obj
                        },
                        _parseBezierData = function(values, type, prepend) {
                            type = type || "soft";
                            var obj = {},
                                inc = type === "cubic" ? 3 : 2,
                                soft = type === "soft",
                                props = [],
                                a, b, c, d, cur, i, j, l, p, cnt, tmp;
                            if (soft && prepend) {
                                values = [prepend].concat(values)
                            }
                            if (values == null || values.length < inc + 1) {
                                throw "invalid Bezier data"
                            }
                            for (p in values[0]) {
                                props.push(p)
                            }
                            i = props.length;
                            while (--i > -1) {
                                p = props[i];
                                obj[p] = cur = [];
                                cnt = 0;
                                l = values.length;
                                for (j = 0; j < l; j++) {
                                    a = prepend == null ? values[j][p] : typeof(tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
                                    if (soft)
                                        if (j > 1)
                                            if (j < l - 1) {
                                                cur[cnt++] = (a + cur[cnt - 2]) / 2
                                            }
                                    cur[cnt++] = a
                                }
                                l = cnt - inc + 1;
                                cnt = 0;
                                for (j = 0; j < l; j += inc) {
                                    a = cur[j];
                                    b = cur[j + 1];
                                    c = cur[j + 2];
                                    d = inc === 2 ? 0 : cur[j + 3];
                                    cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c)
                                }
                                cur.length = cnt
                            }
                            return obj
                        },
                        _addCubicLengths = function(a, steps, resolution) {
                            var inc = 1 / resolution,
                                j = a.length,
                                d, d1, s, da, ca, ba, p, i, inv, bez, index;
                            while (--j > -1) {
                                bez = a[j];
                                s = bez.a;
                                da = bez.d - s;
                                ca = bez.c - s;
                                ba = bez.b - s;
                                d = d1 = 0;
                                for (i = 1; i <= resolution; i++) {
                                    p = inc * i;
                                    inv = 1 - p;
                                    d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
                                    index = j * resolution + i - 1;
                                    steps[index] = (steps[index] || 0) + d * d
                                }
                            }
                        },
                        _parseLengthData = function(obj, resolution) {
                            resolution = resolution >> 0 || 6;
                            var a = [],
                                lengths = [],
                                d = 0,
                                total = 0,
                                threshold = resolution - 1,
                                segments = [],
                                curLS = [],
                                p, i, l, index;
                            for (p in obj) {
                                _addCubicLengths(obj[p], a, resolution)
                            }
                            l = a.length;
                            for (i = 0; i < l; i++) {
                                d += Math.sqrt(a[i]);
                                index = i % resolution;
                                curLS[index] = d;
                                if (index === threshold) {
                                    total += d;
                                    index = i / resolution >> 0;
                                    segments[index] = curLS;
                                    lengths[index] = total;
                                    d = 0;
                                    curLS = []
                                }
                            }
                            return {
                                length: total,
                                lengths: lengths,
                                segments: segments
                            }
                        },
                        BezierPlugin = _gsScope._gsDefine.plugin({
                            propName: "bezier",
                            priority: -1,
                            version: "1.3.8",
                            API: 2,
                            global: true,
                            init: function(target, vars, tween) {
                                this._target = target;
                                if (vars instanceof Array) {
                                    vars = {
                                        values: vars
                                    }
                                }
                                this._func = {};
                                this._mod = {};
                                this._props = [];
                                this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
                                var values = vars.values || [],
                                    first = {},
                                    second = values[0],
                                    autoRotate = vars.autoRotate || tween.vars.orientToBezier,
                                    p, isFunc, i, j, prepend;
                                this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [
                                    ["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]
                                ] : null;
                                for (p in second) {
                                    this._props.push(p)
                                }
                                i = this._props.length;
                                while (--i > -1) {
                                    p = this._props[i];
                                    this._overwriteProps.push(p);
                                    isFunc = this._func[p] = typeof target[p] === "function";
                                    first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
                                    if (!prepend)
                                        if (first[p] !== values[0][p]) {
                                            prepend = first
                                        }
                                }
                                this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
                                this._segCount = this._beziers[p].length;
                                if (this._timeRes) {
                                    var ld = _parseLengthData(this._beziers, this._timeRes);
                                    this._length = ld.length;
                                    this._lengths = ld.lengths;
                                    this._segments = ld.segments;
                                    this._l1 = this._li = this._s1 = this._si = 0;
                                    this._l2 = this._lengths[0];
                                    this._curSeg = this._segments[0];
                                    this._s2 = this._curSeg[0];
                                    this._prec = 1 / this._curSeg.length
                                }
                                if (autoRotate = this._autoRotate) {
                                    this._initialRotations = [];
                                    if (!(autoRotate[0] instanceof Array)) {
                                        this._autoRotate = autoRotate = [autoRotate]
                                    }
                                    i = autoRotate.length;
                                    while (--i > -1) {
                                        for (j = 0; j < 3; j++) {
                                            p = autoRotate[i][j];
                                            this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false
                                        }
                                        p = autoRotate[i][2];
                                        this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
                                        this._overwriteProps.push(p)
                                    }
                                }
                                this._startRatio = tween.vars.runBackwards ? 1 : 0;
                                return true
                            },
                            set: function(v) {
                                var segments = this._segCount,
                                    func = this._func,
                                    target = this._target,
                                    notStart = v !== this._startRatio,
                                    curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
                                if (!this._timeRes) {
                                    curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
                                    t = (v - curIndex * (1 / segments)) * segments
                                } else {
                                    lengths = this._lengths;
                                    curSeg = this._curSeg;
                                    v *= this._length;
                                    i = this._li;
                                    if (v > this._l2 && i < segments - 1) {
                                        l = segments - 1;
                                        while (i < l && (this._l2 = lengths[++i]) <= v) {}
                                        this._l1 = lengths[i - 1];
                                        this._li = i;
                                        this._curSeg = curSeg = this._segments[i];
                                        this._s2 = curSeg[this._s1 = this._si = 0]
                                    } else if (v < this._l1 && i > 0) {
                                        while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
                                        if (i === 0 && v < this._l1) {
                                            this._l1 = 0
                                        } else {
                                            i++
                                        }
                                        this._l2 = lengths[i];
                                        this._li = i;
                                        this._curSeg = curSeg = this._segments[i];
                                        this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
                                        this._s2 = curSeg[this._si]
                                    }
                                    curIndex = i;
                                    v -= this._l1;
                                    i = this._si;
                                    if (v > this._s2 && i < curSeg.length - 1) {
                                        l = curSeg.length - 1;
                                        while (i < l && (this._s2 = curSeg[++i]) <= v) {}
                                        this._s1 = curSeg[i - 1];
                                        this._si = i
                                    } else if (v < this._s1 && i > 0) {
                                        while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
                                        if (i === 0 && v < this._s1) {
                                            this._s1 = 0
                                        } else {
                                            i++
                                        }
                                        this._s2 = curSeg[i];
                                        this._si = i
                                    }
                                    t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                }
                                inv = 1 - t;
                                i = this._props.length;
                                while (--i > -1) {
                                    p = this._props[i];
                                    b = this._beziers[p][curIndex];
                                    val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
                                    if (this._mod[p]) {
                                        val = this._mod[p](val, target)
                                    }
                                    if (func[p]) {
                                        target[p](val)
                                    } else {
                                        target[p] = val
                                    }
                                }
                                if (this._autoRotate) {
                                    var ar = this._autoRotate,
                                        b2, x1, y1, x2, y2, add, conv;
                                    i = ar.length;
                                    while (--i > -1) {
                                        p = ar[i][2];
                                        add = ar[i][3] || 0;
                                        conv = ar[i][4] === true ? 1 : _RAD2DEG;
                                        b = this._beziers[ar[i][0]];
                                        b2 = this._beziers[ar[i][1]];
                                        if (b && b2) {
                                            b = b[curIndex];
                                            b2 = b2[curIndex];
                                            x1 = b.a + (b.b - b.a) * t;
                                            x2 = b.b + (b.c - b.b) * t;
                                            x1 += (x2 - x1) * t;
                                            x2 += (b.c + (b.d - b.c) * t - x2) * t;
                                            y1 = b2.a + (b2.b - b2.a) * t;
                                            y2 = b2.b + (b2.c - b2.b) * t;
                                            y1 += (y2 - y1) * t;
                                            y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;
                                            val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];
                                            if (this._mod[p]) {
                                                val = this._mod[p](val, target)
                                            }
                                            if (func[p]) {
                                                target[p](val)
                                            } else {
                                                target[p] = val
                                            }
                                        }
                                    }
                                }
                            }
                        }),
                        p = BezierPlugin.prototype;
                    BezierPlugin.bezierThrough = bezierThrough;
                    BezierPlugin.cubicToQuadratic = cubicToQuadratic;
                    BezierPlugin._autoCSS = true;
                    BezierPlugin.quadraticToCubic = function(a, b, c) {
                        return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c)
                    };
                    BezierPlugin._cssRegister = function() {
                        var CSSPlugin = _globals.CSSPlugin;
                        if (!CSSPlugin) {
                            return
                        }
                        var _internals = CSSPlugin._internals,
                            _parseToProxy = _internals._parseToProxy,
                            _setPluginRatio = _internals._setPluginRatio,
                            CSSPropTween = _internals.CSSPropTween;
                        _internals._registerComplexSpecialProp("bezier", {
                            parser: function(t, e, prop, cssp, pt, plugin) {
                                if (e instanceof Array) {
                                    e = {
                                        values: e
                                    }
                                }
                                plugin = new BezierPlugin;
                                var values = e.values,
                                    l = values.length - 1,
                                    pluginValues = [],
                                    v = {},
                                    i, p, data;
                                if (l < 0) {
                                    return pt
                                }
                                for (i = 0; i <= l; i++) {
                                    data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
                                    pluginValues[i] = data.end
                                }
                                for (p in e) {
                                    v[p] = e[p]
                                }
                                v.values = pluginValues;
                                pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
                                pt.data = data;
                                pt.plugin = plugin;
                                pt.setRatio = _setPluginRatio;
                                if (v.autoRotate === 0) {
                                    v.autoRotate = true
                                }
                                if (v.autoRotate && !(v.autoRotate instanceof Array)) {
                                    i = v.autoRotate === true ? 0 : Number(v.autoRotate);
                                    v.autoRotate = data.end.left != null ? [
                                        ["left", "top", "rotation", i, false]
                                    ] : data.end.x != null ? [
                                        ["x", "y", "rotation", i, false]
                                    ] : false
                                }
                                if (v.autoRotate) {
                                    if (!cssp._transform) {
                                        cssp._enableTransforms(false)
                                    }
                                    data.autoRotate = cssp._target._gsTransform;
                                    data.proxy.rotation = data.autoRotate.rotation || 0;
                                    cssp._overwriteProps.push("rotation")
                                }
                                plugin._onInitTween(data.proxy, v, cssp._tween);
                                return pt
                            }
                        })
                    };
                    p._mod = function(lookup) {
                        var op = this._overwriteProps,
                            i = op.length,
                            val;
                        while (--i > -1) {
                            val = lookup[op[i]];
                            if (val && typeof val === "function") {
                                this._mod[op[i]] = val
                            }
                        }
                    };
                    p._kill = function(lookup) {
                        var a = this._props,
                            p, i;
                        for (p in this._beziers) {
                            if (p in lookup) {
                                delete this._beziers[p];
                                delete this._func[p];
                                i = a.length;
                                while (--i > -1) {
                                    if (a[i] === p) {
                                        a.splice(i, 1)
                                    }
                                }
                            }
                        }
                        a = this._autoRotate;
                        if (a) {
                            i = a.length;
                            while (--i > -1) {
                                if (lookup[a[i][2]]) {
                                    a.splice(i, 1)
                                }
                            }
                        }
                        return this._super._kill.call(this, lookup)
                    }
                })();
                _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(TweenPlugin, TweenLite) {
                    var CSSPlugin = function() {
                            TweenPlugin.call(this, "css");
                            this._overwriteProps.length = 0;
                            this.setRatio = CSSPlugin.prototype.setRatio
                        },
                        _globals = _gsScope._gsDefine.globals,
                        _hasPriority, _suffixMap, _cs, _overwriteProps, _specialProps = {},
                        p = CSSPlugin.prototype = new TweenPlugin("css");
                    p.constructor = CSSPlugin;
                    CSSPlugin.version = "1.20.4";
                    CSSPlugin.API = 2;
                    CSSPlugin.defaultTransformPerspective = 0;
                    CSSPlugin.defaultSkewType = "compensated";
                    CSSPlugin.defaultSmoothOrigin = true;
                    p = "px";
                    CSSPlugin.suffixMap = {
                        top: p,
                        right: p,
                        bottom: p,
                        left: p,
                        width: p,
                        height: p,
                        fontSize: p,
                        padding: p,
                        margin: p,
                        perspective: p,
                        lineHeight: ""
                    };
                    var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                        _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                        _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                        _NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                        _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
                        _opacityExp = /opacity *= *([^)]*)/i,
                        _opacityValExp = /opacity:([^;]*)/i,
                        _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
                        _rgbhslExp = /^(rgb|hsl)/,
                        _capsExp = /([A-Z])/g,
                        _camelExp = /-([a-z])/gi,
                        _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                        _camelFunc = function(s, g) {
                            return g.toUpperCase()
                        },
                        _horizExp = /(?:Left|Right|Width)/i,
                        _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                        _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                        _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
                        _complexExp = /[\s,\(]/i,
                        _DEG2RAD = Math.PI / 180,
                        _RAD2DEG = 180 / Math.PI,
                        _forcePT = {},
                        _dummyElement = {
                            style: {}
                        },
                        _doc = _gsScope.document || {
                            createElement: function() {
                                return _dummyElement
                            }
                        },
                        _createElement = function(type, ns) {
                            return _doc.createElementNS ? _doc.createElementNS(ns || "http://www.w3.org/1999/xhtml", type) : _doc.createElement(type)
                        },
                        _tempDiv = _createElement("div"),
                        _tempImg = _createElement("img"),
                        _internals = CSSPlugin._internals = {
                            _specialProps: _specialProps
                        },
                        _agent = (_gsScope.navigator || {}).userAgent || "",
                        _autoRound, _reqSafariFix, _isSafari, _isFirefox, _isSafariLT6, _ieVers, _supportsOpacity = function() {
                            var i = _agent.indexOf("Android"),
                                a = _createElement("a");
                            _isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i + 8, 2)) > 3);
                            _isSafariLT6 = _isSafari && parseFloat(_agent.substr(_agent.indexOf("Version/") + 8, 2)) < 6;
                            _isFirefox = _agent.indexOf("Firefox") !== -1;
                            if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
                                _ieVers = parseFloat(RegExp.$1)
                            }
                            if (!a) {
                                return false
                            }
                            a.style.cssText = "top:1px;opacity:.55;";
                            return /^0.55/.test(a.style.opacity)
                        }(),
                        _getIEOpacity = function(v) {
                            return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                        },
                        _log = function(s) {
                            if (_gsScope.console) {
                                console.log(s)
                            }
                        },
                        _target, _index, _prefixCSS = "",
                        _prefix = "",
                        _checkPropPrefix = function(p, e) {
                            e = e || _tempDiv;
                            var s = e.style,
                                a, i;
                            if (s[p] !== undefined) {
                                return p
                            }
                            p = p.charAt(0).toUpperCase() + p.substr(1);
                            a = ["O", "Moz", "ms", "Ms", "Webkit"];
                            i = 5;
                            while (--i > -1 && s[a[i] + p] === undefined) {}
                            if (i >= 0) {
                                _prefix = i === 3 ? "ms" : a[i];
                                _prefixCSS = "-" + _prefix.toLowerCase() + "-";
                                return _prefix + p
                            }
                            return null
                        },
                        _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},
                        _getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
                            var rv;
                            if (!_supportsOpacity)
                                if (p === "opacity") {
                                    return _getIEOpacity(t)
                                }
                            if (!calc && t.style[p]) {
                                rv = t.style[p]
                            } else if (cs = cs || _getComputedStyle(t)) {
                                rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase())
                            } else if (t.currentStyle) {
                                rv = t.currentStyle[p]
                            }
                            return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv
                        },
                        _convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
                            if (sfx === "px" || !sfx && p !== "lineHeight") {
                                return v
                            }
                            if (sfx === "auto" || !v) {
                                return 0
                            }
                            var horiz = _horizExp.test(p),
                                node = t,
                                style = _tempDiv.style,
                                neg = v < 0,
                                precise = v === 1,
                                pix, cache, time;
                            if (neg) {
                                v = -v
                            }
                            if (precise) {
                                v *= 100
                            }
                            if (p === "lineHeight" && !sfx) {
                                cache = _getComputedStyle(t).lineHeight;
                                t.style.lineHeight = v;
                                pix = parseFloat(_getComputedStyle(t).lineHeight);
                                t.style.lineHeight = cache
                            } else if (sfx === "%" && p.indexOf("border") !== -1) {
                                pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight)
                            } else {
                                style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
                                if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
                                    node = t.parentNode || _doc.body;
                                    if (_getStyle(node, "display").indexOf("flex") !== -1) {
                                        style.position = "absolute"
                                    }
                                    cache = node._gsCache;
                                    time = TweenLite.ticker.frame;
                                    if (cache && horiz && cache.time === time) {
                                        return cache.width * v / 100
                                    }
                                    style[horiz ? "width" : "height"] = v + sfx
                                } else {
                                    style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx
                                }
                                node.appendChild(_tempDiv);
                                pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
                                node.removeChild(_tempDiv);
                                if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
                                    cache = node._gsCache = node._gsCache || {};
                                    cache.time = time;
                                    cache.width = pix / v * 100
                                }
                                if (pix === 0 && !recurse) {
                                    pix = _convertToPixels(t, p, v, sfx, true)
                                }
                            }
                            if (precise) {
                                pix /= 100
                            }
                            return neg ? -pix : pix
                        },
                        _calculateOffset = _internals.calculateOffset = function(t, p, cs) {
                            if (_getStyle(t, "position", cs) !== "absolute") {
                                return 0
                            }
                            var dim = p === "left" ? "Left" : "Top",
                                v = _getStyle(t, "margin" + dim, cs);
                            return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0)
                        },
                        _getAllStyles = function(t, cs) {
                            var s = {},
                                i, tr, p;
                            if (cs = cs || _getComputedStyle(t, null)) {
                                if (i = cs.length) {
                                    while (--i > -1) {
                                        p = cs[i];
                                        if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
                                            s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p)
                                        }
                                    }
                                } else {
                                    for (i in cs) {
                                        if (i.indexOf("Transform") === -1 || _transformProp === i) {
                                            s[i] = cs[i]
                                        }
                                    }
                                }
                            } else if (cs = t.currentStyle || t.style) {
                                for (i in cs) {
                                    if (typeof i === "string" && s[i] === undefined) {
                                        s[i.replace(_camelExp, _camelFunc)] = cs[i]
                                    }
                                }
                            }
                            if (!_supportsOpacity) {
                                s.opacity = _getIEOpacity(t)
                            }
                            tr = _getTransform(t, cs, false);
                            s.rotation = tr.rotation;
                            s.skewX = tr.skewX;
                            s.scaleX = tr.scaleX;
                            s.scaleY = tr.scaleY;
                            s.x = tr.x;
                            s.y = tr.y;
                            if (_supports3D) {
                                s.z = tr.z;
                                s.rotationX = tr.rotationX;
                                s.rotationY = tr.rotationY;
                                s.scaleZ = tr.scaleZ
                            }
                            if (s.filters) {
                                delete s.filters
                            }
                            return s
                        },
                        _cssDif = function(t, s1, s2, vars, forceLookup) {
                            var difs = {},
                                style = t.style,
                                val, p, mpt;
                            for (p in s2) {
                                if (p !== "cssText")
                                    if (p !== "length")
                                        if (isNaN(p))
                                            if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p])
                                                if (p.indexOf("Origin") === -1)
                                                    if (typeof val === "number" || typeof val === "string") {
                                                        difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val;
                                                        if (style[p] !== undefined) {
                                                            mpt = new MiniPropTween(style, p, style[p], mpt)
                                                        }
                                                    }
                            }
                            if (vars) {
                                for (p in vars) {
                                    if (p !== "className") {
                                        difs[p] = vars[p]
                                    }
                                }
                            }
                            return {
                                difs: difs,
                                firstMPT: mpt
                            }
                        },
                        _dimensions = {
                            width: ["Left", "Right"],
                            height: ["Top", "Bottom"]
                        },
                        _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                        _getDimension = function(t, p, cs) {
                            if ((t.nodeName + "").toLowerCase() === "svg") {
                                return (cs || _getComputedStyle(t))[p] || 0
                            } else if (t.getCTM && _isSVG(t)) {
                                return t.getBBox()[p] || 0
                            }
                            var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
                                a = _dimensions[p],
                                i = a.length;
                            cs = cs || _getComputedStyle(t, null);
                            while (--i > -1) {
                                v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
                                v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0
                            }
                            return v
                        },
                        _parsePosition = function(v, recObj) {
                            if (v === "contain" || v === "auto" || v === "auto auto") {
                                return v + " "
                            }
                            if (v == null || v === "") {
                                v = "0 0"
                            }
                            var a = v.split(" "),
                                x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
                                y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1],
                                i;
                            if (a.length > 3 && !recObj) {
                                a = v.split(", ").join(",").split(",");
                                v = [];
                                for (i = 0; i < a.length; i++) {
                                    v.push(_parsePosition(a[i]))
                                }
                                return v.join(",")
                            }
                            if (y == null) {
                                y = x === "center" ? "50%" : "0"
                            } else if (y === "center") {
                                y = "50%"
                            }
                            if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
                                x = "50%"
                            }
                            v = x + " " + y + (a.length > 2 ? " " + a[2] : "");
                            if (recObj) {
                                recObj.oxp = x.indexOf("%") !== -1;
                                recObj.oyp = y.indexOf("%") !== -1;
                                recObj.oxr = x.charAt(1) === "=";
                                recObj.oyr = y.charAt(1) === "=";
                                recObj.ox = parseFloat(x.replace(_NaNExp, ""));
                                recObj.oy = parseFloat(y.replace(_NaNExp, ""));
                                recObj.v = v
                            }
                            return recObj || v
                        },
                        _parseChange = function(e, b) {
                            if (typeof e === "function") {
                                e = e(_index, _target)
                            }
                            return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0
                        },
                        _parseVal = function(v, d) {
                            if (typeof v === "function") {
                                v = v(_index, _target)
                            }
                            return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0
                        },
                        _parseAngle = function(v, d, p, directionalEnd) {
                            var min = 1e-6,
                                cap, split, dif, result, isRelative;
                            if (typeof v === "function") {
                                v = v(_index, _target)
                            }
                            if (v == null) {
                                result = d
                            } else if (typeof v === "number") {
                                result = v
                            } else {
                                cap = 360;
                                split = v.split("_");
                                isRelative = v.charAt(1) === "=";
                                dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
                                if (split.length) {
                                    if (directionalEnd) {
                                        directionalEnd[p] = d + dif
                                    }
                                    if (v.indexOf("short") !== -1) {
                                        dif = dif % cap;
                                        if (dif !== dif % (cap / 2)) {
                                            dif = dif < 0 ? dif + cap : dif - cap
                                        }
                                    }
                                    if (v.indexOf("_cw") !== -1 && dif < 0) {
                                        dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap
                                    } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                                        dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap
                                    }
                                }
                                result = d + dif
                            }
                            if (result < min && result > -min) {
                                result = 0
                            }
                            return result
                        },
                        _colorLookup = {
                            aqua: [0, 255, 255],
                            lime: [0, 255, 0],
                            silver: [192, 192, 192],
                            black: [0, 0, 0],
                            maroon: [128, 0, 0],
                            teal: [0, 128, 128],
                            blue: [0, 0, 255],
                            navy: [0, 0, 128],
                            white: [255, 255, 255],
                            fuchsia: [255, 0, 255],
                            olive: [128, 128, 0],
                            yellow: [255, 255, 0],
                            orange: [255, 165, 0],
                            gray: [128, 128, 128],
                            purple: [128, 0, 128],
                            green: [0, 128, 0],
                            red: [255, 0, 0],
                            pink: [255, 192, 203],
                            cyan: [0, 255, 255],
                            transparent: [255, 255, 255, 0]
                        },
                        _hue = function(h, m1, m2) {
                            h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
                            return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + .5 | 0
                        },
                        _parseColor = CSSPlugin.parseColor = function(v, toHSL) {
                            var a, r, g, b, h, s, l, max, min, d, wasHSL;
                            if (!v) {
                                a = _colorLookup.black
                            } else if (typeof v === "number") {
                                a = [v >> 16, v >> 8 & 255, v & 255]
                            } else {
                                if (v.charAt(v.length - 1) === ",") {
                                    v = v.substr(0, v.length - 1)
                                }
                                if (_colorLookup[v]) {
                                    a = _colorLookup[v]
                                } else if (v.charAt(0) === "#") {
                                    if (v.length === 4) {
                                        r = v.charAt(1);
                                        g = v.charAt(2);
                                        b = v.charAt(3);
                                        v = "#" + r + r + g + g + b + b
                                    }
                                    v = parseInt(v.substr(1), 16);
                                    a = [v >> 16, v >> 8 & 255, v & 255]
                                } else if (v.substr(0, 3) === "hsl") {
                                    a = wasHSL = v.match(_numExp);
                                    if (!toHSL) {
                                        h = Number(a[0]) % 360 / 360;
                                        s = Number(a[1]) / 100;
                                        l = Number(a[2]) / 100;
                                        g = l <= .5 ? l * (s + 1) : l + s - l * s;
                                        r = l * 2 - g;
                                        if (a.length > 3) {
                                            a[3] = Number(a[3])
                                        }
                                        a[0] = _hue(h + 1 / 3, r, g);
                                        a[1] = _hue(h, r, g);
                                        a[2] = _hue(h - 1 / 3, r, g)
                                    } else if (v.indexOf("=") !== -1) {
                                        return v.match(_relNumExp)
                                    }
                                } else {
                                    a = v.match(_numExp) || _colorLookup.transparent
                                }
                                a[0] = Number(a[0]);
                                a[1] = Number(a[1]);
                                a[2] = Number(a[2]);
                                if (a.length > 3) {
                                    a[3] = Number(a[3])
                                }
                            }
                            if (toHSL && !wasHSL) {
                                r = a[0] / 255;
                                g = a[1] / 255;
                                b = a[2] / 255;
                                max = Math.max(r, g, b);
                                min = Math.min(r, g, b);
                                l = (max + min) / 2;
                                if (max === min) {
                                    h = s = 0
                                } else {
                                    d = max - min;
                                    s = l > .5 ? d / (2 - max - min) : d / (max + min);
                                    h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
                                    h *= 60
                                }
                                a[0] = h + .5 | 0;
                                a[1] = s * 100 + .5 | 0;
                                a[2] = l * 100 + .5 | 0
                            }
                            return a
                        },
                        _formatColors = function(s, toHSL) {
                            var colors = s.match(_colorExp) || [],
                                charIndex = 0,
                                parsed = "",
                                i, color, temp;
                            if (!colors.length) {
                                return s
                            }
                            for (i = 0; i < colors.length; i++) {
                                color = colors[i];
                                temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
                                charIndex += temp.length + color.length;
                                color = _parseColor(color, toHSL);
                                if (color.length === 3) {
                                    color.push(1)
                                }
                                parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")"
                            }
                            return parsed + s.substr(charIndex)
                        },
                        _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                    for (p in _colorLookup) {
                        _colorExp += "|" + p + "\\b"
                    }
                    _colorExp = new RegExp(_colorExp + ")", "gi");
                    CSSPlugin.colorStringFilter = function(a) {
                        var combined = a[0] + " " + a[1],
                            toHSL;
                        if (_colorExp.test(combined)) {
                            toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
                            a[0] = _formatColors(a[0], toHSL);
                            a[1] = _formatColors(a[1], toHSL)
                        }
                        _colorExp.lastIndex = 0
                    };
                    if (!TweenLite.defaultStringFilter) {
                        TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter
                    }
                    var _getFormatter = function(dflt, clr, collapsible, multi) {
                            if (dflt == null) {
                                return function(v) {
                                    return v
                                }
                            }
                            var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
                                dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
                                pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
                                sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
                                delim = dflt.indexOf(" ") !== -1 ? " " : ",",
                                numVals = dVals.length,
                                dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
                                formatter;
                            if (!numVals) {
                                return function(v) {
                                    return v
                                }
                            }
                            if (clr) {
                                formatter = function(v) {
                                    var color, vals, i, a;
                                    if (typeof v === "number") {
                                        v += dSfx
                                    } else if (multi && _commasOutsideParenExp.test(v)) {
                                        a = v.replace(_commasOutsideParenExp, "|").split("|");
                                        for (i = 0; i < a.length; i++) {
                                            a[i] = formatter(a[i])
                                        }
                                        return a.join(",")
                                    }
                                    color = (v.match(_colorExp) || [dColor])[0];
                                    vals = v.split(color).join("").match(_valuesExp) || [];
                                    i = vals.length;
                                    if (numVals > i--) {
                                        while (++i < numVals) {
                                            vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i]
                                        }
                                    }
                                    return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "")
                                };
                                return formatter
                            }
                            formatter = function(v) {
                                var vals, a, i;
                                if (typeof v === "number") {
                                    v += dSfx
                                } else if (multi && _commasOutsideParenExp.test(v)) {
                                    a = v.replace(_commasOutsideParenExp, "|").split("|");
                                    for (i = 0; i < a.length; i++) {
                                        a[i] = formatter(a[i])
                                    }
                                    return a.join(",")
                                }
                                vals = v.match(_valuesExp) || [];
                                i = vals.length;
                                if (numVals > i--) {
                                    while (++i < numVals) {
                                        vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i]
                                    }
                                }
                                return pfx + vals.join(delim) + sfx
                            };
                            return formatter
                        },
                        _getEdgeParser = function(props) {
                            props = props.split(",");
                            return function(t, e, p, cssp, pt, plugin, vars) {
                                var a = (e + "").split(" "),
                                    i;
                                vars = {};
                                for (i = 0; i < 4; i++) {
                                    vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0]
                                }
                                return cssp.parse(t, vars, pt, plugin)
                            }
                        },
                        _setPluginRatio = _internals._setPluginRatio = function(v) {
                            this.plugin.setRatio(v);
                            var d = this.data,
                                proxy = d.proxy,
                                mpt = d.firstMPT,
                                min = 1e-6,
                                val, pt, i, str, p;
                            while (mpt) {
                                val = proxy[mpt.v];
                                if (mpt.r) {
                                    val = Math.round(val)
                                } else if (val < min && val > -min) {
                                    val = 0
                                }
                                mpt.t[mpt.p] = val;
                                mpt = mpt._next
                            }
                            if (d.autoRotate) {
                                d.autoRotate.rotation = d.mod ? d.mod(proxy.rotation, this.t) : proxy.rotation
                            }
                            if (v === 1 || v === 0) {
                                mpt = d.firstMPT;
                                p = v === 1 ? "e" : "b";
                                while (mpt) {
                                    pt = mpt.t;
                                    if (!pt.type) {
                                        pt[p] = pt.s + pt.xs0
                                    } else if (pt.type === 1) {
                                        str = pt.xs0 + pt.s + pt.xs1;
                                        for (i = 1; i < pt.l; i++) {
                                            str += pt["xn" + i] + pt["xs" + (i + 1)]
                                        }
                                        pt[p] = str
                                    }
                                    mpt = mpt._next
                                }
                            }
                        },
                        MiniPropTween = function(t, p, v, next, r) {
                            this.t = t;
                            this.p = p;
                            this.v = v;
                            this.r = r;
                            if (next) {
                                next._prev = this;
                                this._next = next
                            }
                        },
                        _parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
                            var bpt = pt,
                                start = {},
                                end = {},
                                transform = cssp._transform,
                                oldForce = _forcePT,
                                i, p, xp, mpt, firstPT;
                            cssp._transform = null;
                            _forcePT = vars;
                            pt = firstPT = cssp.parse(t, vars, pt, plugin);
                            _forcePT = oldForce;
                            if (shallow) {
                                cssp._transform = transform;
                                if (bpt) {
                                    bpt._prev = null;
                                    if (bpt._prev) {
                                        bpt._prev._next = null
                                    }
                                }
                            }
                            while (pt && pt !== bpt) {
                                if (pt.type <= 1) {
                                    p = pt.p;
                                    end[p] = pt.s + pt.c;
                                    start[p] = pt.s;
                                    if (!shallow) {
                                        mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
                                        pt.c = 0
                                    }
                                    if (pt.type === 1) {
                                        i = pt.l;
                                        while (--i > 0) {
                                            xp = "xn" + i;
                                            p = pt.p + "_" + xp;
                                            end[p] = pt.data[xp];
                                            start[p] = pt[xp];
                                            if (!shallow) {
                                                mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp])
                                            }
                                        }
                                    }
                                }
                                pt = pt._next
                            }
                            return {
                                proxy: start,
                                end: end,
                                firstMPT: mpt,
                                pt: firstPT
                            }
                        },
                        CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
                            this.t = t;
                            this.p = p;
                            this.s = s;
                            this.c = c;
                            this.n = n || p;
                            if (!(t instanceof CSSPropTween)) {
                                _overwriteProps.push(this.n)
                            }
                            this.r = r;
                            this.type = type || 0;
                            if (pr) {
                                this.pr = pr;
                                _hasPriority = true
                            }
                            this.b = b === undefined ? s : b;
                            this.e = e === undefined ? s + c : e;
                            if (next) {
                                this._next = next;
                                next._prev = this
                            }
                        },
                        _addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) {
                            var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
                            pt.b = start;
                            pt.e = pt.xs0 = end;
                            return pt
                        },
                        _parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
                            b = b || dflt || "";
                            if (typeof e === "function") {
                                e = e(_index, _target)
                            }
                            pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
                            e += "";
                            if (clrs && _colorExp.test(e + b)) {
                                e = [b, e];
                                CSSPlugin.colorStringFilter(e);
                                b = e[0];
                                e = e[1]
                            }
                            var ba = b.split(", ").join(",").split(" "),
                                ea = e.split(", ").join(",").split(" "),
                                l = ba.length,
                                autoRound = _autoRound !== false,
                                i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
                            if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
                                if ((e + b).indexOf("rgb") !== -1 || (e + b).indexOf("hsl") !== -1) {
                                    ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
                                    ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ")
                                } else {
                                    ba = ba.join(" ").split(",").join(", ").split(" ");
                                    ea = ea.join(" ").split(",").join(", ").split(" ")
                                }
                                l = ba.length
                            }
                            if (l !== ea.length) {
                                ba = (dflt || "").split(" ");
                                l = ba.length
                            }
                            pt.plugin = plugin;
                            pt.setRatio = setRatio;
                            _colorExp.lastIndex = 0;
                            for (i = 0; i < l; i++) {
                                bv = ba[i];
                                ev = ea[i];
                                bn = parseFloat(bv);
                                if (bn || bn === 0) {
                                    pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, true)
                                } else if (clrs && _colorExp.test(bv)) {
                                    str = ev.indexOf(")") + 1;
                                    str = ")" + (str ? ev.substr(str) : "");
                                    useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity;
                                    temp = ev;
                                    bv = _parseColor(bv, useHSL);
                                    ev = _parseColor(ev, useHSL);
                                    hasAlpha = bv.length + ev.length > 6;
                                    if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
                                        pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
                                        pt.e = pt.e.split(ea[i]).join("transparent")
                                    } else {
                                        if (!_supportsOpacity) {
                                            hasAlpha = false
                                        }
                                        if (useHSL) {
                                            pt.appendXtra(temp.substr(0, temp.indexOf("hsl")) + (hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, false)
                                        } else {
                                            pt.appendXtra(temp.substr(0, temp.indexOf("rgb")) + (hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, true)
                                        }
                                        if (hasAlpha) {
                                            bv = bv.length < 4 ? 1 : bv[3];
                                            pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false)
                                        }
                                    }
                                    _colorExp.lastIndex = 0
                                } else {
                                    bnums = bv.match(_numExp);
                                    if (!bnums) {
                                        pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev
                                    } else {
                                        enums = ev.match(_relNumExp);
                                        if (!enums || enums.length !== bnums.length) {
                                            return pt
                                        }
                                        ni = 0;
                                        for (xi = 0; xi < bnums.length; xi++) {
                                            cv = bnums[xi];
                                            temp = bv.indexOf(cv, ni);
                                            pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px", xi === 0);
                                            ni = temp + cv.length
                                        }
                                        pt["xs" + pt.l] += bv.substr(ni)
                                    }
                                }
                            }
                            if (e.indexOf("=") !== -1)
                                if (pt.data) {
                                    str = pt.xs0 + pt.data.s;
                                    for (i = 1; i < pt.l; i++) {
                                        str += pt["xs" + i] + pt.data["xn" + i]
                                    }
                                    pt.e = str + pt["xs" + i]
                                }
                            if (!pt.l) {
                                pt.type = -1;
                                pt.xs0 = pt.e
                            }
                            return pt.xfirst || pt
                        },
                        i = 9;
                    p = CSSPropTween.prototype;
                    p.l = p.pr = 0;
                    while (--i > 0) {
                        p["xn" + i] = 0;
                        p["xs" + i] = ""
                    }
                    p.xs0 = "";
                    p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;
                    p.appendXtra = function(pfx, s, c, sfx, r, pad) {
                        var pt = this,
                            l = pt.l;
                        pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "";
                        if (!c)
                            if (l !== 0 && !pt.plugin) {
                                pt["xs" + l] += s + (sfx || "");
                                return pt
                            }
                        pt.l++;
                        pt.type = pt.setRatio ? 2 : 1;
                        pt["xs" + pt.l] = sfx || "";
                        if (l > 0) {
                            pt.data["xn" + l] = s + c;
                            pt.rxp["xn" + l] = r;
                            pt["xn" + l] = s;
                            if (!pt.plugin) {
                                pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
                                pt.xfirst.xs0 = 0
                            }
                            return pt
                        }
                        pt.data = {
                            s: s + c
                        };
                        pt.rxp = {};
                        pt.s = s;
                        pt.c = c;
                        pt.r = r;
                        return pt
                    };
                    var SpecialProp = function(p, options) {
                            options = options || {};
                            this.p = options.prefix ? _checkPropPrefix(p) || p : p;
                            _specialProps[p] = _specialProps[this.p] = this;
                            this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
                            if (options.parser) {
                                this.parse = options.parser
                            }
                            this.clrs = options.color;
                            this.multi = options.multi;
                            this.keyword = options.keyword;
                            this.dflt = options.defaultValue;
                            this.pr = options.priority || 0
                        },
                        _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
                            if (typeof options !== "object") {
                                options = {
                                    parser: defaults
                                }
                            }
                            var a = p.split(","),
                                d = options.defaultValue,
                                i, temp;
                            defaults = defaults || [d];
                            for (i = 0; i < a.length; i++) {
                                options.prefix = i === 0 && options.prefix;
                                options.defaultValue = defaults[i] || d;
                                temp = new SpecialProp(a[i], options)
                            }
                        },
                        _registerPluginProp = _internals._registerPluginProp = function(p) {
                            if (!_specialProps[p]) {
                                var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
                                _registerComplexSpecialProp(p, {
                                    parser: function(t, e, p, cssp, pt, plugin, vars) {
                                        var pluginClass = _globals.com.greensock.plugins[pluginName];
                                        if (!pluginClass) {
                                            _log("Error: " + pluginName + " js file not loaded.");
                                            return pt
                                        }
                                        pluginClass._cssRegister();
                                        return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars)
                                    }
                                })
                            }
                        };
                    p = SpecialProp.prototype;
                    p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
                        var kwd = this.keyword,
                            i, ba, ea, l, bi, ei;
                        if (this.multi)
                            if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
                                ba = b.replace(_commasOutsideParenExp, "|").split("|");
                                ea = e.replace(_commasOutsideParenExp, "|").split("|")
                            } else if (kwd) {
                            ba = [b];
                            ea = [e]
                        }
                        if (ea) {
                            l = ea.length > ba.length ? ea.length : ba.length;
                            for (i = 0; i < l; i++) {
                                b = ba[i] = ba[i] || this.dflt;
                                e = ea[i] = ea[i] || this.dflt;
                                if (kwd) {
                                    bi = b.indexOf(kwd);
                                    ei = e.indexOf(kwd);
                                    if (bi !== ei) {
                                        if (ei === -1) {
                                            ba[i] = ba[i].split(kwd).join("")
                                        } else if (bi === -1) {
                                            ba[i] += " " + kwd
                                        }
                                    }
                                }
                            }
                            b = ba.join(", ");
                            e = ea.join(", ")
                        }
                        return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio)
                    };
                    p.parse = function(t, e, p, cssp, pt, plugin, vars) {
                        return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin)
                    };
                    CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
                        _registerComplexSpecialProp(name, {
                            parser: function(t, e, p, cssp, pt, plugin, vars) {
                                var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
                                rv.plugin = plugin;
                                rv.setRatio = onInitTween(t, e, cssp._tween, p);
                                return rv
                            },
                            priority: priority
                        })
                    };
                    CSSPlugin.useSVGTransformAttr = true;
                    var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                        _transformProp = _checkPropPrefix("transform"),
                        _transformPropCSS = _prefixCSS + "transform",
                        _transformOriginProp = _checkPropPrefix("transformOrigin"),
                        _supports3D = _checkPropPrefix("perspective") !== null,
                        Transform = _internals.Transform = function() {
                            this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
                            this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto"
                        },
                        _SVGElement = _gsScope.SVGElement,
                        _useSVGTransformAttr, _createSVG = function(type, container, attributes) {
                            var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
                                reg = /([a-z])([A-Z])/g,
                                p;
                            for (p in attributes) {
                                element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p])
                            }
                            container.appendChild(element);
                            return element
                        },
                        _docElement = _doc.documentElement || {},
                        _forceSVGTransformAttr = function() {
                            var force = _ieVers || /Android/i.test(_agent) && !_gsScope.chrome,
                                svg, rect, width;
                            if (_doc.createElementNS && !force) {
                                svg = _createSVG("svg", _docElement);
                                rect = _createSVG("rect", svg, {
                                    width: 100,
                                    height: 50,
                                    x: 100
                                });
                                width = rect.getBoundingClientRect().width;
                                rect.style[_transformOriginProp] = "50% 50%";
                                rect.style[_transformProp] = "scaleX(0.5)";
                                force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D);
                                _docElement.removeChild(svg)
                            }
                            return force
                        }(),
                        _parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
                            var tm = e._gsTransform,
                                m = _getMatrix(e, true),
                                v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
                            if (tm) {
                                xOriginOld = tm.xOrigin;
                                yOriginOld = tm.yOrigin
                            }
                            if (!absolute || (v = absolute.split(" ")).length < 2) {
                                b = e.getBBox();
                                if (b.x === 0 && b.y === 0 && b.width + b.height === 0) {
                                    b = {
                                        x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0,
                                        y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0,
                                        width: 0,
                                        height: 0
                                    }
                                }
                                local = _parsePosition(local).split(" ");
                                v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y]
                            }
                            decoratee.xOrigin = xOrigin = parseFloat(v[0]);
                            decoratee.yOrigin = yOrigin = parseFloat(v[1]);
                            if (absolute && m !== _identity2DMatrix) {
                                a = m[0];
                                b = m[1];
                                c = m[2];
                                d = m[3];
                                tx = m[4];
                                ty = m[5];
                                determinant = a * d - b * c;
                                if (determinant) {
                                    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
                                    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
                                    xOrigin = decoratee.xOrigin = v[0] = x;
                                    yOrigin = decoratee.yOrigin = v[1] = y
                                }
                            }
                            if (tm) {
                                if (skipRecord) {
                                    decoratee.xOffset = tm.xOffset;
                                    decoratee.yOffset = tm.yOffset;
                                    tm = decoratee
                                }
                                if (smoothOrigin || smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false) {
                                    x = xOrigin - xOriginOld;
                                    y = yOrigin - yOriginOld;
                                    tm.xOffset += x * m[0] + y * m[2] - x;
                                    tm.yOffset += x * m[1] + y * m[3] - y
                                } else {
                                    tm.xOffset = tm.yOffset = 0
                                }
                            }
                            if (!skipRecord) {
                                e.setAttribute("data-svg-origin", v.join(" "))
                            }
                        },
                        _getBBoxHack = function(swapIfPossible) {
                            var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                oldParent = this.parentNode,
                                oldSibling = this.nextSibling,
                                oldCSS = this.style.cssText,
                                bbox;
                            _docElement.appendChild(svg);
                            svg.appendChild(this);
                            this.style.display = "block";
                            if (swapIfPossible) {
                                try {
                                    bbox = this.getBBox();
                                    this._originalGetBBox = this.getBBox;
                                    this.getBBox = _getBBoxHack
                                } catch (e) {}
                            } else if (this._originalGetBBox) {
                                bbox = this._originalGetBBox()
                            }
                            if (oldSibling) {
                                oldParent.insertBefore(this, oldSibling)
                            } else {
                                oldParent.appendChild(this)
                            }
                            _docElement.removeChild(svg);
                            this.style.cssText = oldCSS;
                            return bbox
                        },
                        _getBBox = function(e) {
                            try {
                                return e.getBBox()
                            } catch (error) {
                                return _getBBoxHack.call(e, true)
                            }
                        },
                        _isSVG = function(e) {
                            return !!(_SVGElement && e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e))
                        },
                        _identity2DMatrix = [1, 0, 0, 1, 0, 0],
                        _getMatrix = function(e, force2D) {
                            var tm = e._gsTransform || new Transform,
                                rnd = 1e5,
                                style = e.style,
                                isDefault, s, m, n, dec, none;
                            if (_transformProp) {
                                s = _getStyle(e, _transformPropCSS, null, true)
                            } else if (e.currentStyle) {
                                s = e.currentStyle.filter.match(_ieGetMatrixExp);
                                s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : ""
                            }
                            isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
                            if (_transformProp && ((none = !_getComputedStyle(e) || _getComputedStyle(e).display === "none") || !e.parentNode)) {
                                if (none) {
                                    n = style.display;
                                    style.display = "block"
                                }
                                if (!e.parentNode) {
                                    dec = 1;
                                    _docElement.appendChild(e)
                                }
                                s = _getStyle(e, _transformPropCSS, null, true);
                                isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
                                if (n) {
                                    style.display = n
                                } else if (none) {
                                    _removeProp(style, "display")
                                }
                                if (dec) {
                                    _docElement.removeChild(e)
                                }
                            }
                            if (tm.svg || e.getCTM && _isSVG(e)) {
                                if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) {
                                    s = style[_transformProp];
                                    isDefault = 0
                                }
                                m = e.getAttribute("transform");
                                if (isDefault && m) {
                                    m = e.transform.baseVal.consolidate().matrix;
                                    s = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
                                    isDefault = 0
                                }
                            }
                            if (isDefault) {
                                return _identity2DMatrix
                            }
                            m = (s || "").match(_numExp) || [];
                            i = m.length;
                            while (--i > -1) {
                                n = Number(m[i]);
                                m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -.5 : .5) | 0) / rnd + n : n
                            }
                            return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m
                        },
                        _getTransform = _internals.getTransform = function(t, cs, rec, parse) {
                            if (t._gsTransform && rec && !parse) {
                                return t._gsTransform
                            }
                            var tm = rec ? t._gsTransform || new Transform : new Transform,
                                invX = tm.scaleX < 0,
                                min = 2e-5,
                                rnd = 1e5,
                                zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
                                defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
                                m, i, scaleX, scaleY, rotation, skewX;
                            tm.svg = !!(t.getCTM && _isSVG(t));
                            if (tm.svg) {
                                _parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
                                _useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr
                            }
                            m = _getMatrix(t);
                            if (m !== _identity2DMatrix) {
                                if (m.length === 16) {
                                    var a11 = m[0],
                                        a21 = m[1],
                                        a31 = m[2],
                                        a41 = m[3],
                                        a12 = m[4],
                                        a22 = m[5],
                                        a32 = m[6],
                                        a42 = m[7],
                                        a13 = m[8],
                                        a23 = m[9],
                                        a33 = m[10],
                                        a14 = m[12],
                                        a24 = m[13],
                                        a34 = m[14],
                                        a43 = m[11],
                                        angle = Math.atan2(a32, a33),
                                        t1, t2, t3, t4, cos, sin;
                                    if (tm.zOrigin) {
                                        a34 = -tm.zOrigin;
                                        a14 = a13 * a34 - m[12];
                                        a24 = a23 * a34 - m[13];
                                        a34 = a33 * a34 + tm.zOrigin - m[14]
                                    }
                                    tm.rotationX = angle * _RAD2DEG;
                                    if (angle) {
                                        cos = Math.cos(-angle);
                                        sin = Math.sin(-angle);
                                        t1 = a12 * cos + a13 * sin;
                                        t2 = a22 * cos + a23 * sin;
                                        t3 = a32 * cos + a33 * sin;
                                        a13 = a12 * -sin + a13 * cos;
                                        a23 = a22 * -sin + a23 * cos;
                                        a33 = a32 * -sin + a33 * cos;
                                        a43 = a42 * -sin + a43 * cos;
                                        a12 = t1;
                                        a22 = t2;
                                        a32 = t3
                                    }
                                    angle = Math.atan2(-a31, a33);
                                    tm.rotationY = angle * _RAD2DEG;
                                    if (angle) {
                                        cos = Math.cos(-angle);
                                        sin = Math.sin(-angle);
                                        t1 = a11 * cos - a13 * sin;
                                        t2 = a21 * cos - a23 * sin;
                                        t3 = a31 * cos - a33 * sin;
                                        a23 = a21 * sin + a23 * cos;
                                        a33 = a31 * sin + a33 * cos;
                                        a43 = a41 * sin + a43 * cos;
                                        a11 = t1;
                                        a21 = t2;
                                        a31 = t3
                                    }
                                    angle = Math.atan2(a21, a11);
                                    tm.rotation = angle * _RAD2DEG;
                                    if (angle) {
                                        cos = Math.cos(angle);
                                        sin = Math.sin(angle);
                                        t1 = a11 * cos + a21 * sin;
                                        t2 = a12 * cos + a22 * sin;
                                        t3 = a13 * cos + a23 * sin;
                                        a21 = a21 * cos - a11 * sin;
                                        a22 = a22 * cos - a12 * sin;
                                        a23 = a23 * cos - a13 * sin;
                                        a11 = t1;
                                        a12 = t2;
                                        a13 = t3
                                    }
                                    if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
                                        tm.rotationX = tm.rotation = 0;
                                        tm.rotationY = 180 - tm.rotationY
                                    }
                                    angle = Math.atan2(a12, a22);
                                    tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31) * rnd + .5 | 0) / rnd;
                                    tm.scaleY = (Math.sqrt(a22 * a22 + a32 * a32) * rnd + .5 | 0) / rnd;
                                    tm.scaleZ = (Math.sqrt(a13 * a13 + a23 * a23 + a33 * a33) * rnd + .5 | 0) / rnd;
                                    a11 /= tm.scaleX;
                                    a12 /= tm.scaleY;
                                    a21 /= tm.scaleX;
                                    a22 /= tm.scaleY;
                                    if (Math.abs(angle) > min) {
                                        tm.skewX = angle * _RAD2DEG;
                                        a12 = 0;
                                        if (tm.skewType !== "simple") {
                                            tm.scaleY *= 1 / Math.cos(angle)
                                        }
                                    } else {
                                        tm.skewX = 0
                                    }
                                    tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
                                    tm.x = a14;
                                    tm.y = a24;
                                    tm.z = a34;
                                    if (tm.svg) {
                                        tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
                                        tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22)
                                    }
                                } else if (!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) {
                                    var k = m.length >= 6,
                                        a = k ? m[0] : 1,
                                        b = m[1] || 0,
                                        c = m[2] || 0,
                                        d = k ? m[3] : 1;
                                    tm.x = m[4] || 0;
                                    tm.y = m[5] || 0;
                                    scaleX = Math.sqrt(a * a + b * b);
                                    scaleY = Math.sqrt(d * d + c * c);
                                    rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0;
                                    skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
                                    tm.scaleX = scaleX;
                                    tm.scaleY = scaleY;
                                    tm.rotation = rotation;
                                    tm.skewX = skewX;
                                    if (_supports3D) {
                                        tm.rotationX = tm.rotationY = tm.z = 0;
                                        tm.perspective = defaultTransformPerspective;
                                        tm.scaleZ = 1
                                    }
                                    if (tm.svg) {
                                        tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
                                        tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d)
                                    }
                                }
                                if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
                                    if (invX) {
                                        tm.scaleX *= -1;
                                        tm.skewX += tm.rotation <= 0 ? 180 : -180;
                                        tm.rotation += tm.rotation <= 0 ? 180 : -180
                                    } else {
                                        tm.scaleY *= -1;
                                        tm.skewX += tm.skewX <= 0 ? 180 : -180
                                    }
                                }
                                tm.zOrigin = zOrigin;
                                for (i in tm) {
                                    if (tm[i] < min)
                                        if (tm[i] > -min) {
                                            tm[i] = 0
                                        }
                                }
                            }
                            if (rec) {
                                t._gsTransform = tm;
                                if (tm.svg) {
                                    if (_useSVGTransformAttr && t.style[_transformProp]) {
                                        TweenLite.delayedCall(.001, function() {
                                            _removeProp(t.style, _transformProp)
                                        })
                                    } else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
                                        TweenLite.delayedCall(.001, function() {
                                            t.removeAttribute("transform")
                                        })
                                    }
                                }
                            }
                            return tm
                        },
                        _setIETransformRatio = function(v) {
                            var t = this.data,
                                ang = -t.rotation * _DEG2RAD,
                                skew = ang + t.skewX * _DEG2RAD,
                                rnd = 1e5,
                                a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
                                b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
                                c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
                                d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
                                style = this.t.style,
                                cs = this.t.currentStyle,
                                filters, val;
                            if (!cs) {
                                return
                            }
                            val = b;
                            b = -c;
                            c = -val;
                            filters = cs.filter;
                            style.filter = "";
                            var w = this.t.offsetWidth,
                                h = this.t.offsetHeight,
                                clip = cs.position !== "absolute",
                                m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
                                ox = t.x + w * t.xPercent / 100,
                                oy = t.y + h * t.yPercent / 100,
                                dx, dy;
                            if (t.ox != null) {
                                dx = (t.oxp ? w * t.ox * .01 : t.ox) - w / 2;
                                dy = (t.oyp ? h * t.oy * .01 : t.oy) - h / 2;
                                ox += dx - (dx * a + dy * b);
                                oy += dy - (dx * c + dy * d)
                            }
                            if (!clip) {
                                m += ", sizingMethod='auto expand')"
                            } else {
                                dx = w / 2;
                                dy = h / 2;
                                m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")"
                            }
                            if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
                                style.filter = filters.replace(_ieSetMatrixExp, m)
                            } else {
                                style.filter = m + " " + filters
                            }
                            if (v === 0 || v === 1)
                                if (a === 1)
                                    if (b === 0)
                                        if (c === 0)
                                            if (d === 1)
                                                if (!clip || m.indexOf("Dx=0, Dy=0") !== -1)
                                                    if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100)
                                                        if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
                                                            style.removeAttribute("filter")
                                                        }
                            if (!clip) {
                                var mult = _ieVers < 8 ? 1 : -1,
                                    marg, prop, dif;
                                dx = t.ieOffsetX || 0;
                                dy = t.ieOffsetY || 0;
                                t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
                                t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
                                for (i = 0; i < 4; i++) {
                                    prop = _margins[i];
                                    marg = cs[prop];
                                    val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
                                    if (val !== t[prop]) {
                                        dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY
                                    } else {
                                        dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY
                                    }
                                    style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px"
                                }
                            }
                        },
                        _setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
                            var t = this.data,
                                style = this.t.style,
                                angle = t.rotation,
                                rotationX = t.rotationX,
                                rotationY = t.rotationY,
                                sx = t.scaleX,
                                sy = t.scaleY,
                                sz = t.scaleZ,
                                x = t.x,
                                y = t.y,
                                z = t.z,
                                isSVG = t.svg,
                                perspective = t.perspective,
                                force3D = t.force3D,
                                skewY = t.skewY,
                                skewX = t.skewX,
                                t1, a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43, zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
                            if (skewY) {
                                skewX += skewY;
                                angle += skewY
                            }
                            if (((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1 || _useSVGTransformAttr && isSVG || !_supports3D) {
                                if (angle || skewX || isSVG) {
                                    angle *= _DEG2RAD;
                                    skew = skewX * _DEG2RAD;
                                    rnd = 1e5;
                                    a11 = Math.cos(angle) * sx;
                                    a21 = Math.sin(angle) * sx;
                                    a12 = Math.sin(angle - skew) * -sy;
                                    a22 = Math.cos(angle - skew) * sy;
                                    if (skew && t.skewType === "simple") {
                                        t1 = Math.tan(skew - skewY * _DEG2RAD);
                                        t1 = Math.sqrt(1 + t1 * t1);
                                        a12 *= t1;
                                        a22 *= t1;
                                        if (skewY) {
                                            t1 = Math.tan(skewY * _DEG2RAD);
                                            t1 = Math.sqrt(1 + t1 * t1);
                                            a11 *= t1;
                                            a21 *= t1
                                        }
                                    }
                                    if (isSVG) {
                                        x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
                                        y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
                                        if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
                                            min = this.t.getBBox();
                                            x += t.xPercent * .01 * min.width;
                                            y += t.yPercent * .01 * min.height
                                        }
                                        min = 1e-6;
                                        if (x < min)
                                            if (x > -min) {
                                                x = 0
                                            }
                                        if (y < min)
                                            if (y > -min) {
                                                y = 0
                                            }
                                    }
                                    transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")";
                                    if (isSVG && _useSVGTransformAttr) {
                                        this.t.setAttribute("transform", "matrix(" + transform)
                                    } else {
                                        style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform
                                    }
                                } else {
                                    style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")"
                                }
                                return
                            }
                            if (_isFirefox) {
                                min = 1e-4;
                                if (sx < min && sx > -min) {
                                    sx = sz = 2e-5
                                }
                                if (sy < min && sy > -min) {
                                    sy = sz = 2e-5
                                }
                                if (perspective && !t.z && !t.rotationX && !t.rotationY) {
                                    perspective = 0
                                }
                            }
                            if (angle || skewX) {
                                angle *= _DEG2RAD;
                                cos = a11 = Math.cos(angle);
                                sin = a21 = Math.sin(angle);
                                if (skewX) {
                                    angle -= skewX * _DEG2RAD;
                                    cos = Math.cos(angle);
                                    sin = Math.sin(angle);
                                    if (t.skewType === "simple") {
                                        t1 = Math.tan((skewX - skewY) * _DEG2RAD);
                                        t1 = Math.sqrt(1 + t1 * t1);
                                        cos *= t1;
                                        sin *= t1;
                                        if (t.skewY) {
                                            t1 = Math.tan(skewY * _DEG2RAD);
                                            t1 = Math.sqrt(1 + t1 * t1);
                                            a11 *= t1;
                                            a21 *= t1
                                        }
                                    }
                                }
                                a12 = -sin;
                                a22 = cos
                            } else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
                                style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
                                return
                            } else {
                                a11 = a22 = 1;
                                a12 = a21 = 0
                            }
                            a33 = 1;
                            a13 = a23 = a31 = a32 = a41 = a42 = 0;
                            a43 = perspective ? -1 / perspective : 0;
                            zOrigin = t.zOrigin;
                            min = 1e-6;
                            comma = ",";
                            zero = "0";
                            angle = rotationY * _DEG2RAD;
                            if (angle) {
                                cos = Math.cos(angle);
                                sin = Math.sin(angle);
                                a31 = -sin;
                                a41 = a43 * -sin;
                                a13 = a11 * sin;
                                a23 = a21 * sin;
                                a33 = cos;
                                a43 *= cos;
                                a11 *= cos;
                                a21 *= cos
                            }
                            angle = rotationX * _DEG2RAD;
                            if (angle) {
                                cos = Math.cos(angle);
                                sin = Math.sin(angle);
                                t1 = a12 * cos + a13 * sin;
                                t2 = a22 * cos + a23 * sin;
                                a32 = a33 * sin;
                                a42 = a43 * sin;
                                a13 = a12 * -sin + a13 * cos;
                                a23 = a22 * -sin + a23 * cos;
                                a33 = a33 * cos;
                                a43 = a43 * cos;
                                a12 = t1;
                                a22 = t2
                            }
                            if (sz !== 1) {
                                a13 *= sz;
                                a23 *= sz;
                                a33 *= sz;
                                a43 *= sz
                            }
                            if (sy !== 1) {
                                a12 *= sy;
                                a22 *= sy;
                                a32 *= sy;
                                a42 *= sy
                            }
                            if (sx !== 1) {
                                a11 *= sx;
                                a21 *= sx;
                                a31 *= sx;
                                a41 *= sx
                            }
                            if (zOrigin || isSVG) {
                                if (zOrigin) {
                                    x += a13 * -zOrigin;
                                    y += a23 * -zOrigin;
                                    z += a33 * -zOrigin + zOrigin
                                }
                                if (isSVG) {
                                    x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
                                    y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset
                                }
                                if (x < min && x > -min) {
                                    x = zero
                                }
                                if (y < min && y > -min) {
                                    y = zero
                                }
                                if (z < min && z > -min) {
                                    z = 0
                                }
                            }
                            transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(";
                            transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31);
                            transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22);
                            if (rotationX || rotationY || sz !== 1) {
                                transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13);
                                transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma
                            } else {
                                transform += ",0,0,0,0,1,0,"
                            }
                            transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")";
                            style[_transformProp] = transform
                        };
                    p = Transform.prototype;
                    p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
                    p.scaleX = p.scaleY = p.scaleZ = 1;
                    _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                        parser: function(t, e, parsingProp, cssp, pt, plugin, vars) {
                            if (cssp._lastParsedTransform === vars) {
                                return pt
                            }
                            cssp._lastParsedTransform = vars;
                            var scaleFunc = vars.scale && typeof vars.scale === "function" ? vars.scale : 0,
                                swapFunc;
                            if (typeof vars[parsingProp] === "function") {
                                swapFunc = vars[parsingProp];
                                vars[parsingProp] = e
                            }
                            if (scaleFunc) {
                                vars.scale = scaleFunc(_index, t)
                            }
                            var originalGSTransform = t._gsTransform,
                                style = t.style,
                                min = 1e-6,
                                i = _transformProps.length,
                                v = vars,
                                endRotations = {},
                                transformOriginString = "transformOrigin",
                                m1 = _getTransform(t, _cs, true, v.parseTransform),
                                orig = v.transform && (typeof v.transform === "function" ? v.transform(_index, _target) : v.transform),
                                m2, copy, has3D, hasChange, dr, x, y, matrix, p;
                            m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
                            cssp._transform = m1;
                            if (orig && typeof orig === "string" && _transformProp) {
                                copy = _tempDiv.style;
                                copy[_transformProp] = orig;
                                copy.display = "block";
                                copy.position = "absolute";
                                _doc.body.appendChild(_tempDiv);
                                m2 = _getTransform(_tempDiv, null, false);
                                if (m1.skewType === "simple") {
                                    m2.scaleY *= Math.cos(m2.skewX * _DEG2RAD)
                                }
                                if (m1.svg) {
                                    x = m1.xOrigin;
                                    y = m1.yOrigin;
                                    m2.x -= m1.xOffset;
                                    m2.y -= m1.yOffset;
                                    if (v.transformOrigin || v.svgOrigin) {
                                        orig = {};
                                        _parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
                                        x = orig.xOrigin;
                                        y = orig.yOrigin;
                                        m2.x -= orig.xOffset - m1.xOffset;
                                        m2.y -= orig.yOffset - m1.yOffset
                                    }
                                    if (x || y) {
                                        matrix = _getMatrix(_tempDiv, true);
                                        m2.x -= x - (x * matrix[0] + y * matrix[2]);
                                        m2.y -= y - (x * matrix[1] + y * matrix[3])
                                    }
                                }
                                _doc.body.removeChild(_tempDiv);
                                if (!m2.perspective) {
                                    m2.perspective = m1.perspective
                                }
                                if (v.xPercent != null) {
                                    m2.xPercent = _parseVal(v.xPercent, m1.xPercent)
                                }
                                if (v.yPercent != null) {
                                    m2.yPercent = _parseVal(v.yPercent, m1.yPercent)
                                }
                            } else if (typeof v === "object") {
                                m2 = {
                                    scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
                                    scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
                                    scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
                                    x: _parseVal(v.x, m1.x),
                                    y: _parseVal(v.y, m1.y),
                                    z: _parseVal(v.z, m1.z),
                                    xPercent: _parseVal(v.xPercent, m1.xPercent),
                                    yPercent: _parseVal(v.yPercent, m1.yPercent),
                                    perspective: _parseVal(v.transformPerspective, m1.perspective)
                                };
                                dr = v.directionalRotation;
                                if (dr != null) {
                                    if (typeof dr === "object") {
                                        for (copy in dr) {
                                            v[copy] = dr[copy]
                                        }
                                    } else {
                                        v.rotation = dr
                                    }
                                }
                                if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
                                    m2.x = 0;
                                    m2.xPercent = _parseVal(v.x, m1.xPercent)
                                }
                                if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
                                    m2.y = 0;
                                    m2.yPercent = _parseVal(v.y, m1.yPercent)
                                }
                                m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
                                if (_supports3D) {
                                    m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
                                    m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations)
                                }
                                m2.skewX = _parseAngle(v.skewX, m1.skewX);
                                m2.skewY = _parseAngle(v.skewY, m1.skewY)
                            }
                            if (_supports3D && v.force3D != null) {
                                m1.force3D = v.force3D;
                                hasChange = true
                            }
                            has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;
                            if (!has3D && v.scale != null) {
                                m2.scaleZ = 1
                            }
                            while (--i > -1) {
                                p = _transformProps[i];
                                orig = m2[p] - m1[p];
                                if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
                                    hasChange = true;
                                    pt = new CSSPropTween(m1, p, m1[p], orig, pt);
                                    if (p in endRotations) {
                                        pt.e = endRotations[p]
                                    }
                                    pt.xs0 = 0;
                                    pt.plugin = plugin;
                                    cssp._overwriteProps.push(pt.n)
                                }
                            }
                            orig = v.transformOrigin;
                            if (m1.svg && (orig || v.svgOrigin)) {
                                x = m1.xOffset;
                                y = m1.yOffset;
                                _parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
                                pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString);
                                pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
                                if (x !== m1.xOffset || y !== m1.yOffset) {
                                    pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString);
                                    pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString)
                                }
                                orig = "0px 0px"
                            }
                            if (orig || _supports3D && has3D && m1.zOrigin) {
                                if (_transformProp) {
                                    hasChange = true;
                                    p = _transformOriginProp;
                                    orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + "";
                                    pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
                                    pt.b = style[p];
                                    pt.plugin = plugin;
                                    if (_supports3D) {
                                        copy = m1.zOrigin;
                                        orig = orig.split(" ");
                                        m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0;
                                        pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px";
                                        pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n);
                                        pt.b = copy;
                                        pt.xs0 = pt.e = m1.zOrigin
                                    } else {
                                        pt.xs0 = pt.e = orig
                                    }
                                } else {
                                    _parsePosition(orig + "", m1)
                                }
                            }
                            if (hasChange) {
                                cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2
                            }
                            if (swapFunc) {
                                vars[parsingProp] = swapFunc
                            }
                            if (scaleFunc) {
                                vars.scale = scaleFunc
                            }
                            return pt
                        },
                        prefix: true
                    });
                    _registerComplexSpecialProp("boxShadow", {
                        defaultValue: "0px 0px 0px 0px #999",
                        prefix: true,
                        color: true,
                        multi: true,
                        keyword: "inset"
                    });
                    _registerComplexSpecialProp("borderRadius", {
                        defaultValue: "0px",
                        parser: function(t, e, p, cssp, pt, plugin) {
                            e = this.format(e);
                            var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                style = t.style,
                                ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
                            w = parseFloat(t.offsetWidth);
                            h = parseFloat(t.offsetHeight);
                            ea1 = e.split(" ");
                            for (i = 0; i < props.length; i++) {
                                if (this.p.indexOf("border")) {
                                    props[i] = _checkPropPrefix(props[i])
                                }
                                bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
                                if (bs.indexOf(" ") !== -1) {
                                    bs2 = bs.split(" ");
                                    bs = bs2[0];
                                    bs2 = bs2[1]
                                }
                                es = es2 = ea1[i];
                                bn = parseFloat(bs);
                                bsfx = bs.substr((bn + "").length);
                                rel = es.charAt(1) === "=";
                                if (rel) {
                                    en = parseInt(es.charAt(0) + "1", 10);
                                    es = es.substr(2);
                                    en *= parseFloat(es);
                                    esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || ""
                                } else {
                                    en = parseFloat(es);
                                    esfx = es.substr((en + "").length)
                                }
                                if (esfx === "") {
                                    esfx = _suffixMap[p] || bsfx
                                }
                                if (esfx !== bsfx) {
                                    hn = _convertToPixels(t, "borderLeft", bn, bsfx);
                                    vn = _convertToPixels(t, "borderTop", bn, bsfx);
                                    if (esfx === "%") {
                                        bs = hn / w * 100 + "%";
                                        bs2 = vn / h * 100 + "%"
                                    } else if (esfx === "em") {
                                        em = _convertToPixels(t, "borderLeft", 1, "em");
                                        bs = hn / em + "em";
                                        bs2 = vn / em + "em"
                                    } else {
                                        bs = hn + "px";
                                        bs2 = vn + "px"
                                    }
                                    if (rel) {
                                        es = parseFloat(bs) + en + esfx;
                                        es2 = parseFloat(bs2) + en + esfx
                                    }
                                }
                                pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt)
                            }
                            return pt
                        },
                        prefix: true,
                        formatter: _getFormatter("0px 0px 0px 0px", false, true)
                    });
                    _registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                        defaultValue: "0px",
                        parser: function(t, e, p, cssp, pt, plugin) {
                            return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt)
                        },
                        prefix: true,
                        formatter: _getFormatter("0px 0px", false, true)
                    });
                    _registerComplexSpecialProp("backgroundPosition", {
                        defaultValue: "0 0",
                        parser: function(t, e, p, cssp, pt, plugin) {
                            var bp = "background-position",
                                cs = _cs || _getComputedStyle(t, null),
                                bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                                es = this.format(e),
                                ba, ea, i, pct, overlap, src;
                            if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
                                src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
                                if (src && src !== "none") {
                                    ba = bs.split(" ");
                                    ea = es.split(" ");
                                    _tempImg.setAttribute("src", src);
                                    i = 2;
                                    while (--i > -1) {
                                        bs = ba[i];
                                        pct = bs.indexOf("%") !== -1;
                                        if (pct !== (ea[i].indexOf("%") !== -1)) {
                                            overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
                                            ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%"
                                        }
                                    }
                                    bs = ba.join(" ")
                                }
                            }
                            return this.parseComplex(t.style, bs, es, pt, plugin)
                        },
                        formatter: _parsePosition
                    });
                    _registerComplexSpecialProp("backgroundSize", {
                        defaultValue: "0 0",
                        formatter: function(v) {
                            v += "";
                            return _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v)
                        }
                    });
                    _registerComplexSpecialProp("perspective", {
                        defaultValue: "0px",
                        prefix: true
                    });
                    _registerComplexSpecialProp("perspectiveOrigin", {
                        defaultValue: "50% 50%",
                        prefix: true
                    });
                    _registerComplexSpecialProp("transformStyle", {
                        prefix: true
                    });
                    _registerComplexSpecialProp("backfaceVisibility", {
                        prefix: true
                    });
                    _registerComplexSpecialProp("userSelect", {
                        prefix: true
                    });
                    _registerComplexSpecialProp("margin", {
                        parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
                    });
                    _registerComplexSpecialProp("padding", {
                        parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
                    });
                    _registerComplexSpecialProp("clip", {
                        defaultValue: "rect(0px,0px,0px,0px)",
                        parser: function(t, e, p, cssp, pt, plugin) {
                            var b, cs, delim;
                            if (_ieVers < 9) {
                                cs = t.currentStyle;
                                delim = _ieVers < 8 ? " " : ",";
                                b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
                                e = this.format(e).split(",").join(delim)
                            } else {
                                b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
                                e = this.format(e)
                            }
                            return this.parseComplex(t.style, b, e, pt, plugin)
                        }
                    });
                    _registerComplexSpecialProp("textShadow", {
                        defaultValue: "0px 0px 0px #999",
                        color: true,
                        multi: true
                    });
                    _registerComplexSpecialProp("autoRound,strictUnits", {
                        parser: function(t, e, p, cssp, pt) {
                            return pt
                        }
                    });
                    _registerComplexSpecialProp("border", {
                        defaultValue: "0px solid #000",
                        parser: function(t, e, p, cssp, pt, plugin) {
                            var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
                                end = this.format(e).split(" "),
                                esfx = end[0].replace(_suffixExp, "");
                            if (esfx !== "px") {
                                bw = parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx) + esfx
                            }
                            return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin)
                        },
                        color: true,
                        formatter: function(v) {
                            var a = v.split(" ");
                            return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0]
                        }
                    });
                    _registerComplexSpecialProp("borderWidth", {
                        parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                    });
                    _registerComplexSpecialProp("float,cssFloat,styleFloat", {
                        parser: function(t, e, p, cssp, pt, plugin) {
                            var s = t.style,
                                prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
                            return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e)
                        }
                    });
                    var _setIEOpacityRatio = function(v) {
                        var t = this.t,
                            filters = t.filter || _getStyle(this.data, "filter") || "",
                            val = this.s + this.c * v | 0,
                            skip;
                        if (val === 100) {
                            if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
                                t.removeAttribute("filter");
                                skip = !_getStyle(this.data, "filter")
                            } else {
                                t.filter = filters.replace(_alphaFilterExp, "");
                                skip = true
                            }
                        }
                        if (!skip) {
                            if (this.xn1) {
                                t.filter = filters = filters || "alpha(opacity=" + val + ")"
                            }
                            if (filters.indexOf("pacity") === -1) {
                                if (val !== 0 || !this.xn1) {
                                    t.filter = filters + " alpha(opacity=" + val + ")"
                                }
                            } else {
                                t.filter = filters.replace(_opacityExp, "opacity=" + val)
                            }
                        }
                    };
                    _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
                        defaultValue: "1",
                        parser: function(t, e, p, cssp, pt, plugin) {
                            var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
                                style = t.style,
                                isAutoAlpha = p === "autoAlpha";
                            if (typeof e === "string" && e.charAt(1) === "=") {
                                e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b
                            }
                            if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
                                b = 0
                            }
                            if (_supportsOpacity) {
                                pt = new CSSPropTween(style, "opacity", b, e - b, pt)
                            } else {
                                pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
                                pt.xn1 = isAutoAlpha ? 1 : 0;
                                style.zoom = 1;
                                pt.type = 2;
                                pt.b = "alpha(opacity=" + pt.s + ")";
                                pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
                                pt.data = t;
                                pt.plugin = plugin;
                                pt.setRatio = _setIEOpacityRatio
                            }
                            if (isAutoAlpha) {
                                pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
                                pt.xs0 = "inherit";
                                cssp._overwriteProps.push(pt.n);
                                cssp._overwriteProps.push(p)
                            }
                            return pt
                        }
                    });
                    var _removeProp = function(s, p) {
                            if (p) {
                                if (s.removeProperty) {
                                    if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
                                        p = "-" + p
                                    }
                                    s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase())
                                } else {
                                    s.removeAttribute(p)
                                }
                            }
                        },
                        _setClassNameRatio = function(v) {
                            this.t._gsClassPT = this;
                            if (v === 1 || v === 0) {
                                this.t.setAttribute("class", v === 0 ? this.b : this.e);
                                var mpt = this.data,
                                    s = this.t.style;
                                while (mpt) {
                                    if (!mpt.v) {
                                        _removeProp(s, mpt.p)
                                    } else {
                                        s[mpt.p] = mpt.v
                                    }
                                    mpt = mpt._next
                                }
                                if (v === 1 && this.t._gsClassPT === this) {
                                    this.t._gsClassPT = null
                                }
                            } else if (this.t.getAttribute("class") !== this.e) {
                                this.t.setAttribute("class", this.e)
                            }
                        };
                    _registerComplexSpecialProp("className", {
                        parser: function(t, e, p, cssp, pt, plugin, vars) {
                            var b = t.getAttribute("class") || "",
                                cssText = t.style.cssText,
                                difData, bs, cnpt, cnptLookup, mpt;
                            pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
                            pt.setRatio = _setClassNameRatio;
                            pt.pr = -11;
                            _hasPriority = true;
                            pt.b = b;
                            bs = _getAllStyles(t, _cs);
                            cnpt = t._gsClassPT;
                            if (cnpt) {
                                cnptLookup = {};
                                mpt = cnpt.data;
                                while (mpt) {
                                    cnptLookup[mpt.p] = 1;
                                    mpt = mpt._next
                                }
                                cnpt.setRatio(1)
                            }
                            t._gsClassPT = pt;
                            pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
                            t.setAttribute("class", pt.e);
                            difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
                            t.setAttribute("class", b);
                            pt.data = difData.firstMPT;
                            t.style.cssText = cssText;
                            pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin);
                            return pt
                        }
                    });
                    var _setClearPropsRatio = function(v) {
                        if (v === 1 || v === 0)
                            if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
                                var s = this.t.style,
                                    transformParse = _specialProps.transform.parse,
                                    a, p, i, clearTransform, transform;
                                if (this.e === "all") {
                                    s.cssText = "";
                                    clearTransform = true
                                } else {
                                    a = this.e.split(" ").join("").split(",");
                                    i = a.length;
                                    while (--i > -1) {
                                        p = a[i];
                                        if (_specialProps[p]) {
                                            if (_specialProps[p].parse === transformParse) {
                                                clearTransform = true
                                            } else {
                                                p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p
                                            }
                                        }
                                        _removeProp(s, p)
                                    }
                                }
                                if (clearTransform) {
                                    _removeProp(s, _transformProp);
                                    transform = this.t._gsTransform;
                                    if (transform) {
                                        if (transform.svg) {
                                            this.t.removeAttribute("data-svg-origin");
                                            this.t.removeAttribute("transform")
                                        }
                                        delete this.t._gsTransform
                                    }
                                }
                            }
                    };
                    _registerComplexSpecialProp("clearProps", {
                        parser: function(t, e, p, cssp, pt) {
                            pt = new CSSPropTween(t, p, 0, 0, pt, 2);
                            pt.setRatio = _setClearPropsRatio;
                            pt.e = e;
                            pt.pr = -10;
                            pt.data = cssp._tween;
                            _hasPriority = true;
                            return pt
                        }
                    });
                    p = "bezier,throwProps,physicsProps,physics2D".split(",");
                    i = p.length;
                    while (i--) {
                        _registerPluginProp(p[i])
                    }
                    p = CSSPlugin.prototype;
                    p._firstPT = p._lastParsedTransform = p._transform = null;
                    p._onInitTween = function(target, vars, tween, index) {
                        if (!target.nodeType) {
                            return false
                        }
                        this._target = _target = target;
                        this._tween = tween;
                        this._vars = vars;
                        _index = index;
                        _autoRound = vars.autoRound;
                        _hasPriority = false;
                        _suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
                        _cs = _getComputedStyle(target, "");
                        _overwriteProps = this._overwriteProps;
                        var style = target.style,
                            v, pt, pt2, first, last, next, zIndex, tpt, threeD;
                        if (_reqSafariFix)
                            if (style.zIndex === "") {
                                v = _getStyle(target, "zIndex", _cs);
                                if (v === "auto" || v === "") {
                                    this._addLazySet(style, "zIndex", 0)
                                }
                            }
                        if (typeof vars === "string") {
                            first = style.cssText;
                            v = _getAllStyles(target, _cs);
                            style.cssText = first + ";" + vars;
                            v = _cssDif(target, v, _getAllStyles(target)).difs;
                            if (!_supportsOpacity && _opacityValExp.test(vars)) {
                                v.opacity = parseFloat(RegExp.$1)
                            }
                            vars = v;
                            style.cssText = first
                        }
                        if (vars.className) {
                            this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars)
                        } else {
                            this._firstPT = pt = this.parse(target, vars, null)
                        }
                        if (this._transformType) {
                            threeD = this._transformType === 3;
                            if (!_transformProp) {
                                style.zoom = 1
                            } else if (_isSafari) {
                                _reqSafariFix = true;
                                if (style.zIndex === "") {
                                    zIndex = _getStyle(target, "zIndex", _cs);
                                    if (zIndex === "auto" || zIndex === "") {
                                        this._addLazySet(style, "zIndex", 0)
                                    }
                                }
                                if (_isSafariLT6) {
                                    this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"))
                                }
                            }
                            pt2 = pt;
                            while (pt2 && pt2._next) {
                                pt2 = pt2._next
                            }
                            tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
                            this._linkCSSP(tpt, null, pt2);
                            tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
                            tpt.data = this._transform || _getTransform(target, _cs, true);
                            tpt.tween = tween;
                            tpt.pr = -1;
                            _overwriteProps.pop()
                        }
                        if (_hasPriority) {
                            while (pt) {
                                next = pt._next;
                                pt2 = first;
                                while (pt2 && pt2.pr > pt.pr) {
                                    pt2 = pt2._next
                                }
                                if (pt._prev = pt2 ? pt2._prev : last) {
                                    pt._prev._next = pt
                                } else {
                                    first = pt
                                }
                                if (pt._next = pt2) {
                                    pt2._prev = pt
                                } else {
                                    last = pt
                                }
                                pt = next
                            }
                            this._firstPT = first
                        }
                        return true
                    };
                    p.parse = function(target, vars, pt, plugin) {
                        var style = target.style,
                            p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
                        for (p in vars) {
                            es = vars[p];
                            if (typeof es === "function") {
                                es = es(_index, _target)
                            }
                            sp = _specialProps[p];
                            if (sp) {
                                pt = sp.parse(target, es, p, this, pt, plugin, vars)
                            } else if (p.substr(0, 2) === "--") {
                                this._tween._propLookup[p] = this._addTween.call(this._tween, target.style, "setProperty", _getComputedStyle(target).getPropertyValue(p) + "", es + "", p, false, p);
                                continue
                            } else {
                                bs = _getStyle(target, p, _cs) + "";
                                isStr = typeof es === "string";
                                if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
                                    if (!isStr) {
                                        es = _parseColor(es);
                                        es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")"
                                    }
                                    pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin)
                                } else if (isStr && _complexExp.test(es)) {
                                    pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin)
                                } else {
                                    bn = parseFloat(bs);
                                    bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : "";
                                    if (bs === "" || bs === "auto") {
                                        if (p === "width" || p === "height") {
                                            bn = _getDimension(target, p, _cs);
                                            bsfx = "px"
                                        } else if (p === "left" || p === "top") {
                                            bn = _calculateOffset(target, p, _cs);
                                            bsfx = "px"
                                        } else {
                                            bn = p !== "opacity" ? 0 : 1;
                                            bsfx = ""
                                        }
                                    }
                                    rel = isStr && es.charAt(1) === "=";
                                    if (rel) {
                                        en = parseInt(es.charAt(0) + "1", 10);
                                        es = es.substr(2);
                                        en *= parseFloat(es);
                                        esfx = es.replace(_suffixExp, "")
                                    } else {
                                        en = parseFloat(es);
                                        esfx = isStr ? es.replace(_suffixExp, "") : ""
                                    }
                                    if (esfx === "") {
                                        esfx = p in _suffixMap ? _suffixMap[p] : bsfx
                                    }
                                    es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p];
                                    if (bsfx !== esfx)
                                        if (esfx !== "" || p === "lineHeight")
                                            if (en || en === 0)
                                                if (bn) {
                                                    bn = _convertToPixels(target, p, bn, bsfx);
                                                    if (esfx === "%") {
                                                        bn /= _convertToPixels(target, p, 100, "%") / 100;
                                                        if (vars.strictUnits !== true) {
                                                            bs = bn + "%"
                                                        }
                                                    } else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
                                                        bn /= _convertToPixels(target, p, 1, esfx)
                                                    } else if (esfx !== "px") {
                                                        en = _convertToPixels(target, p, en, esfx);
                                                        esfx = "px"
                                                    }
                                                    if (rel)
                                                        if (en || en === 0) {
                                                            es = en + bn + esfx
                                                        }
                                                }
                                    if (rel) {
                                        en += bn
                                    }
                                    if ((bn || bn === 0) && (en || en === 0)) {
                                        pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
                                        pt.xs0 = esfx
                                    } else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
                                        _log("invalid " + p + " tween value: " + vars[p])
                                    } else {
                                        pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
                                        pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es
                                    }
                                }
                            }
                            if (plugin)
                                if (pt && !pt.plugin) {
                                    pt.plugin = plugin
                                }
                        }
                        return pt
                    };
                    p.setRatio = function(v) {
                        var pt = this._firstPT,
                            min = 1e-6,
                            val, str, i;
                        if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
                            while (pt) {
                                if (pt.type !== 2) {
                                    if (pt.r && pt.type !== -1) {
                                        val = Math.round(pt.s + pt.c);
                                        if (!pt.type) {
                                            pt.t[pt.p] = val + pt.xs0
                                        } else if (pt.type === 1) {
                                            i = pt.l;
                                            str = pt.xs0 + val + pt.xs1;
                                            for (i = 1; i < pt.l; i++) {
                                                str += pt["xn" + i] + pt["xs" + (i + 1)]
                                            }
                                            pt.t[pt.p] = str
                                        }
                                    } else {
                                        pt.t[pt.p] = pt.e
                                    }
                                } else {
                                    pt.setRatio(v)
                                }
                                pt = pt._next
                            }
                        } else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -1e-6) {
                            while (pt) {
                                val = pt.c * v + pt.s;
                                if (pt.r) {
                                    val = Math.round(val)
                                } else if (val < min)
                                    if (val > -min) {
                                        val = 0
                                    }
                                if (!pt.type) {
                                    pt.t[pt.p] = val + pt.xs0
                                } else if (pt.type === 1) {
                                    i = pt.l;
                                    if (i === 2) {
                                        pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2
                                    } else if (i === 3) {
                                        pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3
                                    } else if (i === 4) {
                                        pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4
                                    } else if (i === 5) {
                                        pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5
                                    } else {
                                        str = pt.xs0 + val + pt.xs1;
                                        for (i = 1; i < pt.l; i++) {
                                            str += pt["xn" + i] + pt["xs" + (i + 1)]
                                        }
                                        pt.t[pt.p] = str
                                    }
                                } else if (pt.type === -1) {
                                    pt.t[pt.p] = pt.xs0
                                } else if (pt.setRatio) {
                                    pt.setRatio(v)
                                }
                                pt = pt._next
                            }
                        } else {
                            while (pt) {
                                if (pt.type !== 2) {
                                    pt.t[pt.p] = pt.b
                                } else {
                                    pt.setRatio(v)
                                }
                                pt = pt._next
                            }
                        }
                    };
                    p._enableTransforms = function(threeD) {
                        this._transform = this._transform || _getTransform(this._target, _cs, true);
                        this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2
                    };
                    var lazySet = function(v) {
                        this.t[this.p] = this.e;
                        this.data._linkCSSP(this, this._next, null, true)
                    };
                    p._addLazySet = function(t, p, v) {
                        var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
                        pt.e = v;
                        pt.setRatio = lazySet;
                        pt.data = this
                    };
                    p._linkCSSP = function(pt, next, prev, remove) {
                        if (pt) {
                            if (next) {
                                next._prev = pt
                            }
                            if (pt._next) {
                                pt._next._prev = pt._prev
                            }
                            if (pt._prev) {
                                pt._prev._next = pt._next
                            } else if (this._firstPT === pt) {
                                this._firstPT = pt._next;
                                remove = true
                            }
                            if (prev) {
                                prev._next = pt
                            } else if (!remove && this._firstPT === null) {
                                this._firstPT = pt
                            }
                            pt._next = next;
                            pt._prev = prev
                        }
                        return pt
                    };
                    p._mod = function(lookup) {
                        var pt = this._firstPT;
                        while (pt) {
                            if (typeof lookup[pt.p] === "function" && lookup[pt.p] === Math.round) {
                                pt.r = 1
                            }
                            pt = pt._next
                        }
                    };
                    p._kill = function(lookup) {
                        var copy = lookup,
                            pt, p, xfirst;
                        if (lookup.autoAlpha || lookup.alpha) {
                            copy = {};
                            for (p in lookup) {
                                copy[p] = lookup[p]
                            }
                            copy.opacity = 1;
                            if (copy.autoAlpha) {
                                copy.visibility = 1
                            }
                        }
                        if (lookup.className && (pt = this._classNamePT)) {
                            xfirst = pt.xfirst;
                            if (xfirst && xfirst._prev) {
                                this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev)
                            } else if (xfirst === this._firstPT) {
                                this._firstPT = pt._next
                            }
                            if (pt._next) {
                                this._linkCSSP(pt._next, pt._next._next, xfirst._prev)
                            }
                            this._classNamePT = null
                        }
                        pt = this._firstPT;
                        while (pt) {
                            if (pt.plugin && pt.plugin !== p && pt.plugin._kill) {
                                pt.plugin._kill(lookup);
                                p = pt.plugin
                            }
                            pt = pt._next
                        }
                        return TweenPlugin.prototype._kill.call(this, copy)
                    };
                    var _getChildStyles = function(e, props, targets) {
                        var children, i, child, type;
                        if (e.slice) {
                            i = e.length;
                            while (--i > -1) {
                                _getChildStyles(e[i], props, targets)
                            }
                            return
                        }
                        children = e.childNodes;
                        i = children.length;
                        while (--i > -1) {
                            child = children[i];
                            type = child.type;
                            if (child.style) {
                                props.push(_getAllStyles(child));
                                if (targets) {
                                    targets.push(child)
                                }
                            }
                            if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
                                _getChildStyles(child, props, targets)
                            }
                        }
                    };
                    CSSPlugin.cascadeTo = function(target, duration, vars) {
                        var tween = TweenLite.to(target, duration, vars),
                            results = [tween],
                            b = [],
                            e = [],
                            targets = [],
                            _reservedProps = TweenLite._internals.reservedProps,
                            i, difs, p, from;
                        target = tween._targets || tween.target;
                        _getChildStyles(target, b, targets);
                        tween.render(duration, true, true);
                        _getChildStyles(target, e);
                        tween.render(0, true, true);
                        tween._enabled(true);
                        i = targets.length;
                        while (--i > -1) {
                            difs = _cssDif(targets[i], b[i], e[i]);
                            if (difs.firstMPT) {
                                difs = difs.difs;
                                for (p in vars) {
                                    if (_reservedProps[p]) {
                                        difs[p] = vars[p]
                                    }
                                }
                                from = {};
                                for (p in difs) {
                                    from[p] = b[i][p]
                                }
                                results.push(TweenLite.fromTo(targets[i], duration, from, difs))
                            }
                        }
                        return results
                    };
                    TweenPlugin.activate([CSSPlugin]);
                    return CSSPlugin
                }, true);
                (function() {
                    var RoundPropsPlugin = _gsScope._gsDefine.plugin({
                            propName: "roundProps",
                            version: "1.6.0",
                            priority: -1,
                            API: 2,
                            init: function(target, value, tween) {
                                this._tween = tween;
                                return true
                            }
                        }),
                        _roundLinkedList = function(node) {
                            while (node) {
                                if (!node.f && !node.blob) {
                                    node.m = Math.round
                                }
                                node = node._next
                            }
                        },
                        p = RoundPropsPlugin.prototype;
                    p._onInitAllProps = function() {
                        var tween = this._tween,
                            rp = tween.vars.roundProps.join ? tween.vars.roundProps : tween.vars.roundProps.split(","),
                            i = rp.length,
                            lookup = {},
                            rpt = tween._propLookup.roundProps,
                            prop, pt, next;
                        while (--i > -1) {
                            lookup[rp[i]] = Math.round
                        }
                        i = rp.length;
                        while (--i > -1) {
                            prop = rp[i];
                            pt = tween._firstPT;
                            while (pt) {
                                next = pt._next;
                                if (pt.pg) {
                                    pt.t._mod(lookup)
                                } else if (pt.n === prop) {
                                    if (pt.f === 2 && pt.t) {
                                        _roundLinkedList(pt.t._firstPT)
                                    } else {
                                        this._add(pt.t, prop, pt.s, pt.c);
                                        if (next) {
                                            next._prev = pt._prev
                                        }
                                        if (pt._prev) {
                                            pt._prev._next = next
                                        } else if (tween._firstPT === pt) {
                                            tween._firstPT = next
                                        }
                                        pt._next = pt._prev = null;
                                        tween._propLookup[prop] = rpt
                                    }
                                }
                                pt = next
                            }
                        }
                        return false
                    };
                    p._add = function(target, p, s, c) {
                        this._addTween(target, p, s, s + c, p, Math.round);
                        this._overwriteProps.push(p)
                    }
                })();
                (function() {
                    _gsScope._gsDefine.plugin({
                        propName: "attr",
                        API: 2,
                        version: "0.6.1",
                        init: function(target, value, tween, index) {
                            var p, end;
                            if (typeof target.setAttribute !== "function") {
                                return false
                            }
                            for (p in value) {
                                end = value[p];
                                if (typeof end === "function") {
                                    end = end(index, target)
                                }
                                this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
                                this._overwriteProps.push(p)
                            }
                            return true
                        }
                    })
                })();
                _gsScope._gsDefine.plugin({
                    propName: "directionalRotation",
                    version: "0.3.1",
                    API: 2,
                    init: function(target, value, tween, index) {
                        if (typeof value !== "object") {
                            value = {
                                rotation: value
                            }
                        }
                        this.finals = {};
                        var cap = value.useRadians === true ? Math.PI * 2 : 360,
                            min = 1e-6,
                            p, v, start, end, dif, split;
                        for (p in value) {
                            if (p !== "useRadians") {
                                end = value[p];
                                if (typeof end === "function") {
                                    end = end(index, target)
                                }
                                split = (end + "").split("_");
                                v = split[0];
                                start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
                                end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
                                dif = end - start;
                                if (split.length) {
                                    v = split.join("_");
                                    if (v.indexOf("short") !== -1) {
                                        dif = dif % cap;
                                        if (dif !== dif % (cap / 2)) {
                                            dif = dif < 0 ? dif + cap : dif - cap
                                        }
                                    }
                                    if (v.indexOf("_cw") !== -1 && dif < 0) {
                                        dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap
                                    } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                                        dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap
                                    }
                                }
                                if (dif > min || dif < -min) {
                                    this._addTween(target, p, start, start + dif, p);
                                    this._overwriteProps.push(p)
                                }
                            }
                        }
                        return true
                    },
                    set: function(ratio) {
                        var pt;
                        if (ratio !== 1) {
                            this._super.setRatio.call(this, ratio)
                        } else {
                            pt = this._firstPT;
                            while (pt) {
                                if (pt.f) {
                                    pt.t[pt.p](this.finals[pt.p])
                                } else {
                                    pt.t[pt.p] = this.finals[pt.p]
                                }
                                pt = pt._next
                            }
                        }
                    }
                })._autoCSS = true;
                _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
                    var w = _gsScope.GreenSockGlobals || _gsScope,
                        gs = w.com.greensock,
                        _2PI = Math.PI * 2,
                        _HALF_PI = Math.PI / 2,
                        _class = gs._class,
                        _create = function(n, f) {
                            var C = _class("easing." + n, function() {}, true),
                                p = C.prototype = new Ease;
                            p.constructor = C;
                            p.getRatio = f;
                            return C
                        },
                        _easeReg = Ease.register || function() {},
                        _wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
                            var C = _class("easing." + name, {
                                easeOut: new EaseOut,
                                easeIn: new EaseIn,
                                easeInOut: new EaseInOut
                            }, true);
                            _easeReg(C, name);
                            return C
                        },
                        EasePoint = function(time, value, next) {
                            this.t = time;
                            this.v = value;
                            if (next) {
                                this.next = next;
                                next.prev = this;
                                this.c = next.v - value;
                                this.gap = next.t - time
                            }
                        },
                        _createBack = function(n, f) {
                            var C = _class("easing." + n, function(overshoot) {
                                    this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
                                    this._p2 = this._p1 * 1.525
                                }, true),
                                p = C.prototype = new Ease;
                            p.constructor = C;
                            p.getRatio = f;
                            p.config = function(overshoot) {
                                return new C(overshoot)
                            };
                            return C
                        },
                        Back = _wrap("Back", _createBack("BackOut", function(p) {
                            return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1
                        }), _createBack("BackIn", function(p) {
                            return p * p * ((this._p1 + 1) * p - this._p1)
                        }), _createBack("BackInOut", function(p) {
                            return (p *= 2) < 1 ? .5 * p * p * ((this._p2 + 1) * p - this._p2) : .5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2)
                        })),
                        SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
                            power = power || power === 0 ? power : .7;
                            if (linearRatio == null) {
                                linearRatio = .7
                            } else if (linearRatio > 1) {
                                linearRatio = 1
                            }
                            this._p = linearRatio !== 1 ? power : 0;
                            this._p1 = (1 - linearRatio) / 2;
                            this._p2 = linearRatio;
                            this._p3 = this._p1 + this._p2;
                            this._calcEnd = yoyoMode === true
                        }, true),
                        p = SlowMo.prototype = new Ease,
                        SteppedEase, ExpoScaleEase, RoughEase, _createElastic;
                    p.constructor = SlowMo;
                    p.getRatio = function(p) {
                        var r = p + (.5 - p) * this._p;
                        if (p < this._p1) {
                            return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r
                        } else if (p > this._p3) {
                            return this._calcEnd ? p === 1 ? 0 : 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p
                        }
                        return this._calcEnd ? 1 : r
                    };
                    SlowMo.ease = new SlowMo(.7, .7);
                    p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
                        return new SlowMo(linearRatio, power, yoyoMode)
                    };
                    SteppedEase = _class("easing.SteppedEase", function(steps, immediateStart) {
                        steps = steps || 1;
                        this._p1 = 1 / steps;
                        this._p2 = steps + (immediateStart ? 0 : 1);
                        this._p3 = immediateStart ? 1 : 0
                    }, true);
                    p = SteppedEase.prototype = new Ease;
                    p.constructor = SteppedEase;
                    p.getRatio = function(p) {
                        if (p < 0) {
                            p = 0
                        } else if (p >= 1) {
                            p = .999999999
                        }
                        return ((this._p2 * p | 0) + this._p3) * this._p1
                    };
                    p.config = SteppedEase.config = function(steps, immediateStart) {
                        return new SteppedEase(steps, immediateStart)
                    };
                    ExpoScaleEase = _class("easing.ExpoScaleEase", function(start, end, ease) {
                        this._p1 = Math.log(end / start);
                        this._p2 = end - start;
                        this._p3 = start;
                        this._ease = ease
                    }, true);
                    p = ExpoScaleEase.prototype = new Ease;
                    p.constructor = ExpoScaleEase;
                    p.getRatio = function(p) {
                        if (this._ease) {
                            p = this._ease.getRatio(p)
                        }
                        return (this._p3 * Math.exp(this._p1 * p) - this._p3) / this._p2
                    };
                    p.config = ExpoScaleEase.config = function(start, end, ease) {
                        return new ExpoScaleEase(start, end, ease)
                    };
                    RoughEase = _class("easing.RoughEase", function(vars) {
                        vars = vars || {};
                        var taper = vars.taper || "none",
                            a = [],
                            cnt = 0,
                            points = (vars.points || 20) | 0,
                            i = points,
                            randomize = vars.randomize !== false,
                            clamp = vars.clamp === true,
                            template = vars.template instanceof Ease ? vars.template : null,
                            strength = typeof vars.strength === "number" ? vars.strength * .4 : .4,
                            x, y, bump, invX, obj, pnt;
                        while (--i > -1) {
                            x = randomize ? Math.random() : 1 / points * i;
                            y = template ? template.getRatio(x) : x;
                            if (taper === "none") {
                                bump = strength
                            } else if (taper === "out") {
                                invX = 1 - x;
                                bump = invX * invX * strength
                            } else if (taper === "in") {
                                bump = x * x * strength
                            } else if (x < .5) {
                                invX = x * 2;
                                bump = invX * invX * .5 * strength
                            } else {
                                invX = (1 - x) * 2;
                                bump = invX * invX * .5 * strength
                            }
                            if (randomize) {
                                y += Math.random() * bump - bump * .5
                            } else if (i % 2) {
                                y += bump * .5
                            } else {
                                y -= bump * .5
                            }
                            if (clamp) {
                                if (y > 1) {
                                    y = 1
                                } else if (y < 0) {
                                    y = 0
                                }
                            }
                            a[cnt++] = {
                                x: x,
                                y: y
                            }
                        }
                        a.sort(function(a, b) {
                            return a.x - b.x
                        });
                        pnt = new EasePoint(1, 1, null);
                        i = points;
                        while (--i > -1) {
                            obj = a[i];
                            pnt = new EasePoint(obj.x, obj.y, pnt)
                        }
                        this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next)
                    }, true);
                    p = RoughEase.prototype = new Ease;
                    p.constructor = RoughEase;
                    p.getRatio = function(p) {
                        var pnt = this._prev;
                        if (p > pnt.t) {
                            while (pnt.next && p >= pnt.t) {
                                pnt = pnt.next
                            }
                            pnt = pnt.prev
                        } else {
                            while (pnt.prev && p <= pnt.t) {
                                pnt = pnt.prev
                            }
                        }
                        this._prev = pnt;
                        return pnt.v + (p - pnt.t) / pnt.gap * pnt.c
                    };
                    p.config = function(vars) {
                        return new RoughEase(vars)
                    };
                    RoughEase.ease = new RoughEase;
                    _wrap("Bounce", _create("BounceOut", function(p) {
                        if (p < 1 / 2.75) {
                            return 7.5625 * p * p
                        } else if (p < 2 / 2.75) {
                            return 7.5625 * (p -= 1.5 / 2.75) * p + .75
                        } else if (p < 2.5 / 2.75) {
                            return 7.5625 * (p -= 2.25 / 2.75) * p + .9375
                        }
                        return 7.5625 * (p -= 2.625 / 2.75) * p + .984375
                    }), _create("BounceIn", function(p) {
                        if ((p = 1 - p) < 1 / 2.75) {
                            return 1 - 7.5625 * p * p
                        } else if (p < 2 / 2.75) {
                            return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + .75)
                        } else if (p < 2.5 / 2.75) {
                            return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + .9375)
                        }
                        return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + .984375)
                    }), _create("BounceInOut", function(p) {
                        var invert = p < .5;
                        if (invert) {
                            p = 1 - p * 2
                        } else {
                            p = p * 2 - 1
                        }
                        if (p < 1 / 2.75) {
                            p = 7.5625 * p * p
                        } else if (p < 2 / 2.75) {
                            p = 7.5625 * (p -= 1.5 / 2.75) * p + .75
                        } else if (p < 2.5 / 2.75) {
                            p = 7.5625 * (p -= 2.25 / 2.75) * p + .9375
                        } else {
                            p = 7.5625 * (p -= 2.625 / 2.75) * p + .984375
                        }
                        return invert ? (1 - p) * .5 : p * .5 + .5
                    }));
                    _wrap("Circ", _create("CircOut", function(p) {
                        return Math.sqrt(1 - (p = p - 1) * p)
                    }), _create("CircIn", function(p) {
                        return -(Math.sqrt(1 - p * p) - 1)
                    }), _create("CircInOut", function(p) {
                        return (p *= 2) < 1 ? -.5 * (Math.sqrt(1 - p * p) - 1) : .5 * (Math.sqrt(1 - (p -= 2) * p) + 1)
                    }));
                    _createElastic = function(n, f, def) {
                        var C = _class("easing." + n, function(amplitude, period) {
                                this._p1 = amplitude >= 1 ? amplitude : 1;
                                this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
                                this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
                                this._p2 = _2PI / this._p2
                            }, true),
                            p = C.prototype = new Ease;
                        p.constructor = C;
                        p.getRatio = f;
                        p.config = function(amplitude, period) {
                            return new C(amplitude, period)
                        };
                        return C
                    };
                    _wrap("Elastic", _createElastic("ElasticOut", function(p) {
                        return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1
                    }, .3), _createElastic("ElasticIn", function(p) {
                        return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2))
                    }, .3), _createElastic("ElasticInOut", function(p) {
                        return (p *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * .5 + 1
                    }, .45));
                    _wrap("Expo", _create("ExpoOut", function(p) {
                        return 1 - Math.pow(2, -10 * p)
                    }), _create("ExpoIn", function(p) {
                        return Math.pow(2, 10 * (p - 1)) - .001
                    }), _create("ExpoInOut", function(p) {
                        return (p *= 2) < 1 ? .5 * Math.pow(2, 10 * (p - 1)) : .5 * (2 - Math.pow(2, -10 * (p - 1)))
                    }));
                    _wrap("Sine", _create("SineOut", function(p) {
                        return Math.sin(p * _HALF_PI)
                    }), _create("SineIn", function(p) {
                        return -Math.cos(p * _HALF_PI) + 1
                    }), _create("SineInOut", function(p) {
                        return -.5 * (Math.cos(Math.PI * p) - 1)
                    }));
                    _class("easing.EaseLookup", {
                        find: function(s) {
                            return Ease.map[s]
                        }
                    }, true);
                    _easeReg(w.SlowMo, "SlowMo", "ease,");
                    _easeReg(RoughEase, "RoughEase", "ease,");
                    _easeReg(SteppedEase, "SteppedEase", "ease,");
                    return Back
                }, true)
            });
            if (_gsScope._gsDefine) {
                _gsScope._gsQueue.pop()()
            }(function(window, moduleName) {
                "use strict";
                var _exports = {},
                    _doc = window.document,
                    _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
                if (_globals.TweenLite) {
                    return
                }
                var _namespace = function(ns) {
                        var a = ns.split("."),
                            p = _globals,
                            i;
                        for (i = 0; i < a.length; i++) {
                            p[a[i]] = p = p[a[i]] || {}
                        }
                        return p
                    },
                    gs = _namespace("com.greensock"),
                    _tinyNum = 1e-10,
                    _slice = function(a) {
                        var b = [],
                            l = a.length,
                            i;
                        for (i = 0; i !== l; b.push(a[i++])) {}
                        return b
                    },
                    _emptyFunc = function() {},
                    _isArray = function() {
                        var toString = Object.prototype.toString,
                            array = toString.call([]);
                        return function(obj) {
                            return obj != null && (obj instanceof Array || typeof obj === "object" && !!obj.push && toString.call(obj) === array)
                        }
                    }(),
                    a, i, p, _ticker, _tickerActive, _defLookup = {},
                    Definition = function(ns, dependencies, func, global) {
                        this.sc = _defLookup[ns] ? _defLookup[ns].sc : [];
                        _defLookup[ns] = this;
                        this.gsClass = null;
                        this.func = func;
                        var _classes = [];
                        this.check = function(init) {
                            var i = dependencies.length,
                                missing = i,
                                cur, a, n, cl;
                            while (--i > -1) {
                                if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
                                    _classes[i] = cur.gsClass;
                                    missing--
                                } else if (init) {
                                    cur.sc.push(this)
                                }
                            }
                            if (missing === 0 && func) {
                                a = ("com.greensock." + ns).split(".");
                                n = a.pop();
                                cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);
                                if (global) {
                                    _globals[n] = _exports[n] = cl;
                                    if (typeof module !== "undefined" && module.exports) {
                                        if (ns === moduleName) {
                                            module.exports = _exports[moduleName] = cl;
                                            for (i in _exports) {
                                                cl[i] = _exports[i]
                                            }
                                        } else if (_exports[moduleName]) {
                                            _exports[moduleName][n] = cl
                                        }
                                    } else if (typeof define === "function" && define.amd) {
                                        define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() {
                                            return cl
                                        })
                                    }
                                }
                                for (i = 0; i < this.sc.length; i++) {
                                    this.sc[i].check()
                                }
                            }
                        };
                        this.check(true)
                    },
                    _gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
                        return new Definition(ns, dependencies, func, global)
                    },
                    _class = gs._class = function(ns, func, global) {
                        func = func || function() {};
                        _gsDefine(ns, [], function() {
                            return func
                        }, global);
                        return func
                    };
                _gsDefine.globals = _globals;
                var _baseParams = [0, 0, 1, 1],
                    Ease = _class("easing.Ease", function(func, extraParams, type, power) {
                        this._func = func;
                        this._type = type || 0;
                        this._power = power || 0;
                        this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams
                    }, true),
                    _easeMap = Ease.map = {},
                    _easeReg = Ease.register = function(ease, names, types, create) {
                        var na = names.split(","),
                            i = na.length,
                            ta = (types || "easeIn,easeOut,easeInOut").split(","),
                            e, name, j, type;
                        while (--i > -1) {
                            name = na[i];
                            e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
                            j = ta.length;
                            while (--j > -1) {
                                type = ta[j];
                                _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease
                            }
                        }
                    };
                p = Ease.prototype;
                p._calcEnd = false;
                p.getRatio = function(p) {
                    if (this._func) {
                        this._params[0] = p;
                        return this._func.apply(null, this._params)
                    }
                    var t = this._type,
                        pw = this._power,
                        r = t === 1 ? 1 - p : t === 2 ? p : p < .5 ? p * 2 : (1 - p) * 2;
                    if (pw === 1) {
                        r *= r
                    } else if (pw === 2) {
                        r *= r * r
                    } else if (pw === 3) {
                        r *= r * r * r
                    } else if (pw === 4) {
                        r *= r * r * r * r
                    }
                    return t === 1 ? 1 - r : t === 2 ? r : p < .5 ? r / 2 : 1 - r / 2
                };
                a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
                i = a.length;
                while (--i > -1) {
                    p = a[i] + ",Power" + i;
                    _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
                    _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
                    _easeReg(new Ease(null, null, 3, i), p, "easeInOut")
                }
                _easeMap.linear = gs.easing.Linear.easeIn;
                _easeMap.swing = gs.easing.Quad.easeInOut;
                var EventDispatcher = _class("events.EventDispatcher", function(target) {
                    this._listeners = {};
                    this._eventTarget = target || this
                });
                p = EventDispatcher.prototype;
                p.addEventListener = function(type, callback, scope, useParam, priority) {
                    priority = priority || 0;
                    var list = this._listeners[type],
                        index = 0,
                        listener, i;
                    if (this === _ticker && !_tickerActive) {
                        _ticker.wake()
                    }
                    if (list == null) {
                        this._listeners[type] = list = []
                    }
                    i = list.length;
                    while (--i > -1) {
                        listener = list[i];
                        if (listener.c === callback && listener.s === scope) {
                            list.splice(i, 1)
                        } else if (index === 0 && listener.pr < priority) {
                            index = i + 1
                        }
                    }
                    list.splice(index, 0, {
                        c: callback,
                        s: scope,
                        up: useParam,
                        pr: priority
                    })
                };
                p.removeEventListener = function(type, callback) {
                    var list = this._listeners[type],
                        i;
                    if (list) {
                        i = list.length;
                        while (--i > -1) {
                            if (list[i].c === callback) {
                                list.splice(i, 1);
                                return
                            }
                        }
                    }
                };
                p.dispatchEvent = function(type) {
                    var list = this._listeners[type],
                        i, t, listener;
                    if (list) {
                        i = list.length;
                        if (i > 1) {
                            list = list.slice(0)
                        }
                        t = this._eventTarget;
                        while (--i > -1) {
                            listener = list[i];
                            if (listener) {
                                if (listener.up) {
                                    listener.c.call(listener.s || t, {
                                        type: type,
                                        target: t
                                    })
                                } else {
                                    listener.c.call(listener.s || t)
                                }
                            }
                        }
                    }
                };
                var _reqAnimFrame = window.requestAnimationFrame,
                    _cancelAnimFrame = window.cancelAnimationFrame,
                    _getTime = Date.now || function() {
                        return (new Date).getTime()
                    },
                    _lastUpdate = _getTime();
                a = ["ms", "moz", "webkit", "o"];
                i = a.length;
                while (--i > -1 && !_reqAnimFrame) {
                    _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
                    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"]
                }
                _class("Ticker", function(fps, useRAF) {
                    var _self = this,
                        _startTime = _getTime(),
                        _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
                        _lagThreshold = 500,
                        _adjustedLag = 33,
                        _tickWord = "tick",
                        _fps, _req, _id, _gap, _nextTime, _tick = function(manual) {
                            var elapsed = _getTime() - _lastUpdate,
                                overlap, dispatch;
                            if (elapsed > _lagThreshold) {
                                _startTime += elapsed - _adjustedLag
                            }
                            _lastUpdate += elapsed;
                            _self.time = (_lastUpdate - _startTime) / 1e3;
                            overlap = _self.time - _nextTime;
                            if (!_fps || overlap > 0 || manual === true) {
                                _self.frame++;
                                _nextTime += overlap + (overlap >= _gap ? .004 : _gap - overlap);
                                dispatch = true
                            }
                            if (manual !== true) {
                                _id = _req(_tick)
                            }
                            if (dispatch) {
                                _self.dispatchEvent(_tickWord)
                            }
                        };
                    EventDispatcher.call(_self);
                    _self.time = _self.frame = 0;
                    _self.tick = function() {
                        _tick(true)
                    };
                    _self.lagSmoothing = function(threshold, adjustedLag) {
                        if (!arguments.length) {
                            return _lagThreshold < 1 / _tinyNum
                        }
                        _lagThreshold = threshold || 1 / _tinyNum;
                        _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0)
                    };
                    _self.sleep = function() {
                        if (_id == null) {
                            return
                        }
                        if (!_useRAF || !_cancelAnimFrame) {
                            clearTimeout(_id)
                        } else {
                            _cancelAnimFrame(_id)
                        }
                        _req = _emptyFunc;
                        _id = null;
                        if (_self === _ticker) {
                            _tickerActive = false
                        }
                    };
                    _self.wake = function(seamless) {
                        if (_id !== null) {
                            _self.sleep()
                        } else if (seamless) {
                            _startTime += -_lastUpdate + (_lastUpdate = _getTime())
                        } else if (_self.frame > 10) {
                            _lastUpdate = _getTime() - _lagThreshold + 5
                        }
                        _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function(f) {
                            return setTimeout(f, (_nextTime - _self.time) * 1e3 + 1 | 0)
                        } : _reqAnimFrame;
                        if (_self === _ticker) {
                            _tickerActive = true
                        }
                        _tick(2)
                    };
                    _self.fps = function(value) {
                        if (!arguments.length) {
                            return _fps
                        }
                        _fps = value;
                        _gap = 1 / (_fps || 60);
                        _nextTime = this.time + _gap;
                        _self.wake()
                    };
                    _self.useRAF = function(value) {
                        if (!arguments.length) {
                            return _useRAF
                        }
                        _self.sleep();
                        _useRAF = value;
                        _self.fps(_fps)
                    };
                    _self.fps(fps);
                    setTimeout(function() {
                        if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
                            _self.useRAF(false)
                        }
                    }, 1500)
                });
                p = gs.Ticker.prototype = new gs.events.EventDispatcher;
                p.constructor = gs.Ticker;
                var Animation = _class("core.Animation", function(duration, vars) {
                    this.vars = vars = vars || {};
                    this._duration = this._totalDuration = duration || 0;
                    this._delay = Number(vars.delay) || 0;
                    this._timeScale = 1;
                    this._active = vars.immediateRender === true;
                    this.data = vars.data;
                    this._reversed = vars.reversed === true;
                    if (!_rootTimeline) {
                        return
                    }
                    if (!_tickerActive) {
                        _ticker.wake()
                    }
                    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
                    tl.add(this, tl._time);
                    if (this.vars.paused) {
                        this.paused(true)
                    }
                });
                _ticker = Animation.ticker = new gs.Ticker;
                p = Animation.prototype;
                p._dirty = p._gc = p._initted = p._paused = false;
                p._totalTime = p._time = 0;
                p._rawPrevTime = -1;
                p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
                p._paused = false;
                var _checkTimeout = function() {
                    if (_tickerActive && _getTime() - _lastUpdate > 2e3 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
                        _ticker.wake()
                    }
                    var t = setTimeout(_checkTimeout, 2e3);
                    if (t.unref) {
                        t.unref()
                    }
                };
                _checkTimeout();
                p.play = function(from, suppressEvents) {
                    if (from != null) {
                        this.seek(from, suppressEvents)
                    }
                    return this.reversed(false).paused(false)
                };
                p.pause = function(atTime, suppressEvents) {
                    if (atTime != null) {
                        this.seek(atTime, suppressEvents)
                    }
                    return this.paused(true)
                };
                p.resume = function(from, suppressEvents) {
                    if (from != null) {
                        this.seek(from, suppressEvents)
                    }
                    return this.paused(false)
                };
                p.seek = function(time, suppressEvents) {
                    return this.totalTime(Number(time), suppressEvents !== false)
                };
                p.restart = function(includeDelay, suppressEvents) {
                    return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true)
                };
                p.reverse = function(from, suppressEvents) {
                    if (from != null) {
                        this.seek(from || this.totalDuration(), suppressEvents)
                    }
                    return this.reversed(true).paused(false)
                };
                p.render = function(time, suppressEvents, force) {};
                p.invalidate = function() {
                    this._time = this._totalTime = 0;
                    this._initted = this._gc = false;
                    this._rawPrevTime = -1;
                    if (this._gc || !this.timeline) {
                        this._enabled(true)
                    }
                    return this
                };
                p.isActive = function() {
                    var tl = this._timeline,
                        startTime = this._startTime,
                        rawTime;
                    return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - 1e-7
                };
                p._enabled = function(enabled, ignoreTimeline) {
                    if (!_tickerActive) {
                        _ticker.wake()
                    }
                    this._gc = !enabled;
                    this._active = this.isActive();
                    if (ignoreTimeline !== true) {
                        if (enabled && !this.timeline) {
                            this._timeline.add(this, this._startTime - this._delay)
                        } else if (!enabled && this.timeline) {
                            this._timeline._remove(this, true)
                        }
                    }
                    return false
                };
                p._kill = function(vars, target) {
                    return this._enabled(false, false)
                };
                p.kill = function(vars, target) {
                    this._kill(vars, target);
                    return this
                };
                p._uncache = function(includeSelf) {
                    var tween = includeSelf ? this : this.timeline;
                    while (tween) {
                        tween._dirty = true;
                        tween = tween.timeline
                    }
                    return this
                };
                p._swapSelfInParams = function(params) {
                    var i = params.length,
                        copy = params.concat();
                    while (--i > -1) {
                        if (params[i] === "{self}") {
                            copy[i] = this
                        }
                    }
                    return copy
                };
                p._callback = function(type) {
                    var v = this.vars,
                        callback = v[type],
                        params = v[type + "Params"],
                        scope = v[type + "Scope"] || v.callbackScope || this,
                        l = params ? params.length : 0;
                    switch (l) {
                        case 0:
                            callback.call(scope);
                            break;
                        case 1:
                            callback.call(scope, params[0]);
                            break;
                        case 2:
                            callback.call(scope, params[0], params[1]);
                            break;
                        default:
                            callback.apply(scope, params)
                    }
                };
                p.eventCallback = function(type, callback, params, scope) {
                    if ((type || "").substr(0, 2) === "on") {
                        var v = this.vars;
                        if (arguments.length === 1) {
                            return v[type]
                        }
                        if (callback == null) {
                            delete v[type]
                        } else {
                            v[type] = callback;
                            v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
                            v[type + "Scope"] = scope
                        }
                        if (type === "onUpdate") {
                            this._onUpdate = callback
                        }
                    }
                    return this
                };
                p.delay = function(value) {
                    if (!arguments.length) {
                        return this._delay
                    }
                    if (this._timeline.smoothChildTiming) {
                        this.startTime(this._startTime + value - this._delay)
                    }
                    this._delay = value;
                    return this
                };
                p.duration = function(value) {
                    if (!arguments.length) {
                        this._dirty = false;
                        return this._duration
                    }
                    this._duration = this._totalDuration = value;
                    this._uncache(true);
                    if (this._timeline.smoothChildTiming)
                        if (this._time > 0)
                            if (this._time < this._duration)
                                if (value !== 0) {
                                    this.totalTime(this._totalTime * (value / this._duration), true)
                                }
                    return this
                };
                p.totalDuration = function(value) {
                    this._dirty = false;
                    return !arguments.length ? this._totalDuration : this.duration(value)
                };
                p.time = function(value, suppressEvents) {
                    if (!arguments.length) {
                        return this._time
                    }
                    if (this._dirty) {
                        this.totalDuration()
                    }
                    return this.totalTime(value > this._duration ? this._duration : value, suppressEvents)
                };
                p.totalTime = function(time, suppressEvents, uncapped) {
                    if (!_tickerActive) {
                        _ticker.wake()
                    }
                    if (!arguments.length) {
                        return this._totalTime
                    }
                    if (this._timeline) {
                        if (time < 0 && !uncapped) {
                            time += this.totalDuration()
                        }
                        if (this._timeline.smoothChildTiming) {
                            if (this._dirty) {
                                this.totalDuration()
                            }
                            var totalDuration = this._totalDuration,
                                tl = this._timeline;
                            if (time > totalDuration && !uncapped) {
                                time = totalDuration
                            }
                            this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
                            if (!tl._dirty) {
                                this._uncache(false)
                            }
                            if (tl._timeline) {
                                while (tl._timeline) {
                                    if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
                                        tl.totalTime(tl._totalTime, true)
                                    }
                                    tl = tl._timeline
                                }
                            }
                        }
                        if (this._gc) {
                            this._enabled(true, false)
                        }
                        if (this._totalTime !== time || this._duration === 0) {
                            if (_lazyTweens.length) {
                                _lazyRender()
                            }
                            this.render(time, suppressEvents, false);
                            if (_lazyTweens.length) {
                                _lazyRender()
                            }
                        }
                    }
                    return this
                };
                p.progress = p.totalProgress = function(value, suppressEvents) {
                    var duration = this.duration();
                    return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents)
                };
                p.startTime = function(value) {
                    if (!arguments.length) {
                        return this._startTime
                    }
                    if (value !== this._startTime) {
                        this._startTime = value;
                        if (this.timeline)
                            if (this.timeline._sortChildren) {
                                this.timeline.add(this, value - this._delay)
                            }
                    }
                    return this
                };
                p.endTime = function(includeRepeats) {
                    return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale
                };
                p.timeScale = function(value) {
                    if (!arguments.length) {
                        return this._timeScale
                    }
                    var pauseTime, t;
                    value = value || _tinyNum;
                    if (this._timeline && this._timeline.smoothChildTiming) {
                        pauseTime = this._pauseTime;
                        t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
                        this._startTime = t - (t - this._startTime) * this._timeScale / value
                    }
                    this._timeScale = value;
                    t = this.timeline;
                    while (t && t.timeline) {
                        t._dirty = true;
                        t.totalDuration();
                        t = t.timeline
                    }
                    return this
                };
                p.reversed = function(value) {
                    if (!arguments.length) {
                        return this._reversed
                    }
                    if (value != this._reversed) {
                        this._reversed = value;
                        this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true)
                    }
                    return this
                };
                p.paused = function(value) {
                    if (!arguments.length) {
                        return this._paused
                    }
                    var tl = this._timeline,
                        raw, elapsed;
                    if (value != this._paused)
                        if (tl) {
                            if (!_tickerActive && !value) {
                                _ticker.wake()
                            }
                            raw = tl.rawTime();
                            elapsed = raw - this._pauseTime;
                            if (!value && tl.smoothChildTiming) {
                                this._startTime += elapsed;
                                this._uncache(false)
                            }
                            this._pauseTime = value ? raw : null;
                            this._paused = value;
                            this._active = this.isActive();
                            if (!value && elapsed !== 0 && this._initted && this.duration()) {
                                raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
                                this.render(raw, raw === this._totalTime, true)
                            }
                        }
                    if (this._gc && !value) {
                        this._enabled(true, false)
                    }
                    return this
                };
                var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
                    Animation.call(this, 0, vars);
                    this.autoRemoveChildren = this.smoothChildTiming = true
                });
                p = SimpleTimeline.prototype = new Animation;
                p.constructor = SimpleTimeline;
                p.kill()._gc = false;
                p._first = p._last = p._recent = null;
                p._sortChildren = false;
                p.add = p.insert = function(child, position, align, stagger) {
                    var prevTween, st;
                    child._startTime = Number(position || 0) + child._delay;
                    if (child._paused)
                        if (this !== child._timeline) {
                            child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale
                        }
                    if (child.timeline) {
                        child.timeline._remove(child, true)
                    }
                    child.timeline = child._timeline = this;
                    if (child._gc) {
                        child._enabled(true, true)
                    }
                    prevTween = this._last;
                    if (this._sortChildren) {
                        st = child._startTime;
                        while (prevTween && prevTween._startTime > st) {
                            prevTween = prevTween._prev
                        }
                    }
                    if (prevTween) {
                        child._next = prevTween._next;
                        prevTween._next = child
                    } else {
                        child._next = this._first;
                        this._first = child
                    }
                    if (child._next) {
                        child._next._prev = child
                    } else {
                        this._last = child
                    }
                    child._prev = prevTween;
                    this._recent = child;
                    if (this._timeline) {
                        this._uncache(true)
                    }
                    return this
                };
                p._remove = function(tween, skipDisable) {
                    if (tween.timeline === this) {
                        if (!skipDisable) {
                            tween._enabled(false, true)
                        }
                        if (tween._prev) {
                            tween._prev._next = tween._next
                        } else if (this._first === tween) {
                            this._first = tween._next
                        }
                        if (tween._next) {
                            tween._next._prev = tween._prev
                        } else if (this._last === tween) {
                            this._last = tween._prev
                        }
                        tween._next = tween._prev = tween.timeline = null;
                        if (tween === this._recent) {
                            this._recent = this._last
                        }
                        if (this._timeline) {
                            this._uncache(true)
                        }
                    }
                    return this
                };
                p.render = function(time, suppressEvents, force) {
                    var tween = this._first,
                        next;
                    this._totalTime = this._time = this._rawPrevTime = time;
                    while (tween) {
                        next = tween._next;
                        if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {
                            if (!tween._reversed) {
                                tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                            } else {
                                tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                            }
                        }
                        tween = next
                    }
                };
                p.rawTime = function() {
                    if (!_tickerActive) {
                        _ticker.wake()
                    }
                    return this._totalTime
                };
                var TweenLite = _class("TweenLite", function(target, duration, vars) {
                        Animation.call(this, duration, vars);
                        this.render = TweenLite.prototype.render;
                        if (target == null) {
                            throw "Cannot tween a null target."
                        }
                        this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
                        var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
                            overwrite = this.vars.overwrite,
                            i, targ, targets;
                        this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];
                        if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
                            this._targets = targets = _slice(target);
                            this._propLookup = [];
                            this._siblings = [];
                            for (i = 0; i < targets.length; i++) {
                                targ = targets[i];
                                if (!targ) {
                                    targets.splice(i--, 1);
                                    continue
                                } else if (typeof targ === "string") {
                                    targ = targets[i--] = TweenLite.selector(targ);
                                    if (typeof targ === "string") {
                                        targets.splice(i + 1, 1)
                                    }
                                    continue
                                } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
                                    targets.splice(i--, 1);
                                    this._targets = targets = targets.concat(_slice(targ));
                                    continue
                                }
                                this._siblings[i] = _register(targ, this, false);
                                if (overwrite === 1)
                                    if (this._siblings[i].length > 1) {
                                        _applyOverwrite(targ, this, null, 1, this._siblings[i])
                                    }
                            }
                        } else {
                            this._propLookup = {};
                            this._siblings = _register(target, this, false);
                            if (overwrite === 1)
                                if (this._siblings.length > 1) {
                                    _applyOverwrite(target, this, null, 1, this._siblings)
                                }
                        }
                        if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
                            this._time = -_tinyNum;
                            this.render(Math.min(0, -this._delay))
                        }
                    }, true),
                    _isSelector = function(v) {
                        return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType)
                    },
                    _autoCSS = function(vars, target) {
                        var css = {},
                            p;
                        for (p in vars) {
                            if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
                                css[p] = vars[p];
                                delete vars[p]
                            }
                        }
                        vars.css = css
                    };
                p = TweenLite.prototype = new Animation;
                p.constructor = TweenLite;
                p.kill()._gc = false;
                p.ratio = 0;
                p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
                p._notifyPluginsOfEnabled = p._lazy = false;
                TweenLite.version = "1.20.4";
                TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
                TweenLite.defaultOverwrite = "auto";
                TweenLite.ticker = _ticker;
                TweenLite.autoSleep = 120;
                TweenLite.lagSmoothing = function(threshold, adjustedLag) {
                    _ticker.lagSmoothing(threshold, adjustedLag)
                };
                TweenLite.selector = window.$ || window.jQuery || function(e) {
                    var selector = window.$ || window.jQuery;
                    if (selector) {
                        TweenLite.selector = selector;
                        return selector(e)
                    }
                    return typeof _doc === "undefined" ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === "#" ? e.substr(1) : e)
                };
                var _lazyTweens = [],
                    _lazyLookup = {},
                    _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    _relExp = /[\+-]=-?[\.\d]/,
                    _setRatio = function(v) {
                        var pt = this._firstPT,
                            min = 1e-6,
                            val;
                        while (pt) {
                            val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join("") : this.start;
                            if (pt.m) {
                                val = pt.m(val, this._target || pt.t)
                            } else if (val < min)
                                if (val > -min && !pt.blob) {
                                    val = 0
                                }
                            if (!pt.f) {
                                pt.t[pt.p] = val
                            } else if (pt.fp) {
                                pt.t[pt.p](pt.fp, val)
                            } else {
                                pt.t[pt.p](val)
                            }
                            pt = pt._next
                        }
                    },
                    _blobDif = function(start, end, filter, pt) {
                        var a = [],
                            charIndex = 0,
                            s = "",
                            color = 0,
                            startNums, endNums, num, i, l, nonNumbers, currentNum;
                        a.start = start;
                        a.end = end;
                        start = a[0] = start + "";
                        end = a[1] = end + "";
                        if (filter) {
                            filter(a);
                            start = a[0];
                            end = a[1]
                        }
                        a.length = 0;
                        startNums = start.match(_numbersExp) || [];
                        endNums = end.match(_numbersExp) || [];
                        if (pt) {
                            pt._next = null;
                            pt.blob = 1;
                            a._firstPT = a._applyPT = pt
                        }
                        l = endNums.length;
                        for (i = 0; i < l; i++) {
                            currentNum = endNums[i];
                            nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
                            s += nonNumbers || !i ? nonNumbers : ",";
                            charIndex += nonNumbers.length;
                            if (color) {
                                color = (color + 1) % 5
                            } else if (nonNumbers.substr(-5) === "rgba(") {
                                color = 1
                            }
                            if (currentNum === startNums[i] || startNums.length <= i) {
                                s += currentNum
                            } else {
                                if (s) {
                                    a.push(s);
                                    s = ""
                                }
                                num = parseFloat(startNums[i]);
                                a.push(num);
                                a._firstPT = {
                                    _next: a._firstPT,
                                    t: a,
                                    p: a.length - 1,
                                    s: num,
                                    c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
                                    f: 0,
                                    m: color && color < 4 ? Math.round : 0
                                }
                            }
                            charIndex += currentNum.length
                        }
                        s += end.substr(charIndex);
                        if (s) {
                            a.push(s)
                        }
                        a.setRatio = _setRatio;
                        if (_relExp.test(end)) {
                            a.end = null
                        }
                        return a
                    },
                    _addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
                        if (typeof end === "function") {
                            end = end(index || 0, target)
                        }
                        var type = typeof target[prop],
                            getterName = type !== "function" ? "" : prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3),
                            s = start !== "get" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
                            isRelative = typeof end === "string" && end.charAt(1) === "=",
                            pt = {
                                t: target,
                                p: prop,
                                s: s,
                                f: type === "function",
                                pg: 0,
                                n: overwriteProp || prop,
                                m: !mod ? 0 : typeof mod === "function" ? mod : Math.round,
                                pr: 0,
                                c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
                            },
                            blob;
                        if (typeof s !== "number" || typeof end !== "number" && !isRelative) {
                            if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === "boolean" || typeof end === "boolean") {
                                pt.fp = funcParam;
                                blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + "").replace(/[0-9\-\.]/g, "") : end, stringFilter || TweenLite.defaultStringFilter, pt);
                                pt = {
                                    t: blob,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 2,
                                    pg: 0,
                                    n: overwriteProp || prop,
                                    pr: 0,
                                    m: 0
                                }
                            } else {
                                pt.s = parseFloat(s);
                                if (!isRelative) {
                                    pt.c = parseFloat(end) - pt.s || 0
                                }
                            }
                        }
                        if (pt.c) {
                            if (pt._next = this._firstPT) {
                                pt._next._prev = pt
                            }
                            this._firstPT = pt;
                            return pt
                        }
                    },
                    _internals = TweenLite._internals = {
                        isArray: _isArray,
                        isSelector: _isSelector,
                        lazyTweens: _lazyTweens,
                        blobDif: _blobDif
                    },
                    _plugins = TweenLite._plugins = {},
                    _tweenLookup = _internals.tweenLookup = {},
                    _tweenLookupNum = 0,
                    _reservedProps = _internals.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1
                    },
                    _overwriteLookup = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    },
                    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline,
                    _rootTimeline = Animation._rootTimeline = new SimpleTimeline,
                    _nextGCFrame = 30,
                    _lazyRender = _internals.lazyRender = function() {
                        var i = _lazyTweens.length,
                            tween;
                        _lazyLookup = {};
                        while (--i > -1) {
                            tween = _lazyTweens[i];
                            if (tween && tween._lazy !== false) {
                                tween.render(tween._lazy[0], tween._lazy[1], true);
                                tween._lazy = false
                            }
                        }
                        _lazyTweens.length = 0
                    };
                _rootTimeline._startTime = _ticker.time;
                _rootFramesTimeline._startTime = _ticker.frame;
                _rootTimeline._active = _rootFramesTimeline._active = true;
                setTimeout(_lazyRender, 1);
                Animation._updateRoot = TweenLite.render = function() {
                    var i, a, p;
                    if (_lazyTweens.length) {
                        _lazyRender()
                    }
                    _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
                    _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
                    if (_lazyTweens.length) {
                        _lazyRender()
                    }
                    if (_ticker.frame >= _nextGCFrame) {
                        _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
                        for (p in _tweenLookup) {
                            a = _tweenLookup[p].tweens;
                            i = a.length;
                            while (--i > -1) {
                                if (a[i]._gc) {
                                    a.splice(i, 1)
                                }
                            }
                            if (a.length === 0) {
                                delete _tweenLookup[p]
                            }
                        }
                        p = _rootTimeline._first;
                        if (!p || p._paused)
                            if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
                                while (p && p._paused) {
                                    p = p._next
                                }
                                if (!p) {
                                    _ticker.sleep()
                                }
                            }
                    }
                };
                _ticker.addEventListener("tick", Animation._updateRoot);
                var _register = function(target, tween, scrub) {
                        var id = target._gsTweenID,
                            a, i;
                        if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
                            _tweenLookup[id] = {
                                target: target,
                                tweens: []
                            }
                        }
                        if (tween) {
                            a = _tweenLookup[id].tweens;
                            a[i = a.length] = tween;
                            if (scrub) {
                                while (--i > -1) {
                                    if (a[i] === tween) {
                                        a.splice(i, 1)
                                    }
                                }
                            }
                        }
                        return _tweenLookup[id].tweens
                    },
                    _onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
                        var func = overwrittenTween.vars.onOverwrite,
                            r1, r2;
                        if (func) {
                            r1 = func(overwrittenTween, overwritingTween, target, killedProps)
                        }
                        func = TweenLite.onOverwrite;
                        if (func) {
                            r2 = func(overwrittenTween, overwritingTween, target, killedProps)
                        }
                        return r1 !== false && r2 !== false
                    },
                    _applyOverwrite = function(target, tween, props, mode, siblings) {
                        var i, changed, curTween, l;
                        if (mode === 1 || mode >= 4) {
                            l = siblings.length;
                            for (i = 0; i < l; i++) {
                                if ((curTween = siblings[i]) !== tween) {
                                    if (!curTween._gc) {
                                        if (curTween._kill(null, target, tween)) {
                                            changed = true
                                        }
                                    }
                                } else if (mode === 5) {
                                    break
                                }
                            }
                            return changed
                        }
                        var startTime = tween._startTime + _tinyNum,
                            overlaps = [],
                            oCount = 0,
                            zeroDur = tween._duration === 0,
                            globalStart;
                        i = siblings.length;
                        while (--i > -1) {
                            if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {} else if (curTween._timeline !== tween._timeline) {
                                globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
                                if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
                                    overlaps[oCount++] = curTween
                                }
                            } else if (curTween._startTime <= startTime)
                                if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)
                                    if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 2e-10)) {
                                        overlaps[oCount++] = curTween
                                    }
                        }
                        i = oCount;
                        while (--i > -1) {
                            curTween = overlaps[i];
                            if (mode === 2)
                                if (curTween._kill(props, target, tween)) {
                                    changed = true
                                }
                            if (mode !== 2 || !curTween._firstPT && curTween._initted) {
                                if (mode !== 2 && !_onOverwrite(curTween, tween)) {
                                    continue
                                }
                                if (curTween._enabled(false, false)) {
                                    changed = true
                                }
                            }
                        }
                        return changed
                    },
                    _checkOverlap = function(tween, reference, zeroDur) {
                        var tl = tween._timeline,
                            ts = tl._timeScale,
                            t = tween._startTime;
                        while (tl._timeline) {
                            t += tl._startTime;
                            ts *= tl._timeScale;
                            if (tl._paused) {
                                return -100
                            }
                            tl = tl._timeline
                        }
                        t /= ts;
                        return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum
                    };
                p._init = function() {
                    var v = this.vars,
                        op = this._overwrittenProps,
                        dur = this._duration,
                        immediate = !!v.immediateRender,
                        ease = v.ease,
                        i, initPlugins, pt, p, startVars, l;
                    if (v.startAt) {
                        if (this._startAt) {
                            this._startAt.render(-1, true);
                            this._startAt.kill()
                        }
                        startVars = {};
                        for (p in v.startAt) {
                            startVars[p] = v.startAt[p]
                        }
                        startVars.data = "isStart";
                        startVars.overwrite = false;
                        startVars.immediateRender = true;
                        startVars.lazy = immediate && v.lazy !== false;
                        startVars.startAt = startVars.delay = null;
                        startVars.onUpdate = v.onUpdate;
                        startVars.onUpdateParams = v.onUpdateParams;
                        startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
                        this._startAt = TweenLite.to(this.target, 0, startVars);
                        if (immediate) {
                            if (this._time > 0) {
                                this._startAt = null
                            } else if (dur !== 0) {
                                return
                            }
                        }
                    } else if (v.runBackwards && dur !== 0) {
                        if (this._startAt) {
                            this._startAt.render(-1, true);
                            this._startAt.kill();
                            this._startAt = null
                        } else {
                            if (this._time !== 0) {
                                immediate = false
                            }
                            pt = {};
                            for (p in v) {
                                if (!_reservedProps[p] || p === "autoCSS") {
                                    pt[p] = v[p]
                                }
                            }
                            pt.overwrite = 0;
                            pt.data = "isFromStart";
                            pt.lazy = immediate && v.lazy !== false;
                            pt.immediateRender = immediate;
                            this._startAt = TweenLite.to(this.target, 0, pt);
                            if (!immediate) {
                                this._startAt._init();
                                this._startAt._enabled(false);
                                if (this.vars.immediateRender) {
                                    this._startAt = null
                                }
                            } else if (this._time === 0) {
                                return
                            }
                        }
                    }
                    this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
                    if (v.easeParams instanceof Array && ease.config) {
                        this._ease = ease.config.apply(ease, v.easeParams)
                    }
                    this._easeType = this._ease._type;
                    this._easePower = this._ease._power;
                    this._firstPT = null;
                    if (this._targets) {
                        l = this._targets.length;
                        for (i = 0; i < l; i++) {
                            if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {
                                initPlugins = true
                            }
                        }
                    } else {
                        initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0)
                    }
                    if (initPlugins) {
                        TweenLite._onPluginEvent("_onInitAllProps", this)
                    }
                    if (op)
                        if (!this._firstPT)
                            if (typeof this.target !== "function") {
                                this._enabled(false, false)
                            }
                    if (v.runBackwards) {
                        pt = this._firstPT;
                        while (pt) {
                            pt.s += pt.c;
                            pt.c = -pt.c;
                            pt = pt._next
                        }
                    }
                    this._onUpdate = v.onUpdate;
                    this._initted = true
                };
                p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
                    var p, i, initPlugins, plugin, pt, v;
                    if (target == null) {
                        return false
                    }
                    if (_lazyLookup[target._gsTweenID]) {
                        _lazyRender()
                    }
                    if (!this.vars.css)
                        if (target.style)
                            if (target !== window && target.nodeType)
                                if (_plugins.css)
                                    if (this.vars.autoCSS !== false) {
                                        _autoCSS(this.vars, target)
                                    }
                    for (p in this.vars) {
                        v = this.vars[p];
                        if (_reservedProps[p]) {
                            if (v)
                                if (v instanceof Array || v.push && _isArray(v))
                                    if (v.join("").indexOf("{self}") !== -1) {
                                        this.vars[p] = v = this._swapSelfInParams(v, this)
                                    }
                        } else if (_plugins[p] && (plugin = new _plugins[p])._onInitTween(target, this.vars[p], this, index)) {
                            this._firstPT = pt = {
                                _next: this._firstPT,
                                t: plugin,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: p,
                                pg: 1,
                                pr: plugin._priority,
                                m: 0
                            };
                            i = plugin._overwriteProps.length;
                            while (--i > -1) {
                                propLookup[plugin._overwriteProps[i]] = this._firstPT
                            }
                            if (plugin._priority || plugin._onInitAllProps) {
                                initPlugins = true
                            }
                            if (plugin._onDisable || plugin._onEnable) {
                                this._notifyPluginsOfEnabled = true
                            }
                            if (pt._next) {
                                pt._next._prev = pt
                            }
                        } else {
                            propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index)
                        }
                    }
                    if (overwrittenProps)
                        if (this._kill(overwrittenProps, target)) {
                            return this._initProps(target, propLookup, siblings, overwrittenProps, index)
                        }
                    if (this._overwrite > 1)
                        if (this._firstPT)
                            if (siblings.length > 1)
                                if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
                                    this._kill(propLookup, target);
                                    return this._initProps(target, propLookup, siblings, overwrittenProps, index)
                                }
                    if (this._firstPT)
                        if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
                            _lazyLookup[target._gsTweenID] = true
                        }
                    return initPlugins
                };
                p.render = function(time, suppressEvents, force) {
                    var prevTime = this._time,
                        duration = this._duration,
                        prevRawPrevTime = this._rawPrevTime,
                        isComplete, callback, pt, rawPrevTime;
                    if (time >= duration - 1e-7 && time >= 0) {
                        this._totalTime = this._time = duration;
                        this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
                        if (!this._reversed) {
                            isComplete = true;
                            callback = "onComplete";
                            force = force || this._timeline.autoRemoveChildren
                        }
                        if (duration === 0)
                            if (this._initted || !this.vars.lazy || force) {
                                if (this._startTime === this._timeline._duration) {
                                    time = 0
                                }
                                if (prevRawPrevTime < 0 || time <= 0 && time >= -1e-7 || prevRawPrevTime === _tinyNum && this.data !== "isPause")
                                    if (prevRawPrevTime !== time) {
                                        force = true;
                                        if (prevRawPrevTime > _tinyNum) {
                                            callback = "onReverseComplete"
                                        }
                                    }
                                this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
                            }
                    } else if (time < 1e-7) {
                        this._totalTime = this._time = 0;
                        this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
                        if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
                            callback = "onReverseComplete";
                            isComplete = this._reversed
                        }
                        if (time < 0) {
                            this._active = false;
                            if (duration === 0)
                                if (this._initted || !this.vars.lazy || force) {
                                    if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
                                        force = true
                                    }
                                    this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
                                }
                        }
                        if (!this._initted || this._startAt && this._startAt.progress()) {
                            force = true
                        }
                    } else {
                        this._totalTime = this._time = time;
                        if (this._easeType) {
                            var r = time / duration,
                                type = this._easeType,
                                pow = this._easePower;
                            if (type === 1 || type === 3 && r >= .5) {
                                r = 1 - r
                            }
                            if (type === 3) {
                                r *= 2
                            }
                            if (pow === 1) {
                                r *= r
                            } else if (pow === 2) {
                                r *= r * r
                            } else if (pow === 3) {
                                r *= r * r * r
                            } else if (pow === 4) {
                                r *= r * r * r * r
                            }
                            if (type === 1) {
                                this.ratio = 1 - r
                            } else if (type === 2) {
                                this.ratio = r
                            } else if (time / duration < .5) {
                                this.ratio = r / 2
                            } else {
                                this.ratio = 1 - r / 2
                            }
                        } else {
                            this.ratio = this._ease.getRatio(time / duration)
                        }
                    }
                    if (this._time === prevTime && !force) {
                        return
                    } else if (!this._initted) {
                        this._init();
                        if (!this._initted || this._gc) {
                            return
                        } else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
                            this._time = this._totalTime = prevTime;
                            this._rawPrevTime = prevRawPrevTime;
                            _lazyTweens.push(this);
                            this._lazy = [time, suppressEvents];
                            return
                        }
                        if (this._time && !isComplete) {
                            this.ratio = this._ease.getRatio(this._time / duration)
                        } else if (isComplete && this._ease._calcEnd) {
                            this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)
                        }
                    }
                    if (this._lazy !== false) {
                        this._lazy = false
                    }
                    if (!this._active)
                        if (!this._paused && this._time !== prevTime && time >= 0) {
                            this._active = true
                        }
                    if (prevTime === 0) {
                        if (this._startAt) {
                            if (time >= 0) {
                                this._startAt.render(time, true, force)
                            } else if (!callback) {
                                callback = "_dummyGS"
                            }
                        }
                        if (this.vars.onStart)
                            if (this._time !== 0 || duration === 0)
                                if (!suppressEvents) {
                                    this._callback("onStart")
                                }
                    }
                    pt = this._firstPT;
                    while (pt) {
                        if (pt.f) {
                            pt.t[pt.p](pt.c * this.ratio + pt.s)
                        } else {
                            pt.t[pt.p] = pt.c * this.ratio + pt.s
                        }
                        pt = pt._next
                    }
                    if (this._onUpdate) {
                        if (time < 0)
                            if (this._startAt && time !== -1e-4) {
                                this._startAt.render(time, true, force)
                            }
                        if (!suppressEvents)
                            if (this._time !== prevTime || isComplete || force) {
                                this._callback("onUpdate")
                            }
                    }
                    if (callback)
                        if (!this._gc || force) {
                            if (time < 0 && this._startAt && !this._onUpdate && time !== -1e-4) {
                                this._startAt.render(time, true, force)
                            }
                            if (isComplete) {
                                if (this._timeline.autoRemoveChildren) {
                                    this._enabled(false, false)
                                }
                                this._active = false
                            }
                            if (!suppressEvents && this.vars[callback]) {
                                this._callback(callback)
                            }
                            if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
                                this._rawPrevTime = 0
                            }
                        }
                };
                p._kill = function(vars, target, overwritingTween) {
                    if (vars === "all") {
                        vars = null
                    }
                    if (vars == null)
                        if (target == null || target === this.target) {
                            this._lazy = false;
                            return this._enabled(false, false)
                        }
                    target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
                    var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
                        i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
                    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
                        i = target.length;
                        while (--i > -1) {
                            if (this._kill(vars, target[i], overwritingTween)) {
                                changed = true
                            }
                        }
                    } else {
                        if (this._targets) {
                            i = this._targets.length;
                            while (--i > -1) {
                                if (target === this._targets[i]) {
                                    propLookup = this._propLookup[i] || {};
                                    this._overwrittenProps = this._overwrittenProps || [];
                                    overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
                                    break
                                }
                            }
                        } else if (target !== this.target) {
                            return false
                        } else {
                            propLookup = this._propLookup;
                            overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all"
                        }
                        if (propLookup) {
                            killProps = vars || propLookup;
                            record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof vars !== "object" || !vars._tempKill);
                            if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
                                for (p in killProps) {
                                    if (propLookup[p]) {
                                        if (!killed) {
                                            killed = []
                                        }
                                        killed.push(p)
                                    }
                                }
                                if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
                                    return false
                                }
                            }
                            for (p in killProps) {
                                if (pt = propLookup[p]) {
                                    if (simultaneousOverwrite) {
                                        if (pt.f) {
                                            pt.t[pt.p](pt.s)
                                        } else {
                                            pt.t[pt.p] = pt.s
                                        }
                                        changed = true
                                    }
                                    if (pt.pg && pt.t._kill(killProps)) {
                                        changed = true
                                    }
                                    if (!pt.pg || pt.t._overwriteProps.length === 0) {
                                        if (pt._prev) {
                                            pt._prev._next = pt._next
                                        } else if (pt === this._firstPT) {
                                            this._firstPT = pt._next
                                        }
                                        if (pt._next) {
                                            pt._next._prev = pt._prev
                                        }
                                        pt._next = pt._prev = null
                                    }
                                    delete propLookup[p]
                                }
                                if (record) {
                                    overwrittenProps[p] = 1
                                }
                            }
                            if (!this._firstPT && this._initted) {
                                this._enabled(false, false)
                            }
                        }
                    }
                    return changed
                };
                p.invalidate = function() {
                    if (this._notifyPluginsOfEnabled) {
                        TweenLite._onPluginEvent("_onDisable", this)
                    }
                    this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
                    this._notifyPluginsOfEnabled = this._active = this._lazy = false;
                    this._propLookup = this._targets ? {} : [];
                    Animation.prototype.invalidate.call(this);
                    if (this.vars.immediateRender) {
                        this._time = -_tinyNum;
                        this.render(Math.min(0, -this._delay))
                    }
                    return this
                };
                p._enabled = function(enabled, ignoreTimeline) {
                    if (!_tickerActive) {
                        _ticker.wake()
                    }
                    if (enabled && this._gc) {
                        var targets = this._targets,
                            i;
                        if (targets) {
                            i = targets.length;
                            while (--i > -1) {
                                this._siblings[i] = _register(targets[i], this, true)
                            }
                        } else {
                            this._siblings = _register(this.target, this, true)
                        }
                    }
                    Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
                    if (this._notifyPluginsOfEnabled)
                        if (this._firstPT) {
                            return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this)
                        }
                    return false
                };
                TweenLite.to = function(target, duration, vars) {
                    return new TweenLite(target, duration, vars)
                };
                TweenLite.from = function(target, duration, vars) {
                    vars.runBackwards = true;
                    vars.immediateRender = vars.immediateRender != false;
                    return new TweenLite(target, duration, vars)
                };
                TweenLite.fromTo = function(target, duration, fromVars, toVars) {
                    toVars.startAt = fromVars;
                    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
                    return new TweenLite(target, duration, toVars)
                };
                TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
                    return new TweenLite(callback, 0, {
                        delay: delay,
                        onComplete: callback,
                        onCompleteParams: params,
                        callbackScope: scope,
                        onReverseComplete: callback,
                        onReverseCompleteParams: params,
                        immediateRender: false,
                        lazy: false,
                        useFrames: useFrames,
                        overwrite: 0
                    })
                };
                TweenLite.set = function(target, vars) {
                    return new TweenLite(target, 0, vars)
                };
                TweenLite.getTweensOf = function(target, onlyActive) {
                    if (target == null) {
                        return []
                    }
                    target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
                    var i, a, j, t;
                    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
                        i = target.length;
                        a = [];
                        while (--i > -1) {
                            a = a.concat(TweenLite.getTweensOf(target[i], onlyActive))
                        }
                        i = a.length;
                        while (--i > -1) {
                            t = a[i];
                            j = i;
                            while (--j > -1) {
                                if (t === a[j]) {
                                    a.splice(i, 1)
                                }
                            }
                        }
                    } else if (target._gsTweenID) {
                        a = _register(target).concat();
                        i = a.length;
                        while (--i > -1) {
                            if (a[i]._gc || onlyActive && !a[i].isActive()) {
                                a.splice(i, 1)
                            }
                        }
                    }
                    return a || []
                };
                TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
                    if (typeof onlyActive === "object") {
                        vars = onlyActive;
                        onlyActive = false
                    }
                    var a = TweenLite.getTweensOf(target, onlyActive),
                        i = a.length;
                    while (--i > -1) {
                        a[i]._kill(vars, target)
                    }
                };
                var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
                    this._overwriteProps = (props || "").split(",");
                    this._propName = this._overwriteProps[0];
                    this._priority = priority || 0;
                    this._super = TweenPlugin.prototype
                }, true);
                p = TweenPlugin.prototype;
                TweenPlugin.version = "1.19.0";
                TweenPlugin.API = 2;
                p._firstPT = null;
                p._addTween = _addPropTween;
                p.setRatio = _setRatio;
                p._kill = function(lookup) {
                    var a = this._overwriteProps,
                        pt = this._firstPT,
                        i;
                    if (lookup[this._propName] != null) {
                        this._overwriteProps = []
                    } else {
                        i = a.length;
                        while (--i > -1) {
                            if (lookup[a[i]] != null) {
                                a.splice(i, 1)
                            }
                        }
                    }
                    while (pt) {
                        if (lookup[pt.n] != null) {
                            if (pt._next) {
                                pt._next._prev = pt._prev
                            }
                            if (pt._prev) {
                                pt._prev._next = pt._next;
                                pt._prev = null
                            } else if (this._firstPT === pt) {
                                this._firstPT = pt._next
                            }
                        }
                        pt = pt._next
                    }
                    return false
                };
                p._mod = p._roundProps = function(lookup) {
                    var pt = this._firstPT,
                        val;
                    while (pt) {
                        val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")];
                        if (val && typeof val === "function") {
                            if (pt.f === 2) {
                                pt.t._applyPT.m = val
                            } else {
                                pt.m = val
                            }
                        }
                        pt = pt._next
                    }
                };
                TweenLite._onPluginEvent = function(type, tween) {
                    var pt = tween._firstPT,
                        changed, pt2, first, last, next;
                    if (type === "_onInitAllProps") {
                        while (pt) {
                            next = pt._next;
                            pt2 = first;
                            while (pt2 && pt2.pr > pt.pr) {
                                pt2 = pt2._next
                            }
                            if (pt._prev = pt2 ? pt2._prev : last) {
                                pt._prev._next = pt
                            } else {
                                first = pt
                            }
                            if (pt._next = pt2) {
                                pt2._prev = pt
                            } else {
                                last = pt
                            }
                            pt = next
                        }
                        pt = tween._firstPT = first
                    }
                    while (pt) {
                        if (pt.pg)
                            if (typeof pt.t[type] === "function")
                                if (pt.t[type]()) {
                                    changed = true
                                }
                        pt = pt._next
                    }
                    return changed
                };
                TweenPlugin.activate = function(plugins) {
                    var i = plugins.length;
                    while (--i > -1) {
                        if (plugins[i].API === TweenPlugin.API) {
                            _plugins[(new plugins[i])._propName] = plugins[i]
                        }
                    }
                    return true
                };
                _gsDefine.plugin = function(config) {
                    if (!config || !config.propName || !config.init || !config.API) {
                        throw "illegal plugin definition."
                    }
                    var propName = config.propName,
                        priority = config.priority || 0,
                        overwriteProps = config.overwriteProps,
                        map = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_mod",
                            mod: "_mod",
                            initAll: "_onInitAllProps"
                        },
                        Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function() {
                            TweenPlugin.call(this, propName, priority);
                            this._overwriteProps = overwriteProps || []
                        }, config.global === true),
                        p = Plugin.prototype = new TweenPlugin(propName),
                        prop;
                    p.constructor = Plugin;
                    Plugin.API = config.API;
                    for (prop in map) {
                        if (typeof config[prop] === "function") {
                            p[map[prop]] = config[prop]
                        }
                    }
                    Plugin.version = config.version;
                    TweenPlugin.activate([Plugin]);
                    return Plugin
                };
                a = window._gsQueue;
                if (a) {
                    for (i = 0; i < a.length; i++) {
                        a[i]()
                    }
                    for (p in _defLookup) {
                        if (!_defLookup[p].func) {
                            window.console.log("GSAP encountered missing dependency: " + p)
                        }
                    }
                }
                _tickerActive = false
            })(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window, "TweenMax")
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}],
    328: [function(require, module, exports) {
        (function(global) {
            ! function(global) {
                "use strict";
                var Op = Object.prototype;
                var hasOwn = Op.hasOwnProperty;
                var undefined;
                var $Symbol = typeof Symbol === "function" ? Symbol : {};
                var iteratorSymbol = $Symbol.iterator || "@@iterator";
                var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
                var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
                var inModule = typeof module === "object";
                var runtime = global.regeneratorRuntime;
                if (runtime) {
                    if (inModule) {
                        module.exports = runtime
                    }
                    return
                }
                runtime = global.regeneratorRuntime = inModule ? module.exports : {};

                function wrap(innerFn, outerFn, self, tryLocsList) {
                    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
                    var generator = Object.create(protoGenerator.prototype);
                    var context = new Context(tryLocsList || []);
                    generator._invoke = makeInvokeMethod(innerFn, self, context);
                    return generator
                }
                runtime.wrap = wrap;

                function tryCatch(fn, obj, arg) {
                    try {
                        return {
                            type: "normal",
                            arg: fn.call(obj, arg)
                        }
                    } catch (err) {
                        return {
                            type: "throw",
                            arg: err
                        }
                    }
                }
                var GenStateSuspendedStart = "suspendedStart";
                var GenStateSuspendedYield = "suspendedYield";
                var GenStateExecuting = "executing";
                var GenStateCompleted = "completed";
                var ContinueSentinel = {};

                function Generator() {}

                function GeneratorFunction() {}

                function GeneratorFunctionPrototype() {}
                var IteratorPrototype = {};
                IteratorPrototype[iteratorSymbol] = function() {
                    return this
                };
                var getProto = Object.getPrototypeOf;
                var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
                    IteratorPrototype = NativeIteratorPrototype
                }
                var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
                GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
                GeneratorFunctionPrototype.constructor = GeneratorFunction;
                GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

                function defineIteratorMethods(prototype) {
                    ["next", "throw", "return"].forEach(function(method) {
                        prototype[method] = function(arg) {
                            return this._invoke(method, arg)
                        }
                    })
                }
                runtime.isGeneratorFunction = function(genFun) {
                    var ctor = typeof genFun === "function" && genFun.constructor;
                    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false
                };
                runtime.mark = function(genFun) {
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype)
                    } else {
                        genFun.__proto__ = GeneratorFunctionPrototype;
                        if (!(toStringTagSymbol in genFun)) {
                            genFun[toStringTagSymbol] = "GeneratorFunction"
                        }
                    }
                    genFun.prototype = Object.create(Gp);
                    return genFun
                };
                runtime.awrap = function(arg) {
                    return {
                        __await: arg
                    }
                };

                function AsyncIterator(generator) {
                    function invoke(method, arg, resolve, reject) {
                        var record = tryCatch(generator[method], generator, arg);
                        if (record.type === "throw") {
                            reject(record.arg)
                        } else {
                            var result = record.arg;
                            var value = result.value;
                            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                                return Promise.resolve(value.__await).then(function(value) {
                                    invoke("next", value, resolve, reject)
                                }, function(err) {
                                    invoke("throw", err, resolve, reject)
                                })
                            }
                            return Promise.resolve(value).then(function(unwrapped) {
                                result.value = unwrapped;
                                resolve(result)
                            }, reject)
                        }
                    }
                    if (typeof global.process === "object" && global.process.domain) {
                        invoke = global.process.domain.bind(invoke)
                    }
                    var previousPromise;

                    function enqueue(method, arg) {
                        function callInvokeWithMethodAndArg() {
                            return new Promise(function(resolve, reject) {
                                invoke(method, arg, resolve, reject)
                            })
                        }
                        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg()
                    }
                    this._invoke = enqueue
                }
                defineIteratorMethods(AsyncIterator.prototype);
                AsyncIterator.prototype[asyncIteratorSymbol] = function() {
                    return this
                };
                runtime.AsyncIterator = AsyncIterator;
                runtime.async = function(innerFn, outerFn, self, tryLocsList) {
                    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
                    return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                        return result.done ? result.value : iter.next()
                    })
                };

                function makeInvokeMethod(innerFn, self, context) {
                    var state = GenStateSuspendedStart;
                    return function invoke(method, arg) {
                        if (state === GenStateExecuting) {
                            throw new Error("Generator is already running")
                        }
                        if (state === GenStateCompleted) {
                            if (method === "throw") {
                                throw arg
                            }
                            return doneResult()
                        }
                        context.method = method;
                        context.arg = arg;
                        while (true) {
                            var delegate = context.delegate;
                            if (delegate) {
                                var delegateResult = maybeInvokeDelegate(delegate, context);
                                if (delegateResult) {
                                    if (delegateResult === ContinueSentinel) continue;
                                    return delegateResult
                                }
                            }
                            if (context.method === "next") {
                                context.sent = context._sent = context.arg
                            } else if (context.method === "throw") {
                                if (state === GenStateSuspendedStart) {
                                    state = GenStateCompleted;
                                    throw context.arg
                                }
                                context.dispatchException(context.arg)
                            } else if (context.method === "return") {
                                context.abrupt("return", context.arg)
                            }
                            state = GenStateExecuting;
                            var record = tryCatch(innerFn, self, context);
                            if (record.type === "normal") {
                                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                                if (record.arg === ContinueSentinel) {
                                    continue
                                }
                                return {
                                    value: record.arg,
                                    done: context.done
                                }
                            } else if (record.type === "throw") {
                                state = GenStateCompleted;
                                context.method = "throw";
                                context.arg = record.arg
                            }
                        }
                    }
                }

                function maybeInvokeDelegate(delegate, context) {
                    var method = delegate.iterator[context.method];
                    if (method === undefined) {
                        context.delegate = null;
                        if (context.method === "throw") {
                            if (delegate.iterator.return) {
                                context.method = "return";
                                context.arg = undefined;
                                maybeInvokeDelegate(delegate, context);
                                if (context.method === "throw") {
                                    return ContinueSentinel
                                }
                            }
                            context.method = "throw";
                            context.arg = new TypeError("The iterator does not provide a 'throw' method")
                        }
                        return ContinueSentinel
                    }
                    var record = tryCatch(method, delegate.iterator, context.arg);
                    if (record.type === "throw") {
                        context.method = "throw";
                        context.arg = record.arg;
                        context.delegate = null;
                        return ContinueSentinel
                    }
                    var info = record.arg;
                    if (!info) {
                        context.method = "throw";
                        context.arg = new TypeError("iterator result is not an object");
                        context.delegate = null;
                        return ContinueSentinel
                    }
                    if (info.done) {
                        context[delegate.resultName] = info.value;
                        context.next = delegate.nextLoc;
                        if (context.method !== "return") {
                            context.method = "next";
                            context.arg = undefined
                        }
                    } else {
                        return info
                    }
                    context.delegate = null;
                    return ContinueSentinel
                }
                defineIteratorMethods(Gp);
                Gp[toStringTagSymbol] = "Generator";
                Gp[iteratorSymbol] = function() {
                    return this
                };
                Gp.toString = function() {
                    return "[object Generator]"
                };

                function pushTryEntry(locs) {
                    var entry = {
                        tryLoc: locs[0]
                    };
                    if (1 in locs) {
                        entry.catchLoc = locs[1]
                    }
                    if (2 in locs) {
                        entry.finallyLoc = locs[2];
                        entry.afterLoc = locs[3]
                    }
                    this.tryEntries.push(entry)
                }

                function resetTryEntry(entry) {
                    var record = entry.completion || {};
                    record.type = "normal";
                    delete record.arg;
                    entry.completion = record
                }

                function Context(tryLocsList) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }];
                    tryLocsList.forEach(pushTryEntry, this);
                    this.reset(true)
                }
                runtime.keys = function(object) {
                    var keys = [];
                    for (var key in object) {
                        keys.push(key)
                    }
                    keys.reverse();
                    return function next() {
                        while (keys.length) {
                            var key = keys.pop();
                            if (key in object) {
                                next.value = key;
                                next.done = false;
                                return next
                            }
                        }
                        next.done = true;
                        return next
                    }
                };

                function values(iterable) {
                    if (iterable) {
                        var iteratorMethod = iterable[iteratorSymbol];
                        if (iteratorMethod) {
                            return iteratorMethod.call(iterable)
                        }
                        if (typeof iterable.next === "function") {
                            return iterable
                        }
                        if (!isNaN(iterable.length)) {
                            var i = -1,
                                next = function next() {
                                    while (++i < iterable.length) {
                                        if (hasOwn.call(iterable, i)) {
                                            next.value = iterable[i];
                                            next.done = false;
                                            return next
                                        }
                                    }
                                    next.value = undefined;
                                    next.done = true;
                                    return next
                                };
                            return next.next = next
                        }
                    }
                    return {
                        next: doneResult
                    }
                }
                runtime.values = values;

                function doneResult() {
                    return {
                        value: undefined,
                        done: true
                    }
                }
                Context.prototype = {
                    constructor: Context,
                    reset: function(skipTempReset) {
                        this.prev = 0;
                        this.next = 0;
                        this.sent = this._sent = undefined;
                        this.done = false;
                        this.delegate = null;
                        this.method = "next";
                        this.arg = undefined;
                        this.tryEntries.forEach(resetTryEntry);
                        if (!skipTempReset) {
                            for (var name in this) {
                                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                                    this[name] = undefined
                                }
                            }
                        }
                    },
                    stop: function() {
                        this.done = true;
                        var rootEntry = this.tryEntries[0];
                        var rootRecord = rootEntry.completion;
                        if (rootRecord.type === "throw") {
                            throw rootRecord.arg
                        }
                        return this.rval
                    },
                    dispatchException: function(exception) {
                        if (this.done) {
                            throw exception
                        }
                        var context = this;

                        function handle(loc, caught) {
                            record.type = "throw";
                            record.arg = exception;
                            context.next = loc;
                            if (caught) {
                                context.method = "next";
                                context.arg = undefined
                            }
                            return !!caught
                        }
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            var record = entry.completion;
                            if (entry.tryLoc === "root") {
                                return handle("end")
                            }
                            if (entry.tryLoc <= this.prev) {
                                var hasCatch = hasOwn.call(entry, "catchLoc");
                                var hasFinally = hasOwn.call(entry, "finallyLoc");
                                if (hasCatch && hasFinally) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true)
                                    } else if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc)
                                    }
                                } else if (hasCatch) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true)
                                    }
                                } else if (hasFinally) {
                                    if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc)
                                    }
                                } else {
                                    throw new Error("try statement without catch or finally")
                                }
                            }
                        }
                    },
                    abrupt: function(type, arg) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                                var finallyEntry = entry;
                                break
                            }
                        }
                        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                            finallyEntry = null
                        }
                        var record = finallyEntry ? finallyEntry.completion : {};
                        record.type = type;
                        record.arg = arg;
                        if (finallyEntry) {
                            this.method = "next";
                            this.next = finallyEntry.finallyLoc;
                            return ContinueSentinel
                        }
                        return this.complete(record)
                    },
                    complete: function(record, afterLoc) {
                        if (record.type === "throw") {
                            throw record.arg
                        }
                        if (record.type === "break" || record.type === "continue") {
                            this.next = record.arg
                        } else if (record.type === "return") {
                            this.rval = this.arg = record.arg;
                            this.method = "return";
                            this.next = "end"
                        } else if (record.type === "normal" && afterLoc) {
                            this.next = afterLoc
                        }
                        return ContinueSentinel
                    },
                    finish: function(finallyLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.finallyLoc === finallyLoc) {
                                this.complete(entry.completion, entry.afterLoc);
                                resetTryEntry(entry);
                                return ContinueSentinel
                            }
                        }
                    },
                    catch: function(tryLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc === tryLoc) {
                                var record = entry.completion;
                                if (record.type === "throw") {
                                    var thrown = record.arg;
                                    resetTryEntry(entry)
                                }
                                return thrown
                            }
                        }
                        throw new Error("illegal catch attempt")
                    },
                    delegateYield: function(iterable, resultName, nextLoc) {
                        this.delegate = {
                            iterator: values(iterable),
                            resultName: resultName,
                            nextLoc: nextLoc
                        };
                        if (this.method === "next") {
                            this.arg = undefined
                        }
                        return ContinueSentinel
                    }
                }
            }(typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this)
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}],
    329: [function(require, module, exports) {
        (function(global, factory) {
            typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.THREE = {})
        })(this, function(exports) {
            "use strict";
            if (Number.EPSILON === undefined) {
                Number.EPSILON = Math.pow(2, -52)
            }
            if (Number.isInteger === undefined) {
                Number.isInteger = function(value) {
                    return typeof value === "number" && isFinite(value) && Math.floor(value) === value
                }
            }
            if (Math.sign === undefined) {
                Math.sign = function(x) {
                    return x < 0 ? -1 : x > 0 ? 1 : +x
                }
            }
            if ("name" in Function.prototype === false) {
                Object.defineProperty(Function.prototype, "name", {
                    get: function() {
                        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                    }
                })
            }
            if (Object.assign === undefined) {
                (function() {
                    Object.assign = function(target) {
                        if (target === undefined || target === null) {
                            throw new TypeError("Cannot convert undefined or null to object")
                        }
                        var output = Object(target);
                        for (var index = 1; index < arguments.length; index++) {
                            var source = arguments[index];
                            if (source !== undefined && source !== null) {
                                for (var nextKey in source) {
                                    if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                                        output[nextKey] = source[nextKey]
                                    }
                                }
                            }
                        }
                        return output
                    }
                })()
            }

            function EventDispatcher() {}
            Object.assign(EventDispatcher.prototype, {
                addEventListener: function(type, listener) {
                    if (this._listeners === undefined) this._listeners = {};
                    var listeners = this._listeners;
                    if (listeners[type] === undefined) {
                        listeners[type] = []
                    }
                    if (listeners[type].indexOf(listener) === -1) {
                        listeners[type].push(listener)
                    }
                },
                hasEventListener: function(type, listener) {
                    if (this._listeners === undefined) return false;
                    var listeners = this._listeners;
                    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1
                },
                removeEventListener: function(type, listener) {
                    if (this._listeners === undefined) return;
                    var listeners = this._listeners;
                    var listenerArray = listeners[type];
                    if (listenerArray !== undefined) {
                        var index = listenerArray.indexOf(listener);
                        if (index !== -1) {
                            listenerArray.splice(index, 1)
                        }
                    }
                },
                dispatchEvent: function(event) {
                    if (this._listeners === undefined) return;
                    var listeners = this._listeners;
                    var listenerArray = listeners[event.type];
                    if (listenerArray !== undefined) {
                        event.target = this;
                        var array = listenerArray.slice(0);
                        for (var i = 0, l = array.length; i < l; i++) {
                            array[i].call(this, event)
                        }
                    }
                }
            });
            var REVISION = "91";
            var MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            };
            var CullFaceNone = 0;
            var CullFaceBack = 1;
            var CullFaceFront = 2;
            var CullFaceFrontBack = 3;
            var FrontFaceDirectionCW = 0;
            var FrontFaceDirectionCCW = 1;
            var BasicShadowMap = 0;
            var PCFShadowMap = 1;
            var PCFSoftShadowMap = 2;
            var FrontSide = 0;
            var BackSide = 1;
            var DoubleSide = 2;
            var FlatShading = 1;
            var SmoothShading = 2;
            var NoColors = 0;
            var FaceColors = 1;
            var VertexColors = 2;
            var NoBlending = 0;
            var NormalBlending = 1;
            var AdditiveBlending = 2;
            var SubtractiveBlending = 3;
            var MultiplyBlending = 4;
            var CustomBlending = 5;
            var AddEquation = 100;
            var SubtractEquation = 101;
            var ReverseSubtractEquation = 102;
            var MinEquation = 103;
            var MaxEquation = 104;
            var ZeroFactor = 200;
            var OneFactor = 201;
            var SrcColorFactor = 202;
            var OneMinusSrcColorFactor = 203;
            var SrcAlphaFactor = 204;
            var OneMinusSrcAlphaFactor = 205;
            var DstAlphaFactor = 206;
            var OneMinusDstAlphaFactor = 207;
            var DstColorFactor = 208;
            var OneMinusDstColorFactor = 209;
            var SrcAlphaSaturateFactor = 210;
            var NeverDepth = 0;
            var AlwaysDepth = 1;
            var LessDepth = 2;
            var LessEqualDepth = 3;
            var EqualDepth = 4;
            var GreaterEqualDepth = 5;
            var GreaterDepth = 6;
            var NotEqualDepth = 7;
            var MultiplyOperation = 0;
            var MixOperation = 1;
            var AddOperation = 2;
            var NoToneMapping = 0;
            var LinearToneMapping = 1;
            var ReinhardToneMapping = 2;
            var Uncharted2ToneMapping = 3;
            var CineonToneMapping = 4;
            var UVMapping = 300;
            var CubeReflectionMapping = 301;
            var CubeRefractionMapping = 302;
            var EquirectangularReflectionMapping = 303;
            var EquirectangularRefractionMapping = 304;
            var SphericalReflectionMapping = 305;
            var CubeUVReflectionMapping = 306;
            var CubeUVRefractionMapping = 307;
            var RepeatWrapping = 1e3;
            var ClampToEdgeWrapping = 1001;
            var MirroredRepeatWrapping = 1002;
            var NearestFilter = 1003;
            var NearestMipMapNearestFilter = 1004;
            var NearestMipMapLinearFilter = 1005;
            var LinearFilter = 1006;
            var LinearMipMapNearestFilter = 1007;
            var LinearMipMapLinearFilter = 1008;
            var UnsignedByteType = 1009;
            var ByteType = 1010;
            var ShortType = 1011;
            var UnsignedShortType = 1012;
            var IntType = 1013;
            var UnsignedIntType = 1014;
            var FloatType = 1015;
            var HalfFloatType = 1016;
            var UnsignedShort4444Type = 1017;
            var UnsignedShort5551Type = 1018;
            var UnsignedShort565Type = 1019;
            var UnsignedInt248Type = 1020;
            var AlphaFormat = 1021;
            var RGBFormat = 1022;
            var RGBAFormat = 1023;
            var LuminanceFormat = 1024;
            var LuminanceAlphaFormat = 1025;
            var RGBEFormat = RGBAFormat;
            var DepthFormat = 1026;
            var DepthStencilFormat = 1027;
            var RGB_S3TC_DXT1_Format = 33776;
            var RGBA_S3TC_DXT1_Format = 33777;
            var RGBA_S3TC_DXT3_Format = 33778;
            var RGBA_S3TC_DXT5_Format = 33779;
            var RGB_PVRTC_4BPPV1_Format = 35840;
            var RGB_PVRTC_2BPPV1_Format = 35841;
            var RGBA_PVRTC_4BPPV1_Format = 35842;
            var RGBA_PVRTC_2BPPV1_Format = 35843;
            var RGB_ETC1_Format = 36196;
            var RGBA_ASTC_4x4_Format = 37808;
            var RGBA_ASTC_5x4_Format = 37809;
            var RGBA_ASTC_5x5_Format = 37810;
            var RGBA_ASTC_6x5_Format = 37811;
            var RGBA_ASTC_6x6_Format = 37812;
            var RGBA_ASTC_8x5_Format = 37813;
            var RGBA_ASTC_8x6_Format = 37814;
            var RGBA_ASTC_8x8_Format = 37815;
            var RGBA_ASTC_10x5_Format = 37816;
            var RGBA_ASTC_10x6_Format = 37817;
            var RGBA_ASTC_10x8_Format = 37818;
            var RGBA_ASTC_10x10_Format = 37819;
            var RGBA_ASTC_12x10_Format = 37820;
            var RGBA_ASTC_12x12_Format = 37821;
            var LoopOnce = 2200;
            var LoopRepeat = 2201;
            var LoopPingPong = 2202;
            var InterpolateDiscrete = 2300;
            var InterpolateLinear = 2301;
            var InterpolateSmooth = 2302;
            var ZeroCurvatureEnding = 2400;
            var ZeroSlopeEnding = 2401;
            var WrapAroundEnding = 2402;
            var TrianglesDrawMode = 0;
            var TriangleStripDrawMode = 1;
            var TriangleFanDrawMode = 2;
            var LinearEncoding = 3e3;
            var sRGBEncoding = 3001;
            var GammaEncoding = 3007;
            var RGBEEncoding = 3002;
            var LogLuvEncoding = 3003;
            var RGBM7Encoding = 3004;
            var RGBM16Encoding = 3005;
            var RGBDEncoding = 3006;
            var BasicDepthPacking = 3200;
            var RGBADepthPacking = 3201;
            var _Math = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var lut = [];
                    for (var i = 0; i < 256; i++) {
                        lut[i] = (i < 16 ? "0" : "") + i.toString(16).toUpperCase()
                    }
                    return function generateUUID() {
                        var d0 = Math.random() * 4294967295 | 0;
                        var d1 = Math.random() * 4294967295 | 0;
                        var d2 = Math.random() * 4294967295 | 0;
                        var d3 = Math.random() * 4294967295 | 0;
                        return lut[d0 & 255] + lut[d0 >> 8 & 255] + lut[d0 >> 16 & 255] + lut[d0 >> 24 & 255] + "-" + lut[d1 & 255] + lut[d1 >> 8 & 255] + "-" + lut[d1 >> 16 & 15 | 64] + lut[d1 >> 24 & 255] + "-" + lut[d2 & 63 | 128] + lut[d2 >> 8 & 255] + "-" + lut[d2 >> 16 & 255] + lut[d2 >> 24 & 255] + lut[d3 & 255] + lut[d3 >> 8 & 255] + lut[d3 >> 16 & 255] + lut[d3 >> 24 & 255]
                    }
                }(),
                clamp: function(value, min, max) {
                    return Math.max(min, Math.min(max, value))
                },
                euclideanModulo: function(n, m) {
                    return (n % m + m) % m
                },
                mapLinear: function(x, a1, a2, b1, b2) {
                    return b1 + (x - a1) * (b2 - b1) / (a2 - a1)
                },
                lerp: function(x, y, t) {
                    return (1 - t) * x + t * y
                },
                smoothstep: function(x, min, max) {
                    if (x <= min) return 0;
                    if (x >= max) return 1;
                    x = (x - min) / (max - min);
                    return x * x * (3 - 2 * x)
                },
                smootherstep: function(x, min, max) {
                    if (x <= min) return 0;
                    if (x >= max) return 1;
                    x = (x - min) / (max - min);
                    return x * x * x * (x * (x * 6 - 15) + 10)
                },
                randInt: function(low, high) {
                    return low + Math.floor(Math.random() * (high - low + 1))
                },
                randFloat: function(low, high) {
                    return low + Math.random() * (high - low)
                },
                randFloatSpread: function(range) {
                    return range * (.5 - Math.random())
                },
                degToRad: function(degrees) {
                    return degrees * _Math.DEG2RAD
                },
                radToDeg: function(radians) {
                    return radians * _Math.RAD2DEG
                },
                isPowerOfTwo: function(value) {
                    return (value & value - 1) === 0 && value !== 0
                },
                ceilPowerOfTwo: function(value) {
                    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2))
                },
                floorPowerOfTwo: function(value) {
                    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2))
                }
            };

            function Vector2(x, y) {
                this.x = x || 0;
                this.y = y || 0
            }
            Object.defineProperties(Vector2.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(value) {
                        this.x = value
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(value) {
                        this.y = value
                    }
                }
            });
            Object.assign(Vector2.prototype, {
                isVector2: true,
                set: function(x, y) {
                    this.x = x;
                    this.y = y;
                    return this
                },
                setScalar: function(scalar) {
                    this.x = scalar;
                    this.y = scalar;
                    return this
                },
                setX: function(x) {
                    this.x = x;
                    return this
                },
                setY: function(y) {
                    this.y = y;
                    return this
                },
                setComponent: function(index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                    return this
                },
                getComponent: function(index) {
                    switch (index) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(v) {
                    this.x = v.x;
                    this.y = v.y;
                    return this
                },
                add: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                        return this.addVectors(v, w)
                    }
                    this.x += v.x;
                    this.y += v.y;
                    return this
                },
                addScalar: function(s) {
                    this.x += s;
                    this.y += s;
                    return this
                },
                addVectors: function(a, b) {
                    this.x = a.x + b.x;
                    this.y = a.y + b.y;
                    return this
                },
                addScaledVector: function(v, s) {
                    this.x += v.x * s;
                    this.y += v.y * s;
                    return this
                },
                sub: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                        return this.subVectors(v, w)
                    }
                    this.x -= v.x;
                    this.y -= v.y;
                    return this
                },
                subScalar: function(s) {
                    this.x -= s;
                    this.y -= s;
                    return this
                },
                subVectors: function(a, b) {
                    this.x = a.x - b.x;
                    this.y = a.y - b.y;
                    return this
                },
                multiply: function(v) {
                    this.x *= v.x;
                    this.y *= v.y;
                    return this
                },
                multiplyScalar: function(scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    return this
                },
                divide: function(v) {
                    this.x /= v.x;
                    this.y /= v.y;
                    return this
                },
                divideScalar: function(scalar) {
                    return this.multiplyScalar(1 / scalar)
                },
                applyMatrix3: function(m) {
                    var x = this.x,
                        y = this.y;
                    var e = m.elements;
                    this.x = e[0] * x + e[3] * y + e[6];
                    this.y = e[1] * x + e[4] * y + e[7];
                    return this
                },
                min: function(v) {
                    this.x = Math.min(this.x, v.x);
                    this.y = Math.min(this.y, v.y);
                    return this
                },
                max: function(v) {
                    this.x = Math.max(this.x, v.x);
                    this.y = Math.max(this.y, v.y);
                    return this
                },
                clamp: function(min, max) {
                    this.x = Math.max(min.x, Math.min(max.x, this.x));
                    this.y = Math.max(min.y, Math.min(max.y, this.y));
                    return this
                },
                clampScalar: function() {
                    var min = new Vector2;
                    var max = new Vector2;
                    return function clampScalar(minVal, maxVal) {
                        min.set(minVal, minVal);
                        max.set(maxVal, maxVal);
                        return this.clamp(min, max)
                    }
                }(),
                clampLength: function(min, max) {
                    var length = this.length();
                    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
                },
                floor: function() {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    return this
                },
                ceil: function() {
                    this.x = Math.ceil(this.x);
                    this.y = Math.ceil(this.y);
                    return this
                },
                round: function() {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    return this
                },
                roundToZero: function() {
                    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
                    return this
                },
                negate: function() {
                    this.x = -this.x;
                    this.y = -this.y;
                    return this
                },
                dot: function(v) {
                    return this.x * v.x + this.y * v.y
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var angle = Math.atan2(this.y, this.x);
                    if (angle < 0) angle += 2 * Math.PI;
                    return angle
                },
                distanceTo: function(v) {
                    return Math.sqrt(this.distanceToSquared(v))
                },
                distanceToSquared: function(v) {
                    var dx = this.x - v.x,
                        dy = this.y - v.y;
                    return dx * dx + dy * dy
                },
                manhattanDistanceTo: function(v) {
                    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)
                },
                setLength: function(length) {
                    return this.normalize().multiplyScalar(length)
                },
                lerp: function(v, alpha) {
                    this.x += (v.x - this.x) * alpha;
                    this.y += (v.y - this.y) * alpha;
                    return this
                },
                lerpVectors: function(v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
                },
                equals: function(v) {
                    return v.x === this.x && v.y === this.y
                },
                fromArray: function(array, offset) {
                    if (offset === undefined) offset = 0;
                    this.x = array[offset];
                    this.y = array[offset + 1];
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    array[offset] = this.x;
                    array[offset + 1] = this.y;
                    return array
                },
                fromBufferAttribute: function(attribute, index, offset) {
                    if (offset !== undefined) {
                        console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().")
                    }
                    this.x = attribute.getX(index);
                    this.y = attribute.getY(index);
                    return this
                },
                rotateAround: function(center, angle) {
                    var c = Math.cos(angle),
                        s = Math.sin(angle);
                    var x = this.x - center.x;
                    var y = this.y - center.y;
                    this.x = x * c - y * s + center.x;
                    this.y = x * s + y * c + center.y;
                    return this
                }
            });

            function Matrix4() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                if (arguments.length > 0) {
                    console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
            }
            Object.assign(Matrix4.prototype, {
                isMatrix4: true,
                set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                    var te = this.elements;
                    te[0] = n11;
                    te[4] = n12;
                    te[8] = n13;
                    te[12] = n14;
                    te[1] = n21;
                    te[5] = n22;
                    te[9] = n23;
                    te[13] = n24;
                    te[2] = n31;
                    te[6] = n32;
                    te[10] = n33;
                    te[14] = n34;
                    te[3] = n41;
                    te[7] = n42;
                    te[11] = n43;
                    te[15] = n44;
                    return this
                },
                identity: function() {
                    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                    return this
                },
                clone: function() {
                    return (new Matrix4).fromArray(this.elements)
                },
                copy: function(m) {
                    var te = this.elements;
                    var me = m.elements;
                    te[0] = me[0];
                    te[1] = me[1];
                    te[2] = me[2];
                    te[3] = me[3];
                    te[4] = me[4];
                    te[5] = me[5];
                    te[6] = me[6];
                    te[7] = me[7];
                    te[8] = me[8];
                    te[9] = me[9];
                    te[10] = me[10];
                    te[11] = me[11];
                    te[12] = me[12];
                    te[13] = me[13];
                    te[14] = me[14];
                    te[15] = me[15];
                    return this
                },
                copyPosition: function(m) {
                    var te = this.elements,
                        me = m.elements;
                    te[12] = me[12];
                    te[13] = me[13];
                    te[14] = me[14];
                    return this
                },
                extractBasis: function(xAxis, yAxis, zAxis) {
                    xAxis.setFromMatrixColumn(this, 0);
                    yAxis.setFromMatrixColumn(this, 1);
                    zAxis.setFromMatrixColumn(this, 2);
                    return this
                },
                makeBasis: function(xAxis, yAxis, zAxis) {
                    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
                    return this
                },
                extractRotation: function() {
                    var v1 = new Vector3;
                    return function extractRotation(m) {
                        var te = this.elements;
                        var me = m.elements;
                        var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                        var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                        var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                        te[0] = me[0] * scaleX;
                        te[1] = me[1] * scaleX;
                        te[2] = me[2] * scaleX;
                        te[4] = me[4] * scaleY;
                        te[5] = me[5] * scaleY;
                        te[6] = me[6] * scaleY;
                        te[8] = me[8] * scaleZ;
                        te[9] = me[9] * scaleZ;
                        te[10] = me[10] * scaleZ;
                        return this
                    }
                }(),
                makeRotationFromEuler: function(euler) {
                    if (!(euler && euler.isEuler)) {
                        console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.")
                    }
                    var te = this.elements;
                    var x = euler.x,
                        y = euler.y,
                        z = euler.z;
                    var a = Math.cos(x),
                        b = Math.sin(x);
                    var c = Math.cos(y),
                        d = Math.sin(y);
                    var e = Math.cos(z),
                        f = Math.sin(z);
                    if (euler.order === "XYZ") {
                        var ae = a * e,
                            af = a * f,
                            be = b * e,
                            bf = b * f;
                        te[0] = c * e;
                        te[4] = -c * f;
                        te[8] = d;
                        te[1] = af + be * d;
                        te[5] = ae - bf * d;
                        te[9] = -b * c;
                        te[2] = bf - ae * d;
                        te[6] = be + af * d;
                        te[10] = a * c
                    } else if (euler.order === "YXZ") {
                        var ce = c * e,
                            cf = c * f,
                            de = d * e,
                            df = d * f;
                        te[0] = ce + df * b;
                        te[4] = de * b - cf;
                        te[8] = a * d;
                        te[1] = a * f;
                        te[5] = a * e;
                        te[9] = -b;
                        te[2] = cf * b - de;
                        te[6] = df + ce * b;
                        te[10] = a * c
                    } else if (euler.order === "ZXY") {
                        var ce = c * e,
                            cf = c * f,
                            de = d * e,
                            df = d * f;
                        te[0] = ce - df * b;
                        te[4] = -a * f;
                        te[8] = de + cf * b;
                        te[1] = cf + de * b;
                        te[5] = a * e;
                        te[9] = df - ce * b;
                        te[2] = -a * d;
                        te[6] = b;
                        te[10] = a * c
                    } else if (euler.order === "ZYX") {
                        var ae = a * e,
                            af = a * f,
                            be = b * e,
                            bf = b * f;
                        te[0] = c * e;
                        te[4] = be * d - af;
                        te[8] = ae * d + bf;
                        te[1] = c * f;
                        te[5] = bf * d + ae;
                        te[9] = af * d - be;
                        te[2] = -d;
                        te[6] = b * c;
                        te[10] = a * c
                    } else if (euler.order === "YZX") {
                        var ac = a * c,
                            ad = a * d,
                            bc = b * c,
                            bd = b * d;
                        te[0] = c * e;
                        te[4] = bd - ac * f;
                        te[8] = bc * f + ad;
                        te[1] = f;
                        te[5] = a * e;
                        te[9] = -b * e;
                        te[2] = -d * e;
                        te[6] = ad * f + bc;
                        te[10] = ac - bd * f
                    } else if (euler.order === "XZY") {
                        var ac = a * c,
                            ad = a * d,
                            bc = b * c,
                            bd = b * d;
                        te[0] = c * e;
                        te[4] = -f;
                        te[8] = d * e;
                        te[1] = ac * f + bd;
                        te[5] = a * e;
                        te[9] = ad * f - bc;
                        te[2] = bc * f - ad;
                        te[6] = b * e;
                        te[10] = bd * f + ac
                    }
                    te[3] = 0;
                    te[7] = 0;
                    te[11] = 0;
                    te[12] = 0;
                    te[13] = 0;
                    te[14] = 0;
                    te[15] = 1;
                    return this
                },
                makeRotationFromQuaternion: function(q) {
                    var te = this.elements;
                    var x = q._x,
                        y = q._y,
                        z = q._z,
                        w = q._w;
                    var x2 = x + x,
                        y2 = y + y,
                        z2 = z + z;
                    var xx = x * x2,
                        xy = x * y2,
                        xz = x * z2;
                    var yy = y * y2,
                        yz = y * z2,
                        zz = z * z2;
                    var wx = w * x2,
                        wy = w * y2,
                        wz = w * z2;
                    te[0] = 1 - (yy + zz);
                    te[4] = xy - wz;
                    te[8] = xz + wy;
                    te[1] = xy + wz;
                    te[5] = 1 - (xx + zz);
                    te[9] = yz - wx;
                    te[2] = xz - wy;
                    te[6] = yz + wx;
                    te[10] = 1 - (xx + yy);
                    te[3] = 0;
                    te[7] = 0;
                    te[11] = 0;
                    te[12] = 0;
                    te[13] = 0;
                    te[14] = 0;
                    te[15] = 1;
                    return this
                },
                lookAt: function() {
                    var x = new Vector3;
                    var y = new Vector3;
                    var z = new Vector3;
                    return function lookAt(eye, target, up) {
                        var te = this.elements;
                        z.subVectors(eye, target);
                        if (z.lengthSq() === 0) {
                            z.z = 1
                        }
                        z.normalize();
                        x.crossVectors(up, z);
                        if (x.lengthSq() === 0) {
                            if (Math.abs(up.z) === 1) {
                                z.x += 1e-4
                            } else {
                                z.z += 1e-4
                            }
                            z.normalize();
                            x.crossVectors(up, z)
                        }
                        x.normalize();
                        y.crossVectors(z, x);
                        te[0] = x.x;
                        te[4] = y.x;
                        te[8] = z.x;
                        te[1] = x.y;
                        te[5] = y.y;
                        te[9] = z.y;
                        te[2] = x.z;
                        te[6] = y.z;
                        te[10] = z.z;
                        return this
                    }
                }(),
                multiply: function(m, n) {
                    if (n !== undefined) {
                        console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
                        return this.multiplyMatrices(m, n)
                    }
                    return this.multiplyMatrices(this, m)
                },
                premultiply: function(m) {
                    return this.multiplyMatrices(m, this)
                },
                multiplyMatrices: function(a, b) {
                    var ae = a.elements;
                    var be = b.elements;
                    var te = this.elements;
                    var a11 = ae[0],
                        a12 = ae[4],
                        a13 = ae[8],
                        a14 = ae[12];
                    var a21 = ae[1],
                        a22 = ae[5],
                        a23 = ae[9],
                        a24 = ae[13];
                    var a31 = ae[2],
                        a32 = ae[6],
                        a33 = ae[10],
                        a34 = ae[14];
                    var a41 = ae[3],
                        a42 = ae[7],
                        a43 = ae[11],
                        a44 = ae[15];
                    var b11 = be[0],
                        b12 = be[4],
                        b13 = be[8],
                        b14 = be[12];
                    var b21 = be[1],
                        b22 = be[5],
                        b23 = be[9],
                        b24 = be[13];
                    var b31 = be[2],
                        b32 = be[6],
                        b33 = be[10],
                        b34 = be[14];
                    var b41 = be[3],
                        b42 = be[7],
                        b43 = be[11],
                        b44 = be[15];
                    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                    return this
                },
                multiplyScalar: function(s) {
                    var te = this.elements;
                    te[0] *= s;
                    te[4] *= s;
                    te[8] *= s;
                    te[12] *= s;
                    te[1] *= s;
                    te[5] *= s;
                    te[9] *= s;
                    te[13] *= s;
                    te[2] *= s;
                    te[6] *= s;
                    te[10] *= s;
                    te[14] *= s;
                    te[3] *= s;
                    te[7] *= s;
                    te[11] *= s;
                    te[15] *= s;
                    return this
                },
                applyToBufferAttribute: function() {
                    var v1 = new Vector3;
                    return function applyToBufferAttribute(attribute) {
                        for (var i = 0, l = attribute.count; i < l; i++) {
                            v1.x = attribute.getX(i);
                            v1.y = attribute.getY(i);
                            v1.z = attribute.getZ(i);
                            v1.applyMatrix4(this);
                            attribute.setXYZ(i, v1.x, v1.y, v1.z)
                        }
                        return attribute
                    }
                }(),
                determinant: function() {
                    var te = this.elements;
                    var n11 = te[0],
                        n12 = te[4],
                        n13 = te[8],
                        n14 = te[12];
                    var n21 = te[1],
                        n22 = te[5],
                        n23 = te[9],
                        n24 = te[13];
                    var n31 = te[2],
                        n32 = te[6],
                        n33 = te[10],
                        n34 = te[14];
                    var n41 = te[3],
                        n42 = te[7],
                        n43 = te[11],
                        n44 = te[15];
                    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31)
                },
                transpose: function() {
                    var te = this.elements;
                    var tmp;
                    tmp = te[1];
                    te[1] = te[4];
                    te[4] = tmp;
                    tmp = te[2];
                    te[2] = te[8];
                    te[8] = tmp;
                    tmp = te[6];
                    te[6] = te[9];
                    te[9] = tmp;
                    tmp = te[3];
                    te[3] = te[12];
                    te[12] = tmp;
                    tmp = te[7];
                    te[7] = te[13];
                    te[13] = tmp;
                    tmp = te[11];
                    te[11] = te[14];
                    te[14] = tmp;
                    return this
                },
                setPosition: function(v) {
                    var te = this.elements;
                    te[12] = v.x;
                    te[13] = v.y;
                    te[14] = v.z;
                    return this
                },
                getInverse: function(m, throwOnDegenerate) {
                    var te = this.elements,
                        me = m.elements,
                        n11 = me[0],
                        n21 = me[1],
                        n31 = me[2],
                        n41 = me[3],
                        n12 = me[4],
                        n22 = me[5],
                        n32 = me[6],
                        n42 = me[7],
                        n13 = me[8],
                        n23 = me[9],
                        n33 = me[10],
                        n43 = me[11],
                        n14 = me[12],
                        n24 = me[13],
                        n34 = me[14],
                        n44 = me[15],
                        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
                    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
                    if (det === 0) {
                        var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (throwOnDegenerate === true) {
                            throw new Error(msg)
                        } else {
                            console.warn(msg)
                        }
                        return this.identity()
                    }
                    var detInv = 1 / det;
                    te[0] = t11 * detInv;
                    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
                    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
                    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
                    te[4] = t12 * detInv;
                    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
                    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
                    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
                    te[8] = t13 * detInv;
                    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
                    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
                    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
                    te[12] = t14 * detInv;
                    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
                    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
                    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
                    return this
                },
                scale: function(v) {
                    var te = this.elements;
                    var x = v.x,
                        y = v.y,
                        z = v.z;
                    te[0] *= x;
                    te[4] *= y;
                    te[8] *= z;
                    te[1] *= x;
                    te[5] *= y;
                    te[9] *= z;
                    te[2] *= x;
                    te[6] *= y;
                    te[10] *= z;
                    te[3] *= x;
                    te[7] *= y;
                    te[11] *= z;
                    return this
                },
                getMaxScaleOnAxis: function() {
                    var te = this.elements;
                    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
                    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
                    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
                    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq))
                },
                makeTranslation: function(x, y, z) {
                    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
                    return this
                },
                makeRotationX: function(theta) {
                    var c = Math.cos(theta),
                        s = Math.sin(theta);
                    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
                    return this
                },
                makeRotationY: function(theta) {
                    var c = Math.cos(theta),
                        s = Math.sin(theta);
                    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
                    return this
                },
                makeRotationZ: function(theta) {
                    var c = Math.cos(theta),
                        s = Math.sin(theta);
                    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                    return this
                },
                makeRotationAxis: function(axis, angle) {
                    var c = Math.cos(angle);
                    var s = Math.sin(angle);
                    var t = 1 - c;
                    var x = axis.x,
                        y = axis.y,
                        z = axis.z;
                    var tx = t * x,
                        ty = t * y;
                    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
                    return this
                },
                makeScale: function(x, y, z) {
                    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
                    return this
                },
                makeShear: function(x, y, z) {
                    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
                    return this
                },
                compose: function(position, quaternion, scale) {
                    this.makeRotationFromQuaternion(quaternion);
                    this.scale(scale);
                    this.setPosition(position);
                    return this
                },
                decompose: function() {
                    var vector = new Vector3;
                    var matrix = new Matrix4;
                    return function decompose(position, quaternion, scale) {
                        var te = this.elements;
                        var sx = vector.set(te[0], te[1], te[2]).length();
                        var sy = vector.set(te[4], te[5], te[6]).length();
                        var sz = vector.set(te[8], te[9], te[10]).length();
                        var det = this.determinant();
                        if (det < 0) sx = -sx;
                        position.x = te[12];
                        position.y = te[13];
                        position.z = te[14];
                        matrix.copy(this);
                        var invSX = 1 / sx;
                        var invSY = 1 / sy;
                        var invSZ = 1 / sz;
                        matrix.elements[0] *= invSX;
                        matrix.elements[1] *= invSX;
                        matrix.elements[2] *= invSX;
                        matrix.elements[4] *= invSY;
                        matrix.elements[5] *= invSY;
                        matrix.elements[6] *= invSY;
                        matrix.elements[8] *= invSZ;
                        matrix.elements[9] *= invSZ;
                        matrix.elements[10] *= invSZ;
                        quaternion.setFromRotationMatrix(matrix);
                        scale.x = sx;
                        scale.y = sy;
                        scale.z = sz;
                        return this
                    }
                }(),
                makePerspective: function(left, right, top, bottom, near, far) {
                    if (far === undefined) {
                        console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.")
                    }
                    var te = this.elements;
                    var x = 2 * near / (right - left);
                    var y = 2 * near / (top - bottom);
                    var a = (right + left) / (right - left);
                    var b = (top + bottom) / (top - bottom);
                    var c = -(far + near) / (far - near);
                    var d = -2 * far * near / (far - near);
                    te[0] = x;
                    te[4] = 0;
                    te[8] = a;
                    te[12] = 0;
                    te[1] = 0;
                    te[5] = y;
                    te[9] = b;
                    te[13] = 0;
                    te[2] = 0;
                    te[6] = 0;
                    te[10] = c;
                    te[14] = d;
                    te[3] = 0;
                    te[7] = 0;
                    te[11] = -1;
                    te[15] = 0;
                    return this
                },
                makeOrthographic: function(left, right, top, bottom, near, far) {
                    var te = this.elements;
                    var w = 1 / (right - left);
                    var h = 1 / (top - bottom);
                    var p = 1 / (far - near);
                    var x = (right + left) * w;
                    var y = (top + bottom) * h;
                    var z = (far + near) * p;
                    te[0] = 2 * w;
                    te[4] = 0;
                    te[8] = 0;
                    te[12] = -x;
                    te[1] = 0;
                    te[5] = 2 * h;
                    te[9] = 0;
                    te[13] = -y;
                    te[2] = 0;
                    te[6] = 0;
                    te[10] = -2 * p;
                    te[14] = -z;
                    te[3] = 0;
                    te[7] = 0;
                    te[11] = 0;
                    te[15] = 1;
                    return this
                },
                equals: function(matrix) {
                    var te = this.elements;
                    var me = matrix.elements;
                    for (var i = 0; i < 16; i++) {
                        if (te[i] !== me[i]) return false
                    }
                    return true
                },
                fromArray: function(array, offset) {
                    if (offset === undefined) offset = 0;
                    for (var i = 0; i < 16; i++) {
                        this.elements[i] = array[i + offset]
                    }
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    var te = this.elements;
                    array[offset] = te[0];
                    array[offset + 1] = te[1];
                    array[offset + 2] = te[2];
                    array[offset + 3] = te[3];
                    array[offset + 4] = te[4];
                    array[offset + 5] = te[5];
                    array[offset + 6] = te[6];
                    array[offset + 7] = te[7];
                    array[offset + 8] = te[8];
                    array[offset + 9] = te[9];
                    array[offset + 10] = te[10];
                    array[offset + 11] = te[11];
                    array[offset + 12] = te[12];
                    array[offset + 13] = te[13];
                    array[offset + 14] = te[14];
                    array[offset + 15] = te[15];
                    return array
                }
            });

            function Quaternion(x, y, z, w) {
                this._x = x || 0;
                this._y = y || 0;
                this._z = z || 0;
                this._w = w !== undefined ? w : 1
            }
            Object.assign(Quaternion, {
                slerp: function(qa, qb, qm, t) {
                    return qm.copy(qa).slerp(qb, t)
                },
                slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
                    var x0 = src0[srcOffset0 + 0],
                        y0 = src0[srcOffset0 + 1],
                        z0 = src0[srcOffset0 + 2],
                        w0 = src0[srcOffset0 + 3],
                        x1 = src1[srcOffset1 + 0],
                        y1 = src1[srcOffset1 + 1],
                        z1 = src1[srcOffset1 + 2],
                        w1 = src1[srcOffset1 + 3];
                    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                        var s = 1 - t,
                            cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                            dir = cos >= 0 ? 1 : -1,
                            sqrSin = 1 - cos * cos;
                        if (sqrSin > Number.EPSILON) {
                            var sin = Math.sqrt(sqrSin),
                                len = Math.atan2(sin, cos * dir);
                            s = Math.sin(s * len) / sin;
                            t = Math.sin(t * len) / sin
                        }
                        var tDir = t * dir;
                        x0 = x0 * s + x1 * tDir;
                        y0 = y0 * s + y1 * tDir;
                        z0 = z0 * s + z1 * tDir;
                        w0 = w0 * s + w1 * tDir;
                        if (s === 1 - t) {
                            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                            x0 *= f;
                            y0 *= f;
                            z0 *= f;
                            w0 *= f
                        }
                    }
                    dst[dstOffset] = x0;
                    dst[dstOffset + 1] = y0;
                    dst[dstOffset + 2] = z0;
                    dst[dstOffset + 3] = w0
                }
            });
            Object.defineProperties(Quaternion.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(value) {
                        this._x = value;
                        this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(value) {
                        this._y = value;
                        this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(value) {
                        this._z = value;
                        this.onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(value) {
                        this._w = value;
                        this.onChangeCallback()
                    }
                }
            });
            Object.assign(Quaternion.prototype, {
                set: function(x, y, z, w) {
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    this._w = w;
                    this.onChangeCallback();
                    return this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(quaternion) {
                    this._x = quaternion.x;
                    this._y = quaternion.y;
                    this._z = quaternion.z;
                    this._w = quaternion.w;
                    this.onChangeCallback();
                    return this
                },
                setFromEuler: function(euler, update) {
                    if (!(euler && euler.isEuler)) {
                        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.")
                    }
                    var x = euler._x,
                        y = euler._y,
                        z = euler._z,
                        order = euler.order;
                    var cos = Math.cos;
                    var sin = Math.sin;
                    var c1 = cos(x / 2);
                    var c2 = cos(y / 2);
                    var c3 = cos(z / 2);
                    var s1 = sin(x / 2);
                    var s2 = sin(y / 2);
                    var s3 = sin(z / 2);
                    if (order === "XYZ") {
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3
                    } else if (order === "YXZ") {
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3
                    } else if (order === "ZXY") {
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3
                    } else if (order === "ZYX") {
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3
                    } else if (order === "YZX") {
                        this._x = s1 * c2 * c3 + c1 * s2 * s3;
                        this._y = c1 * s2 * c3 + s1 * c2 * s3;
                        this._z = c1 * c2 * s3 - s1 * s2 * c3;
                        this._w = c1 * c2 * c3 - s1 * s2 * s3
                    } else if (order === "XZY") {
                        this._x = s1 * c2 * c3 - c1 * s2 * s3;
                        this._y = c1 * s2 * c3 - s1 * c2 * s3;
                        this._z = c1 * c2 * s3 + s1 * s2 * c3;
                        this._w = c1 * c2 * c3 + s1 * s2 * s3
                    }
                    if (update !== false) this.onChangeCallback();
                    return this
                },
                setFromAxisAngle: function(axis, angle) {
                    var halfAngle = angle / 2,
                        s = Math.sin(halfAngle);
                    this._x = axis.x * s;
                    this._y = axis.y * s;
                    this._z = axis.z * s;
                    this._w = Math.cos(halfAngle);
                    this.onChangeCallback();
                    return this
                },
                setFromRotationMatrix: function(m) {
                    var te = m.elements,
                        m11 = te[0],
                        m12 = te[4],
                        m13 = te[8],
                        m21 = te[1],
                        m22 = te[5],
                        m23 = te[9],
                        m31 = te[2],
                        m32 = te[6],
                        m33 = te[10],
                        trace = m11 + m22 + m33,
                        s;
                    if (trace > 0) {
                        s = .5 / Math.sqrt(trace + 1);
                        this._w = .25 / s;
                        this._x = (m32 - m23) * s;
                        this._y = (m13 - m31) * s;
                        this._z = (m21 - m12) * s
                    } else if (m11 > m22 && m11 > m33) {
                        s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                        this._w = (m32 - m23) / s;
                        this._x = .25 * s;
                        this._y = (m12 + m21) / s;
                        this._z = (m13 + m31) / s
                    } else if (m22 > m33) {
                        s = 2 * Math.sqrt(1 + m22 - m11 - m33);
                        this._w = (m13 - m31) / s;
                        this._x = (m12 + m21) / s;
                        this._y = .25 * s;
                        this._z = (m23 + m32) / s
                    } else {
                        s = 2 * Math.sqrt(1 + m33 - m11 - m22);
                        this._w = (m21 - m12) / s;
                        this._x = (m13 + m31) / s;
                        this._y = (m23 + m32) / s;
                        this._z = .25 * s
                    }
                    this.onChangeCallback();
                    return this
                },
                setFromUnitVectors: function() {
                    var v1 = new Vector3;
                    var r;
                    var EPS = 1e-6;
                    return function setFromUnitVectors(vFrom, vTo) {
                        if (v1 === undefined) v1 = new Vector3;
                        r = vFrom.dot(vTo) + 1;
                        if (r < EPS) {
                            r = 0;
                            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                                v1.set(-vFrom.y, vFrom.x, 0)
                            } else {
                                v1.set(0, -vFrom.z, vFrom.y)
                            }
                        } else {
                            v1.crossVectors(vFrom, vTo)
                        }
                        this._x = v1.x;
                        this._y = v1.y;
                        this._z = v1.z;
                        this._w = r;
                        return this.normalize()
                    }
                }(),
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    this._x *= -1;
                    this._y *= -1;
                    this._z *= -1;
                    this.onChangeCallback();
                    return this
                },
                dot: function(v) {
                    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var l = this.length();
                    if (l === 0) {
                        this._x = 0;
                        this._y = 0;
                        this._z = 0;
                        this._w = 1
                    } else {
                        l = 1 / l;
                        this._x = this._x * l;
                        this._y = this._y * l;
                        this._z = this._z * l;
                        this._w = this._w * l
                    }
                    this.onChangeCallback();
                    return this
                },
                multiply: function(q, p) {
                    if (p !== undefined) {
                        console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
                        return this.multiplyQuaternions(q, p)
                    }
                    return this.multiplyQuaternions(this, q)
                },
                premultiply: function(q) {
                    return this.multiplyQuaternions(q, this)
                },
                multiplyQuaternions: function(a, b) {
                    var qax = a._x,
                        qay = a._y,
                        qaz = a._z,
                        qaw = a._w;
                    var qbx = b._x,
                        qby = b._y,
                        qbz = b._z,
                        qbw = b._w;
                    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
                    this.onChangeCallback();
                    return this
                },
                slerp: function(qb, t) {
                    if (t === 0) return this;
                    if (t === 1) return this.copy(qb);
                    var x = this._x,
                        y = this._y,
                        z = this._z,
                        w = this._w;
                    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
                    if (cosHalfTheta < 0) {
                        this._w = -qb._w;
                        this._x = -qb._x;
                        this._y = -qb._y;
                        this._z = -qb._z;
                        cosHalfTheta = -cosHalfTheta
                    } else {
                        this.copy(qb)
                    }
                    if (cosHalfTheta >= 1) {
                        this._w = w;
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        return this
                    }
                    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
                    if (Math.abs(sinHalfTheta) < .001) {
                        this._w = .5 * (w + this._w);
                        this._x = .5 * (x + this._x);
                        this._y = .5 * (y + this._y);
                        this._z = .5 * (z + this._z);
                        return this
                    }
                    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
                    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                    this._w = w * ratioA + this._w * ratioB;
                    this._x = x * ratioA + this._x * ratioB;
                    this._y = y * ratioA + this._y * ratioB;
                    this._z = z * ratioA + this._z * ratioB;
                    this.onChangeCallback();
                    return this
                },
                equals: function(quaternion) {
                    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w
                },
                fromArray: function(array, offset) {
                    if (offset === undefined) offset = 0;
                    this._x = array[offset];
                    this._y = array[offset + 1];
                    this._z = array[offset + 2];
                    this._w = array[offset + 3];
                    this.onChangeCallback();
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    array[offset] = this._x;
                    array[offset + 1] = this._y;
                    array[offset + 2] = this._z;
                    array[offset + 3] = this._w;
                    return array
                },
                onChange: function(callback) {
                    this.onChangeCallback = callback;
                    return this
                },
                onChangeCallback: function() {}
            });

            function Vector3(x, y, z) {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0
            }
            Object.assign(Vector3.prototype, {
                isVector3: true,
                set: function(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this
                },
                setScalar: function(scalar) {
                    this.x = scalar;
                    this.y = scalar;
                    this.z = scalar;
                    return this
                },
                setX: function(x) {
                    this.x = x;
                    return this
                },
                setY: function(y) {
                    this.y = y;
                    return this
                },
                setZ: function(z) {
                    this.z = z;
                    return this
                },
                setComponent: function(index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        case 2:
                            this.z = value;
                            break;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                    return this
                },
                getComponent: function(index) {
                    switch (index) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this
                },
                add: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                        return this.addVectors(v, w)
                    }
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                    return this
                },
                addScalar: function(s) {
                    this.x += s;
                    this.y += s;
                    this.z += s;
                    return this
                },
                addVectors: function(a, b) {
                    this.x = a.x + b.x;
                    this.y = a.y + b.y;
                    this.z = a.z + b.z;
                    return this
                },
                addScaledVector: function(v, s) {
                    this.x += v.x * s;
                    this.y += v.y * s;
                    this.z += v.z * s;
                    return this
                },
                sub: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                        return this.subVectors(v, w)
                    }
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                    return this
                },
                subScalar: function(s) {
                    this.x -= s;
                    this.y -= s;
                    this.z -= s;
                    return this
                },
                subVectors: function(a, b) {
                    this.x = a.x - b.x;
                    this.y = a.y - b.y;
                    this.z = a.z - b.z;
                    return this
                },
                multiply: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
                        return this.multiplyVectors(v, w)
                    }
                    this.x *= v.x;
                    this.y *= v.y;
                    this.z *= v.z;
                    return this
                },
                multiplyScalar: function(scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    this.z *= scalar;
                    return this
                },
                multiplyVectors: function(a, b) {
                    this.x = a.x * b.x;
                    this.y = a.y * b.y;
                    this.z = a.z * b.z;
                    return this
                },
                applyEuler: function() {
                    var quaternion = new Quaternion;
                    return function applyEuler(euler) {
                        if (!(euler && euler.isEuler)) {
                            console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.")
                        }
                        return this.applyQuaternion(quaternion.setFromEuler(euler))
                    }
                }(),
                applyAxisAngle: function() {
                    var quaternion = new Quaternion;
                    return function applyAxisAngle(axis, angle) {
                        return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
                    }
                }(),
                applyMatrix3: function(m) {
                    var x = this.x,
                        y = this.y,
                        z = this.z;
                    var e = m.elements;
                    this.x = e[0] * x + e[3] * y + e[6] * z;
                    this.y = e[1] * x + e[4] * y + e[7] * z;
                    this.z = e[2] * x + e[5] * y + e[8] * z;
                    return this
                },
                applyMatrix4: function(m) {
                    var x = this.x,
                        y = this.y,
                        z = this.z;
                    var e = m.elements;
                    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
                    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
                    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
                    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
                    return this
                },
                applyQuaternion: function(q) {
                    var x = this.x,
                        y = this.y,
                        z = this.z;
                    var qx = q.x,
                        qy = q.y,
                        qz = q.z,
                        qw = q.w;
                    var ix = qw * x + qy * z - qz * y;
                    var iy = qw * y + qz * x - qx * z;
                    var iz = qw * z + qx * y - qy * x;
                    var iw = -qx * x - qy * y - qz * z;
                    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                    return this
                },
                project: function() {
                    var matrix = new Matrix4;
                    return function project(camera) {
                        matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                        return this.applyMatrix4(matrix)
                    }
                }(),
                unproject: function() {
                    var matrix = new Matrix4;
                    return function unproject(camera) {
                        matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                        return this.applyMatrix4(matrix)
                    }
                }(),
                transformDirection: function(m) {
                    var x = this.x,
                        y = this.y,
                        z = this.z;
                    var e = m.elements;
                    this.x = e[0] * x + e[4] * y + e[8] * z;
                    this.y = e[1] * x + e[5] * y + e[9] * z;
                    this.z = e[2] * x + e[6] * y + e[10] * z;
                    return this.normalize()
                },
                divide: function(v) {
                    this.x /= v.x;
                    this.y /= v.y;
                    this.z /= v.z;
                    return this
                },
                divideScalar: function(scalar) {
                    return this.multiplyScalar(1 / scalar)
                },
                min: function(v) {
                    this.x = Math.min(this.x, v.x);
                    this.y = Math.min(this.y, v.y);
                    this.z = Math.min(this.z, v.z);
                    return this
                },
                max: function(v) {
                    this.x = Math.max(this.x, v.x);
                    this.y = Math.max(this.y, v.y);
                    this.z = Math.max(this.z, v.z);
                    return this
                },
                clamp: function(min, max) {
                    this.x = Math.max(min.x, Math.min(max.x, this.x));
                    this.y = Math.max(min.y, Math.min(max.y, this.y));
                    this.z = Math.max(min.z, Math.min(max.z, this.z));
                    return this
                },
                clampScalar: function() {
                    var min = new Vector3;
                    var max = new Vector3;
                    return function clampScalar(minVal, maxVal) {
                        min.set(minVal, minVal, minVal);
                        max.set(maxVal, maxVal, maxVal);
                        return this.clamp(min, max)
                    }
                }(),
                clampLength: function(min, max) {
                    var length = this.length();
                    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
                },
                floor: function() {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.z = Math.floor(this.z);
                    return this
                },
                ceil: function() {
                    this.x = Math.ceil(this.x);
                    this.y = Math.ceil(this.y);
                    this.z = Math.ceil(this.z);
                    return this
                },
                round: function() {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    this.z = Math.round(this.z);
                    return this
                },
                roundToZero: function() {
                    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
                    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
                    return this
                },
                negate: function() {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this
                },
                dot: function(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(length) {
                    return this.normalize().multiplyScalar(length)
                },
                lerp: function(v, alpha) {
                    this.x += (v.x - this.x) * alpha;
                    this.y += (v.y - this.y) * alpha;
                    this.z += (v.z - this.z) * alpha;
                    return this
                },
                lerpVectors: function(v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
                },
                cross: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
                        return this.crossVectors(v, w)
                    }
                    return this.crossVectors(this, v)
                },
                crossVectors: function(a, b) {
                    var ax = a.x,
                        ay = a.y,
                        az = a.z;
                    var bx = b.x,
                        by = b.y,
                        bz = b.z;
                    this.x = ay * bz - az * by;
                    this.y = az * bx - ax * bz;
                    this.z = ax * by - ay * bx;
                    return this
                },
                projectOnVector: function(vector) {
                    var scalar = vector.dot(this) / vector.lengthSq();
                    return this.copy(vector).multiplyScalar(scalar)
                },
                projectOnPlane: function() {
                    var v1 = new Vector3;
                    return function projectOnPlane(planeNormal) {
                        v1.copy(this).projectOnVector(planeNormal);
                        return this.sub(v1)
                    }
                }(),
                reflect: function() {
                    var v1 = new Vector3;
                    return function reflect(normal) {
                        return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
                    }
                }(),
                angleTo: function(v) {
                    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
                    return Math.acos(_Math.clamp(theta, -1, 1))
                },
                distanceTo: function(v) {
                    return Math.sqrt(this.distanceToSquared(v))
                },
                distanceToSquared: function(v) {
                    var dx = this.x - v.x,
                        dy = this.y - v.y,
                        dz = this.z - v.z;
                    return dx * dx + dy * dy + dz * dz
                },
                manhattanDistanceTo: function(v) {
                    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
                },
                setFromSpherical: function(s) {
                    var sinPhiRadius = Math.sin(s.phi) * s.radius;
                    this.x = sinPhiRadius * Math.sin(s.theta);
                    this.y = Math.cos(s.phi) * s.radius;
                    this.z = sinPhiRadius * Math.cos(s.theta);
                    return this
                },
                setFromCylindrical: function(c) {
                    this.x = c.radius * Math.sin(c.theta);
                    this.y = c.y;
                    this.z = c.radius * Math.cos(c.theta);
                    return this
                },
                setFromMatrixPosition: function(m) {
                    var e = m.elements;
                    this.x = e[12];
                    this.y = e[13];
                    this.z = e[14];
                    return this
                },
                setFromMatrixScale: function(m) {
                    var sx = this.setFromMatrixColumn(m, 0).length();
                    var sy = this.setFromMatrixColumn(m, 1).length();
                    var sz = this.setFromMatrixColumn(m, 2).length();
                    this.x = sx;
                    this.y = sy;
                    this.z = sz;
                    return this
                },
                setFromMatrixColumn: function(m, index) {
                    return this.fromArray(m.elements, index * 4)
                },
                equals: function(v) {
                    return v.x === this.x && v.y === this.y && v.z === this.z
                },
                fromArray: function(array, offset) {
                    if (offset === undefined) offset = 0;
                    this.x = array[offset];
                    this.y = array[offset + 1];
                    this.z = array[offset + 2];
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    array[offset] = this.x;
                    array[offset + 1] = this.y;
                    array[offset + 2] = this.z;
                    return array
                },
                fromBufferAttribute: function(attribute, index, offset) {
                    if (offset !== undefined) {
                        console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().")
                    }
                    this.x = attribute.getX(index);
                    this.y = attribute.getY(index);
                    this.z = attribute.getZ(index);
                    return this
                }
            });

            function Matrix3() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                if (arguments.length > 0) {
                    console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
            }
            Object.assign(Matrix3.prototype, {
                isMatrix3: true,
                set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                    var te = this.elements;
                    te[0] = n11;
                    te[1] = n21;
                    te[2] = n31;
                    te[3] = n12;
                    te[4] = n22;
                    te[5] = n32;
                    te[6] = n13;
                    te[7] = n23;
                    te[8] = n33;
                    return this
                },
                identity: function() {
                    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                    return this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(m) {
                    var te = this.elements;
                    var me = m.elements;
                    te[0] = me[0];
                    te[1] = me[1];
                    te[2] = me[2];
                    te[3] = me[3];
                    te[4] = me[4];
                    te[5] = me[5];
                    te[6] = me[6];
                    te[7] = me[7];
                    te[8] = me[8];
                    return this
                },
                setFromMatrix4: function(m) {
                    var me = m.elements;
                    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
                    return this
                },
                applyToBufferAttribute: function() {
                    var v1 = new Vector3;
                    return function applyToBufferAttribute(attribute) {
                        for (var i = 0, l = attribute.count; i < l; i++) {
                            v1.x = attribute.getX(i);
                            v1.y = attribute.getY(i);
                            v1.z = attribute.getZ(i);
                            v1.applyMatrix3(this);
                            attribute.setXYZ(i, v1.x, v1.y, v1.z)
                        }
                        return attribute
                    }
                }(),
                multiply: function(m) {
                    return this.multiplyMatrices(this, m)
                },
                premultiply: function(m) {
                    return this.multiplyMatrices(m, this)
                },
                multiplyMatrices: function(a, b) {
                    var ae = a.elements;
                    var be = b.elements;
                    var te = this.elements;
                    var a11 = ae[0],
                        a12 = ae[3],
                        a13 = ae[6];
                    var a21 = ae[1],
                        a22 = ae[4],
                        a23 = ae[7];
                    var a31 = ae[2],
                        a32 = ae[5],
                        a33 = ae[8];
                    var b11 = be[0],
                        b12 = be[3],
                        b13 = be[6];
                    var b21 = be[1],
                        b22 = be[4],
                        b23 = be[7];
                    var b31 = be[2],
                        b32 = be[5],
                        b33 = be[8];
                    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
                    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
                    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
                    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
                    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
                    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
                    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
                    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
                    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
                    return this
                },
                multiplyScalar: function(s) {
                    var te = this.elements;
                    te[0] *= s;
                    te[3] *= s;
                    te[6] *= s;
                    te[1] *= s;
                    te[4] *= s;
                    te[7] *= s;
                    te[2] *= s;
                    te[5] *= s;
                    te[8] *= s;
                    return this
                },
                determinant: function() {
                    var te = this.elements;
                    var a = te[0],
                        b = te[1],
                        c = te[2],
                        d = te[3],
                        e = te[4],
                        f = te[5],
                        g = te[6],
                        h = te[7],
                        i = te[8];
                    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
                },
                getInverse: function(matrix, throwOnDegenerate) {
                    if (matrix && matrix.isMatrix4) {
                        console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.")
                    }
                    var me = matrix.elements,
                        te = this.elements,
                        n11 = me[0],
                        n21 = me[1],
                        n31 = me[2],
                        n12 = me[3],
                        n22 = me[4],
                        n32 = me[5],
                        n13 = me[6],
                        n23 = me[7],
                        n33 = me[8],
                        t11 = n33 * n22 - n32 * n23,
                        t12 = n32 * n13 - n33 * n12,
                        t13 = n23 * n12 - n22 * n13,
                        det = n11 * t11 + n21 * t12 + n31 * t13;
                    if (det === 0) {
                        var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (throwOnDegenerate === true) {
                            throw new Error(msg)
                        } else {
                            console.warn(msg)
                        }
                        return this.identity()
                    }
                    var detInv = 1 / det;
                    te[0] = t11 * detInv;
                    te[1] = (n31 * n23 - n33 * n21) * detInv;
                    te[2] = (n32 * n21 - n31 * n22) * detInv;
                    te[3] = t12 * detInv;
                    te[4] = (n33 * n11 - n31 * n13) * detInv;
                    te[5] = (n31 * n12 - n32 * n11) * detInv;
                    te[6] = t13 * detInv;
                    te[7] = (n21 * n13 - n23 * n11) * detInv;
                    te[8] = (n22 * n11 - n21 * n12) * detInv;
                    return this
                },
                transpose: function() {
                    var tmp, m = this.elements;
                    tmp = m[1];
                    m[1] = m[3];
                    m[3] = tmp;
                    tmp = m[2];
                    m[2] = m[6];
                    m[6] = tmp;
                    tmp = m[5];
                    m[5] = m[7];
                    m[7] = tmp;
                    return this
                },
                getNormalMatrix: function(matrix4) {
                    return this.setFromMatrix4(matrix4).getInverse(this).transpose()
                },
                transposeIntoArray: function(r) {
                    var m = this.elements;
                    r[0] = m[0];
                    r[1] = m[3];
                    r[2] = m[6];
                    r[3] = m[1];
                    r[4] = m[4];
                    r[5] = m[7];
                    r[6] = m[2];
                    r[7] = m[5];
                    r[8] = m[8];
                    return this
                },
                setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
                    var c = Math.cos(rotation);
                    var s = Math.sin(rotation);
                    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1)
                },
                scale: function(sx, sy) {
                    var te = this.elements;
                    te[0] *= sx;
                    te[3] *= sx;
                    te[6] *= sx;
                    te[1] *= sy;
                    te[4] *= sy;
                    te[7] *= sy;
                    return this
                },
                rotate: function(theta) {
                    var c = Math.cos(theta);
                    var s = Math.sin(theta);
                    var te = this.elements;
                    var a11 = te[0],
                        a12 = te[3],
                        a13 = te[6];
                    var a21 = te[1],
                        a22 = te[4],
                        a23 = te[7];
                    te[0] = c * a11 + s * a21;
                    te[3] = c * a12 + s * a22;
                    te[6] = c * a13 + s * a23;
                    te[1] = -s * a11 + c * a21;
                    te[4] = -s * a12 + c * a22;
                    te[7] = -s * a13 + c * a23;
                    return this
                },
                translate: function(tx, ty) {
                    var te = this.elements;
                    te[0] += tx * te[2];
                    te[3] += tx * te[5];
                    te[6] += tx * te[8];
                    te[1] += ty * te[2];
                    te[4] += ty * te[5];
                    te[7] += ty * te[8];
                    return this
                },
                equals: function(matrix) {
                    var te = this.elements;
                    var me = matrix.elements;
                    for (var i = 0; i < 9; i++) {
                        if (te[i] !== me[i]) return false
                    }
                    return true
                },
                fromArray: function(array, offset) {
                    if (offset === undefined) offset = 0;
                    for (var i = 0; i < 9; i++) {
                        this.elements[i] = array[i + offset]
                    }
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    var te = this.elements;
                    array[offset] = te[0];
                    array[offset + 1] = te[1];
                    array[offset + 2] = te[2];
                    array[offset + 3] = te[3];
                    array[offset + 4] = te[4];
                    array[offset + 5] = te[5];
                    array[offset + 6] = te[6];
                    array[offset + 7] = te[7];
                    array[offset + 8] = te[8];
                    return array
                }
            });
            var textureId = 0;

            function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
                Object.defineProperty(this, "id", {
                    value: textureId++
                });
                this.uuid = _Math.generateUUID();
                this.name = "";
                this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
                this.mipmaps = [];
                this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
                this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
                this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
                this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
                this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
                this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
                this.format = format !== undefined ? format : RGBAFormat;
                this.type = type !== undefined ? type : UnsignedByteType;
                this.offset = new Vector2(0, 0);
                this.repeat = new Vector2(1, 1);
                this.center = new Vector2(0, 0);
                this.rotation = 0;
                this.matrixAutoUpdate = true;
                this.matrix = new Matrix3;
                this.generateMipmaps = true;
                this.premultiplyAlpha = false;
                this.flipY = true;
                this.unpackAlignment = 4;
                this.encoding = encoding !== undefined ? encoding : LinearEncoding;
                this.version = 0;
                this.onUpdate = null
            }
            Texture.DEFAULT_IMAGE = undefined;
            Texture.DEFAULT_MAPPING = UVMapping;
            Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Texture,
                isTexture: true,
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    this.name = source.name;
                    this.image = source.image;
                    this.mipmaps = source.mipmaps.slice(0);
                    this.mapping = source.mapping;
                    this.wrapS = source.wrapS;
                    this.wrapT = source.wrapT;
                    this.magFilter = source.magFilter;
                    this.minFilter = source.minFilter;
                    this.anisotropy = source.anisotropy;
                    this.format = source.format;
                    this.type = source.type;
                    this.offset.copy(source.offset);
                    this.repeat.copy(source.repeat);
                    this.center.copy(source.center);
                    this.rotation = source.rotation;
                    this.matrixAutoUpdate = source.matrixAutoUpdate;
                    this.matrix.copy(source.matrix);
                    this.generateMipmaps = source.generateMipmaps;
                    this.premultiplyAlpha = source.premultiplyAlpha;
                    this.flipY = source.flipY;
                    this.unpackAlignment = source.unpackAlignment;
                    this.encoding = source.encoding;
                    return this
                },
                toJSON: function(meta) {
                    var isRootObject = meta === undefined || typeof meta === "string";
                    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                        return meta.textures[this.uuid]
                    }

                    function getDataURL(image) {
                        var canvas;
                        if (image instanceof HTMLCanvasElement) {
                            canvas = image
                        } else {
                            canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                            canvas.width = image.width;
                            canvas.height = image.height;
                            var context = canvas.getContext("2d");
                            if (image instanceof ImageData) {
                                context.putImageData(image, 0, 0)
                            } else {
                                context.drawImage(image, 0, 0, image.width, image.height)
                            }
                        }
                        if (canvas.width > 2048 || canvas.height > 2048) {
                            return canvas.toDataURL("image/jpeg", .6)
                        } else {
                            return canvas.toDataURL("image/png")
                        }
                    }
                    var output = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (this.image !== undefined) {
                        var image = this.image;
                        if (image.uuid === undefined) {
                            image.uuid = _Math.generateUUID()
                        }
                        if (!isRootObject && meta.images[image.uuid] === undefined) {
                            meta.images[image.uuid] = {
                                uuid: image.uuid,
                                url: getDataURL(image)
                            }
                        }
                        output.image = image.uuid
                    }
                    if (!isRootObject) {
                        meta.textures[this.uuid] = output
                    }
                    return output
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(uv) {
                    if (this.mapping !== UVMapping) return;
                    uv.applyMatrix3(this.matrix);
                    if (uv.x < 0 || uv.x > 1) {
                        switch (this.wrapS) {
                            case RepeatWrapping:
                                uv.x = uv.x - Math.floor(uv.x);
                                break;
                            case ClampToEdgeWrapping:
                                uv.x = uv.x < 0 ? 0 : 1;
                                break;
                            case MirroredRepeatWrapping:
                                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                                    uv.x = Math.ceil(uv.x) - uv.x
                                } else {
                                    uv.x = uv.x - Math.floor(uv.x)
                                }
                                break
                        }
                    }
                    if (uv.y < 0 || uv.y > 1) {
                        switch (this.wrapT) {
                            case RepeatWrapping:
                                uv.y = uv.y - Math.floor(uv.y);
                                break;
                            case ClampToEdgeWrapping:
                                uv.y = uv.y < 0 ? 0 : 1;
                                break;
                            case MirroredRepeatWrapping:
                                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                                    uv.y = Math.ceil(uv.y) - uv.y
                                } else {
                                    uv.y = uv.y - Math.floor(uv.y)
                                }
                                break
                        }
                    }
                    if (this.flipY) {
                        uv.y = 1 - uv.y
                    }
                }
            });
            Object.defineProperty(Texture.prototype, "needsUpdate", {
                set: function(value) {
                    if (value === true) this.version++
                }
            });

            function Vector4(x, y, z, w) {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
                this.w = w !== undefined ? w : 1
            }
            Object.assign(Vector4.prototype, {
                isVector4: true,
                set: function(x, y, z, w) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                    return this
                },
                setScalar: function(scalar) {
                    this.x = scalar;
                    this.y = scalar;
                    this.z = scalar;
                    this.w = scalar;
                    return this
                },
                setX: function(x) {
                    this.x = x;
                    return this
                },
                setY: function(y) {
                    this.y = y;
                    return this
                },
                setZ: function(z) {
                    this.z = z;
                    return this
                },
                setW: function(w) {
                    this.w = w;
                    return this
                },
                setComponent: function(index, value) {
                    switch (index) {
                        case 0:
                            this.x = value;
                            break;
                        case 1:
                            this.y = value;
                            break;
                        case 2:
                            this.z = value;
                            break;
                        case 3:
                            this.w = value;
                            break;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                    return this
                },
                getComponent: function(index) {
                    switch (index) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + index)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    this.w = v.w !== undefined ? v.w : 1;
                    return this
                },
                add: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                        return this.addVectors(v, w)
                    }
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                    this.w += v.w;
                    return this
                },
                addScalar: function(s) {
                    this.x += s;
                    this.y += s;
                    this.z += s;
                    this.w += s;
                    return this
                },
                addVectors: function(a, b) {
                    this.x = a.x + b.x;
                    this.y = a.y + b.y;
                    this.z = a.z + b.z;
                    this.w = a.w + b.w;
                    return this
                },
                addScaledVector: function(v, s) {
                    this.x += v.x * s;
                    this.y += v.y * s;
                    this.z += v.z * s;
                    this.w += v.w * s;
                    return this
                },
                sub: function(v, w) {
                    if (w !== undefined) {
                        console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                        return this.subVectors(v, w)
                    }
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                    this.w -= v.w;
                    return this
                },
                subScalar: function(s) {
                    this.x -= s;
                    this.y -= s;
                    this.z -= s;
                    this.w -= s;
                    return this
                },
                subVectors: function(a, b) {
                    this.x = a.x - b.x;
                    this.y = a.y - b.y;
                    this.z = a.z - b.z;
                    this.w = a.w - b.w;
                    return this
                },
                multiplyScalar: function(scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    this.z *= scalar;
                    this.w *= scalar;
                    return this
                },
                applyMatrix4: function(m) {
                    var x = this.x,
                        y = this.y,
                        z = this.z,
                        w = this.w;
                    var e = m.elements;
                    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
                    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
                    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
                    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
                    return this
                },
                divideScalar: function(scalar) {
                    return this.multiplyScalar(1 / scalar)
                },
                setAxisAngleFromQuaternion: function(q) {
                    this.w = 2 * Math.acos(q.w);
                    var s = Math.sqrt(1 - q.w * q.w);
                    if (s < 1e-4) {
                        this.x = 1;
                        this.y = 0;
                        this.z = 0
                    } else {
                        this.x = q.x / s;
                        this.y = q.y / s;
                        this.z = q.z / s
                    }
                    return this
                },
                setAxisAngleFromRotationMatrix: function(m) {
                    var angle, x, y, z, epsilon = .01,
                        epsilon2 = .1,
                        te = m.elements,
                        m11 = te[0],
                        m12 = te[4],
                        m13 = te[8],
                        m21 = te[1],
                        m22 = te[5],
                        m23 = te[9],
                        m31 = te[2],
                        m32 = te[6],
                        m33 = te[10];
                    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                            this.set(1, 0, 0, 0);
                            return this
                        }
                        angle = Math.PI;
                        var xx = (m11 + 1) / 2;
                        var yy = (m22 + 1) / 2;
                        var zz = (m33 + 1) / 2;
                        var xy = (m12 + m21) / 4;
                        var xz = (m13 + m31) / 4;
                        var yz = (m23 + m32) / 4;
                        if (xx > yy && xx > zz) {
                            if (xx < epsilon) {
                                x = 0;
                                y = .707106781;
                                z = .707106781
                            } else {
                                x = Math.sqrt(xx);
                                y = xy / x;
                                z = xz / x
                            }
                        } else if (yy > zz) {
                            if (yy < epsilon) {
                                x = .707106781;
                                y = 0;
                                z = .707106781
                            } else {
                                y = Math.sqrt(yy);
                                x = xy / y;
                                z = yz / y
                            }
                        } else {
                            if (zz < epsilon) {
                                x = .707106781;
                                y = .707106781;
                                z = 0
                            } else {
                                z = Math.sqrt(zz);
                                x = xz / z;
                                y = yz / z
                            }
                        }
                        this.set(x, y, z, angle);
                        return this
                    }
                    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
                    if (Math.abs(s) < .001) s = 1;
                    this.x = (m32 - m23) / s;
                    this.y = (m13 - m31) / s;
                    this.z = (m21 - m12) / s;
                    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
                    return this
                },
                min: function(v) {
                    this.x = Math.min(this.x, v.x);
                    this.y = Math.min(this.y, v.y);
                    this.z = Math.min(this.z, v.z);
                    this.w = Math.min(this.w, v.w);
                    return this
                },
                max: function(v) {
                    this.x = Math.max(this.x, v.x);
                    this.y = Math.max(this.y, v.y);
                    this.z = Math.max(this.z, v.z);
                    this.w = Math.max(this.w, v.w);
                    return this
                },
                clamp: function(min, max) {
                    this.x = Math.max(min.x, Math.min(max.x, this.x));
                    this.y = Math.max(min.y, Math.min(max.y, this.y));
                    this.z = Math.max(min.z, Math.min(max.z, this.z));
                    this.w = Math.max(min.w, Math.min(max.w, this.w));
                    return this
                },
                clampScalar: function() {
                    var min, max;
                    return function clampScalar(minVal, maxVal) {
                        if (min === undefined) {
                            min = new Vector4;
                            max = new Vector4
                        }
                        min.set(minVal, minVal, minVal, minVal);
                        max.set(maxVal, maxVal, maxVal, maxVal);
                        return this.clamp(min, max)
                    }
                }(),
                clampLength: function(min, max) {
                    var length = this.length();
                    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
                },
                floor: function() {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.z = Math.floor(this.z);
                    this.w = Math.floor(this.w);
                    return this
                },
                ceil: function() {
                    this.x = Math.ceil(this.x);
                    this.y = Math.ceil(this.y);
                    this.z = Math.ceil(this.z);
                    this.w = Math.ceil(this.w);
                    return this
                },
                round: function() {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    this.z = Math.round(this.z);
                    this.w = Math.round(this.w);
                    return this
                },
                roundToZero: function() {
                    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
                    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
                    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
                    return this
                },
                negate: function() {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    this.w = -this.w;
                    return this
                },
                dot: function(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(length) {
                    return this.normalize().multiplyScalar(length)
                },
                lerp: function(v, alpha) {
                    this.x += (v.x - this.x) * alpha;
                    this.y += (v.y - this.y) * alpha;
                    this.z += (v.z - this.z) * alpha;
                    this.w += (v.w - this.w) * alpha;
                    return this
                },
                lerpVectors: function(v1, v2, alpha) {
                    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
                },
                equals: function(v) {
                    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w
                },
                fromArray: function(array, offset) {
                    if (offset === undefined) offset = 0;
                    this.x = array[offset];
                    this.y = array[offset + 1];
                    this.z = array[offset + 2];
                    this.w = array[offset + 3];
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    array[offset] = this.x;
                    array[offset + 1] = this.y;
                    array[offset + 2] = this.z;
                    array[offset + 3] = this.w;
                    return array
                },
                fromBufferAttribute: function(attribute, index, offset) {
                    if (offset !== undefined) {
                        console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().")
                    }
                    this.x = attribute.getX(index);
                    this.y = attribute.getY(index);
                    this.z = attribute.getZ(index);
                    this.w = attribute.getW(index);
                    return this
                }
            });

            function WebGLRenderTarget(width, height, options) {
                this.width = width;
                this.height = height;
                this.scissor = new Vector4(0, 0, width, height);
                this.scissorTest = false;
                this.viewport = new Vector4(0, 0, width, height);
                options = options || {};
                if (options.minFilter === undefined) options.minFilter = LinearFilter;
                this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
                this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
                this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
                this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null
            }
            WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: WebGLRenderTarget,
                isWebGLRenderTarget: true,
                setSize: function(width, height) {
                    if (this.width !== width || this.height !== height) {
                        this.width = width;
                        this.height = height;
                        this.dispose()
                    }
                    this.viewport.set(0, 0, width, height);
                    this.scissor.set(0, 0, width, height)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    this.width = source.width;
                    this.height = source.height;
                    this.viewport.copy(source.viewport);
                    this.texture = source.texture.clone();
                    this.depthBuffer = source.depthBuffer;
                    this.stencilBuffer = source.stencilBuffer;
                    this.depthTexture = source.depthTexture;
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });

            function WebGLRenderTargetCube(width, height, options) {
                WebGLRenderTarget.call(this, width, height, options);
                this.activeCubeFace = 0;
                this.activeMipMapLevel = 0
            }
            WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
            WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
            WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

            function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
                Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
                this.image = {
                    data: data,
                    width: width,
                    height: height
                };
                this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
                this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
                this.generateMipmaps = false;
                this.flipY = false;
                this.unpackAlignment = 1
            }
            DataTexture.prototype = Object.create(Texture.prototype);
            DataTexture.prototype.constructor = DataTexture;
            DataTexture.prototype.isDataTexture = true;

            function Box3(min, max) {
                this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
                this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity)
            }
            Object.assign(Box3.prototype, {
                isBox3: true,
                set: function(min, max) {
                    this.min.copy(min);
                    this.max.copy(max);
                    return this
                },
                setFromArray: function(array) {
                    var minX = +Infinity;
                    var minY = +Infinity;
                    var minZ = +Infinity;
                    var maxX = -Infinity;
                    var maxY = -Infinity;
                    var maxZ = -Infinity;
                    for (var i = 0, l = array.length; i < l; i += 3) {
                        var x = array[i];
                        var y = array[i + 1];
                        var z = array[i + 2];
                        if (x < minX) minX = x;
                        if (y < minY) minY = y;
                        if (z < minZ) minZ = z;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                        if (z > maxZ) maxZ = z
                    }
                    this.min.set(minX, minY, minZ);
                    this.max.set(maxX, maxY, maxZ);
                    return this
                },
                setFromBufferAttribute: function(attribute) {
                    var minX = +Infinity;
                    var minY = +Infinity;
                    var minZ = +Infinity;
                    var maxX = -Infinity;
                    var maxY = -Infinity;
                    var maxZ = -Infinity;
                    for (var i = 0, l = attribute.count; i < l; i++) {
                        var x = attribute.getX(i);
                        var y = attribute.getY(i);
                        var z = attribute.getZ(i);
                        if (x < minX) minX = x;
                        if (y < minY) minY = y;
                        if (z < minZ) minZ = z;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                        if (z > maxZ) maxZ = z
                    }
                    this.min.set(minX, minY, minZ);
                    this.max.set(maxX, maxY, maxZ);
                    return this
                },
                setFromPoints: function(points) {
                    this.makeEmpty();
                    for (var i = 0, il = points.length; i < il; i++) {
                        this.expandByPoint(points[i])
                    }
                    return this
                },
                setFromCenterAndSize: function() {
                    var v1 = new Vector3;
                    return function setFromCenterAndSize(center, size) {
                        var halfSize = v1.copy(size).multiplyScalar(.5);
                        this.min.copy(center).sub(halfSize);
                        this.max.copy(center).add(halfSize);
                        return this
                    }
                }(),
                setFromObject: function(object) {
                    this.makeEmpty();
                    return this.expandByObject(object)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(box) {
                    this.min.copy(box.min);
                    this.max.copy(box.max);
                    return this
                },
                makeEmpty: function() {
                    this.min.x = this.min.y = this.min.z = +Infinity;
                    this.max.x = this.max.y = this.max.z = -Infinity;
                    return this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Box3: .getCenter() target is now required");
                        target = new Vector3
                    }
                    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Box3: .getSize() target is now required");
                        target = new Vector3
                    }
                    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min)
                },
                expandByPoint: function(point) {
                    this.min.min(point);
                    this.max.max(point);
                    return this
                },
                expandByVector: function(vector) {
                    this.min.sub(vector);
                    this.max.add(vector);
                    return this
                },
                expandByScalar: function(scalar) {
                    this.min.addScalar(-scalar);
                    this.max.addScalar(scalar);
                    return this
                },
                expandByObject: function() {
                    var scope, i, l;
                    var v1 = new Vector3;

                    function traverse(node) {
                        var geometry = node.geometry;
                        if (geometry !== undefined) {
                            if (geometry.isGeometry) {
                                var vertices = geometry.vertices;
                                for (i = 0, l = vertices.length; i < l; i++) {
                                    v1.copy(vertices[i]);
                                    v1.applyMatrix4(node.matrixWorld);
                                    scope.expandByPoint(v1)
                                }
                            } else if (geometry.isBufferGeometry) {
                                var attribute = geometry.attributes.position;
                                if (attribute !== undefined) {
                                    for (i = 0, l = attribute.count; i < l; i++) {
                                        v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                                        scope.expandByPoint(v1)
                                    }
                                }
                            }
                        }
                    }
                    return function expandByObject(object) {
                        scope = this;
                        object.updateMatrixWorld(true);
                        object.traverse(traverse);
                        return this
                    }
                }(),
                containsPoint: function(point) {
                    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true
                },
                containsBox: function(box) {
                    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z
                },
                getParameter: function(point, target) {
                    if (target === undefined) {
                        console.warn("THREE.Box3: .getParameter() target is now required");
                        target = new Vector3
                    }
                    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(box) {
                    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true
                },
                intersectsSphere: function() {
                    var closestPoint = new Vector3;
                    return function intersectsSphere(sphere) {
                        this.clampPoint(sphere.center, closestPoint);
                        return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius
                    }
                }(),
                intersectsPlane: function(plane) {
                    var min, max;
                    if (plane.normal.x > 0) {
                        min = plane.normal.x * this.min.x;
                        max = plane.normal.x * this.max.x
                    } else {
                        min = plane.normal.x * this.max.x;
                        max = plane.normal.x * this.min.x
                    }
                    if (plane.normal.y > 0) {
                        min += plane.normal.y * this.min.y;
                        max += plane.normal.y * this.max.y
                    } else {
                        min += plane.normal.y * this.max.y;
                        max += plane.normal.y * this.min.y
                    }
                    if (plane.normal.z > 0) {
                        min += plane.normal.z * this.min.z;
                        max += plane.normal.z * this.max.z
                    } else {
                        min += plane.normal.z * this.max.z;
                        max += plane.normal.z * this.min.z
                    }
                    return min <= plane.constant && max >= plane.constant
                },
                intersectsTriangle: function() {
                    var v0 = new Vector3;
                    var v1 = new Vector3;
                    var v2 = new Vector3;
                    var f0 = new Vector3;
                    var f1 = new Vector3;
                    var f2 = new Vector3;
                    var testAxis = new Vector3;
                    var center = new Vector3;
                    var extents = new Vector3;
                    var triangleNormal = new Vector3;

                    function satForAxes(axes) {
                        var i, j;
                        for (i = 0, j = axes.length - 3; i <= j; i += 3) {
                            testAxis.fromArray(axes, i);
                            var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
                            var p0 = v0.dot(testAxis);
                            var p1 = v1.dot(testAxis);
                            var p2 = v2.dot(testAxis);
                            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                                return false
                            }
                        }
                        return true
                    }
                    return function intersectsTriangle(triangle) {
                        if (this.isEmpty()) {
                            return false
                        }
                        this.getCenter(center);
                        extents.subVectors(this.max, center);
                        v0.subVectors(triangle.a, center);
                        v1.subVectors(triangle.b, center);
                        v2.subVectors(triangle.c, center);
                        f0.subVectors(v1, v0);
                        f1.subVectors(v2, v1);
                        f2.subVectors(v0, v2);
                        var axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];
                        if (!satForAxes(axes)) {
                            return false
                        }
                        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                        if (!satForAxes(axes)) {
                            return false
                        }
                        triangleNormal.crossVectors(f0, f1);
                        axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
                        return satForAxes(axes)
                    }
                }(),
                clampPoint: function(point, target) {
                    if (target === undefined) {
                        console.warn("THREE.Box3: .clampPoint() target is now required");
                        target = new Vector3
                    }
                    return target.copy(point).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var v1 = new Vector3;
                    return function distanceToPoint(point) {
                        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                        return clampedPoint.sub(point).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var v1 = new Vector3;
                    return function getBoundingSphere(target) {
                        if (target === undefined) {
                            console.warn("THREE.Box3: .getBoundingSphere() target is now required");
                            target = new Sphere
                        }
                        this.getCenter(target.center);
                        target.radius = this.getSize(v1).length() * .5;
                        return target
                    }
                }(),
                intersect: function(box) {
                    this.min.max(box.min);
                    this.max.min(box.max);
                    if (this.isEmpty()) this.makeEmpty();
                    return this
                },
                union: function(box) {
                    this.min.min(box.min);
                    this.max.max(box.max);
                    return this
                },
                applyMatrix4: function() {
                    var points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3];
                    return function applyMatrix4(matrix) {
                        if (this.isEmpty()) return this;
                        points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
                        points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
                        points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
                        points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
                        points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
                        points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
                        points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
                        points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
                        this.setFromPoints(points);
                        return this
                    }
                }(),
                translate: function(offset) {
                    this.min.add(offset);
                    this.max.add(offset);
                    return this
                },
                equals: function(box) {
                    return box.min.equals(this.min) && box.max.equals(this.max)
                }
            });

            function Sphere(center, radius) {
                this.center = center !== undefined ? center : new Vector3;
                this.radius = radius !== undefined ? radius : 0
            }
            Object.assign(Sphere.prototype, {
                set: function(center, radius) {
                    this.center.copy(center);
                    this.radius = radius;
                    return this
                },
                setFromPoints: function() {
                    var box = new Box3;
                    return function setFromPoints(points, optionalCenter) {
                        var center = this.center;
                        if (optionalCenter !== undefined) {
                            center.copy(optionalCenter)
                        } else {
                            box.setFromPoints(points).getCenter(center)
                        }
                        var maxRadiusSq = 0;
                        for (var i = 0, il = points.length; i < il; i++) {
                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]))
                        }
                        this.radius = Math.sqrt(maxRadiusSq);
                        return this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(sphere) {
                    this.center.copy(sphere.center);
                    this.radius = sphere.radius;
                    return this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(point) {
                    return point.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(point) {
                    return point.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(sphere) {
                    var radiusSum = this.radius + sphere.radius;
                    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
                },
                intersectsBox: function(box) {
                    return box.intersectsSphere(this)
                },
                intersectsPlane: function(plane) {
                    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(point, target) {
                    var deltaLengthSq = this.center.distanceToSquared(point);
                    if (target === undefined) {
                        console.warn("THREE.Sphere: .clampPoint() target is now required");
                        target = new Vector3
                    }
                    target.copy(point);
                    if (deltaLengthSq > this.radius * this.radius) {
                        target.sub(this.center).normalize();
                        target.multiplyScalar(this.radius).add(this.center)
                    }
                    return target
                },
                getBoundingBox: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Sphere: .getBoundingBox() target is now required");
                        target = new Box3
                    }
                    target.set(this.center, this.center);
                    target.expandByScalar(this.radius);
                    return target
                },
                applyMatrix4: function(matrix) {
                    this.center.applyMatrix4(matrix);
                    this.radius = this.radius * matrix.getMaxScaleOnAxis();
                    return this
                },
                translate: function(offset) {
                    this.center.add(offset);
                    return this
                },
                equals: function(sphere) {
                    return sphere.center.equals(this.center) && sphere.radius === this.radius
                }
            });

            function Plane(normal, constant) {
                this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
                this.constant = constant !== undefined ? constant : 0
            }
            Object.assign(Plane.prototype, {
                set: function(normal, constant) {
                    this.normal.copy(normal);
                    this.constant = constant;
                    return this
                },
                setComponents: function(x, y, z, w) {
                    this.normal.set(x, y, z);
                    this.constant = w;
                    return this
                },
                setFromNormalAndCoplanarPoint: function(normal, point) {
                    this.normal.copy(normal);
                    this.constant = -point.dot(this.normal);
                    return this
                },
                setFromCoplanarPoints: function() {
                    var v1 = new Vector3;
                    var v2 = new Vector3;
                    return function setFromCoplanarPoints(a, b, c) {
                        var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                        this.setFromNormalAndCoplanarPoint(normal, a);
                        return this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(plane) {
                    this.normal.copy(plane.normal);
                    this.constant = plane.constant;
                    return this
                },
                normalize: function() {
                    var inverseNormalLength = 1 / this.normal.length();
                    this.normal.multiplyScalar(inverseNormalLength);
                    this.constant *= inverseNormalLength;
                    return this
                },
                negate: function() {
                    this.constant *= -1;
                    this.normal.negate();
                    return this
                },
                distanceToPoint: function(point) {
                    return this.normal.dot(point) + this.constant
                },
                distanceToSphere: function(sphere) {
                    return this.distanceToPoint(sphere.center) - sphere.radius
                },
                projectPoint: function(point, target) {
                    if (target === undefined) {
                        console.warn("THREE.Plane: .projectPoint() target is now required");
                        target = new Vector3
                    }
                    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point)
                },
                intersectLine: function() {
                    var v1 = new Vector3;
                    return function intersectLine(line, target) {
                        if (target === undefined) {
                            console.warn("THREE.Plane: .intersectLine() target is now required");
                            target = new Vector3
                        }
                        var direction = line.delta(v1);
                        var denominator = this.normal.dot(direction);
                        if (denominator === 0) {
                            if (this.distanceToPoint(line.start) === 0) {
                                return target.copy(line.start)
                            }
                            return undefined
                        }
                        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                        if (t < 0 || t > 1) {
                            return undefined
                        }
                        return target.copy(direction).multiplyScalar(t).add(line.start)
                    }
                }(),
                intersectsLine: function(line) {
                    var startSign = this.distanceToPoint(line.start);
                    var endSign = this.distanceToPoint(line.end);
                    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0
                },
                intersectsBox: function(box) {
                    return box.intersectsPlane(this)
                },
                intersectsSphere: function(sphere) {
                    return sphere.intersectsPlane(this)
                },
                coplanarPoint: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Plane: .coplanarPoint() target is now required");
                        target = new Vector3
                    }
                    return target.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var v1 = new Vector3;
                    var m1 = new Matrix3;
                    return function applyMatrix4(matrix, optionalNormalMatrix) {
                        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
                        var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
                        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                        this.constant = -referencePoint.dot(normal);
                        return this
                    }
                }(),
                translate: function(offset) {
                    this.constant -= offset.dot(this.normal);
                    return this
                },
                equals: function(plane) {
                    return plane.normal.equals(this.normal) && plane.constant === this.constant
                }
            });

            function Frustum(p0, p1, p2, p3, p4, p5) {
                this.planes = [p0 !== undefined ? p0 : new Plane, p1 !== undefined ? p1 : new Plane, p2 !== undefined ? p2 : new Plane, p3 !== undefined ? p3 : new Plane, p4 !== undefined ? p4 : new Plane, p5 !== undefined ? p5 : new Plane]
            }
            Object.assign(Frustum.prototype, {
                set: function(p0, p1, p2, p3, p4, p5) {
                    var planes = this.planes;
                    planes[0].copy(p0);
                    planes[1].copy(p1);
                    planes[2].copy(p2);
                    planes[3].copy(p3);
                    planes[4].copy(p4);
                    planes[5].copy(p5);
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(frustum) {
                    var planes = this.planes;
                    for (var i = 0; i < 6; i++) {
                        planes[i].copy(frustum.planes[i])
                    }
                    return this
                },
                setFromMatrix: function(m) {
                    var planes = this.planes;
                    var me = m.elements;
                    var me0 = me[0],
                        me1 = me[1],
                        me2 = me[2],
                        me3 = me[3];
                    var me4 = me[4],
                        me5 = me[5],
                        me6 = me[6],
                        me7 = me[7];
                    var me8 = me[8],
                        me9 = me[9],
                        me10 = me[10],
                        me11 = me[11];
                    var me12 = me[12],
                        me13 = me[13],
                        me14 = me[14],
                        me15 = me[15];
                    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
                    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
                    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
                    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
                    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
                    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
                    return this
                },
                intersectsObject: function() {
                    var sphere = new Sphere;
                    return function intersectsObject(object) {
                        var geometry = object.geometry;
                        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                        sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                        return this.intersectsSphere(sphere)
                    }
                }(),
                intersectsSprite: function() {
                    var sphere = new Sphere;
                    return function intersectsSprite(sprite) {
                        sphere.center.set(0, 0, 0);
                        sphere.radius = .7071067811865476;
                        sphere.applyMatrix4(sprite.matrixWorld);
                        return this.intersectsSphere(sphere)
                    }
                }(),
                intersectsSphere: function(sphere) {
                    var planes = this.planes;
                    var center = sphere.center;
                    var negRadius = -sphere.radius;
                    for (var i = 0; i < 6; i++) {
                        var distance = planes[i].distanceToPoint(center);
                        if (distance < negRadius) {
                            return false
                        }
                    }
                    return true
                },
                intersectsBox: function() {
                    var p1 = new Vector3,
                        p2 = new Vector3;
                    return function intersectsBox(box) {
                        var planes = this.planes;
                        for (var i = 0; i < 6; i++) {
                            var plane = planes[i];
                            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                            var d1 = plane.distanceToPoint(p1);
                            var d2 = plane.distanceToPoint(p2);
                            if (d1 < 0 && d2 < 0) {
                                return false
                            }
                        }
                        return true
                    }
                }(),
                containsPoint: function(point) {
                    var planes = this.planes;
                    for (var i = 0; i < 6; i++) {
                        if (planes[i].distanceToPoint(point) < 0) {
                            return false
                        }
                    }
                    return true
                }
            });
            var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
            var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
            var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
            var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
            var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
            var begin_vertex = "\nvec3 transformed = vec3( position );\n";
            var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
            var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
            var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
            var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";
            var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
            var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
            var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
            var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
            var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
            var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
            var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
            var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";
            var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
            var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";
            var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
            var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
            var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
            var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
            var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
            var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
            var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
            var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
            var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
            var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
            var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
            var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
            var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
            var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
            var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
            var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
            var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
            var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
            var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n";
            var lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
            var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
            var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
            var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
            var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
            var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n";
            var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n";
            var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
            var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
            var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
            var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
            var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";
            var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
            var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
            var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
            var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";
            var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";
            var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
            var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
            var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
            var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
            var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n";
            var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
            var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
            var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
            var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
            var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
            var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
            var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";
            var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";
            var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
            var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
            var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
            var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
            var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
            var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
            var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
            var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";
            var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
            var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
            var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
            var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
            var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
            var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
            var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";
            var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
            var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
            var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
            var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
            var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
            var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
            var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";
            var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
            var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
            var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";
            var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";
            var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
            var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
            var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
            var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
            var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
            var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
            var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
            var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
            var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
            var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
            var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
            var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
            var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
            var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
            var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
            var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
            var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";
            var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
            var ShaderChunk = {
                alphamap_fragment: alphamap_fragment,
                alphamap_pars_fragment: alphamap_pars_fragment,
                alphatest_fragment: alphatest_fragment,
                aomap_fragment: aomap_fragment,
                aomap_pars_fragment: aomap_pars_fragment,
                begin_vertex: begin_vertex,
                beginnormal_vertex: beginnormal_vertex,
                bsdfs: bsdfs,
                bumpmap_pars_fragment: bumpmap_pars_fragment,
                clipping_planes_fragment: clipping_planes_fragment,
                clipping_planes_pars_fragment: clipping_planes_pars_fragment,
                clipping_planes_pars_vertex: clipping_planes_pars_vertex,
                clipping_planes_vertex: clipping_planes_vertex,
                color_fragment: color_fragment,
                color_pars_fragment: color_pars_fragment,
                color_pars_vertex: color_pars_vertex,
                color_vertex: color_vertex,
                common: common,
                cube_uv_reflection_fragment: cube_uv_reflection_fragment,
                defaultnormal_vertex: defaultnormal_vertex,
                displacementmap_pars_vertex: displacementmap_pars_vertex,
                displacementmap_vertex: displacementmap_vertex,
                emissivemap_fragment: emissivemap_fragment,
                emissivemap_pars_fragment: emissivemap_pars_fragment,
                encodings_fragment: encodings_fragment,
                encodings_pars_fragment: encodings_pars_fragment,
                envmap_fragment: envmap_fragment,
                envmap_pars_fragment: envmap_pars_fragment,
                envmap_pars_vertex: envmap_pars_vertex,
                envmap_vertex: envmap_vertex,
                fog_vertex: fog_vertex,
                fog_pars_vertex: fog_pars_vertex,
                fog_fragment: fog_fragment,
                fog_pars_fragment: fog_pars_fragment,
                gradientmap_pars_fragment: gradientmap_pars_fragment,
                lightmap_fragment: lightmap_fragment,
                lightmap_pars_fragment: lightmap_pars_fragment,
                lights_lambert_vertex: lights_lambert_vertex,
                lights_pars_begin: lights_pars_begin,
                lights_pars_maps: lights_pars_maps,
                lights_phong_fragment: lights_phong_fragment,
                lights_phong_pars_fragment: lights_phong_pars_fragment,
                lights_physical_fragment: lights_physical_fragment,
                lights_physical_pars_fragment: lights_physical_pars_fragment,
                lights_fragment_begin: lights_fragment_begin,
                lights_fragment_maps: lights_fragment_maps,
                lights_fragment_end: lights_fragment_end,
                logdepthbuf_fragment: logdepthbuf_fragment,
                logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
                logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
                logdepthbuf_vertex: logdepthbuf_vertex,
                map_fragment: map_fragment,
                map_pars_fragment: map_pars_fragment,
                map_particle_fragment: map_particle_fragment,
                map_particle_pars_fragment: map_particle_pars_fragment,
                metalnessmap_fragment: metalnessmap_fragment,
                metalnessmap_pars_fragment: metalnessmap_pars_fragment,
                morphnormal_vertex: morphnormal_vertex,
                morphtarget_pars_vertex: morphtarget_pars_vertex,
                morphtarget_vertex: morphtarget_vertex,
                normal_fragment_begin: normal_fragment_begin,
                normal_fragment_maps: normal_fragment_maps,
                normalmap_pars_fragment: normalmap_pars_fragment,
                packing: packing,
                premultiplied_alpha_fragment: premultiplied_alpha_fragment,
                project_vertex: project_vertex,
                dithering_fragment: dithering_fragment,
                dithering_pars_fragment: dithering_pars_fragment,
                roughnessmap_fragment: roughnessmap_fragment,
                roughnessmap_pars_fragment: roughnessmap_pars_fragment,
                shadowmap_pars_fragment: shadowmap_pars_fragment,
                shadowmap_pars_vertex: shadowmap_pars_vertex,
                shadowmap_vertex: shadowmap_vertex,
                shadowmask_pars_fragment: shadowmask_pars_fragment,
                skinbase_vertex: skinbase_vertex,
                skinning_pars_vertex: skinning_pars_vertex,
                skinning_vertex: skinning_vertex,
                skinnormal_vertex: skinnormal_vertex,
                specularmap_fragment: specularmap_fragment,
                specularmap_pars_fragment: specularmap_pars_fragment,
                tonemapping_fragment: tonemapping_fragment,
                tonemapping_pars_fragment: tonemapping_pars_fragment,
                uv_pars_fragment: uv_pars_fragment,
                uv_pars_vertex: uv_pars_vertex,
                uv_vertex: uv_vertex,
                uv2_pars_fragment: uv2_pars_fragment,
                uv2_pars_vertex: uv2_pars_vertex,
                uv2_vertex: uv2_vertex,
                worldpos_vertex: worldpos_vertex,
                cube_frag: cube_frag,
                cube_vert: cube_vert,
                depth_frag: depth_frag,
                depth_vert: depth_vert,
                distanceRGBA_frag: distanceRGBA_frag,
                distanceRGBA_vert: distanceRGBA_vert,
                equirect_frag: equirect_frag,
                equirect_vert: equirect_vert,
                linedashed_frag: linedashed_frag,
                linedashed_vert: linedashed_vert,
                meshbasic_frag: meshbasic_frag,
                meshbasic_vert: meshbasic_vert,
                meshlambert_frag: meshlambert_frag,
                meshlambert_vert: meshlambert_vert,
                meshphong_frag: meshphong_frag,
                meshphong_vert: meshphong_vert,
                meshphysical_frag: meshphysical_frag,
                meshphysical_vert: meshphysical_vert,
                normal_frag: normal_frag,
                normal_vert: normal_vert,
                points_frag: points_frag,
                points_vert: points_vert,
                shadow_frag: shadow_frag,
                shadow_vert: shadow_vert
            };
            var UniformsUtils = {
                merge: function(uniforms) {
                    var merged = {};
                    for (var u = 0; u < uniforms.length; u++) {
                        var tmp = this.clone(uniforms[u]);
                        for (var p in tmp) {
                            merged[p] = tmp[p]
                        }
                    }
                    return merged
                },
                clone: function(uniforms_src) {
                    var uniforms_dst = {};
                    for (var u in uniforms_src) {
                        uniforms_dst[u] = {};
                        for (var p in uniforms_src[u]) {
                            var parameter_src = uniforms_src[u][p];
                            if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {
                                uniforms_dst[u][p] = parameter_src.clone()
                            } else if (Array.isArray(parameter_src)) {
                                uniforms_dst[u][p] = parameter_src.slice()
                            } else {
                                uniforms_dst[u][p] = parameter_src
                            }
                        }
                    }
                    return uniforms_dst
                }
            };
            var ColorKeywords = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            };

            function Color(r, g, b) {
                if (g === undefined && b === undefined) {
                    return this.set(r)
                }
                return this.setRGB(r, g, b)
            }
            Object.assign(Color.prototype, {
                isColor: true,
                r: 1,
                g: 1,
                b: 1,
                set: function(value) {
                    if (value && value.isColor) {
                        this.copy(value)
                    } else if (typeof value === "number") {
                        this.setHex(value)
                    } else if (typeof value === "string") {
                        this.setStyle(value)
                    }
                    return this
                },
                setScalar: function(scalar) {
                    this.r = scalar;
                    this.g = scalar;
                    this.b = scalar;
                    return this
                },
                setHex: function(hex) {
                    hex = Math.floor(hex);
                    this.r = (hex >> 16 & 255) / 255;
                    this.g = (hex >> 8 & 255) / 255;
                    this.b = (hex & 255) / 255;
                    return this
                },
                setRGB: function(r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    return this
                },
                setHSL: function() {
                    function hue2rgb(p, q, t) {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
                        return p
                    }
                    return function setHSL(h, s, l) {
                        h = _Math.euclideanModulo(h, 1);
                        s = _Math.clamp(s, 0, 1);
                        l = _Math.clamp(l, 0, 1);
                        if (s === 0) {
                            this.r = this.g = this.b = l
                        } else {
                            var p = l <= .5 ? l * (1 + s) : l + s - l * s;
                            var q = 2 * l - p;
                            this.r = hue2rgb(q, p, h + 1 / 3);
                            this.g = hue2rgb(q, p, h);
                            this.b = hue2rgb(q, p, h - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(style) {
                    function handleAlpha(string) {
                        if (string === undefined) return;
                        if (parseFloat(string) < 1) {
                            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.")
                        }
                    }
                    var m;
                    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                        var color;
                        var name = m[1];
                        var components = m[2];
                        switch (name) {
                            case "rgb":
                            case "rgba":
                                if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                    this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                                    this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                                    this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                                    handleAlpha(color[5]);
                                    return this
                                }
                                if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                    this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                                    this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                                    this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                                    handleAlpha(color[5]);
                                    return this
                                }
                                break;
                            case "hsl":
                            case "hsla":
                                if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                                    var h = parseFloat(color[1]) / 360;
                                    var s = parseInt(color[2], 10) / 100;
                                    var l = parseInt(color[3], 10) / 100;
                                    handleAlpha(color[5]);
                                    return this.setHSL(h, s, l)
                                }
                                break
                        }
                    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                        var hex = m[1];
                        var size = hex.length;
                        if (size === 3) {
                            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                            return this
                        } else if (size === 6) {
                            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                            return this
                        }
                    }
                    if (style && style.length > 0) {
                        var hex = ColorKeywords[style];
                        if (hex !== undefined) {
                            this.setHex(hex)
                        } else {
                            console.warn("THREE.Color: Unknown color " + style)
                        }
                    }
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(color) {
                    this.r = color.r;
                    this.g = color.g;
                    this.b = color.b;
                    return this
                },
                copyGammaToLinear: function(color, gammaFactor) {
                    if (gammaFactor === undefined) gammaFactor = 2;
                    this.r = Math.pow(color.r, gammaFactor);
                    this.g = Math.pow(color.g, gammaFactor);
                    this.b = Math.pow(color.b, gammaFactor);
                    return this
                },
                copyLinearToGamma: function(color, gammaFactor) {
                    if (gammaFactor === undefined) gammaFactor = 2;
                    var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
                    this.r = Math.pow(color.r, safeInverse);
                    this.g = Math.pow(color.g, safeInverse);
                    this.b = Math.pow(color.b, safeInverse);
                    return this
                },
                convertGammaToLinear: function() {
                    var r = this.r,
                        g = this.g,
                        b = this.b;
                    this.r = r * r;
                    this.g = g * g;
                    this.b = b * b;
                    return this
                },
                convertLinearToGamma: function() {
                    this.r = Math.sqrt(this.r);
                    this.g = Math.sqrt(this.g);
                    this.b = Math.sqrt(this.b);
                    return this
                },
                getHex: function() {
                    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Color: .getHSL() target is now required");
                        target = {
                            h: 0,
                            s: 0,
                            l: 0
                        }
                    }
                    var r = this.r,
                        g = this.g,
                        b = this.b;
                    var max = Math.max(r, g, b);
                    var min = Math.min(r, g, b);
                    var hue, saturation;
                    var lightness = (min + max) / 2;
                    if (min === max) {
                        hue = 0;
                        saturation = 0
                    } else {
                        var delta = max - min;
                        saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min);
                        switch (max) {
                            case r:
                                hue = (g - b) / delta + (g < b ? 6 : 0);
                                break;
                            case g:
                                hue = (b - r) / delta + 2;
                                break;
                            case b:
                                hue = (r - g) / delta + 4;
                                break
                        }
                        hue /= 6
                    }
                    target.h = hue;
                    target.s = saturation;
                    target.l = lightness;
                    return target
                },
                getStyle: function() {
                    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")"
                },
                offsetHSL: function() {
                    var hsl = {};
                    return function(h, s, l) {
                        this.getHSL(hsl);
                        hsl.h += h;
                        hsl.s += s;
                        hsl.l += l;
                        this.setHSL(hsl.h, hsl.s, hsl.l);
                        return this
                    }
                }(),
                add: function(color) {
                    this.r += color.r;
                    this.g += color.g;
                    this.b += color.b;
                    return this
                },
                addColors: function(color1, color2) {
                    this.r = color1.r + color2.r;
                    this.g = color1.g + color2.g;
                    this.b = color1.b + color2.b;
                    return this
                },
                addScalar: function(s) {
                    this.r += s;
                    this.g += s;
                    this.b += s;
                    return this
                },
                sub: function(color) {
                    this.r = Math.max(0, this.r - color.r);
                    this.g = Math.max(0, this.g - color.g);
                    this.b = Math.max(0, this.b - color.b);
                    return this
                },
                multiply: function(color) {
                    this.r *= color.r;
                    this.g *= color.g;
                    this.b *= color.b;
                    return this
                },
                multiplyScalar: function(s) {
                    this.r *= s;
                    this.g *= s;
                    this.b *= s;
                    return this
                },
                lerp: function(color, alpha) {
                    this.r += (color.r - this.r) * alpha;
                    this.g += (color.g - this.g) * alpha;
                    this.b += (color.b - this.b) * alpha;
                    return this
                },
                equals: function(c) {
                    return c.r === this.r && c.g === this.g && c.b === this.b
                },
                fromArray: function(array, offset) {
                    if (offset === undefined) offset = 0;
                    this.r = array[offset];
                    this.g = array[offset + 1];
                    this.b = array[offset + 2];
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    array[offset] = this.r;
                    array[offset + 1] = this.g;
                    array[offset + 2] = this.b;
                    return array
                },
                toJSON: function() {
                    return this.getHex()
                }
            });
            var UniformsLib = {
                common: {
                    diffuse: {
                        value: new Color(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new Matrix3
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new Vector2(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Color(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new Color(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new Matrix3
                    }
                }
            };
            var ShaderLib = {
                basic: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
                    vertexShader: ShaderChunk.meshbasic_vert,
                    fragmentShader: ShaderChunk.meshbasic_frag
                },
                lambert: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                        emissive: {
                            value: new Color(0)
                        }
                    }]),
                    vertexShader: ShaderChunk.meshlambert_vert,
                    fragmentShader: ShaderChunk.meshlambert_frag
                },
                phong: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                        emissive: {
                            value: new Color(0)
                        },
                        specular: {
                            value: new Color(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: ShaderChunk.meshphong_vert,
                    fragmentShader: ShaderChunk.meshphong_frag
                },
                standard: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                        emissive: {
                            value: new Color(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: .5
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ShaderChunk.meshphysical_vert,
                    fragmentShader: ShaderChunk.meshphysical_frag
                },
                points: {
                    uniforms: UniformsUtils.merge([UniformsLib.points, UniformsLib.fog]),
                    vertexShader: ShaderChunk.points_vert,
                    fragmentShader: ShaderChunk.points_frag
                },
                dashed: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: ShaderChunk.linedashed_vert,
                    fragmentShader: ShaderChunk.linedashed_frag
                },
                depth: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.displacementmap]),
                    vertexShader: ShaderChunk.depth_vert,
                    fragmentShader: ShaderChunk.depth_frag
                },
                normal: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ShaderChunk.normal_vert,
                    fragmentShader: ShaderChunk.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: ShaderChunk.cube_vert,
                    fragmentShader: ShaderChunk.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: ShaderChunk.equirect_vert,
                    fragmentShader: ShaderChunk.equirect_frag
                },
                distanceRGBA: {
                    uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.displacementmap, {
                        referencePosition: {
                            value: new Vector3
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: ShaderChunk.distanceRGBA_vert,
                    fragmentShader: ShaderChunk.distanceRGBA_frag
                },
                shadow: {
                    uniforms: UniformsUtils.merge([UniformsLib.lights, UniformsLib.fog, {
                        color: {
                            value: new Color(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ShaderChunk.shadow_vert,
                    fragmentShader: ShaderChunk.shadow_frag
                }
            };
            ShaderLib.physical = {
                uniforms: UniformsUtils.merge([ShaderLib.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: ShaderChunk.meshphysical_vert,
                fragmentShader: ShaderChunk.meshphysical_frag
            };

            function WebGLAttributes(gl) {
                var buffers = new WeakMap;

                function createBuffer(attribute, bufferType) {
                    var array = attribute.array;
                    var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                    var buffer = gl.createBuffer();
                    gl.bindBuffer(bufferType, buffer);
                    gl.bufferData(bufferType, array, usage);
                    attribute.onUploadCallback();
                    var type = gl.FLOAT;
                    if (array instanceof Float32Array) {
                        type = gl.FLOAT
                    } else if (array instanceof Float64Array) {
                        console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.")
                    } else if (array instanceof Uint16Array) {
                        type = gl.UNSIGNED_SHORT
                    } else if (array instanceof Int16Array) {
                        type = gl.SHORT
                    } else if (array instanceof Uint32Array) {
                        type = gl.UNSIGNED_INT
                    } else if (array instanceof Int32Array) {
                        type = gl.INT
                    } else if (array instanceof Int8Array) {
                        type = gl.BYTE
                    } else if (array instanceof Uint8Array) {
                        type = gl.UNSIGNED_BYTE
                    }
                    return {
                        buffer: buffer,
                        type: type,
                        bytesPerElement: array.BYTES_PER_ELEMENT,
                        version: attribute.version
                    }
                }

                function updateBuffer(buffer, attribute, bufferType) {
                    var array = attribute.array;
                    var updateRange = attribute.updateRange;
                    gl.bindBuffer(bufferType, buffer);
                    if (attribute.dynamic === false) {
                        gl.bufferData(bufferType, array, gl.STATIC_DRAW)
                    } else if (updateRange.count === -1) {
                        gl.bufferSubData(bufferType, 0, array)
                    } else if (updateRange.count === 0) {
                        console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.")
                    } else {
                        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                        updateRange.count = -1
                    }
                }

                function get(attribute) {
                    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                    return buffers.get(attribute)
                }

                function remove(attribute) {
                    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                    var data = buffers.get(attribute);
                    if (data) {
                        gl.deleteBuffer(data.buffer);
                        buffers.delete(attribute)
                    }
                }

                function update(attribute, bufferType) {
                    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                    var data = buffers.get(attribute);
                    if (data === undefined) {
                        buffers.set(attribute, createBuffer(attribute, bufferType))
                    } else if (data.version < attribute.version) {
                        updateBuffer(data.buffer, attribute, bufferType);
                        data.version = attribute.version
                    }
                }
                return {
                    get: get,
                    remove: remove,
                    update: update
                }
            }

            function Euler(x, y, z, order) {
                this._x = x || 0;
                this._y = y || 0;
                this._z = z || 0;
                this._order = order || Euler.DefaultOrder
            }
            Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            Euler.DefaultOrder = "XYZ";
            Object.defineProperties(Euler.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(value) {
                        this._x = value;
                        this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(value) {
                        this._y = value;
                        this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(value) {
                        this._z = value;
                        this.onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(value) {
                        this._order = value;
                        this.onChangeCallback()
                    }
                }
            });
            Object.assign(Euler.prototype, {
                isEuler: true,
                set: function(x, y, z, order) {
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    this._order = order || this._order;
                    this.onChangeCallback();
                    return this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(euler) {
                    this._x = euler._x;
                    this._y = euler._y;
                    this._z = euler._z;
                    this._order = euler._order;
                    this.onChangeCallback();
                    return this
                },
                setFromRotationMatrix: function(m, order, update) {
                    var clamp = _Math.clamp;
                    var te = m.elements;
                    var m11 = te[0],
                        m12 = te[4],
                        m13 = te[8];
                    var m21 = te[1],
                        m22 = te[5],
                        m23 = te[9];
                    var m31 = te[2],
                        m32 = te[6],
                        m33 = te[10];
                    order = order || this._order;
                    if (order === "XYZ") {
                        this._y = Math.asin(clamp(m13, -1, 1));
                        if (Math.abs(m13) < .99999) {
                            this._x = Math.atan2(-m23, m33);
                            this._z = Math.atan2(-m12, m11)
                        } else {
                            this._x = Math.atan2(m32, m22);
                            this._z = 0
                        }
                    } else if (order === "YXZ") {
                        this._x = Math.asin(-clamp(m23, -1, 1));
                        if (Math.abs(m23) < .99999) {
                            this._y = Math.atan2(m13, m33);
                            this._z = Math.atan2(m21, m22)
                        } else {
                            this._y = Math.atan2(-m31, m11);
                            this._z = 0
                        }
                    } else if (order === "ZXY") {
                        this._x = Math.asin(clamp(m32, -1, 1));
                        if (Math.abs(m32) < .99999) {
                            this._y = Math.atan2(-m31, m33);
                            this._z = Math.atan2(-m12, m22)
                        } else {
                            this._y = 0;
                            this._z = Math.atan2(m21, m11)
                        }
                    } else if (order === "ZYX") {
                        this._y = Math.asin(-clamp(m31, -1, 1));
                        if (Math.abs(m31) < .99999) {
                            this._x = Math.atan2(m32, m33);
                            this._z = Math.atan2(m21, m11)
                        } else {
                            this._x = 0;
                            this._z = Math.atan2(-m12, m22)
                        }
                    } else if (order === "YZX") {
                        this._z = Math.asin(clamp(m21, -1, 1));
                        if (Math.abs(m21) < .99999) {
                            this._x = Math.atan2(-m23, m22);
                            this._y = Math.atan2(-m31, m11)
                        } else {
                            this._x = 0;
                            this._y = Math.atan2(m13, m33)
                        }
                    } else if (order === "XZY") {
                        this._z = Math.asin(-clamp(m12, -1, 1));
                        if (Math.abs(m12) < .99999) {
                            this._x = Math.atan2(m32, m22);
                            this._y = Math.atan2(m13, m11)
                        } else {
                            this._x = Math.atan2(-m23, m33);
                            this._y = 0
                        }
                    } else {
                        console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order)
                    }
                    this._order = order;
                    if (update !== false) this.onChangeCallback();
                    return this
                },
                setFromQuaternion: function() {
                    var matrix = new Matrix4;
                    return function setFromQuaternion(q, order, update) {
                        matrix.makeRotationFromQuaternion(q);
                        return this.setFromRotationMatrix(matrix, order, update)
                    }
                }(),
                setFromVector3: function(v, order) {
                    return this.set(v.x, v.y, v.z, order || this._order)
                },
                reorder: function() {
                    var q = new Quaternion;
                    return function reorder(newOrder) {
                        q.setFromEuler(this);
                        return this.setFromQuaternion(q, newOrder)
                    }
                }(),
                equals: function(euler) {
                    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order
                },
                fromArray: function(array) {
                    this._x = array[0];
                    this._y = array[1];
                    this._z = array[2];
                    if (array[3] !== undefined) this._order = array[3];
                    this.onChangeCallback();
                    return this
                },
                toArray: function(array, offset) {
                    if (array === undefined) array = [];
                    if (offset === undefined) offset = 0;
                    array[offset] = this._x;
                    array[offset + 1] = this._y;
                    array[offset + 2] = this._z;
                    array[offset + 3] = this._order;
                    return array
                },
                toVector3: function(optionalResult) {
                    if (optionalResult) {
                        return optionalResult.set(this._x, this._y, this._z)
                    } else {
                        return new Vector3(this._x, this._y, this._z)
                    }
                },
                onChange: function(callback) {
                    this.onChangeCallback = callback;
                    return this
                },
                onChangeCallback: function() {}
            });

            function Layers() {
                this.mask = 1 | 0
            }
            Object.assign(Layers.prototype, {
                set: function(channel) {
                    this.mask = 1 << channel | 0
                },
                enable: function(channel) {
                    this.mask |= 1 << channel | 0
                },
                toggle: function(channel) {
                    this.mask ^= 1 << channel | 0
                },
                disable: function(channel) {
                    this.mask &= ~(1 << channel | 0)
                },
                test: function(layers) {
                    return (this.mask & layers.mask) !== 0
                }
            });
            var object3DId = 0;

            function Object3D() {
                Object.defineProperty(this, "id", {
                    value: object3DId++
                });
                this.uuid = _Math.generateUUID();
                this.name = "";
                this.type = "Object3D";
                this.parent = null;
                this.children = [];
                this.up = Object3D.DefaultUp.clone();
                var position = new Vector3;
                var rotation = new Euler;
                var quaternion = new Quaternion;
                var scale = new Vector3(1, 1, 1);

                function onRotationChange() {
                    quaternion.setFromEuler(rotation, false)
                }

                function onQuaternionChange() {
                    rotation.setFromQuaternion(quaternion, undefined, false)
                }
                rotation.onChange(onRotationChange);
                quaternion.onChange(onQuaternionChange);
                Object.defineProperties(this, {
                    position: {
                        enumerable: true,
                        value: position
                    },
                    rotation: {
                        enumerable: true,
                        value: rotation
                    },
                    quaternion: {
                        enumerable: true,
                        value: quaternion
                    },
                    scale: {
                        enumerable: true,
                        value: scale
                    },
                    modelViewMatrix: {
                        value: new Matrix4
                    },
                    normalMatrix: {
                        value: new Matrix3
                    }
                });
                this.matrix = new Matrix4;
                this.matrixWorld = new Matrix4;
                this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
                this.matrixWorldNeedsUpdate = false;
                this.layers = new Layers;
                this.visible = true;
                this.castShadow = false;
                this.receiveShadow = false;
                this.frustumCulled = true;
                this.renderOrder = 0;
                this.userData = {}
            }
            Object3D.DefaultUp = new Vector3(0, 1, 0);
            Object3D.DefaultMatrixAutoUpdate = true;
            Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Object3D,
                isObject3D: true,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(matrix) {
                    this.matrix.multiplyMatrices(matrix, this.matrix);
                    this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(q) {
                    this.quaternion.premultiply(q);
                    return this
                },
                setRotationFromAxisAngle: function(axis, angle) {
                    this.quaternion.setFromAxisAngle(axis, angle)
                },
                setRotationFromEuler: function(euler) {
                    this.quaternion.setFromEuler(euler, true)
                },
                setRotationFromMatrix: function(m) {
                    this.quaternion.setFromRotationMatrix(m)
                },
                setRotationFromQuaternion: function(q) {
                    this.quaternion.copy(q)
                },
                rotateOnAxis: function() {
                    var q1 = new Quaternion;
                    return function rotateOnAxis(axis, angle) {
                        q1.setFromAxisAngle(axis, angle);
                        this.quaternion.multiply(q1);
                        return this
                    }
                }(),
                rotateOnWorldAxis: function() {
                    var q1 = new Quaternion;
                    return function rotateOnWorldAxis(axis, angle) {
                        q1.setFromAxisAngle(axis, angle);
                        this.quaternion.premultiply(q1);
                        return this
                    }
                }(),
                rotateX: function() {
                    var v1 = new Vector3(1, 0, 0);
                    return function rotateX(angle) {
                        return this.rotateOnAxis(v1, angle)
                    }
                }(),
                rotateY: function() {
                    var v1 = new Vector3(0, 1, 0);
                    return function rotateY(angle) {
                        return this.rotateOnAxis(v1, angle)
                    }
                }(),
                rotateZ: function() {
                    var v1 = new Vector3(0, 0, 1);
                    return function rotateZ(angle) {
                        return this.rotateOnAxis(v1, angle)
                    }
                }(),
                translateOnAxis: function() {
                    var v1 = new Vector3;
                    return function translateOnAxis(axis, distance) {
                        v1.copy(axis).applyQuaternion(this.quaternion);
                        this.position.add(v1.multiplyScalar(distance));
                        return this
                    }
                }(),
                translateX: function() {
                    var v1 = new Vector3(1, 0, 0);
                    return function translateX(distance) {
                        return this.translateOnAxis(v1, distance)
                    }
                }(),
                translateY: function() {
                    var v1 = new Vector3(0, 1, 0);
                    return function translateY(distance) {
                        return this.translateOnAxis(v1, distance)
                    }
                }(),
                translateZ: function() {
                    var v1 = new Vector3(0, 0, 1);
                    return function translateZ(distance) {
                        return this.translateOnAxis(v1, distance)
                    }
                }(),
                localToWorld: function(vector) {
                    return vector.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var m1 = new Matrix4;
                    return function worldToLocal(vector) {
                        return vector.applyMatrix4(m1.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var m1 = new Matrix4;
                    var vector = new Vector3;
                    return function lookAt(x, y, z) {
                        if (x.isVector3) {
                            vector.copy(x)
                        } else {
                            vector.set(x, y, z)
                        }
                        if (this.isCamera) {
                            m1.lookAt(this.position, vector, this.up)
                        } else {
                            m1.lookAt(vector, this.position, this.up)
                        }
                        this.quaternion.setFromRotationMatrix(m1)
                    }
                }(),
                add: function(object) {
                    if (arguments.length > 1) {
                        for (var i = 0; i < arguments.length; i++) {
                            this.add(arguments[i])
                        }
                        return this
                    }
                    if (object === this) {
                        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                        return this
                    }
                    if (object && object.isObject3D) {
                        if (object.parent !== null) {
                            object.parent.remove(object)
                        }
                        object.parent = this;
                        object.dispatchEvent({
                            type: "added"
                        });
                        this.children.push(object)
                    } else {
                        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object)
                    }
                    return this
                },
                remove: function(object) {
                    if (arguments.length > 1) {
                        for (var i = 0; i < arguments.length; i++) {
                            this.remove(arguments[i])
                        }
                        return this
                    }
                    var index = this.children.indexOf(object);
                    if (index !== -1) {
                        object.parent = null;
                        object.dispatchEvent({
                            type: "removed"
                        });
                        this.children.splice(index, 1)
                    }
                    return this
                },
                getObjectById: function(id) {
                    return this.getObjectByProperty("id", id)
                },
                getObjectByName: function(name) {
                    return this.getObjectByProperty("name", name)
                },
                getObjectByProperty: function(name, value) {
                    if (this[name] === value) return this;
                    for (var i = 0, l = this.children.length; i < l; i++) {
                        var child = this.children[i];
                        var object = child.getObjectByProperty(name, value);
                        if (object !== undefined) {
                            return object
                        }
                    }
                    return undefined
                },
                getWorldPosition: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Object3D: .getWorldPosition() target is now required");
                        target = new Vector3
                    }
                    this.updateMatrixWorld(true);
                    return target.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var position = new Vector3;
                    var scale = new Vector3;
                    return function getWorldQuaternion(target) {
                        if (target === undefined) {
                            console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
                            target = new Quaternion
                        }
                        this.updateMatrixWorld(true);
                        this.matrixWorld.decompose(position, target, scale);
                        return target
                    }
                }(),
                getWorldScale: function() {
                    var position = new Vector3;
                    var quaternion = new Quaternion;
                    return function getWorldScale(target) {
                        if (target === undefined) {
                            console.warn("THREE.Object3D: .getWorldScale() target is now required");
                            target = new Vector3
                        }
                        this.updateMatrixWorld(true);
                        this.matrixWorld.decompose(position, quaternion, target);
                        return target
                    }
                }(),
                getWorldDirection: function() {
                    var quaternion = new Quaternion;
                    return function getWorldDirection(target) {
                        if (target === undefined) {
                            console.warn("THREE.Object3D: .getWorldDirection() target is now required");
                            target = new Vector3
                        }
                        this.getWorldQuaternion(quaternion);
                        return target.set(0, 0, 1).applyQuaternion(quaternion)
                    }
                }(),
                raycast: function() {},
                traverse: function(callback) {
                    callback(this);
                    var children = this.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        children[i].traverse(callback)
                    }
                },
                traverseVisible: function(callback) {
                    if (this.visible === false) return;
                    callback(this);
                    var children = this.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        children[i].traverseVisible(callback)
                    }
                },
                traverseAncestors: function(callback) {
                    var parent = this.parent;
                    if (parent !== null) {
                        callback(parent);
                        parent.traverseAncestors(callback)
                    }
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale);
                    this.matrixWorldNeedsUpdate = true
                },
                updateMatrixWorld: function(force) {
                    if (this.matrixAutoUpdate) this.updateMatrix();
                    if (this.matrixWorldNeedsUpdate || force) {
                        if (this.parent === null) {
                            this.matrixWorld.copy(this.matrix)
                        } else {
                            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)
                        }
                        this.matrixWorldNeedsUpdate = false;
                        force = true
                    }
                    var children = this.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        children[i].updateMatrixWorld(force)
                    }
                },
                toJSON: function(meta) {
                    var isRootObject = meta === undefined || typeof meta === "string";
                    var output = {};
                    if (isRootObject) {
                        meta = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {}
                        };
                        output.metadata = {
                            version: 4.5,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        }
                    }
                    var object = {};
                    object.uuid = this.uuid;
                    object.type = this.type;
                    if (this.name !== "") object.name = this.name;
                    if (this.castShadow === true) object.castShadow = true;
                    if (this.receiveShadow === true) object.receiveShadow = true;
                    if (this.visible === false) object.visible = false;
                    if (this.frustumCulled === false) object.frustumCulled = false;
                    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
                    if (JSON.stringify(this.userData) !== "{}") object.userData = this.userData;
                    object.matrix = this.matrix.toArray();

                    function serialize(library, element) {
                        if (library[element.uuid] === undefined) {
                            library[element.uuid] = element.toJSON(meta)
                        }
                        return element.uuid
                    }
                    if (this.geometry !== undefined) {
                        object.geometry = serialize(meta.geometries, this.geometry);
                        var parameters = this.geometry.parameters;
                        if (parameters !== undefined && parameters.shapes !== undefined) {
                            var shapes = parameters.shapes;
                            if (Array.isArray(shapes)) {
                                for (var i = 0, l = shapes.length; i < l; i++) {
                                    var shape = shapes[i];
                                    serialize(meta.shapes, shape)
                                }
                            } else {
                                serialize(meta.shapes, shapes)
                            }
                        }
                    }
                    if (this.material !== undefined) {
                        if (Array.isArray(this.material)) {
                            var uuids = [];
                            for (var i = 0, l = this.material.length; i < l; i++) {
                                uuids.push(serialize(meta.materials, this.material[i]))
                            }
                            object.material = uuids
                        } else {
                            object.material = serialize(meta.materials, this.material)
                        }
                    }
                    if (this.children.length > 0) {
                        object.children = [];
                        for (var i = 0; i < this.children.length; i++) {
                            object.children.push(this.children[i].toJSON(meta).object)
                        }
                    }
                    if (isRootObject) {
                        var geometries = extractFromCache(meta.geometries);
                        var materials = extractFromCache(meta.materials);
                        var textures = extractFromCache(meta.textures);
                        var images = extractFromCache(meta.images);
                        var shapes = extractFromCache(meta.shapes);
                        if (geometries.length > 0) output.geometries = geometries;
                        if (materials.length > 0) output.materials = materials;
                        if (textures.length > 0) output.textures = textures;
                        if (images.length > 0) output.images = images;
                        if (shapes.length > 0) output.shapes = shapes
                    }
                    output.object = object;
                    return output;

                    function extractFromCache(cache) {
                        var values = [];
                        for (var key in cache) {
                            var data = cache[key];
                            delete data.metadata;
                            values.push(data)
                        }
                        return values
                    }
                },
                clone: function(recursive) {
                    return (new this.constructor).copy(this, recursive)
                },
                copy: function(source, recursive) {
                    if (recursive === undefined) recursive = true;
                    this.name = source.name;
                    this.up.copy(source.up);
                    this.position.copy(source.position);
                    this.quaternion.copy(source.quaternion);
                    this.scale.copy(source.scale);
                    this.matrix.copy(source.matrix);
                    this.matrixWorld.copy(source.matrixWorld);
                    this.matrixAutoUpdate = source.matrixAutoUpdate;
                    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
                    this.layers.mask = source.layers.mask;
                    this.visible = source.visible;
                    this.castShadow = source.castShadow;
                    this.receiveShadow = source.receiveShadow;
                    this.frustumCulled = source.frustumCulled;
                    this.renderOrder = source.renderOrder;
                    this.userData = JSON.parse(JSON.stringify(source.userData));
                    if (recursive === true) {
                        for (var i = 0; i < source.children.length; i++) {
                            var child = source.children[i];
                            this.add(child.clone())
                        }
                    }
                    return this
                }
            });

            function Camera() {
                Object3D.call(this);
                this.type = "Camera";
                this.matrixWorldInverse = new Matrix4;
                this.projectionMatrix = new Matrix4
            }
            Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Camera,
                isCamera: true,
                copy: function(source, recursive) {
                    Object3D.prototype.copy.call(this, source, recursive);
                    this.matrixWorldInverse.copy(source.matrixWorldInverse);
                    this.projectionMatrix.copy(source.projectionMatrix);
                    return this
                },
                getWorldDirection: function() {
                    var quaternion = new Quaternion;
                    return function getWorldDirection(target) {
                        if (target === undefined) {
                            console.warn("THREE.Camera: .getWorldDirection() target is now required");
                            target = new Vector3
                        }
                        this.getWorldQuaternion(quaternion);
                        return target.set(0, 0, -1).applyQuaternion(quaternion)
                    }
                }(),
                updateMatrixWorld: function(force) {
                    Object3D.prototype.updateMatrixWorld.call(this, force);
                    this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            });

            function OrthographicCamera(left, right, top, bottom, near, far) {
                Camera.call(this);
                this.type = "OrthographicCamera";
                this.zoom = 1;
                this.view = null;
                this.left = left;
                this.right = right;
                this.top = top;
                this.bottom = bottom;
                this.near = near !== undefined ? near : .1;
                this.far = far !== undefined ? far : 2e3;
                this.updateProjectionMatrix()
            }
            OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
                constructor: OrthographicCamera,
                isOrthographicCamera: true,
                copy: function(source, recursive) {
                    Camera.prototype.copy.call(this, source, recursive);
                    this.left = source.left;
                    this.right = source.right;
                    this.top = source.top;
                    this.bottom = source.bottom;
                    this.near = source.near;
                    this.far = source.far;
                    this.zoom = source.zoom;
                    this.view = source.view === null ? null : Object.assign({}, source.view);
                    return this
                },
                setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
                    if (this.view === null) {
                        this.view = {
                            enabled: true,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }
                    }
                    this.view.enabled = true;
                    this.view.fullWidth = fullWidth;
                    this.view.fullHeight = fullHeight;
                    this.view.offsetX = x;
                    this.view.offsetY = y;
                    this.view.width = width;
                    this.view.height = height;
                    this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    if (this.view !== null) {
                        this.view.enabled = false
                    }
                    this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var dx = (this.right - this.left) / (2 * this.zoom);
                    var dy = (this.top - this.bottom) / (2 * this.zoom);
                    var cx = (this.right + this.left) / 2;
                    var cy = (this.top + this.bottom) / 2;
                    var left = cx - dx;
                    var right = cx + dx;
                    var top = cy + dy;
                    var bottom = cy - dy;
                    if (this.view !== null && this.view.enabled) {
                        var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                        var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                        var scaleW = (this.right - this.left) / this.view.width;
                        var scaleH = (this.top - this.bottom) / this.view.height;
                        left += scaleW * (this.view.offsetX / zoomW);
                        right = left + scaleW * (this.view.width / zoomW);
                        top -= scaleH * (this.view.offsetY / zoomH);
                        bottom = top - scaleH * (this.view.height / zoomH)
                    }
                    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far)
                },
                toJSON: function(meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    data.object.zoom = this.zoom;
                    data.object.left = this.left;
                    data.object.right = this.right;
                    data.object.top = this.top;
                    data.object.bottom = this.bottom;
                    data.object.near = this.near;
                    data.object.far = this.far;
                    if (this.view !== null) data.object.view = Object.assign({}, this.view);
                    return data
                }
            });

            function Face3(a, b, c, normal, color, materialIndex) {
                this.a = a;
                this.b = b;
                this.c = c;
                this.normal = normal && normal.isVector3 ? normal : new Vector3;
                this.vertexNormals = Array.isArray(normal) ? normal : [];
                this.color = color && color.isColor ? color : new Color;
                this.vertexColors = Array.isArray(color) ? color : [];
                this.materialIndex = materialIndex !== undefined ? materialIndex : 0
            }
            Object.assign(Face3.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    this.a = source.a;
                    this.b = source.b;
                    this.c = source.c;
                    this.normal.copy(source.normal);
                    this.color.copy(source.color);
                    this.materialIndex = source.materialIndex;
                    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                        this.vertexNormals[i] = source.vertexNormals[i].clone()
                    }
                    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                        this.vertexColors[i] = source.vertexColors[i].clone()
                    }
                    return this
                }
            });
            var geometryId = 0;

            function Geometry() {
                Object.defineProperty(this, "id", {
                    value: geometryId += 2
                });
                this.uuid = _Math.generateUUID();
                this.name = "";
                this.type = "Geometry";
                this.vertices = [];
                this.colors = [];
                this.faces = [];
                this.faceVertexUvs = [
                    []
                ];
                this.morphTargets = [];
                this.morphNormals = [];
                this.skinWeights = [];
                this.skinIndices = [];
                this.lineDistances = [];
                this.boundingBox = null;
                this.boundingSphere = null;
                this.elementsNeedUpdate = false;
                this.verticesNeedUpdate = false;
                this.uvsNeedUpdate = false;
                this.normalsNeedUpdate = false;
                this.colorsNeedUpdate = false;
                this.lineDistancesNeedUpdate = false;
                this.groupsNeedUpdate = false
            }
            Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Geometry,
                isGeometry: true,
                applyMatrix: function(matrix) {
                    var normalMatrix = (new Matrix3).getNormalMatrix(matrix);
                    for (var i = 0, il = this.vertices.length; i < il; i++) {
                        var vertex = this.vertices[i];
                        vertex.applyMatrix4(matrix)
                    }
                    for (var i = 0, il = this.faces.length; i < il; i++) {
                        var face = this.faces[i];
                        face.normal.applyMatrix3(normalMatrix).normalize();
                        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize()
                        }
                    }
                    if (this.boundingBox !== null) {
                        this.computeBoundingBox()
                    }
                    if (this.boundingSphere !== null) {
                        this.computeBoundingSphere()
                    }
                    this.verticesNeedUpdate = true;
                    this.normalsNeedUpdate = true;
                    return this
                },
                rotateX: function() {
                    var m1 = new Matrix4;
                    return function rotateX(angle) {
                        m1.makeRotationX(angle);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                rotateY: function() {
                    var m1 = new Matrix4;
                    return function rotateY(angle) {
                        m1.makeRotationY(angle);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                rotateZ: function() {
                    var m1 = new Matrix4;
                    return function rotateZ(angle) {
                        m1.makeRotationZ(angle);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                translate: function() {
                    var m1 = new Matrix4;
                    return function translate(x, y, z) {
                        m1.makeTranslation(x, y, z);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                scale: function() {
                    var m1 = new Matrix4;
                    return function scale(x, y, z) {
                        m1.makeScale(x, y, z);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                lookAt: function() {
                    var obj = new Object3D;
                    return function lookAt(vector) {
                        obj.lookAt(vector);
                        obj.updateMatrix();
                        this.applyMatrix(obj.matrix)
                    }
                }(),
                fromBufferGeometry: function(geometry) {
                    var scope = this;
                    var indices = geometry.index !== null ? geometry.index.array : undefined;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;
                    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
                    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
                    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
                    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
                    if (uvs2 !== undefined) this.faceVertexUvs[1] = [];
                    var tempNormals = [];
                    var tempUVs = [];
                    var tempUVs2 = [];
                    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
                        scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
                        if (normals !== undefined) {
                            tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]))
                        }
                        if (colors !== undefined) {
                            scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]))
                        }
                        if (uvs !== undefined) {
                            tempUVs.push(new Vector2(uvs[j], uvs[j + 1]))
                        }
                        if (uvs2 !== undefined) {
                            tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]))
                        }
                    }

                    function addFace(a, b, c, materialIndex) {
                        var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                        var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
                        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                        scope.faces.push(face);
                        if (uvs !== undefined) {
                            scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()])
                        }
                        if (uvs2 !== undefined) {
                            scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()])
                        }
                    }
                    var groups = geometry.groups;
                    if (groups.length > 0) {
                        for (var i = 0; i < groups.length; i++) {
                            var group = groups[i];
                            var start = group.start;
                            var count = group.count;
                            for (var j = start, jl = start + count; j < jl; j += 3) {
                                if (indices !== undefined) {
                                    addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex)
                                } else {
                                    addFace(j, j + 1, j + 2, group.materialIndex)
                                }
                            }
                        }
                    } else {
                        if (indices !== undefined) {
                            for (var i = 0; i < indices.length; i += 3) {
                                addFace(indices[i], indices[i + 1], indices[i + 2])
                            }
                        } else {
                            for (var i = 0; i < positions.length / 3; i += 3) {
                                addFace(i, i + 1, i + 2)
                            }
                        }
                    }
                    this.computeFaceNormals();
                    if (geometry.boundingBox !== null) {
                        this.boundingBox = geometry.boundingBox.clone()
                    }
                    if (geometry.boundingSphere !== null) {
                        this.boundingSphere = geometry.boundingSphere.clone()
                    }
                    return this
                },
                center: function() {
                    var offset = new Vector3;
                    return function center() {
                        this.computeBoundingBox();
                        this.boundingBox.getCenter(offset).negate();
                        this.translate(offset.x, offset.y, offset.z);
                        return this
                    }
                }(),
                normalize: function() {
                    this.computeBoundingSphere();
                    var center = this.boundingSphere.center;
                    var radius = this.boundingSphere.radius;
                    var s = radius === 0 ? 1 : 1 / radius;
                    var matrix = new Matrix4;
                    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
                    this.applyMatrix(matrix);
                    return this
                },
                computeFaceNormals: function() {
                    var cb = new Vector3,
                        ab = new Vector3;
                    for (var f = 0, fl = this.faces.length; f < fl; f++) {
                        var face = this.faces[f];
                        var vA = this.vertices[face.a];
                        var vB = this.vertices[face.b];
                        var vC = this.vertices[face.c];
                        cb.subVectors(vC, vB);
                        ab.subVectors(vA, vB);
                        cb.cross(ab);
                        cb.normalize();
                        face.normal.copy(cb)
                    }
                },
                computeVertexNormals: function(areaWeighted) {
                    if (areaWeighted === undefined) areaWeighted = true;
                    var v, vl, f, fl, face, vertices;
                    vertices = new Array(this.vertices.length);
                    for (v = 0, vl = this.vertices.length; v < vl; v++) {
                        vertices[v] = new Vector3
                    }
                    if (areaWeighted) {
                        var vA, vB, vC;
                        var cb = new Vector3,
                            ab = new Vector3;
                        for (f = 0, fl = this.faces.length; f < fl; f++) {
                            face = this.faces[f];
                            vA = this.vertices[face.a];
                            vB = this.vertices[face.b];
                            vC = this.vertices[face.c];
                            cb.subVectors(vC, vB);
                            ab.subVectors(vA, vB);
                            cb.cross(ab);
                            vertices[face.a].add(cb);
                            vertices[face.b].add(cb);
                            vertices[face.c].add(cb)
                        }
                    } else {
                        this.computeFaceNormals();
                        for (f = 0, fl = this.faces.length; f < fl; f++) {
                            face = this.faces[f];
                            vertices[face.a].add(face.normal);
                            vertices[face.b].add(face.normal);
                            vertices[face.c].add(face.normal)
                        }
                    }
                    for (v = 0, vl = this.vertices.length; v < vl; v++) {
                        vertices[v].normalize()
                    }
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        var vertexNormals = face.vertexNormals;
                        if (vertexNormals.length === 3) {
                            vertexNormals[0].copy(vertices[face.a]);
                            vertexNormals[1].copy(vertices[face.b]);
                            vertexNormals[2].copy(vertices[face.c])
                        } else {
                            vertexNormals[0] = vertices[face.a].clone();
                            vertexNormals[1] = vertices[face.b].clone();
                            vertexNormals[2] = vertices[face.c].clone()
                        }
                    }
                    if (this.faces.length > 0) {
                        this.normalsNeedUpdate = true
                    }
                },
                computeFlatVertexNormals: function() {
                    var f, fl, face;
                    this.computeFaceNormals();
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        var vertexNormals = face.vertexNormals;
                        if (vertexNormals.length === 3) {
                            vertexNormals[0].copy(face.normal);
                            vertexNormals[1].copy(face.normal);
                            vertexNormals[2].copy(face.normal)
                        } else {
                            vertexNormals[0] = face.normal.clone();
                            vertexNormals[1] = face.normal.clone();
                            vertexNormals[2] = face.normal.clone()
                        }
                    }
                    if (this.faces.length > 0) {
                        this.normalsNeedUpdate = true
                    }
                },
                computeMorphNormals: function() {
                    var i, il, f, fl, face;
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        if (!face.__originalFaceNormal) {
                            face.__originalFaceNormal = face.normal.clone()
                        } else {
                            face.__originalFaceNormal.copy(face.normal)
                        }
                        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
                        for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                            if (!face.__originalVertexNormals[i]) {
                                face.__originalVertexNormals[i] = face.vertexNormals[i].clone()
                            } else {
                                face.__originalVertexNormals[i].copy(face.vertexNormals[i])
                            }
                        }
                    }
                    var tmpGeo = new Geometry;
                    tmpGeo.faces = this.faces;
                    for (i = 0, il = this.morphTargets.length; i < il; i++) {
                        if (!this.morphNormals[i]) {
                            this.morphNormals[i] = {};
                            this.morphNormals[i].faceNormals = [];
                            this.morphNormals[i].vertexNormals = [];
                            var dstNormalsFace = this.morphNormals[i].faceNormals;
                            var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                            var faceNormal, vertexNormals;
                            for (f = 0, fl = this.faces.length; f < fl; f++) {
                                faceNormal = new Vector3;
                                vertexNormals = {
                                    a: new Vector3,
                                    b: new Vector3,
                                    c: new Vector3
                                };
                                dstNormalsFace.push(faceNormal);
                                dstNormalsVertex.push(vertexNormals)
                            }
                        }
                        var morphNormals = this.morphNormals[i];
                        tmpGeo.vertices = this.morphTargets[i].vertices;
                        tmpGeo.computeFaceNormals();
                        tmpGeo.computeVertexNormals();
                        var faceNormal, vertexNormals;
                        for (f = 0, fl = this.faces.length; f < fl; f++) {
                            face = this.faces[f];
                            faceNormal = morphNormals.faceNormals[f];
                            vertexNormals = morphNormals.vertexNormals[f];
                            faceNormal.copy(face.normal);
                            vertexNormals.a.copy(face.vertexNormals[0]);
                            vertexNormals.b.copy(face.vertexNormals[1]);
                            vertexNormals.c.copy(face.vertexNormals[2])
                        }
                    }
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        face = this.faces[f];
                        face.normal = face.__originalFaceNormal;
                        face.vertexNormals = face.__originalVertexNormals
                    }
                },
                computeBoundingBox: function() {
                    if (this.boundingBox === null) {
                        this.boundingBox = new Box3
                    }
                    this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    if (this.boundingSphere === null) {
                        this.boundingSphere = new Sphere
                    }
                    this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(geometry, matrix, materialIndexOffset) {
                    if (!(geometry && geometry.isGeometry)) {
                        console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
                        return
                    }
                    var normalMatrix, vertexOffset = this.vertices.length,
                        vertices1 = this.vertices,
                        vertices2 = geometry.vertices,
                        faces1 = this.faces,
                        faces2 = geometry.faces,
                        uvs1 = this.faceVertexUvs[0],
                        uvs2 = geometry.faceVertexUvs[0],
                        colors1 = this.colors,
                        colors2 = geometry.colors;
                    if (materialIndexOffset === undefined) materialIndexOffset = 0;
                    if (matrix !== undefined) {
                        normalMatrix = (new Matrix3).getNormalMatrix(matrix)
                    }
                    for (var i = 0, il = vertices2.length; i < il; i++) {
                        var vertex = vertices2[i];
                        var vertexCopy = vertex.clone();
                        if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
                        vertices1.push(vertexCopy)
                    }
                    for (var i = 0, il = colors2.length; i < il; i++) {
                        colors1.push(colors2[i].clone())
                    }
                    for (i = 0, il = faces2.length; i < il; i++) {
                        var face = faces2[i],
                            faceCopy, normal, color, faceVertexNormals = face.vertexNormals,
                            faceVertexColors = face.vertexColors;
                        faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                        faceCopy.normal.copy(face.normal);
                        if (normalMatrix !== undefined) {
                            faceCopy.normal.applyMatrix3(normalMatrix).normalize()
                        }
                        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                            normal = faceVertexNormals[j].clone();
                            if (normalMatrix !== undefined) {
                                normal.applyMatrix3(normalMatrix).normalize()
                            }
                            faceCopy.vertexNormals.push(normal)
                        }
                        faceCopy.color.copy(face.color);
                        for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                            color = faceVertexColors[j];
                            faceCopy.vertexColors.push(color.clone())
                        }
                        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                        faces1.push(faceCopy)
                    }
                    for (i = 0, il = uvs2.length; i < il; i++) {
                        var uv = uvs2[i],
                            uvCopy = [];
                        if (uv === undefined) {
                            continue
                        }
                        for (var j = 0, jl = uv.length; j < jl; j++) {
                            uvCopy.push(uv[j].clone())
                        }
                        uvs1.push(uvCopy)
                    }
                },
                mergeMesh: function(mesh) {
                    if (!(mesh && mesh.isMesh)) {
                        console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
                        return
                    }
                    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
                    this.merge(mesh.geometry, mesh.matrix)
                },
                mergeVertices: function() {
                    var verticesMap = {};
                    var unique = [],
                        changes = [];
                    var v, key;
                    var precisionPoints = 4;
                    var precision = Math.pow(10, precisionPoints);
                    var i, il, face;
                    var indices, j, jl;
                    for (i = 0, il = this.vertices.length; i < il; i++) {
                        v = this.vertices[i];
                        key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
                        if (verticesMap[key] === undefined) {
                            verticesMap[key] = i;
                            unique.push(this.vertices[i]);
                            changes[i] = unique.length - 1
                        } else {
                            changes[i] = changes[verticesMap[key]]
                        }
                    }
                    var faceIndicesToRemove = [];
                    for (i = 0, il = this.faces.length; i < il; i++) {
                        face = this.faces[i];
                        face.a = changes[face.a];
                        face.b = changes[face.b];
                        face.c = changes[face.c];
                        indices = [face.a, face.b, face.c];
                        for (var n = 0; n < 3; n++) {
                            if (indices[n] === indices[(n + 1) % 3]) {
                                faceIndicesToRemove.push(i);
                                break
                            }
                        }
                    }
                    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                        var idx = faceIndicesToRemove[i];
                        this.faces.splice(idx, 1);
                        for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                            this.faceVertexUvs[j].splice(idx, 1)
                        }
                    }
                    var diff = this.vertices.length - unique.length;
                    this.vertices = unique;
                    return diff
                },
                setFromPoints: function(points) {
                    this.vertices = [];
                    for (var i = 0, l = points.length; i < l; i++) {
                        var point = points[i];
                        this.vertices.push(new Vector3(point.x, point.y, point.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    var faces = this.faces;
                    var length = faces.length;
                    for (var i = 0; i < length; i++) {
                        faces[i]._id = i
                    }

                    function materialIndexSort(a, b) {
                        return a.materialIndex - b.materialIndex
                    }
                    faces.sort(materialIndexSort);
                    var uvs1 = this.faceVertexUvs[0];
                    var uvs2 = this.faceVertexUvs[1];
                    var newUvs1, newUvs2;
                    if (uvs1 && uvs1.length === length) newUvs1 = [];
                    if (uvs2 && uvs2.length === length) newUvs2 = [];
                    for (var i = 0; i < length; i++) {
                        var id = faces[i]._id;
                        if (newUvs1) newUvs1.push(uvs1[id]);
                        if (newUvs2) newUvs2.push(uvs2[id])
                    }
                    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
                    if (newUvs2) this.faceVertexUvs[1] = newUvs2
                },
                toJSON: function() {
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    data.uuid = this.uuid;
                    data.type = this.type;
                    if (this.name !== "") data.name = this.name;
                    if (this.parameters !== undefined) {
                        var parameters = this.parameters;
                        for (var key in parameters) {
                            if (parameters[key] !== undefined) data[key] = parameters[key]
                        }
                        return data
                    }
                    var vertices = [];
                    for (var i = 0; i < this.vertices.length; i++) {
                        var vertex = this.vertices[i];
                        vertices.push(vertex.x, vertex.y, vertex.z)
                    }
                    var faces = [];
                    var normals = [];
                    var normalsHash = {};
                    var colors = [];
                    var colorsHash = {};
                    var uvs = [];
                    var uvsHash = {};
                    for (var i = 0; i < this.faces.length; i++) {
                        var face = this.faces[i];
                        var hasMaterial = true;
                        var hasFaceUv = false;
                        var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                        var hasFaceNormal = face.normal.length() > 0;
                        var hasFaceVertexNormal = face.vertexNormals.length > 0;
                        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                        var hasFaceVertexColor = face.vertexColors.length > 0;
                        var faceType = 0;
                        faceType = setBit(faceType, 0, 0);
                        faceType = setBit(faceType, 1, hasMaterial);
                        faceType = setBit(faceType, 2, hasFaceUv);
                        faceType = setBit(faceType, 3, hasFaceVertexUv);
                        faceType = setBit(faceType, 4, hasFaceNormal);
                        faceType = setBit(faceType, 5, hasFaceVertexNormal);
                        faceType = setBit(faceType, 6, hasFaceColor);
                        faceType = setBit(faceType, 7, hasFaceVertexColor);
                        faces.push(faceType);
                        faces.push(face.a, face.b, face.c);
                        faces.push(face.materialIndex);
                        if (hasFaceVertexUv) {
                            var faceVertexUvs = this.faceVertexUvs[0][i];
                            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]))
                        }
                        if (hasFaceNormal) {
                            faces.push(getNormalIndex(face.normal))
                        }
                        if (hasFaceVertexNormal) {
                            var vertexNormals = face.vertexNormals;
                            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]))
                        }
                        if (hasFaceColor) {
                            faces.push(getColorIndex(face.color))
                        }
                        if (hasFaceVertexColor) {
                            var vertexColors = face.vertexColors;
                            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]))
                        }
                    }

                    function setBit(value, position, enabled) {
                        return enabled ? value | 1 << position : value & ~(1 << position)
                    }

                    function getNormalIndex(normal) {
                        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                        if (normalsHash[hash] !== undefined) {
                            return normalsHash[hash]
                        }
                        normalsHash[hash] = normals.length / 3;
                        normals.push(normal.x, normal.y, normal.z);
                        return normalsHash[hash]
                    }

                    function getColorIndex(color) {
                        var hash = color.r.toString() + color.g.toString() + color.b.toString();
                        if (colorsHash[hash] !== undefined) {
                            return colorsHash[hash]
                        }
                        colorsHash[hash] = colors.length;
                        colors.push(color.getHex());
                        return colorsHash[hash]
                    }

                    function getUvIndex(uv) {
                        var hash = uv.x.toString() + uv.y.toString();
                        if (uvsHash[hash] !== undefined) {
                            return uvsHash[hash]
                        }
                        uvsHash[hash] = uvs.length / 2;
                        uvs.push(uv.x, uv.y);
                        return uvsHash[hash]
                    }
                    data.data = {};
                    data.data.vertices = vertices;
                    data.data.normals = normals;
                    if (colors.length > 0) data.data.colors = colors;
                    if (uvs.length > 0) data.data.uvs = [uvs];
                    data.data.faces = faces;
                    return data
                },
                clone: function() {
                    return (new Geometry).copy(this)
                },
                copy: function(source) {
                    var i, il, j, jl, k, kl;
                    this.vertices = [];
                    this.colors = [];
                    this.faces = [];
                    this.faceVertexUvs = [
                        []
                    ];
                    this.morphTargets = [];
                    this.morphNormals = [];
                    this.skinWeights = [];
                    this.skinIndices = [];
                    this.lineDistances = [];
                    this.boundingBox = null;
                    this.boundingSphere = null;
                    this.name = source.name;
                    var vertices = source.vertices;
                    for (i = 0, il = vertices.length; i < il; i++) {
                        this.vertices.push(vertices[i].clone())
                    }
                    var colors = source.colors;
                    for (i = 0, il = colors.length; i < il; i++) {
                        this.colors.push(colors[i].clone())
                    }
                    var faces = source.faces;
                    for (i = 0, il = faces.length; i < il; i++) {
                        this.faces.push(faces[i].clone())
                    }
                    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                        var faceVertexUvs = source.faceVertexUvs[i];
                        if (this.faceVertexUvs[i] === undefined) {
                            this.faceVertexUvs[i] = []
                        }
                        for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                            var uvs = faceVertexUvs[j],
                                uvsCopy = [];
                            for (k = 0, kl = uvs.length; k < kl; k++) {
                                var uv = uvs[k];
                                uvsCopy.push(uv.clone())
                            }
                            this.faceVertexUvs[i].push(uvsCopy)
                        }
                    }
                    var morphTargets = source.morphTargets;
                    for (i = 0, il = morphTargets.length; i < il; i++) {
                        var morphTarget = {};
                        morphTarget.name = morphTargets[i].name;
                        if (morphTargets[i].vertices !== undefined) {
                            morphTarget.vertices = [];
                            for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
                                morphTarget.vertices.push(morphTargets[i].vertices[j].clone())
                            }
                        }
                        if (morphTargets[i].normals !== undefined) {
                            morphTarget.normals = [];
                            for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
                                morphTarget.normals.push(morphTargets[i].normals[j].clone())
                            }
                        }
                        this.morphTargets.push(morphTarget)
                    }
                    var morphNormals = source.morphNormals;
                    for (i = 0, il = morphNormals.length; i < il; i++) {
                        var morphNormal = {};
                        if (morphNormals[i].vertexNormals !== undefined) {
                            morphNormal.vertexNormals = [];
                            for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                                var srcVertexNormal = morphNormals[i].vertexNormals[j];
                                var destVertexNormal = {};
                                destVertexNormal.a = srcVertexNormal.a.clone();
                                destVertexNormal.b = srcVertexNormal.b.clone();
                                destVertexNormal.c = srcVertexNormal.c.clone();
                                morphNormal.vertexNormals.push(destVertexNormal)
                            }
                        }
                        if (morphNormals[i].faceNormals !== undefined) {
                            morphNormal.faceNormals = [];
                            for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
                                morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone())
                            }
                        }
                        this.morphNormals.push(morphNormal)
                    }
                    var skinWeights = source.skinWeights;
                    for (i = 0, il = skinWeights.length; i < il; i++) {
                        this.skinWeights.push(skinWeights[i].clone())
                    }
                    var skinIndices = source.skinIndices;
                    for (i = 0, il = skinIndices.length; i < il; i++) {
                        this.skinIndices.push(skinIndices[i].clone())
                    }
                    var lineDistances = source.lineDistances;
                    for (i = 0, il = lineDistances.length; i < il; i++) {
                        this.lineDistances.push(lineDistances[i])
                    }
                    var boundingBox = source.boundingBox;
                    if (boundingBox !== null) {
                        this.boundingBox = boundingBox.clone()
                    }
                    var boundingSphere = source.boundingSphere;
                    if (boundingSphere !== null) {
                        this.boundingSphere = boundingSphere.clone()
                    }
                    this.elementsNeedUpdate = source.elementsNeedUpdate;
                    this.verticesNeedUpdate = source.verticesNeedUpdate;
                    this.uvsNeedUpdate = source.uvsNeedUpdate;
                    this.normalsNeedUpdate = source.normalsNeedUpdate;
                    this.colorsNeedUpdate = source.colorsNeedUpdate;
                    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
                    this.groupsNeedUpdate = source.groupsNeedUpdate;
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });

            function BufferAttribute(array, itemSize, normalized) {
                if (Array.isArray(array)) {
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.")
                }
                this.name = "";
                this.array = array;
                this.itemSize = itemSize;
                this.count = array !== undefined ? array.length / itemSize : 0;
                this.normalized = normalized === true;
                this.dynamic = false;
                this.updateRange = {
                    offset: 0,
                    count: -1
                };
                this.version = 0
            }
            Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
                set: function(value) {
                    if (value === true) this.version++
                }
            });
            Object.assign(BufferAttribute.prototype, {
                isBufferAttribute: true,
                onUploadCallback: function() {},
                setArray: function(array) {
                    if (Array.isArray(array)) {
                        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.")
                    }
                    this.count = array !== undefined ? array.length / this.itemSize : 0;
                    this.array = array
                },
                setDynamic: function(value) {
                    this.dynamic = value;
                    return this
                },
                copy: function(source) {
                    this.array = new source.array.constructor(source.array);
                    this.itemSize = source.itemSize;
                    this.count = source.count;
                    this.normalized = source.normalized;
                    this.dynamic = source.dynamic;
                    return this
                },
                copyAt: function(index1, attribute, index2) {
                    index1 *= this.itemSize;
                    index2 *= attribute.itemSize;
                    for (var i = 0, l = this.itemSize; i < l; i++) {
                        this.array[index1 + i] = attribute.array[index2 + i]
                    }
                    return this
                },
                copyArray: function(array) {
                    this.array.set(array);
                    return this
                },
                copyColorsArray: function(colors) {
                    var array = this.array,
                        offset = 0;
                    for (var i = 0, l = colors.length; i < l; i++) {
                        var color = colors[i];
                        if (color === undefined) {
                            console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
                            color = new Color
                        }
                        array[offset++] = color.r;
                        array[offset++] = color.g;
                        array[offset++] = color.b
                    }
                    return this
                },
                copyVector2sArray: function(vectors) {
                    var array = this.array,
                        offset = 0;
                    for (var i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        if (vector === undefined) {
                            console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
                            vector = new Vector2
                        }
                        array[offset++] = vector.x;
                        array[offset++] = vector.y
                    }
                    return this
                },
                copyVector3sArray: function(vectors) {
                    var array = this.array,
                        offset = 0;
                    for (var i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        if (vector === undefined) {
                            console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
                            vector = new Vector3
                        }
                        array[offset++] = vector.x;
                        array[offset++] = vector.y;
                        array[offset++] = vector.z
                    }
                    return this
                },
                copyVector4sArray: function(vectors) {
                    var array = this.array,
                        offset = 0;
                    for (var i = 0, l = vectors.length; i < l; i++) {
                        var vector = vectors[i];
                        if (vector === undefined) {
                            console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
                            vector = new Vector4
                        }
                        array[offset++] = vector.x;
                        array[offset++] = vector.y;
                        array[offset++] = vector.z;
                        array[offset++] = vector.w
                    }
                    return this
                },
                set: function(value, offset) {
                    if (offset === undefined) offset = 0;
                    this.array.set(value, offset);
                    return this
                },
                getX: function(index) {
                    return this.array[index * this.itemSize]
                },
                setX: function(index, x) {
                    this.array[index * this.itemSize] = x;
                    return this
                },
                getY: function(index) {
                    return this.array[index * this.itemSize + 1]
                },
                setY: function(index, y) {
                    this.array[index * this.itemSize + 1] = y;
                    return this
                },
                getZ: function(index) {
                    return this.array[index * this.itemSize + 2]
                },
                setZ: function(index, z) {
                    this.array[index * this.itemSize + 2] = z;
                    return this
                },
                getW: function(index) {
                    return this.array[index * this.itemSize + 3]
                },
                setW: function(index, w) {
                    this.array[index * this.itemSize + 3] = w;
                    return this
                },
                setXY: function(index, x, y) {
                    index *= this.itemSize;
                    this.array[index + 0] = x;
                    this.array[index + 1] = y;
                    return this
                },
                setXYZ: function(index, x, y, z) {
                    index *= this.itemSize;
                    this.array[index + 0] = x;
                    this.array[index + 1] = y;
                    this.array[index + 2] = z;
                    return this
                },
                setXYZW: function(index, x, y, z, w) {
                    index *= this.itemSize;
                    this.array[index + 0] = x;
                    this.array[index + 1] = y;
                    this.array[index + 2] = z;
                    this.array[index + 3] = w;
                    return this
                },
                onUpload: function(callback) {
                    this.onUploadCallback = callback;
                    return this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            });

            function Int8BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Int8Array(array), itemSize, normalized)
            }
            Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

            function Uint8BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized)
            }
            Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

            function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized)
            }
            Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

            function Int16BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Int16Array(array), itemSize, normalized)
            }
            Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

            function Uint16BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized)
            }
            Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

            function Int32BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Int32Array(array), itemSize, normalized)
            }
            Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

            function Uint32BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized)
            }
            Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

            function Float32BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Float32Array(array), itemSize, normalized)
            }
            Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

            function Float64BufferAttribute(array, itemSize, normalized) {
                BufferAttribute.call(this, new Float64Array(array), itemSize, normalized)
            }
            Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
            Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

            function DirectGeometry() {
                this.vertices = [];
                this.normals = [];
                this.colors = [];
                this.uvs = [];
                this.uvs2 = [];
                this.groups = [];
                this.morphTargets = {};
                this.skinWeights = [];
                this.skinIndices = [];
                this.boundingBox = null;
                this.boundingSphere = null;
                this.verticesNeedUpdate = false;
                this.normalsNeedUpdate = false;
                this.colorsNeedUpdate = false;
                this.uvsNeedUpdate = false;
                this.groupsNeedUpdate = false
            }
            Object.assign(DirectGeometry.prototype, {
                computeGroups: function(geometry) {
                    var group;
                    var groups = [];
                    var materialIndex = undefined;
                    var faces = geometry.faces;
                    for (var i = 0; i < faces.length; i++) {
                        var face = faces[i];
                        if (face.materialIndex !== materialIndex) {
                            materialIndex = face.materialIndex;
                            if (group !== undefined) {
                                group.count = i * 3 - group.start;
                                groups.push(group)
                            }
                            group = {
                                start: i * 3,
                                materialIndex: materialIndex
                            }
                        }
                    }
                    if (group !== undefined) {
                        group.count = i * 3 - group.start;
                        groups.push(group)
                    }
                    this.groups = groups
                },
                fromGeometry: function(geometry) {
                    var faces = geometry.faces;
                    var vertices = geometry.vertices;
                    var faceVertexUvs = geometry.faceVertexUvs;
                    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
                    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
                    var morphTargets = geometry.morphTargets;
                    var morphTargetsLength = morphTargets.length;
                    var morphTargetsPosition;
                    if (morphTargetsLength > 0) {
                        morphTargetsPosition = [];
                        for (var i = 0; i < morphTargetsLength; i++) {
                            morphTargetsPosition[i] = []
                        }
                        this.morphTargets.position = morphTargetsPosition
                    }
                    var morphNormals = geometry.morphNormals;
                    var morphNormalsLength = morphNormals.length;
                    var morphTargetsNormal;
                    if (morphNormalsLength > 0) {
                        morphTargetsNormal = [];
                        for (var i = 0; i < morphNormalsLength; i++) {
                            morphTargetsNormal[i] = []
                        }
                        this.morphTargets.normal = morphTargetsNormal
                    }
                    var skinIndices = geometry.skinIndices;
                    var skinWeights = geometry.skinWeights;
                    var hasSkinIndices = skinIndices.length === vertices.length;
                    var hasSkinWeights = skinWeights.length === vertices.length;
                    for (var i = 0; i < faces.length; i++) {
                        var face = faces[i];
                        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                        var vertexNormals = face.vertexNormals;
                        if (vertexNormals.length === 3) {
                            this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2])
                        } else {
                            var normal = face.normal;
                            this.normals.push(normal, normal, normal)
                        }
                        var vertexColors = face.vertexColors;
                        if (vertexColors.length === 3) {
                            this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2])
                        } else {
                            var color = face.color;
                            this.colors.push(color, color, color)
                        }
                        if (hasFaceVertexUv === true) {
                            var vertexUvs = faceVertexUvs[0][i];
                            if (vertexUvs !== undefined) {
                                this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])
                            } else {
                                console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
                                this.uvs.push(new Vector2, new Vector2, new Vector2)
                            }
                        }
                        if (hasFaceVertexUv2 === true) {
                            var vertexUvs = faceVertexUvs[1][i];
                            if (vertexUvs !== undefined) {
                                this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])
                            } else {
                                console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
                                this.uvs2.push(new Vector2, new Vector2, new Vector2)
                            }
                        }
                        for (var j = 0; j < morphTargetsLength; j++) {
                            var morphTarget = morphTargets[j].vertices;
                            morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c])
                        }
                        for (var j = 0; j < morphNormalsLength; j++) {
                            var morphNormal = morphNormals[j].vertexNormals[i];
                            morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c)
                        }
                        if (hasSkinIndices) {
                            this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c])
                        }
                        if (hasSkinWeights) {
                            this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c])
                        }
                    }
                    this.computeGroups(geometry);
                    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
                    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
                    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
                    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
                    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
                    return this
                }
            });

            function arrayMax(array) {
                if (array.length === 0) return -Infinity;
                var max = array[0];
                for (var i = 1, l = array.length; i < l; ++i) {
                    if (array[i] > max) max = array[i]
                }
                return max
            }
            var bufferGeometryId = 1;

            function BufferGeometry() {
                Object.defineProperty(this, "id", {
                    value: bufferGeometryId += 2
                });
                this.uuid = _Math.generateUUID();
                this.name = "";
                this.type = "BufferGeometry";
                this.index = null;
                this.attributes = {};
                this.morphAttributes = {};
                this.groups = [];
                this.boundingBox = null;
                this.boundingSphere = null;
                this.drawRange = {
                    start: 0,
                    count: Infinity
                }
            }
            BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: BufferGeometry,
                isBufferGeometry: true,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(index) {
                    if (Array.isArray(index)) {
                        this.index = new(arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1)
                    } else {
                        this.index = index
                    }
                },
                addAttribute: function(name, attribute) {
                    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
                        console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
                        this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
                        return
                    }
                    if (name === "index") {
                        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
                        this.setIndex(attribute);
                        return
                    }
                    this.attributes[name] = attribute;
                    return this
                },
                getAttribute: function(name) {
                    return this.attributes[name]
                },
                removeAttribute: function(name) {
                    delete this.attributes[name];
                    return this
                },
                addGroup: function(start, count, materialIndex) {
                    this.groups.push({
                        start: start,
                        count: count,
                        materialIndex: materialIndex !== undefined ? materialIndex : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(start, count) {
                    this.drawRange.start = start;
                    this.drawRange.count = count
                },
                applyMatrix: function(matrix) {
                    var position = this.attributes.position;
                    if (position !== undefined) {
                        matrix.applyToBufferAttribute(position);
                        position.needsUpdate = true
                    }
                    var normal = this.attributes.normal;
                    if (normal !== undefined) {
                        var normalMatrix = (new Matrix3).getNormalMatrix(matrix);
                        normalMatrix.applyToBufferAttribute(normal);
                        normal.needsUpdate = true
                    }
                    if (this.boundingBox !== null) {
                        this.computeBoundingBox()
                    }
                    if (this.boundingSphere !== null) {
                        this.computeBoundingSphere()
                    }
                    return this
                },
                rotateX: function() {
                    var m1 = new Matrix4;
                    return function rotateX(angle) {
                        m1.makeRotationX(angle);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                rotateY: function() {
                    var m1 = new Matrix4;
                    return function rotateY(angle) {
                        m1.makeRotationY(angle);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                rotateZ: function() {
                    var m1 = new Matrix4;
                    return function rotateZ(angle) {
                        m1.makeRotationZ(angle);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                translate: function() {
                    var m1 = new Matrix4;
                    return function translate(x, y, z) {
                        m1.makeTranslation(x, y, z);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                scale: function() {
                    var m1 = new Matrix4;
                    return function scale(x, y, z) {
                        m1.makeScale(x, y, z);
                        this.applyMatrix(m1);
                        return this
                    }
                }(),
                lookAt: function() {
                    var obj = new Object3D;
                    return function lookAt(vector) {
                        obj.lookAt(vector);
                        obj.updateMatrix();
                        this.applyMatrix(obj.matrix)
                    }
                }(),
                center: function() {
                    var offset = new Vector3;
                    return function center() {
                        this.computeBoundingBox();
                        this.boundingBox.getCenter(offset).negate();
                        this.translate(offset.x, offset.y, offset.z);
                        return this
                    }
                }(),
                setFromObject: function(object) {
                    var geometry = object.geometry;
                    if (object.isPoints || object.isLine) {
                        var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                        var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
                        this.addAttribute("position", positions.copyVector3sArray(geometry.vertices));
                        this.addAttribute("color", colors.copyColorsArray(geometry.colors));
                        if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                            var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                            this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances))
                        }
                        if (geometry.boundingSphere !== null) {
                            this.boundingSphere = geometry.boundingSphere.clone()
                        }
                        if (geometry.boundingBox !== null) {
                            this.boundingBox = geometry.boundingBox.clone()
                        }
                    } else if (object.isMesh) {
                        if (geometry && geometry.isGeometry) {
                            this.fromGeometry(geometry)
                        }
                    }
                    return this
                },
                setFromPoints: function(points) {
                    var position = [];
                    for (var i = 0, l = points.length; i < l; i++) {
                        var point = points[i];
                        position.push(point.x, point.y, point.z || 0)
                    }
                    this.addAttribute("position", new Float32BufferAttribute(position, 3));
                    return this
                },
                updateFromObject: function(object) {
                    var geometry = object.geometry;
                    if (object.isMesh) {
                        var direct = geometry.__directGeometry;
                        if (geometry.elementsNeedUpdate === true) {
                            direct = undefined;
                            geometry.elementsNeedUpdate = false
                        }
                        if (direct === undefined) {
                            return this.fromGeometry(geometry)
                        }
                        direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                        direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                        direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                        direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                        direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                        geometry.verticesNeedUpdate = false;
                        geometry.normalsNeedUpdate = false;
                        geometry.colorsNeedUpdate = false;
                        geometry.uvsNeedUpdate = false;
                        geometry.groupsNeedUpdate = false;
                        geometry = direct
                    }
                    var attribute;
                    if (geometry.verticesNeedUpdate === true) {
                        attribute = this.attributes.position;
                        if (attribute !== undefined) {
                            attribute.copyVector3sArray(geometry.vertices);
                            attribute.needsUpdate = true
                        }
                        geometry.verticesNeedUpdate = false
                    }
                    if (geometry.normalsNeedUpdate === true) {
                        attribute = this.attributes.normal;
                        if (attribute !== undefined) {
                            attribute.copyVector3sArray(geometry.normals);
                            attribute.needsUpdate = true
                        }
                        geometry.normalsNeedUpdate = false
                    }
                    if (geometry.colorsNeedUpdate === true) {
                        attribute = this.attributes.color;
                        if (attribute !== undefined) {
                            attribute.copyColorsArray(geometry.colors);
                            attribute.needsUpdate = true
                        }
                        geometry.colorsNeedUpdate = false
                    }
                    if (geometry.uvsNeedUpdate) {
                        attribute = this.attributes.uv;
                        if (attribute !== undefined) {
                            attribute.copyVector2sArray(geometry.uvs);
                            attribute.needsUpdate = true
                        }
                        geometry.uvsNeedUpdate = false
                    }
                    if (geometry.lineDistancesNeedUpdate) {
                        attribute = this.attributes.lineDistance;
                        if (attribute !== undefined) {
                            attribute.copyArray(geometry.lineDistances);
                            attribute.needsUpdate = true
                        }
                        geometry.lineDistancesNeedUpdate = false
                    }
                    if (geometry.groupsNeedUpdate) {
                        geometry.computeGroups(object.geometry);
                        this.groups = geometry.groups;
                        geometry.groupsNeedUpdate = false
                    }
                    return this
                },
                fromGeometry: function(geometry) {
                    geometry.__directGeometry = (new DirectGeometry).fromGeometry(geometry);
                    return this.fromDirectGeometry(geometry.__directGeometry)
                },
                fromDirectGeometry: function(geometry) {
                    var positions = new Float32Array(geometry.vertices.length * 3);
                    this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
                    if (geometry.normals.length > 0) {
                        var normals = new Float32Array(geometry.normals.length * 3);
                        this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals))
                    }
                    if (geometry.colors.length > 0) {
                        var colors = new Float32Array(geometry.colors.length * 3);
                        this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors))
                    }
                    if (geometry.uvs.length > 0) {
                        var uvs = new Float32Array(geometry.uvs.length * 2);
                        this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs))
                    }
                    if (geometry.uvs2.length > 0) {
                        var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                        this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2))
                    }
                    this.groups = geometry.groups;
                    for (var name in geometry.morphTargets) {
                        var array = [];
                        var morphTargets = geometry.morphTargets[name];
                        for (var i = 0, l = morphTargets.length; i < l; i++) {
                            var morphTarget = morphTargets[i];
                            var attribute = new Float32BufferAttribute(morphTarget.length * 3, 3);
                            array.push(attribute.copyVector3sArray(morphTarget))
                        }
                        this.morphAttributes[name] = array
                    }
                    if (geometry.skinIndices.length > 0) {
                        var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                        this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices))
                    }
                    if (geometry.skinWeights.length > 0) {
                        var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                        this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights))
                    }
                    if (geometry.boundingSphere !== null) {
                        this.boundingSphere = geometry.boundingSphere.clone()
                    }
                    if (geometry.boundingBox !== null) {
                        this.boundingBox = geometry.boundingBox.clone()
                    }
                    return this
                },
                computeBoundingBox: function() {
                    if (this.boundingBox === null) {
                        this.boundingBox = new Box3
                    }
                    var position = this.attributes.position;
                    if (position !== undefined) {
                        this.boundingBox.setFromBufferAttribute(position)
                    } else {
                        this.boundingBox.makeEmpty()
                    }
                    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                        console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                },
                computeBoundingSphere: function() {
                    var box = new Box3;
                    var vector = new Vector3;
                    return function computeBoundingSphere() {
                        if (this.boundingSphere === null) {
                            this.boundingSphere = new Sphere
                        }
                        var position = this.attributes.position;
                        if (position) {
                            var center = this.boundingSphere.center;
                            box.setFromBufferAttribute(position);
                            box.getCenter(center);
                            var maxRadiusSq = 0;
                            for (var i = 0, il = position.count; i < il; i++) {
                                vector.x = position.getX(i);
                                vector.y = position.getY(i);
                                vector.z = position.getZ(i);
                                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector))
                            }
                            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                            if (isNaN(this.boundingSphere.radius)) {
                                console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var index = this.index;
                    var attributes = this.attributes;
                    var groups = this.groups;
                    if (attributes.position) {
                        var positions = attributes.position.array;
                        if (attributes.normal === undefined) {
                            this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3))
                        } else {
                            var array = attributes.normal.array;
                            for (var i = 0, il = array.length; i < il; i++) {
                                array[i] = 0
                            }
                        }
                        var normals = attributes.normal.array;
                        var vA, vB, vC;
                        var pA = new Vector3,
                            pB = new Vector3,
                            pC = new Vector3;
                        var cb = new Vector3,
                            ab = new Vector3;
                        if (index) {
                            var indices = index.array;
                            if (groups.length === 0) {
                                this.addGroup(0, indices.length)
                            }
                            for (var j = 0, jl = groups.length; j < jl; ++j) {
                                var group = groups[j];
                                var start = group.start;
                                var count = group.count;
                                for (var i = start, il = start + count; i < il; i += 3) {
                                    vA = indices[i + 0] * 3;
                                    vB = indices[i + 1] * 3;
                                    vC = indices[i + 2] * 3;
                                    pA.fromArray(positions, vA);
                                    pB.fromArray(positions, vB);
                                    pC.fromArray(positions, vC);
                                    cb.subVectors(pC, pB);
                                    ab.subVectors(pA, pB);
                                    cb.cross(ab);
                                    normals[vA] += cb.x;
                                    normals[vA + 1] += cb.y;
                                    normals[vA + 2] += cb.z;
                                    normals[vB] += cb.x;
                                    normals[vB + 1] += cb.y;
                                    normals[vB + 2] += cb.z;
                                    normals[vC] += cb.x;
                                    normals[vC + 1] += cb.y;
                                    normals[vC + 2] += cb.z
                                }
                            }
                        } else {
                            for (var i = 0, il = positions.length; i < il; i += 9) {
                                pA.fromArray(positions, i);
                                pB.fromArray(positions, i + 3);
                                pC.fromArray(positions, i + 6);
                                cb.subVectors(pC, pB);
                                ab.subVectors(pA, pB);
                                cb.cross(ab);
                                normals[i] = cb.x;
                                normals[i + 1] = cb.y;
                                normals[i + 2] = cb.z;
                                normals[i + 3] = cb.x;
                                normals[i + 4] = cb.y;
                                normals[i + 5] = cb.z;
                                normals[i + 6] = cb.x;
                                normals[i + 7] = cb.y;
                                normals[i + 8] = cb.z
                            }
                        }
                        this.normalizeNormals();
                        attributes.normal.needsUpdate = true
                    }
                },
                merge: function(geometry, offset) {
                    if (!(geometry && geometry.isBufferGeometry)) {
                        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
                        return
                    }
                    if (offset === undefined) {
                        offset = 0;
                        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. " + "Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")
                    }
                    var attributes = this.attributes;
                    for (var key in attributes) {
                        if (geometry.attributes[key] === undefined) continue;
                        var attribute1 = attributes[key];
                        var attributeArray1 = attribute1.array;
                        var attribute2 = geometry.attributes[key];
                        var attributeArray2 = attribute2.array;
                        var attributeSize = attribute2.itemSize;
                        for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                            attributeArray1[j] = attributeArray2[i]
                        }
                    }
                    return this
                },
                normalizeNormals: function() {
                    var vector = new Vector3;
                    return function normalizeNormals() {
                        var normals = this.attributes.normal;
                        for (var i = 0, il = normals.count; i < il; i++) {
                            vector.x = normals.getX(i);
                            vector.y = normals.getY(i);
                            vector.z = normals.getZ(i);
                            vector.normalize();
                            normals.setXYZ(i, vector.x, vector.y, vector.z)
                        }
                    }
                }(),
                toNonIndexed: function() {
                    if (this.index === null) {
                        console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
                        return this
                    }
                    var geometry2 = new BufferGeometry;
                    var indices = this.index.array;
                    var attributes = this.attributes;
                    for (var name in attributes) {
                        var attribute = attributes[name];
                        var array = attribute.array;
                        var itemSize = attribute.itemSize;
                        var array2 = new array.constructor(indices.length * itemSize);
                        var index = 0,
                            index2 = 0;
                        for (var i = 0, l = indices.length; i < l; i++) {
                            index = indices[i] * itemSize;
                            for (var j = 0; j < itemSize; j++) {
                                array2[index2++] = array[index++]
                            }
                        }
                        geometry2.addAttribute(name, new BufferAttribute(array2, itemSize))
                    }
                    var groups = this.groups;
                    for (var i = 0, l = groups.length; i < l; i++) {
                        var group = groups[i];
                        geometry2.addGroup(group.start, group.count, group.materialIndex)
                    }
                    return geometry2
                },
                toJSON: function() {
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    data.uuid = this.uuid;
                    data.type = this.type;
                    if (this.name !== "") data.name = this.name;
                    if (this.parameters !== undefined) {
                        var parameters = this.parameters;
                        for (var key in parameters) {
                            if (parameters[key] !== undefined) data[key] = parameters[key]
                        }
                        return data
                    }
                    data.data = {
                        attributes: {}
                    };
                    var index = this.index;
                    if (index !== null) {
                        var array = Array.prototype.slice.call(index.array);
                        data.data.index = {
                            type: index.array.constructor.name,
                            array: array
                        }
                    }
                    var attributes = this.attributes;
                    for (var key in attributes) {
                        var attribute = attributes[key];
                        var array = Array.prototype.slice.call(attribute.array);
                        data.data.attributes[key] = {
                            itemSize: attribute.itemSize,
                            type: attribute.array.constructor.name,
                            array: array,
                            normalized: attribute.normalized
                        }
                    }
                    var groups = this.groups;
                    if (groups.length > 0) {
                        data.data.groups = JSON.parse(JSON.stringify(groups))
                    }
                    var boundingSphere = this.boundingSphere;
                    if (boundingSphere !== null) {
                        data.data.boundingSphere = {
                            center: boundingSphere.center.toArray(),
                            radius: boundingSphere.radius
                        }
                    }
                    return data
                },
                clone: function() {
                    return (new BufferGeometry).copy(this)
                },
                copy: function(source) {
                    var name, i, l;
                    this.index = null;
                    this.attributes = {};
                    this.morphAttributes = {};
                    this.groups = [];
                    this.boundingBox = null;
                    this.boundingSphere = null;
                    this.name = source.name;
                    var index = source.index;
                    if (index !== null) {
                        this.setIndex(index.clone())
                    }
                    var attributes = source.attributes;
                    for (name in attributes) {
                        var attribute = attributes[name];
                        this.addAttribute(name, attribute.clone())
                    }
                    var morphAttributes = source.morphAttributes;
                    for (name in morphAttributes) {
                        var array = [];
                        var morphAttribute = morphAttributes[name];
                        for (i = 0, l = morphAttribute.length; i < l; i++) {
                            array.push(morphAttribute[i].clone())
                        }
                        this.morphAttributes[name] = array
                    }
                    var groups = source.groups;
                    for (i = 0, l = groups.length; i < l; i++) {
                        var group = groups[i];
                        this.addGroup(group.start, group.count, group.materialIndex)
                    }
                    var boundingBox = source.boundingBox;
                    if (boundingBox !== null) {
                        this.boundingBox = boundingBox.clone()
                    }
                    var boundingSphere = source.boundingSphere;
                    if (boundingSphere !== null) {
                        this.boundingSphere = boundingSphere.clone()
                    }
                    this.drawRange.start = source.drawRange.start;
                    this.drawRange.count = source.drawRange.count;
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });

            function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
                Geometry.call(this);
                this.type = "BoxGeometry";
                this.parameters = {
                    width: width,
                    height: height,
                    depth: depth,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments,
                    depthSegments: depthSegments
                };
                this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
                this.mergeVertices()
            }
            BoxGeometry.prototype = Object.create(Geometry.prototype);
            BoxGeometry.prototype.constructor = BoxGeometry;

            function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
                BufferGeometry.call(this);
                this.type = "BoxBufferGeometry";
                this.parameters = {
                    width: width,
                    height: height,
                    depth: depth,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments,
                    depthSegments: depthSegments
                };
                var scope = this;
                width = width || 1;
                height = height || 1;
                depth = depth || 1;
                widthSegments = Math.floor(widthSegments) || 1;
                heightSegments = Math.floor(heightSegments) || 1;
                depthSegments = Math.floor(depthSegments) || 1;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var numberOfVertices = 0;
                var groupStart = 0;
                buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
                buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
                buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
                buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
                buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
                buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));

                function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                    var segmentWidth = width / gridX;
                    var segmentHeight = height / gridY;
                    var widthHalf = width / 2;
                    var heightHalf = height / 2;
                    var depthHalf = depth / 2;
                    var gridX1 = gridX + 1;
                    var gridY1 = gridY + 1;
                    var vertexCounter = 0;
                    var groupCount = 0;
                    var ix, iy;
                    var vector = new Vector3;
                    for (iy = 0; iy < gridY1; iy++) {
                        var y = iy * segmentHeight - heightHalf;
                        for (ix = 0; ix < gridX1; ix++) {
                            var x = ix * segmentWidth - widthHalf;
                            vector[u] = x * udir;
                            vector[v] = y * vdir;
                            vector[w] = depthHalf;
                            vertices.push(vector.x, vector.y, vector.z);
                            vector[u] = 0;
                            vector[v] = 0;
                            vector[w] = depth > 0 ? 1 : -1;
                            normals.push(vector.x, vector.y, vector.z);
                            uvs.push(ix / gridX);
                            uvs.push(1 - iy / gridY);
                            vertexCounter += 1
                        }
                    }
                    for (iy = 0; iy < gridY; iy++) {
                        for (ix = 0; ix < gridX; ix++) {
                            var a = numberOfVertices + ix + gridX1 * iy;
                            var b = numberOfVertices + ix + gridX1 * (iy + 1);
                            var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                            var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                            indices.push(a, b, d);
                            indices.push(b, c, d);
                            groupCount += 6
                        }
                    }
                    scope.addGroup(groupStart, groupCount, materialIndex);
                    groupStart += groupCount;
                    numberOfVertices += vertexCounter
                }
            }
            BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

            function PlaneGeometry(width, height, widthSegments, heightSegments) {
                Geometry.call(this);
                this.type = "PlaneGeometry";
                this.parameters = {
                    width: width,
                    height: height,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments
                };
                this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
                this.mergeVertices()
            }
            PlaneGeometry.prototype = Object.create(Geometry.prototype);
            PlaneGeometry.prototype.constructor = PlaneGeometry;

            function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
                BufferGeometry.call(this);
                this.type = "PlaneBufferGeometry";
                this.parameters = {
                    width: width,
                    height: height,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments
                };
                width = width || 1;
                height = height || 1;
                var width_half = width / 2;
                var height_half = height / 2;
                var gridX = Math.floor(widthSegments) || 1;
                var gridY = Math.floor(heightSegments) || 1;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var segment_width = width / gridX;
                var segment_height = height / gridY;
                var ix, iy;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                for (iy = 0; iy < gridY1; iy++) {
                    var y = iy * segment_height - height_half;
                    for (ix = 0; ix < gridX1; ix++) {
                        var x = ix * segment_width - width_half;
                        vertices.push(x, -y, 0);
                        normals.push(0, 0, 1);
                        uvs.push(ix / gridX);
                        uvs.push(1 - iy / gridY)
                    }
                }
                for (iy = 0; iy < gridY; iy++) {
                    for (ix = 0; ix < gridX; ix++) {
                        var a = ix + gridX1 * iy;
                        var b = ix + gridX1 * (iy + 1);
                        var c = ix + 1 + gridX1 * (iy + 1);
                        var d = ix + 1 + gridX1 * iy;
                        indices.push(a, b, d);
                        indices.push(b, c, d)
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2))
            }
            PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
            var materialId = 0;

            function Material() {
                Object.defineProperty(this, "id", {
                    value: materialId++
                });
                this.uuid = _Math.generateUUID();
                this.name = "";
                this.type = "Material";
                this.fog = true;
                this.lights = true;
                this.blending = NormalBlending;
                this.side = FrontSide;
                this.flatShading = false;
                this.vertexColors = NoColors;
                this.opacity = 1;
                this.transparent = false;
                this.blendSrc = SrcAlphaFactor;
                this.blendDst = OneMinusSrcAlphaFactor;
                this.blendEquation = AddEquation;
                this.blendSrcAlpha = null;
                this.blendDstAlpha = null;
                this.blendEquationAlpha = null;
                this.depthFunc = LessEqualDepth;
                this.depthTest = true;
                this.depthWrite = true;
                this.clippingPlanes = null;
                this.clipIntersection = false;
                this.clipShadows = false;
                this.shadowSide = null;
                this.colorWrite = true;
                this.precision = null;
                this.polygonOffset = false;
                this.polygonOffsetFactor = 0;
                this.polygonOffsetUnits = 0;
                this.dithering = false;
                this.alphaTest = 0;
                this.premultipliedAlpha = false;
                this.overdraw = 0;
                this.visible = true;
                this.userData = {};
                this.needsUpdate = true
            }
            Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: Material,
                isMaterial: true,
                onBeforeCompile: function() {},
                setValues: function(values) {
                    if (values === undefined) return;
                    for (var key in values) {
                        var newValue = values[key];
                        if (newValue === undefined) {
                            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                            continue
                        }
                        if (key === "shading") {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
                            this.flatShading = newValue === FlatShading ? true : false;
                            continue
                        }
                        var currentValue = this[key];
                        if (currentValue === undefined) {
                            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                            continue
                        }
                        if (currentValue && currentValue.isColor) {
                            currentValue.set(newValue)
                        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
                            currentValue.copy(newValue)
                        } else if (key === "overdraw") {
                            this[key] = Number(newValue)
                        } else {
                            this[key] = newValue
                        }
                    }
                },
                toJSON: function(meta) {
                    var isRoot = meta === undefined || typeof meta === "string";
                    if (isRoot) {
                        meta = {
                            textures: {},
                            images: {}
                        }
                    }
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    data.uuid = this.uuid;
                    data.type = this.type;
                    if (this.name !== "") data.name = this.name;
                    if (this.color && this.color.isColor) data.color = this.color.getHex();
                    if (this.roughness !== undefined) data.roughness = this.roughness;
                    if (this.metalness !== undefined) data.metalness = this.metalness;
                    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
                    if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
                    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
                    if (this.shininess !== undefined) data.shininess = this.shininess;
                    if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
                    if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;
                    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
                    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
                    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
                    if (this.bumpMap && this.bumpMap.isTexture) {
                        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                        data.bumpScale = this.bumpScale
                    }
                    if (this.normalMap && this.normalMap.isTexture) {
                        data.normalMap = this.normalMap.toJSON(meta).uuid;
                        data.normalScale = this.normalScale.toArray()
                    }
                    if (this.displacementMap && this.displacementMap.isTexture) {
                        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                        data.displacementScale = this.displacementScale;
                        data.displacementBias = this.displacementBias
                    }
                    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
                    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
                    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
                    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
                    if (this.envMap && this.envMap.isTexture) {
                        data.envMap = this.envMap.toJSON(meta).uuid;
                        data.reflectivity = this.reflectivity
                    }
                    if (this.gradientMap && this.gradientMap.isTexture) {
                        data.gradientMap = this.gradientMap.toJSON(meta).uuid
                    }
                    if (this.size !== undefined) data.size = this.size;
                    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
                    if (this.blending !== NormalBlending) data.blending = this.blending;
                    if (this.flatShading === true) data.flatShading = this.flatShading;
                    if (this.side !== FrontSide) data.side = this.side;
                    if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
                    if (this.opacity < 1) data.opacity = this.opacity;
                    if (this.transparent === true) data.transparent = this.transparent;
                    data.depthFunc = this.depthFunc;
                    data.depthTest = this.depthTest;
                    data.depthWrite = this.depthWrite;
                    if (this.rotation !== 0) data.rotation = this.rotation;
                    if (this.linewidth !== 1) data.linewidth = this.linewidth;
                    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
                    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
                    if (this.scale !== undefined) data.scale = this.scale;
                    if (this.dithering === true) data.dithering = true;
                    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
                    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
                    if (this.wireframe === true) data.wireframe = this.wireframe;
                    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
                    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
                    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
                    if (this.morphTargets === true) data.morphTargets = true;
                    if (this.skinning === true) data.skinning = true;
                    if (this.visible === false) data.visible = false;
                    if (JSON.stringify(this.userData) !== "{}") data.userData = this.userData;

                    function extractFromCache(cache) {
                        var values = [];
                        for (var key in cache) {
                            var data = cache[key];
                            delete data.metadata;
                            values.push(data)
                        }
                        return values
                    }
                    if (isRoot) {
                        var textures = extractFromCache(meta.textures);
                        var images = extractFromCache(meta.images);
                        if (textures.length > 0) data.textures = textures;
                        if (images.length > 0) data.images = images
                    }
                    return data
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    this.name = source.name;
                    this.fog = source.fog;
                    this.lights = source.lights;
                    this.blending = source.blending;
                    this.side = source.side;
                    this.flatShading = source.flatShading;
                    this.vertexColors = source.vertexColors;
                    this.opacity = source.opacity;
                    this.transparent = source.transparent;
                    this.blendSrc = source.blendSrc;
                    this.blendDst = source.blendDst;
                    this.blendEquation = source.blendEquation;
                    this.blendSrcAlpha = source.blendSrcAlpha;
                    this.blendDstAlpha = source.blendDstAlpha;
                    this.blendEquationAlpha = source.blendEquationAlpha;
                    this.depthFunc = source.depthFunc;
                    this.depthTest = source.depthTest;
                    this.depthWrite = source.depthWrite;
                    this.colorWrite = source.colorWrite;
                    this.precision = source.precision;
                    this.polygonOffset = source.polygonOffset;
                    this.polygonOffsetFactor = source.polygonOffsetFactor;
                    this.polygonOffsetUnits = source.polygonOffsetUnits;
                    this.dithering = source.dithering;
                    this.alphaTest = source.alphaTest;
                    this.premultipliedAlpha = source.premultipliedAlpha;
                    this.overdraw = source.overdraw;
                    this.visible = source.visible;
                    this.userData = JSON.parse(JSON.stringify(source.userData));
                    this.clipShadows = source.clipShadows;
                    this.clipIntersection = source.clipIntersection;
                    var srcPlanes = source.clippingPlanes,
                        dstPlanes = null;
                    if (srcPlanes !== null) {
                        var n = srcPlanes.length;
                        dstPlanes = new Array(n);
                        for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone()
                    }
                    this.clippingPlanes = dstPlanes;
                    this.shadowSide = source.shadowSide;
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });

            function MeshBasicMaterial(parameters) {
                Material.call(this);
                this.type = "MeshBasicMaterial";
                this.color = new Color(16777215);
                this.map = null;
                this.lightMap = null;
                this.lightMapIntensity = 1;
                this.aoMap = null;
                this.aoMapIntensity = 1;
                this.specularMap = null;
                this.alphaMap = null;
                this.envMap = null;
                this.combine = MultiplyOperation;
                this.reflectivity = 1;
                this.refractionRatio = .98;
                this.wireframe = false;
                this.wireframeLinewidth = 1;
                this.wireframeLinecap = "round";
                this.wireframeLinejoin = "round";
                this.skinning = false;
                this.morphTargets = false;
                this.lights = false;
                this.setValues(parameters)
            }
            MeshBasicMaterial.prototype = Object.create(Material.prototype);
            MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
            MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
            MeshBasicMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.combine = source.combine;
                this.reflectivity = source.reflectivity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                return this
            };

            function ShaderMaterial(parameters) {
                Material.call(this);
                this.type = "ShaderMaterial";
                this.defines = {};
                this.uniforms = {};
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
                this.linewidth = 1;
                this.wireframe = false;
                this.wireframeLinewidth = 1;
                this.fog = false;
                this.lights = false;
                this.clipping = false;
                this.skinning = false;
                this.morphTargets = false;
                this.morphNormals = false;
                this.extensions = {
                    derivatives: false,
                    fragDepth: false,
                    drawBuffers: false,
                    shaderTextureLOD: false
                };
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                };
                this.index0AttributeName = undefined;
                this.uniformsNeedUpdate = false;
                if (parameters !== undefined) {
                    if (parameters.attributes !== undefined) {
                        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.")
                    }
                    this.setValues(parameters)
                }
            }
            ShaderMaterial.prototype = Object.create(Material.prototype);
            ShaderMaterial.prototype.constructor = ShaderMaterial;
            ShaderMaterial.prototype.isShaderMaterial = true;
            ShaderMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.fragmentShader = source.fragmentShader;
                this.vertexShader = source.vertexShader;
                this.uniforms = UniformsUtils.clone(source.uniforms);
                this.defines = source.defines;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.lights = source.lights;
                this.clipping = source.clipping;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                this.extensions = source.extensions;
                return this
            };
            ShaderMaterial.prototype.toJSON = function(meta) {
                var data = Material.prototype.toJSON.call(this, meta);
                data.uniforms = this.uniforms;
                data.vertexShader = this.vertexShader;
                data.fragmentShader = this.fragmentShader;
                return data
            };

            function Ray(origin, direction) {
                this.origin = origin !== undefined ? origin : new Vector3;
                this.direction = direction !== undefined ? direction : new Vector3
            }
            Object.assign(Ray.prototype, {
                set: function(origin, direction) {
                    this.origin.copy(origin);
                    this.direction.copy(direction);
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(ray) {
                    this.origin.copy(ray.origin);
                    this.direction.copy(ray.direction);
                    return this
                },
                at: function(t, target) {
                    if (target === undefined) {
                        console.warn("THREE.Ray: .at() target is now required");
                        target = new Vector3
                    }
                    return target.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(v) {
                    this.direction.copy(v).sub(this.origin).normalize();
                    return this
                },
                recast: function() {
                    var v1 = new Vector3;
                    return function recast(t) {
                        this.origin.copy(this.at(t, v1));
                        return this
                    }
                }(),
                closestPointToPoint: function(point, target) {
                    if (target === undefined) {
                        console.warn("THREE.Ray: .closestPointToPoint() target is now required");
                        target = new Vector3
                    }
                    target.subVectors(point, this.origin);
                    var directionDistance = target.dot(this.direction);
                    if (directionDistance < 0) {
                        return target.copy(this.origin)
                    }
                    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin)
                },
                distanceToPoint: function(point) {
                    return Math.sqrt(this.distanceSqToPoint(point))
                },
                distanceSqToPoint: function() {
                    var v1 = new Vector3;
                    return function distanceSqToPoint(point) {
                        var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                        if (directionDistance < 0) {
                            return this.origin.distanceToSquared(point)
                        }
                        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                        return v1.distanceToSquared(point)
                    }
                }(),
                distanceSqToSegment: function() {
                    var segCenter = new Vector3;
                    var segDir = new Vector3;
                    var diff = new Vector3;
                    return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                        segCenter.copy(v0).add(v1).multiplyScalar(.5);
                        segDir.copy(v1).sub(v0).normalize();
                        diff.copy(this.origin).sub(segCenter);
                        var segExtent = v0.distanceTo(v1) * .5;
                        var a01 = -this.direction.dot(segDir);
                        var b0 = diff.dot(this.direction);
                        var b1 = -diff.dot(segDir);
                        var c = diff.lengthSq();
                        var det = Math.abs(1 - a01 * a01);
                        var s0, s1, sqrDist, extDet;
                        if (det > 0) {
                            s0 = a01 * b1 - b0;
                            s1 = a01 * b0 - b1;
                            extDet = segExtent * det;
                            if (s0 >= 0) {
                                if (s1 >= -extDet) {
                                    if (s1 <= extDet) {
                                        var invDet = 1 / det;
                                        s0 *= invDet;
                                        s1 *= invDet;
                                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c
                                    } else {
                                        s1 = segExtent;
                                        s0 = Math.max(0, -(a01 * s1 + b0));
                                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                    }
                                } else {
                                    s1 = -segExtent;
                                    s0 = Math.max(0, -(a01 * s1 + b0));
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                }
                            } else {
                                if (s1 <= -extDet) {
                                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                } else if (s1 <= extDet) {
                                    s0 = 0;
                                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = s1 * (s1 + 2 * b1) + c
                                } else {
                                    s0 = Math.max(0, -(a01 * segExtent + b0));
                                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                }
                            }
                        } else {
                            s1 = a01 > 0 ? -segExtent : segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                        }
                        if (optionalPointOnRay) {
                            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin)
                        }
                        if (optionalPointOnSegment) {
                            optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter)
                        }
                        return sqrDist
                    }
                }(),
                intersectSphere: function() {
                    var v1 = new Vector3;
                    return function intersectSphere(sphere, target) {
                        v1.subVectors(sphere.center, this.origin);
                        var tca = v1.dot(this.direction);
                        var d2 = v1.dot(v1) - tca * tca;
                        var radius2 = sphere.radius * sphere.radius;
                        if (d2 > radius2) return null;
                        var thc = Math.sqrt(radius2 - d2);
                        var t0 = tca - thc;
                        var t1 = tca + thc;
                        if (t0 < 0 && t1 < 0) return null;
                        if (t0 < 0) return this.at(t1, target);
                        return this.at(t0, target)
                    }
                }(),
                intersectsSphere: function(sphere) {
                    return this.distanceToPoint(sphere.center) <= sphere.radius
                },
                distanceToPlane: function(plane) {
                    var denominator = plane.normal.dot(this.direction);
                    if (denominator === 0) {
                        if (plane.distanceToPoint(this.origin) === 0) {
                            return 0
                        }
                        return null
                    }
                    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
                    return t >= 0 ? t : null
                },
                intersectPlane: function(plane, target) {
                    var t = this.distanceToPlane(plane);
                    if (t === null) {
                        return null
                    }
                    return this.at(t, target)
                },
                intersectsPlane: function(plane) {
                    var distToPoint = plane.distanceToPoint(this.origin);
                    if (distToPoint === 0) {
                        return true
                    }
                    var denominator = plane.normal.dot(this.direction);
                    if (denominator * distToPoint < 0) {
                        return true
                    }
                    return false
                },
                intersectBox: function(box, target) {
                    var tmin, tmax, tymin, tymax, tzmin, tzmax;
                    var invdirx = 1 / this.direction.x,
                        invdiry = 1 / this.direction.y,
                        invdirz = 1 / this.direction.z;
                    var origin = this.origin;
                    if (invdirx >= 0) {
                        tmin = (box.min.x - origin.x) * invdirx;
                        tmax = (box.max.x - origin.x) * invdirx
                    } else {
                        tmin = (box.max.x - origin.x) * invdirx;
                        tmax = (box.min.x - origin.x) * invdirx
                    }
                    if (invdiry >= 0) {
                        tymin = (box.min.y - origin.y) * invdiry;
                        tymax = (box.max.y - origin.y) * invdiry
                    } else {
                        tymin = (box.max.y - origin.y) * invdiry;
                        tymax = (box.min.y - origin.y) * invdiry
                    }
                    if (tmin > tymax || tymin > tmax) return null;
                    if (tymin > tmin || tmin !== tmin) tmin = tymin;
                    if (tymax < tmax || tmax !== tmax) tmax = tymax;
                    if (invdirz >= 0) {
                        tzmin = (box.min.z - origin.z) * invdirz;
                        tzmax = (box.max.z - origin.z) * invdirz
                    } else {
                        tzmin = (box.max.z - origin.z) * invdirz;
                        tzmax = (box.min.z - origin.z) * invdirz
                    }
                    if (tmin > tzmax || tzmin > tmax) return null;
                    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
                    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
                    if (tmax < 0) return null;
                    return this.at(tmin >= 0 ? tmin : tmax, target)
                },
                intersectsBox: function() {
                    var v = new Vector3;
                    return function intersectsBox(box) {
                        return this.intersectBox(box, v) !== null
                    }
                }(),
                intersectTriangle: function() {
                    var diff = new Vector3;
                    var edge1 = new Vector3;
                    var edge2 = new Vector3;
                    var normal = new Vector3;
                    return function intersectTriangle(a, b, c, backfaceCulling, target) {
                        edge1.subVectors(b, a);
                        edge2.subVectors(c, a);
                        normal.crossVectors(edge1, edge2);
                        var DdN = this.direction.dot(normal);
                        var sign;
                        if (DdN > 0) {
                            if (backfaceCulling) return null;
                            sign = 1
                        } else if (DdN < 0) {
                            sign = -1;
                            DdN = -DdN
                        } else {
                            return null
                        }
                        diff.subVectors(this.origin, a);
                        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                        if (DdQxE2 < 0) {
                            return null
                        }
                        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                        if (DdE1xQ < 0) {
                            return null
                        }
                        if (DdQxE2 + DdE1xQ > DdN) {
                            return null
                        }
                        var QdN = -sign * diff.dot(normal);
                        if (QdN < 0) {
                            return null
                        }
                        return this.at(QdN / DdN, target)
                    }
                }(),
                applyMatrix4: function(matrix4) {
                    this.origin.applyMatrix4(matrix4);
                    this.direction.transformDirection(matrix4);
                    return this
                },
                equals: function(ray) {
                    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
                }
            });

            function Line3(start, end) {
                this.start = start !== undefined ? start : new Vector3;
                this.end = end !== undefined ? end : new Vector3
            }
            Object.assign(Line3.prototype, {
                set: function(start, end) {
                    this.start.copy(start);
                    this.end.copy(end);
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(line) {
                    this.start.copy(line.start);
                    this.end.copy(line.end);
                    return this
                },
                getCenter: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Line3: .getCenter() target is now required");
                        target = new Vector3
                    }
                    return target.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Line3: .delta() target is now required");
                        target = new Vector3
                    }
                    return target.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(t, target) {
                    if (target === undefined) {
                        console.warn("THREE.Line3: .at() target is now required");
                        target = new Vector3
                    }
                    return this.delta(target).multiplyScalar(t).add(this.start)
                },
                closestPointToPointParameter: function() {
                    var startP = new Vector3;
                    var startEnd = new Vector3;
                    return function closestPointToPointParameter(point, clampToLine) {
                        startP.subVectors(point, this.start);
                        startEnd.subVectors(this.end, this.start);
                        var startEnd2 = startEnd.dot(startEnd);
                        var startEnd_startP = startEnd.dot(startP);
                        var t = startEnd_startP / startEnd2;
                        if (clampToLine) {
                            t = _Math.clamp(t, 0, 1)
                        }
                        return t
                    }
                }(),
                closestPointToPoint: function(point, clampToLine, target) {
                    var t = this.closestPointToPointParameter(point, clampToLine);
                    if (target === undefined) {
                        console.warn("THREE.Line3: .closestPointToPoint() target is now required");
                        target = new Vector3
                    }
                    return this.delta(target).multiplyScalar(t).add(this.start)
                },
                applyMatrix4: function(matrix) {
                    this.start.applyMatrix4(matrix);
                    this.end.applyMatrix4(matrix);
                    return this
                },
                equals: function(line) {
                    return line.start.equals(this.start) && line.end.equals(this.end)
                }
            });

            function Triangle(a, b, c) {
                this.a = a !== undefined ? a : new Vector3;
                this.b = b !== undefined ? b : new Vector3;
                this.c = c !== undefined ? c : new Vector3
            }
            Object.assign(Triangle, {
                getNormal: function() {
                    var v0 = new Vector3;
                    return function getNormal(a, b, c, target) {
                        if (target === undefined) {
                            console.warn("THREE.Triangle: .getNormal() target is now required");
                            target = new Vector3
                        }
                        target.subVectors(c, b);
                        v0.subVectors(a, b);
                        target.cross(v0);
                        var targetLengthSq = target.lengthSq();
                        if (targetLengthSq > 0) {
                            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq))
                        }
                        return target.set(0, 0, 0)
                    }
                }(),
                getBarycoord: function() {
                    var v0 = new Vector3;
                    var v1 = new Vector3;
                    var v2 = new Vector3;
                    return function getBarycoord(point, a, b, c, target) {
                        v0.subVectors(c, a);
                        v1.subVectors(b, a);
                        v2.subVectors(point, a);
                        var dot00 = v0.dot(v0);
                        var dot01 = v0.dot(v1);
                        var dot02 = v0.dot(v2);
                        var dot11 = v1.dot(v1);
                        var dot12 = v1.dot(v2);
                        var denom = dot00 * dot11 - dot01 * dot01;
                        if (target === undefined) {
                            console.warn("THREE.Triangle: .getBarycoord() target is now required");
                            target = new Vector3
                        }
                        if (denom === 0) {
                            return target.set(-2, -1, -1)
                        }
                        var invDenom = 1 / denom;
                        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                        return target.set(1 - u - v, v, u)
                    }
                }(),
                containsPoint: function() {
                    var v1 = new Vector3;
                    return function containsPoint(point, a, b, c) {
                        Triangle.getBarycoord(point, a, b, c, v1);
                        return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1
                    }
                }()
            });
            Object.assign(Triangle.prototype, {
                set: function(a, b, c) {
                    this.a.copy(a);
                    this.b.copy(b);
                    this.c.copy(c);
                    return this
                },
                setFromPointsAndIndices: function(points, i0, i1, i2) {
                    this.a.copy(points[i0]);
                    this.b.copy(points[i1]);
                    this.c.copy(points[i2]);
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(triangle) {
                    this.a.copy(triangle.a);
                    this.b.copy(triangle.b);
                    this.c.copy(triangle.c);
                    return this
                },
                getArea: function() {
                    var v0 = new Vector3;
                    var v1 = new Vector3;
                    return function getArea() {
                        v0.subVectors(this.c, this.b);
                        v1.subVectors(this.a, this.b);
                        return v0.cross(v1).length() * .5
                    }
                }(),
                getMidpoint: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Triangle: .getMidpoint() target is now required");
                        target = new Vector3
                    }
                    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(target) {
                    return Triangle.getNormal(this.a, this.b, this.c, target)
                },
                getPlane: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Triangle: .getPlane() target is now required");
                        target = new Vector3
                    }
                    return target.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(point, target) {
                    return Triangle.getBarycoord(point, this.a, this.b, this.c, target)
                },
                containsPoint: function(point) {
                    return Triangle.containsPoint(point, this.a, this.b, this.c)
                },
                intersectsBox: function(box) {
                    return box.intersectsTriangle(this)
                },
                closestPointToPoint: function() {
                    var plane = new Plane;
                    var edgeList = [new Line3, new Line3, new Line3];
                    var projectedPoint = new Vector3;
                    var closestPoint = new Vector3;
                    return function closestPointToPoint(point, target) {
                        if (target === undefined) {
                            console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
                            target = new Vector3
                        }
                        var minDistance = Infinity;
                        plane.setFromCoplanarPoints(this.a, this.b, this.c);
                        plane.projectPoint(point, projectedPoint);
                        if (this.containsPoint(projectedPoint) === true) {
                            target.copy(projectedPoint)
                        } else {
                            edgeList[0].set(this.a, this.b);
                            edgeList[1].set(this.b, this.c);
                            edgeList[2].set(this.c, this.a);
                            for (var i = 0; i < edgeList.length; i++) {
                                edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                                var distance = projectedPoint.distanceToSquared(closestPoint);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    target.copy(closestPoint)
                                }
                            }
                        }
                        return target
                    }
                }(),
                equals: function(triangle) {
                    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c)
                }
            });

            function Mesh(geometry, material) {
                Object3D.call(this);
                this.type = "Mesh";
                this.geometry = geometry !== undefined ? geometry : new BufferGeometry;
                this.material = material !== undefined ? material : new MeshBasicMaterial({
                    color: Math.random() * 16777215
                });
                this.drawMode = TrianglesDrawMode;
                this.updateMorphTargets()
            }
            Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Mesh,
                isMesh: true,
                setDrawMode: function(value) {
                    this.drawMode = value
                },
                copy: function(source) {
                    Object3D.prototype.copy.call(this, source);
                    this.drawMode = source.drawMode;
                    if (source.morphTargetInfluences !== undefined) {
                        this.morphTargetInfluences = source.morphTargetInfluences.slice()
                    }
                    if (source.morphTargetDictionary !== undefined) {
                        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)
                    }
                    return this
                },
                updateMorphTargets: function() {
                    var geometry = this.geometry;
                    var m, ml, name;
                    if (geometry.isBufferGeometry) {
                        var morphAttributes = geometry.morphAttributes;
                        var keys = Object.keys(morphAttributes);
                        if (keys.length > 0) {
                            var morphAttribute = morphAttributes[keys[0]];
                            if (morphAttribute !== undefined) {
                                this.morphTargetInfluences = [];
                                this.morphTargetDictionary = {};
                                for (m = 0, ml = morphAttribute.length; m < ml; m++) {
                                    name = morphAttribute[m].name || String(m);
                                    this.morphTargetInfluences.push(0);
                                    this.morphTargetDictionary[name] = m
                                }
                            }
                        }
                    } else {
                        var morphTargets = geometry.morphTargets;
                        if (morphTargets !== undefined && morphTargets.length > 0) {
                            this.morphTargetInfluences = [];
                            this.morphTargetDictionary = {};
                            for (m = 0, ml = morphTargets.length; m < ml; m++) {
                                name = morphTargets[m].name || String(m);
                                this.morphTargetInfluences.push(0);
                                this.morphTargetDictionary[name] = m
                            }
                        }
                    }
                },
                raycast: function() {
                    var inverseMatrix = new Matrix4;
                    var ray = new Ray;
                    var sphere = new Sphere;
                    var vA = new Vector3;
                    var vB = new Vector3;
                    var vC = new Vector3;
                    var tempA = new Vector3;
                    var tempB = new Vector3;
                    var tempC = new Vector3;
                    var uvA = new Vector2;
                    var uvB = new Vector2;
                    var uvC = new Vector2;
                    var barycoord = new Vector3;
                    var intersectionPoint = new Vector3;
                    var intersectionPointWorld = new Vector3;

                    function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                        Triangle.getBarycoord(point, p1, p2, p3, barycoord);
                        uv1.multiplyScalar(barycoord.x);
                        uv2.multiplyScalar(barycoord.y);
                        uv3.multiplyScalar(barycoord.z);
                        uv1.add(uv2).add(uv3);
                        return uv1.clone()
                    }

                    function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
                        var intersect;
                        if (material.side === BackSide) {
                            intersect = ray.intersectTriangle(pC, pB, pA, true, point)
                        } else {
                            intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point)
                        }
                        if (intersect === null) return null;
                        intersectionPointWorld.copy(point);
                        intersectionPointWorld.applyMatrix4(object.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                        if (distance < raycaster.near || distance > raycaster.far) return null;
                        return {
                            distance: distance,
                            point: intersectionPointWorld.clone(),
                            object: object
                        }
                    }

                    function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                        vA.fromBufferAttribute(position, a);
                        vB.fromBufferAttribute(position, b);
                        vC.fromBufferAttribute(position, c);
                        var intersection = checkIntersection(object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint);
                        if (intersection) {
                            if (uv) {
                                uvA.fromBufferAttribute(uv, a);
                                uvB.fromBufferAttribute(uv, b);
                                uvC.fromBufferAttribute(uv, c);
                                intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC)
                            }
                            var face = new Face3(a, b, c);
                            Triangle.getNormal(vA, vB, vC, face.normal);
                            intersection.face = face;
                            intersection.faceIndex = a
                        }
                        return intersection
                    }
                    return function raycast(raycaster, intersects) {
                        var geometry = this.geometry;
                        var material = this.material;
                        var matrixWorld = this.matrixWorld;
                        if (material === undefined) return;
                        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                        sphere.copy(geometry.boundingSphere);
                        sphere.applyMatrix4(matrixWorld);
                        if (raycaster.ray.intersectsSphere(sphere) === false) return;
                        inverseMatrix.getInverse(matrixWorld);
                        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                        if (geometry.boundingBox !== null) {
                            if (ray.intersectsBox(geometry.boundingBox) === false) return
                        }
                        var intersection;
                        if (geometry.isBufferGeometry) {
                            var a, b, c;
                            var index = geometry.index;
                            var position = geometry.attributes.position;
                            var uv = geometry.attributes.uv;
                            var i, l;
                            if (index !== null) {
                                for (i = 0, l = index.count; i < l; i += 3) {
                                    a = index.getX(i);
                                    b = index.getX(i + 1);
                                    c = index.getX(i + 2);
                                    intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                                    if (intersection) {
                                        intersection.faceIndex = Math.floor(i / 3);
                                        intersects.push(intersection)
                                    }
                                }
                            } else if (position !== undefined) {
                                for (i = 0, l = position.count; i < l; i += 3) {
                                    a = i;
                                    b = i + 1;
                                    c = i + 2;
                                    intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                                    if (intersection) {
                                        intersection.index = a;
                                        intersects.push(intersection)
                                    }
                                }
                            }
                        } else if (geometry.isGeometry) {
                            var fvA, fvB, fvC;
                            var isMultiMaterial = Array.isArray(material);
                            var vertices = geometry.vertices;
                            var faces = geometry.faces;
                            var uvs;
                            var faceVertexUvs = geometry.faceVertexUvs[0];
                            if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
                            for (var f = 0, fl = faces.length; f < fl; f++) {
                                var face = faces[f];
                                var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                                if (faceMaterial === undefined) continue;
                                fvA = vertices[face.a];
                                fvB = vertices[face.b];
                                fvC = vertices[face.c];
                                if (faceMaterial.morphTargets === true) {
                                    var morphTargets = geometry.morphTargets;
                                    var morphInfluences = this.morphTargetInfluences;
                                    vA.set(0, 0, 0);
                                    vB.set(0, 0, 0);
                                    vC.set(0, 0, 0);
                                    for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                        var influence = morphInfluences[t];
                                        if (influence === 0) continue;
                                        var targets = morphTargets[t].vertices;
                                        vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                                        vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                                        vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence)
                                    }
                                    vA.add(fvA);
                                    vB.add(fvB);
                                    vC.add(fvC);
                                    fvA = vA;
                                    fvB = vB;
                                    fvC = vC
                                }
                                intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                                if (intersection) {
                                    if (uvs && uvs[f]) {
                                        var uvs_f = uvs[f];
                                        uvA.copy(uvs_f[0]);
                                        uvB.copy(uvs_f[1]);
                                        uvC.copy(uvs_f[2]);
                                        intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC)
                                    }
                                    intersection.face = face;
                                    intersection.faceIndex = f;
                                    intersects.push(intersection)
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });

            function WebGLBackground(renderer, state, geometries, premultipliedAlpha) {
                var clearColor = new Color(0);
                var clearAlpha = 0;
                var planeCamera, planeMesh;
                var boxMesh;

                function render(renderList, scene, camera, forceClear) {
                    var background = scene.background;
                    if (background === null) {
                        setClear(clearColor, clearAlpha)
                    } else if (background && background.isColor) {
                        setClear(background, 1);
                        forceClear = true
                    }
                    if (renderer.autoClear || forceClear) {
                        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil)
                    }
                    if (background && background.isCubeTexture) {
                        if (boxMesh === undefined) {
                            boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                                uniforms: ShaderLib.cube.uniforms,
                                vertexShader: ShaderLib.cube.vertexShader,
                                fragmentShader: ShaderLib.cube.fragmentShader,
                                side: BackSide,
                                depthTest: true,
                                depthWrite: false,
                                fog: false
                            }));
                            boxMesh.geometry.removeAttribute("normal");
                            boxMesh.geometry.removeAttribute("uv");
                            boxMesh.onBeforeRender = function(renderer, scene, camera) {
                                this.matrixWorld.copyPosition(camera.matrixWorld)
                            };
                            geometries.update(boxMesh.geometry)
                        }
                        boxMesh.material.uniforms.tCube.value = background;
                        renderList.push(boxMesh, boxMesh.geometry, boxMesh.material, 0, null)
                    } else if (background && background.isTexture) {
                        if (planeCamera === undefined) {
                            planeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                            planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
                                depthTest: false,
                                depthWrite: false,
                                fog: false
                            }));
                            geometries.update(planeMesh.geometry)
                        }
                        planeMesh.material.map = background;
                        renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null)
                    }
                }

                function setClear(color, alpha) {
                    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha)
                }
                return {
                    getClearColor: function() {
                        return clearColor
                    },
                    setClearColor: function(color, alpha) {
                        clearColor.set(color);
                        clearAlpha = alpha !== undefined ? alpha : 1;
                        setClear(clearColor, clearAlpha)
                    },
                    getClearAlpha: function() {
                        return clearAlpha
                    },
                    setClearAlpha: function(alpha) {
                        clearAlpha = alpha;
                        setClear(clearColor, clearAlpha)
                    },
                    render: render
                }
            }

            function WebGLBufferRenderer(gl, extensions, info) {
                var mode;

                function setMode(value) {
                    mode = value
                }

                function render(start, count) {
                    gl.drawArrays(mode, start, count);
                    info.update(count, mode)
                }

                function renderInstances(geometry, start, count) {
                    var extension = extensions.get("ANGLE_instanced_arrays");
                    if (extension === null) {
                        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        return
                    }
                    var position = geometry.attributes.position;
                    if (position.isInterleavedBufferAttribute) {
                        count = position.data.count;
                        extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount)
                    } else {
                        extension.drawArraysInstancedANGLE(mode, start, count, geometry.maxInstancedCount)
                    }
                    info.update(count, mode, geometry.maxInstancedCount)
                }
                this.setMode = setMode;
                this.render = render;
                this.renderInstances = renderInstances
            }

            function WebGLCapabilities(gl, extensions, parameters) {
                var maxAnisotropy;

                function getMaxAnisotropy() {
                    if (maxAnisotropy !== undefined) return maxAnisotropy;
                    var extension = extensions.get("EXT_texture_filter_anisotropic");
                    if (extension !== null) {
                        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else {
                        maxAnisotropy = 0
                    }
                    return maxAnisotropy
                }

                function getMaxPrecision(precision) {
                    if (precision === "highp") {
                        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                            return "highp"
                        }
                        precision = "mediump"
                    }
                    if (precision === "mediump") {
                        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                            return "mediump"
                        }
                    }
                    return "lowp"
                }
                var precision = parameters.precision !== undefined ? parameters.precision : "highp";
                var maxPrecision = getMaxPrecision(precision);
                if (maxPrecision !== precision) {
                    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
                    precision = maxPrecision
                }
                var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
                var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
                var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                var vertexTextures = maxVertexTextures > 0;
                var floatFragmentTextures = !!extensions.get("OES_texture_float");
                var floatVertexTextures = vertexTextures && floatFragmentTextures;
                return {
                    getMaxAnisotropy: getMaxAnisotropy,
                    getMaxPrecision: getMaxPrecision,
                    precision: precision,
                    logarithmicDepthBuffer: logarithmicDepthBuffer,
                    maxTextures: maxTextures,
                    maxVertexTextures: maxVertexTextures,
                    maxTextureSize: maxTextureSize,
                    maxCubemapSize: maxCubemapSize,
                    maxAttributes: maxAttributes,
                    maxVertexUniforms: maxVertexUniforms,
                    maxVaryings: maxVaryings,
                    maxFragmentUniforms: maxFragmentUniforms,
                    vertexTextures: vertexTextures,
                    floatFragmentTextures: floatFragmentTextures,
                    floatVertexTextures: floatVertexTextures
                }
            }

            function WebGLClipping() {
                var scope = this,
                    globalState = null,
                    numGlobalPlanes = 0,
                    localClippingEnabled = false,
                    renderingShadows = false,
                    plane = new Plane,
                    viewNormalMatrix = new Matrix3,
                    uniform = {
                        value: null,
                        needsUpdate: false
                    };
                this.uniform = uniform;
                this.numPlanes = 0;
                this.numIntersection = 0;
                this.init = function(planes, enableLocalClipping, camera) {
                    var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
                    localClippingEnabled = enableLocalClipping;
                    globalState = projectPlanes(planes, camera, 0);
                    numGlobalPlanes = planes.length;
                    return enabled
                };
                this.beginShadows = function() {
                    renderingShadows = true;
                    projectPlanes(null)
                };
                this.endShadows = function() {
                    renderingShadows = false;
                    resetGlobalState()
                };
                this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
                    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                        if (renderingShadows) {
                            projectPlanes(null)
                        } else {
                            resetGlobalState()
                        }
                    } else {
                        var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                            lGlobal = nGlobal * 4,
                            dstArray = cache.clippingState || null;
                        uniform.value = dstArray;
                        dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                        for (var i = 0; i !== lGlobal; ++i) {
                            dstArray[i] = globalState[i]
                        }
                        cache.clippingState = dstArray;
                        this.numIntersection = clipIntersection ? this.numPlanes : 0;
                        this.numPlanes += nGlobal
                    }
                };

                function resetGlobalState() {
                    if (uniform.value !== globalState) {
                        uniform.value = globalState;
                        uniform.needsUpdate = numGlobalPlanes > 0
                    }
                    scope.numPlanes = numGlobalPlanes;
                    scope.numIntersection = 0
                }

                function projectPlanes(planes, camera, dstOffset, skipTransform) {
                    var nPlanes = planes !== null ? planes.length : 0,
                        dstArray = null;
                    if (nPlanes !== 0) {
                        dstArray = uniform.value;
                        if (skipTransform !== true || dstArray === null) {
                            var flatSize = dstOffset + nPlanes * 4,
                                viewMatrix = camera.matrixWorldInverse;
                            viewNormalMatrix.getNormalMatrix(viewMatrix);
                            if (dstArray === null || dstArray.length < flatSize) {
                                dstArray = new Float32Array(flatSize)
                            }
                            for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                                plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                                plane.normal.toArray(dstArray, i4);
                                dstArray[i4 + 3] = plane.constant
                            }
                        }
                        uniform.value = dstArray;
                        uniform.needsUpdate = true
                    }
                    scope.numPlanes = nPlanes;
                    return dstArray
                }
            }

            function WebGLExtensions(gl) {
                var extensions = {};
                return {
                    get: function(name) {
                        if (extensions[name] !== undefined) {
                            return extensions[name]
                        }
                        var extension;
                        switch (name) {
                            case "WEBGL_depth_texture":
                                extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            case "WEBGL_compressed_texture_etc1":
                                extension = gl.getExtension("WEBGL_compressed_texture_etc1");
                                break;
                            default:
                                extension = gl.getExtension(name)
                        }
                        if (extension === null) {
                            console.warn("THREE.WebGLRenderer: " + name + " extension not supported.")
                        }
                        extensions[name] = extension;
                        return extension
                    }
                }
            }

            function WebGLGeometries(gl, attributes, info) {
                var geometries = {};
                var wireframeAttributes = {};

                function onGeometryDispose(event) {
                    var geometry = event.target;
                    var buffergeometry = geometries[geometry.id];
                    if (buffergeometry.index !== null) {
                        attributes.remove(buffergeometry.index)
                    }
                    for (var name in buffergeometry.attributes) {
                        attributes.remove(buffergeometry.attributes[name])
                    }
                    geometry.removeEventListener("dispose", onGeometryDispose);
                    delete geometries[geometry.id];
                    var attribute = wireframeAttributes[geometry.id];
                    if (attribute) {
                        attributes.remove(attribute);
                        delete wireframeAttributes[geometry.id]
                    }
                    attribute = wireframeAttributes[buffergeometry.id];
                    if (attribute) {
                        attributes.remove(attribute);
                        delete wireframeAttributes[buffergeometry.id]
                    }
                    info.memory.geometries--
                }

                function get(object, geometry) {
                    var buffergeometry = geometries[geometry.id];
                    if (buffergeometry) return buffergeometry;
                    geometry.addEventListener("dispose", onGeometryDispose);
                    if (geometry.isBufferGeometry) {
                        buffergeometry = geometry
                    } else if (geometry.isGeometry) {
                        if (geometry._bufferGeometry === undefined) {
                            geometry._bufferGeometry = (new BufferGeometry).setFromObject(object)
                        }
                        buffergeometry = geometry._bufferGeometry
                    }
                    geometries[geometry.id] = buffergeometry;
                    info.memory.geometries++;
                    return buffergeometry
                }

                function update(geometry) {
                    var index = geometry.index;
                    var geometryAttributes = geometry.attributes;
                    if (index !== null) {
                        attributes.update(index, gl.ELEMENT_ARRAY_BUFFER)
                    }
                    for (var name in geometryAttributes) {
                        attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER)
                    }
                    var morphAttributes = geometry.morphAttributes;
                    for (var name in morphAttributes) {
                        var array = morphAttributes[name];
                        for (var i = 0, l = array.length; i < l; i++) {
                            attributes.update(array[i], gl.ARRAY_BUFFER)
                        }
                    }
                }

                function getWireframeAttribute(geometry) {
                    var attribute = wireframeAttributes[geometry.id];
                    if (attribute) return attribute;
                    var indices = [];
                    var geometryIndex = geometry.index;
                    var geometryAttributes = geometry.attributes;
                    if (geometryIndex !== null) {
                        var array = geometryIndex.array;
                        for (var i = 0, l = array.length; i < l; i += 3) {
                            var a = array[i + 0];
                            var b = array[i + 1];
                            var c = array[i + 2];
                            indices.push(a, b, b, c, c, a)
                        }
                    } else {
                        var array = geometryAttributes.position.array;
                        for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                            var a = i + 0;
                            var b = i + 1;
                            var c = i + 2;
                            indices.push(a, b, b, c, c, a)
                        }
                    }
                    attribute = new(arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
                    attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);
                    wireframeAttributes[geometry.id] = attribute;
                    return attribute
                }
                return {
                    get: get,
                    update: update,
                    getWireframeAttribute: getWireframeAttribute
                }
            }

            function WebGLIndexedBufferRenderer(gl, extensions, info) {
                var mode;

                function setMode(value) {
                    mode = value
                }
                var type, bytesPerElement;

                function setIndex(value) {
                    type = value.type;
                    bytesPerElement = value.bytesPerElement
                }

                function render(start, count) {
                    gl.drawElements(mode, count, type, start * bytesPerElement);
                    info.update(count, mode)
                }

                function renderInstances(geometry, start, count) {
                    var extension = extensions.get("ANGLE_instanced_arrays");
                    if (extension === null) {
                        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        return
                    }
                    extension.drawElementsInstancedANGLE(mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);
                    info.update(count, mode, geometry.maxInstancedCount)
                }
                this.setMode = setMode;
                this.setIndex = setIndex;
                this.render = render;
                this.renderInstances = renderInstances
            }

            function WebGLInfo(gl) {
                var memory = {
                    geometries: 0,
                    textures: 0
                };
                var render = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };

                function update(count, mode, instanceCount) {
                    instanceCount = instanceCount || 1;
                    render.calls++;
                    switch (mode) {
                        case gl.TRIANGLES:
                            render.triangles += instanceCount * (count / 3);
                            break;
                        case gl.TRIANGLE_STRIP:
                        case gl.TRIANGLE_FAN:
                            render.triangles += instanceCount * (count - 2);
                            break;
                        case gl.LINES:
                            render.lines += instanceCount * (count / 2);
                            break;
                        case gl.LINE_STRIP:
                            render.lines += instanceCount * (count - 1);
                            break;
                        case gl.LINE_LOOP:
                            render.lines += instanceCount * count;
                            break;
                        case gl.POINTS:
                            render.points += instanceCount * count;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
                            break
                    }
                }

                function reset() {
                    render.frame++;
                    render.calls = 0;
                    render.triangles = 0;
                    render.points = 0;
                    render.lines = 0
                }
                return {
                    memory: memory,
                    render: render,
                    programs: null,
                    autoReset: true,
                    reset: reset,
                    update: update
                }
            }

            function absNumericalSort(a, b) {
                return Math.abs(b[1]) - Math.abs(a[1])
            }

            function WebGLMorphtargets(gl) {
                var influencesList = {};
                var morphInfluences = new Float32Array(8);

                function update(object, geometry, material, program) {
                    var objectInfluences = object.morphTargetInfluences;
                    var length = objectInfluences.length;
                    var influences = influencesList[geometry.id];
                    if (influences === undefined) {
                        influences = [];
                        for (var i = 0; i < length; i++) {
                            influences[i] = [i, 0]
                        }
                        influencesList[geometry.id] = influences
                    }
                    var morphTargets = material.morphTargets && geometry.morphAttributes.position;
                    var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
                    for (var i = 0; i < length; i++) {
                        var influence = influences[i];
                        if (influence[1] !== 0) {
                            if (morphTargets) geometry.removeAttribute("morphTarget" + i);
                            if (morphNormals) geometry.removeAttribute("morphNormal" + i)
                        }
                    }
                    for (var i = 0; i < length; i++) {
                        var influence = influences[i];
                        influence[0] = i;
                        influence[1] = objectInfluences[i]
                    }
                    influences.sort(absNumericalSort);
                    for (var i = 0; i < 8; i++) {
                        var influence = influences[i];
                        if (influence) {
                            var index = influence[0];
                            var value = influence[1];
                            if (value) {
                                if (morphTargets) geometry.addAttribute("morphTarget" + i, morphTargets[index]);
                                if (morphNormals) geometry.addAttribute("morphNormal" + i, morphNormals[index]);
                                morphInfluences[i] = value;
                                continue
                            }
                        }
                        morphInfluences[i] = 0
                    }
                    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences)
                }
                return {
                    update: update
                }
            }

            function WebGLObjects(geometries, info) {
                var updateList = {};

                function update(object) {
                    var frame = info.render.frame;
                    var geometry = object.geometry;
                    var buffergeometry = geometries.get(object, geometry);
                    if (updateList[buffergeometry.id] !== frame) {
                        if (geometry.isGeometry) {
                            buffergeometry.updateFromObject(object)
                        }
                        geometries.update(buffergeometry);
                        updateList[buffergeometry.id] = frame
                    }
                    return buffergeometry
                }

                function dispose() {
                    updateList = {}
                }
                return {
                    update: update,
                    dispose: dispose
                }
            }

            function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
                images = images !== undefined ? images : [];
                mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
                Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
                this.flipY = false
            }
            CubeTexture.prototype = Object.create(Texture.prototype);
            CubeTexture.prototype.constructor = CubeTexture;
            CubeTexture.prototype.isCubeTexture = true;
            Object.defineProperty(CubeTexture.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(value) {
                    this.image = value
                }
            });
            var emptyTexture = new Texture;
            var emptyCubeTexture = new CubeTexture;

            function UniformContainer() {
                this.seq = [];
                this.map = {}
            }
            var arrayCacheF32 = [];
            var arrayCacheI32 = [];
            var mat4array = new Float32Array(16);
            var mat3array = new Float32Array(9);

            function flatten(array, nBlocks, blockSize) {
                var firstElem = array[0];
                if (firstElem <= 0 || firstElem > 0) return array;
                var n = nBlocks * blockSize,
                    r = arrayCacheF32[n];
                if (r === undefined) {
                    r = new Float32Array(n);
                    arrayCacheF32[n] = r
                }
                if (nBlocks !== 0) {
                    firstElem.toArray(r, 0);
                    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                        offset += blockSize;
                        array[i].toArray(r, offset)
                    }
                }
                return r
            }

            function allocTexUnits(renderer, n) {
                var r = arrayCacheI32[n];
                if (r === undefined) {
                    r = new Int32Array(n);
                    arrayCacheI32[n] = r
                }
                for (var i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();
                return r
            }

            function setValue1f(gl, v) {
                gl.uniform1f(this.addr, v)
            }

            function setValue1i(gl, v) {
                gl.uniform1i(this.addr, v)
            }

            function setValue2fv(gl, v) {
                if (v.x === undefined) {
                    gl.uniform2fv(this.addr, v)
                } else {
                    gl.uniform2f(this.addr, v.x, v.y)
                }
            }

            function setValue3fv(gl, v) {
                if (v.x !== undefined) {
                    gl.uniform3f(this.addr, v.x, v.y, v.z)
                } else if (v.r !== undefined) {
                    gl.uniform3f(this.addr, v.r, v.g, v.b)
                } else {
                    gl.uniform3fv(this.addr, v)
                }
            }

            function setValue4fv(gl, v) {
                if (v.x === undefined) {
                    gl.uniform4fv(this.addr, v)
                } else {
                    gl.uniform4f(this.addr, v.x, v.y, v.z, v.w)
                }
            }

            function setValue2fm(gl, v) {
                gl.uniformMatrix2fv(this.addr, false, v.elements || v)
            }

            function setValue3fm(gl, v) {
                if (v.elements === undefined) {
                    gl.uniformMatrix3fv(this.addr, false, v)
                } else {
                    mat3array.set(v.elements);
                    gl.uniformMatrix3fv(this.addr, false, mat3array)
                }
            }

            function setValue4fm(gl, v) {
                if (v.elements === undefined) {
                    gl.uniformMatrix4fv(this.addr, false, v)
                } else {
                    mat4array.set(v.elements);
                    gl.uniformMatrix4fv(this.addr, false, mat4array)
                }
            }

            function setValueT1(gl, v, renderer) {
                var unit = renderer.allocTextureUnit();
                gl.uniform1i(this.addr, unit);
                renderer.setTexture2D(v || emptyTexture, unit)
            }

            function setValueT6(gl, v, renderer) {
                var unit = renderer.allocTextureUnit();
                gl.uniform1i(this.addr, unit);
                renderer.setTextureCube(v || emptyCubeTexture, unit)
            }

            function setValue2iv(gl, v) {
                gl.uniform2iv(this.addr, v)
            }

            function setValue3iv(gl, v) {
                gl.uniform3iv(this.addr, v)
            }

            function setValue4iv(gl, v) {
                gl.uniform4iv(this.addr, v)
            }

            function getSingularSetter(type) {
                switch (type) {
                    case 5126:
                        return setValue1f;
                    case 35664:
                        return setValue2fv;
                    case 35665:
                        return setValue3fv;
                    case 35666:
                        return setValue4fv;
                    case 35674:
                        return setValue2fm;
                    case 35675:
                        return setValue3fm;
                    case 35676:
                        return setValue4fm;
                    case 35678:
                    case 36198:
                        return setValueT1;
                    case 35680:
                        return setValueT6;
                    case 5124:
                    case 35670:
                        return setValue1i;
                    case 35667:
                    case 35671:
                        return setValue2iv;
                    case 35668:
                    case 35672:
                        return setValue3iv;
                    case 35669:
                    case 35673:
                        return setValue4iv
                }
            }

            function setValue1fv(gl, v) {
                gl.uniform1fv(this.addr, v)
            }

            function setValue1iv(gl, v) {
                gl.uniform1iv(this.addr, v)
            }

            function setValueV2a(gl, v) {
                gl.uniform2fv(this.addr, flatten(v, this.size, 2))
            }

            function setValueV3a(gl, v) {
                gl.uniform3fv(this.addr, flatten(v, this.size, 3))
            }

            function setValueV4a(gl, v) {
                gl.uniform4fv(this.addr, flatten(v, this.size, 4))
            }

            function setValueM2a(gl, v) {
                gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4))
            }

            function setValueM3a(gl, v) {
                gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9))
            }

            function setValueM4a(gl, v) {
                gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16))
            }

            function setValueT1a(gl, v, renderer) {
                var n = v.length,
                    units = allocTexUnits(renderer, n);
                gl.uniform1iv(this.addr, units);
                for (var i = 0; i !== n; ++i) {
                    renderer.setTexture2D(v[i] || emptyTexture, units[i])
                }
            }

            function setValueT6a(gl, v, renderer) {
                var n = v.length,
                    units = allocTexUnits(renderer, n);
                gl.uniform1iv(this.addr, units);
                for (var i = 0; i !== n; ++i) {
                    renderer.setTextureCube(v[i] || emptyCubeTexture, units[i])
                }
            }

            function getPureArraySetter(type) {
                switch (type) {
                    case 5126:
                        return setValue1fv;
                    case 35664:
                        return setValueV2a;
                    case 35665:
                        return setValueV3a;
                    case 35666:
                        return setValueV4a;
                    case 35674:
                        return setValueM2a;
                    case 35675:
                        return setValueM3a;
                    case 35676:
                        return setValueM4a;
                    case 35678:
                        return setValueT1a;
                    case 35680:
                        return setValueT6a;
                    case 5124:
                    case 35670:
                        return setValue1iv;
                    case 35667:
                    case 35671:
                        return setValue2iv;
                    case 35668:
                    case 35672:
                        return setValue3iv;
                    case 35669:
                    case 35673:
                        return setValue4iv
                }
            }

            function SingleUniform(id, activeInfo, addr) {
                this.id = id;
                this.addr = addr;
                this.setValue = getSingularSetter(activeInfo.type)
            }

            function PureArrayUniform(id, activeInfo, addr) {
                this.id = id;
                this.addr = addr;
                this.size = activeInfo.size;
                this.setValue = getPureArraySetter(activeInfo.type)
            }

            function StructuredUniform(id) {
                this.id = id;
                UniformContainer.call(this)
            }
            StructuredUniform.prototype.setValue = function(gl, value) {
                var seq = this.seq;
                for (var i = 0, n = seq.length; i !== n; ++i) {
                    var u = seq[i];
                    u.setValue(gl, value[u.id])
                }
            };
            var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

            function addUniform(container, uniformObject) {
                container.seq.push(uniformObject);
                container.map[uniformObject.id] = uniformObject
            }

            function parseUniform(activeInfo, addr, container) {
                var path = activeInfo.name,
                    pathLength = path.length;
                RePathPart.lastIndex = 0;
                for (;;) {
                    var match = RePathPart.exec(path),
                        matchEnd = RePathPart.lastIndex,
                        id = match[1],
                        idIsIndex = match[2] === "]",
                        subscript = match[3];
                    if (idIsIndex) id = id | 0;
                    if (subscript === undefined || subscript === "[" && matchEnd + 2 === pathLength) {
                        addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                        break
                    } else {
                        var map = container.map,
                            next = map[id];
                        if (next === undefined) {
                            next = new StructuredUniform(id);
                            addUniform(container, next)
                        }
                        container = next
                    }
                }
            }

            function WebGLUniforms(gl, program, renderer) {
                UniformContainer.call(this);
                this.renderer = renderer;
                var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (var i = 0; i < n; ++i) {
                    var info = gl.getActiveUniform(program, i),
                        path = info.name,
                        addr = gl.getUniformLocation(program, path);
                    parseUniform(info, addr, this)
                }
            }
            WebGLUniforms.prototype.setValue = function(gl, name, value) {
                var u = this.map[name];
                if (u !== undefined) u.setValue(gl, value, this.renderer)
            };
            WebGLUniforms.prototype.setOptional = function(gl, object, name) {
                var v = object[name];
                if (v !== undefined) this.setValue(gl, name, v)
            };
            WebGLUniforms.upload = function(gl, seq, values, renderer) {
                for (var i = 0, n = seq.length; i !== n; ++i) {
                    var u = seq[i],
                        v = values[u.id];
                    if (v.needsUpdate !== false) {
                        u.setValue(gl, v.value, renderer)
                    }
                }
            };
            WebGLUniforms.seqWithValue = function(seq, values) {
                var r = [];
                for (var i = 0, n = seq.length; i !== n; ++i) {
                    var u = seq[i];
                    if (u.id in values) r.push(u)
                }
                return r
            };

            function addLineNumbers(string) {
                var lines = string.split("\n");
                for (var i = 0; i < lines.length; i++) {
                    lines[i] = i + 1 + ": " + lines[i]
                }
                return lines.join("\n")
            }

            function WebGLShader(gl, type, string) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, string);
                gl.compileShader(shader);
                if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
                    console.error("THREE.WebGLShader: Shader couldn't compile.")
                }
                if (gl.getShaderInfoLog(shader) !== "") {
                    console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string))
                }
                return shader
            }
            var programIdCount = 0;

            function getEncodingComponents(encoding) {
                switch (encoding) {
                    case LinearEncoding:
                        return ["Linear", "( value )"];
                    case sRGBEncoding:
                        return ["sRGB", "( value )"];
                    case RGBEEncoding:
                        return ["RGBE", "( value )"];
                    case RGBM7Encoding:
                        return ["RGBM", "( value, 7.0 )"];
                    case RGBM16Encoding:
                        return ["RGBM", "( value, 16.0 )"];
                    case RGBDEncoding:
                        return ["RGBD", "( value, 256.0 )"];
                    case GammaEncoding:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + encoding)
                }
            }

            function getTexelDecodingFunction(functionName, encoding) {
                var components = getEncodingComponents(encoding);
                return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }"
            }

            function getTexelEncodingFunction(functionName, encoding) {
                var components = getEncodingComponents(encoding);
                return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }"
            }

            function getToneMappingFunction(functionName, toneMapping) {
                var toneMappingName;
                switch (toneMapping) {
                    case LinearToneMapping:
                        toneMappingName = "Linear";
                        break;
                    case ReinhardToneMapping:
                        toneMappingName = "Reinhard";
                        break;
                    case Uncharted2ToneMapping:
                        toneMappingName = "Uncharted2";
                        break;
                    case CineonToneMapping:
                        toneMappingName = "OptimizedCineon";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + toneMapping)
                }
                return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }"
            }

            function generateExtensions(extensions, parameters, rendererExtensions) {
                extensions = extensions || {};
                var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                return chunks.filter(filterEmptyLine).join("\n")
            }

            function generateDefines(defines) {
                var chunks = [];
                for (var name in defines) {
                    var value = defines[name];
                    if (value === false) continue;
                    chunks.push("#define " + name + " " + value)
                }
                return chunks.join("\n")
            }

            function fetchAttributeLocations(gl, program) {
                var attributes = {};
                var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
                for (var i = 0; i < n; i++) {
                    var info = gl.getActiveAttrib(program, i);
                    var name = info.name;
                    attributes[name] = gl.getAttribLocation(program, name)
                }
                return attributes
            }

            function filterEmptyLine(string) {
                return string !== ""
            }

            function replaceLightNums(string, parameters) {
                return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
            }

            function replaceClippingPlaneNums(string, parameters) {
                return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection)
            }

            function parseIncludes(string) {
                var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

                function replace(match, include) {
                    var replace = ShaderChunk[include];
                    if (replace === undefined) {
                        throw new Error("Can not resolve #include <" + include + ">")
                    }
                    return parseIncludes(replace)
                }
                return string.replace(pattern, replace)
            }

            function unrollLoops(string) {
                var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

                function replace(match, start, end, snippet) {
                    var unroll = "";
                    for (var i = parseInt(start); i < parseInt(end); i++) {
                        unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]")
                    }
                    return unroll
                }
                return string.replace(pattern, replace)
            }

            function WebGLProgram(renderer, extensions, code, material, shader, parameters) {
                var gl = renderer.context;
                var defines = material.defines;
                var vertexShader = shader.vertexShader;
                var fragmentShader = shader.fragmentShader;
                var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
                if (parameters.shadowMapType === PCFShadowMap) {
                    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF"
                } else if (parameters.shadowMapType === PCFSoftShadowMap) {
                    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT"
                }
                var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
                var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                if (parameters.envMap) {
                    switch (material.envMap.mapping) {
                        case CubeReflectionMapping:
                        case CubeRefractionMapping:
                            envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                            break;
                        case CubeUVReflectionMapping:
                        case CubeUVRefractionMapping:
                            envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case EquirectangularReflectionMapping:
                        case EquirectangularRefractionMapping:
                            envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case SphericalReflectionMapping:
                            envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
                            break
                    }
                    switch (material.envMap.mapping) {
                        case CubeRefractionMapping:
                        case EquirectangularRefractionMapping:
                            envMapModeDefine = "ENVMAP_MODE_REFRACTION";
                            break
                    }
                    switch (material.combine) {
                        case MultiplyOperation:
                            envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case MixOperation:
                            envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                            break;
                        case AddOperation:
                            envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
                            break
                    }
                }
                var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
                var customExtensions = generateExtensions(material.extensions, parameters, extensions);
                var customDefines = generateDefines(defines);
                var program = gl.createProgram();
                var prefixVertex, prefixFragment;
                if (material.isRawShaderMaterial) {
                    prefixVertex = [customDefines].filter(filterEmptyLine).join("\n");
                    if (prefixVertex.length > 0) {
                        prefixVertex += "\n"
                    }
                    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join("\n");
                    if (prefixFragment.length > 0) {
                        prefixFragment += "\n"
                    }
                } else {
                    prefixVertex = ["precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + shader.name, customDefines, parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n");
                    prefixFragment = [customExtensions, "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + shader.name, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.gradientMap ? "#define USE_GRADIENTMAP" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", parameters.envMap && extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "", parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.dithering ? "#define DITHERING" : "", parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n")
                }
                vertexShader = parseIncludes(vertexShader);
                vertexShader = replaceLightNums(vertexShader, parameters);
                vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
                fragmentShader = parseIncludes(fragmentShader);
                fragmentShader = replaceLightNums(fragmentShader, parameters);
                fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
                vertexShader = unrollLoops(vertexShader);
                fragmentShader = unrollLoops(fragmentShader);
                var vertexGlsl = prefixVertex + vertexShader;
                var fragmentGlsl = prefixFragment + fragmentShader;
                var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
                var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
                gl.attachShader(program, glVertexShader);
                gl.attachShader(program, glFragmentShader);
                if (material.index0AttributeName !== undefined) {
                    gl.bindAttribLocation(program, 0, material.index0AttributeName)
                } else if (parameters.morphTargets === true) {
                    gl.bindAttribLocation(program, 0, "position")
                }
                gl.linkProgram(program);
                var programLog = gl.getProgramInfoLog(program).trim();
                var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
                var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
                var runnable = true;
                var haveDiagnostics = true;
                if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
                    runnable = false;
                    console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog)
                } else if (programLog !== "") {
                    console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog)
                } else if (vertexLog === "" || fragmentLog === "") {
                    haveDiagnostics = false
                }
                if (haveDiagnostics) {
                    this.diagnostics = {
                        runnable: runnable,
                        material: material,
                        programLog: programLog,
                        vertexShader: {
                            log: vertexLog,
                            prefix: prefixVertex
                        },
                        fragmentShader: {
                            log: fragmentLog,
                            prefix: prefixFragment
                        }
                    }
                }
                gl.deleteShader(glVertexShader);
                gl.deleteShader(glFragmentShader);
                var cachedUniforms;
                this.getUniforms = function() {
                    if (cachedUniforms === undefined) {
                        cachedUniforms = new WebGLUniforms(gl, program, renderer)
                    }
                    return cachedUniforms
                };
                var cachedAttributes;
                this.getAttributes = function() {
                    if (cachedAttributes === undefined) {
                        cachedAttributes = fetchAttributeLocations(gl, program)
                    }
                    return cachedAttributes
                };
                this.destroy = function() {
                    gl.deleteProgram(program);
                    this.program = undefined
                };
                Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
                            return this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
                            return this.getAttributes()
                        }
                    }
                });
                this.id = programIdCount++;
                this.code = code;
                this.usedTimes = 1;
                this.program = program;
                this.vertexShader = glVertexShader;
                this.fragmentShader = glFragmentShader;
                return this
            }

            function WebGLPrograms(renderer, extensions, capabilities) {
                var programs = [];
                var shaderIDs = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow"
                };
                var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function allocateBones(object) {
                    var skeleton = object.skeleton;
                    var bones = skeleton.bones;
                    if (capabilities.floatVertexTextures) {
                        return 1024
                    } else {
                        var nVertexUniforms = capabilities.maxVertexUniforms;
                        var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                        var maxBones = Math.min(nVertexMatrices, bones.length);
                        if (maxBones < bones.length) {
                            console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
                            return 0
                        }
                        return maxBones
                    }
                }

                function getTextureEncodingFromMap(map, gammaOverrideLinear) {
                    var encoding;
                    if (!map) {
                        encoding = LinearEncoding
                    } else if (map.isTexture) {
                        encoding = map.encoding
                    } else if (map.isWebGLRenderTarget) {
                        console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                        encoding = map.texture.encoding
                    }
                    if (encoding === LinearEncoding && gammaOverrideLinear) {
                        encoding = GammaEncoding
                    }
                    return encoding
                }
                this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
                    var shaderID = shaderIDs[material.type];
                    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
                    var precision = capabilities.precision;
                    if (material.precision !== null) {
                        precision = capabilities.getMaxPrecision(material.precision);
                        if (precision !== material.precision) {
                            console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.")
                        }
                    }
                    var currentRenderTarget = renderer.getRenderTarget();
                    var parameters = {
                        shaderID: shaderID,
                        precision: precision,
                        supportsVertexTextures: capabilities.vertexTextures,
                        outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
                        map: !!material.map,
                        mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                        envMap: !!material.envMap,
                        envMapMode: material.envMap && material.envMap.mapping,
                        envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                        envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
                        lightMap: !!material.lightMap,
                        aoMap: !!material.aoMap,
                        emissiveMap: !!material.emissiveMap,
                        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                        bumpMap: !!material.bumpMap,
                        normalMap: !!material.normalMap,
                        displacementMap: !!material.displacementMap,
                        roughnessMap: !!material.roughnessMap,
                        metalnessMap: !!material.metalnessMap,
                        specularMap: !!material.specularMap,
                        alphaMap: !!material.alphaMap,
                        gradientMap: !!material.gradientMap,
                        combine: material.combine,
                        vertexColors: material.vertexColors,
                        fog: !!fog,
                        useFog: material.fog,
                        fogExp: fog && fog.isFogExp2,
                        flatShading: material.flatShading,
                        sizeAttenuation: material.sizeAttenuation,
                        logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                        skinning: material.skinning && maxBones > 0,
                        maxBones: maxBones,
                        useVertexTexture: capabilities.floatVertexTextures,
                        morphTargets: material.morphTargets,
                        morphNormals: material.morphNormals,
                        maxMorphTargets: renderer.maxMorphTargets,
                        maxMorphNormals: renderer.maxMorphNormals,
                        numDirLights: lights.directional.length,
                        numPointLights: lights.point.length,
                        numSpotLights: lights.spot.length,
                        numRectAreaLights: lights.rectArea.length,
                        numHemiLights: lights.hemi.length,
                        numClippingPlanes: nClipPlanes,
                        numClipIntersection: nClipIntersection,
                        dithering: material.dithering,
                        shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
                        shadowMapType: renderer.shadowMap.type,
                        toneMapping: renderer.toneMapping,
                        physicallyCorrectLights: renderer.physicallyCorrectLights,
                        premultipliedAlpha: material.premultipliedAlpha,
                        alphaTest: material.alphaTest,
                        doubleSided: material.side === DoubleSide,
                        flipSided: material.side === BackSide,
                        depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
                    };
                    return parameters
                };
                this.getProgramCode = function(material, parameters) {
                    var array = [];
                    if (parameters.shaderID) {
                        array.push(parameters.shaderID)
                    } else {
                        array.push(material.fragmentShader);
                        array.push(material.vertexShader)
                    }
                    if (material.defines !== undefined) {
                        for (var name in material.defines) {
                            array.push(name);
                            array.push(material.defines[name])
                        }
                    }
                    for (var i = 0; i < parameterNames.length; i++) {
                        array.push(parameters[parameterNames[i]])
                    }
                    array.push(material.onBeforeCompile.toString());
                    array.push(renderer.gammaOutput);
                    return array.join()
                };
                this.acquireProgram = function(material, shader, parameters, code) {
                    var program;
                    for (var p = 0, pl = programs.length; p < pl; p++) {
                        var programInfo = programs[p];
                        if (programInfo.code === code) {
                            program = programInfo;
                            ++program.usedTimes;
                            break
                        }
                    }
                    if (program === undefined) {
                        program = new WebGLProgram(renderer, extensions, code, material, shader, parameters);
                        programs.push(program)
                    }
                    return program
                };
                this.releaseProgram = function(program) {
                    if (--program.usedTimes === 0) {
                        var i = programs.indexOf(program);
                        programs[i] = programs[programs.length - 1];
                        programs.pop();
                        program.destroy()
                    }
                };
                this.programs = programs
            }

            function WebGLProperties() {
                var properties = new WeakMap;

                function get(object) {
                    var map = properties.get(object);
                    if (map === undefined) {
                        map = {};
                        properties.set(object, map)
                    }
                    return map
                }

                function remove(object) {
                    properties.delete(object)
                }

                function update(object, key, value) {
                    properties.get(object)[key] = value
                }

                function dispose() {
                    properties = new WeakMap
                }
                return {
                    get: get,
                    remove: remove,
                    update: update,
                    dispose: dispose
                }
            }

            function painterSortStable(a, b) {
                if (a.renderOrder !== b.renderOrder) {
                    return a.renderOrder - b.renderOrder
                } else if (a.program && b.program && a.program !== b.program) {
                    return a.program.id - b.program.id
                } else if (a.material.id !== b.material.id) {
                    return a.material.id - b.material.id
                } else if (a.z !== b.z) {
                    return a.z - b.z
                } else {
                    return a.id - b.id
                }
            }

            function reversePainterSortStable(a, b) {
                if (a.renderOrder !== b.renderOrder) {
                    return a.renderOrder - b.renderOrder
                }
                if (a.z !== b.z) {
                    return b.z - a.z
                } else {
                    return a.id - b.id
                }
            }

            function WebGLRenderList() {
                var renderItems = [];
                var renderItemsIndex = 0;
                var opaque = [];
                var transparent = [];

                function init() {
                    renderItemsIndex = 0;
                    opaque.length = 0;
                    transparent.length = 0
                }

                function push(object, geometry, material, z, group) {
                    var renderItem = renderItems[renderItemsIndex];
                    if (renderItem === undefined) {
                        renderItem = {
                            id: object.id,
                            object: object,
                            geometry: geometry,
                            material: material,
                            program: material.program,
                            renderOrder: object.renderOrder,
                            z: z,
                            group: group
                        };
                        renderItems[renderItemsIndex] = renderItem
                    } else {
                        renderItem.id = object.id;
                        renderItem.object = object;
                        renderItem.geometry = geometry;
                        renderItem.material = material;
                        renderItem.program = material.program;
                        renderItem.renderOrder = object.renderOrder;
                        renderItem.z = z;
                        renderItem.group = group
                    }(material.transparent === true ? transparent : opaque).push(renderItem);
                    renderItemsIndex++
                }

                function sort() {
                    if (opaque.length > 1) opaque.sort(painterSortStable);
                    if (transparent.length > 1) transparent.sort(reversePainterSortStable)
                }
                return {
                    opaque: opaque,
                    transparent: transparent,
                    init: init,
                    push: push,
                    sort: sort
                }
            }

            function WebGLRenderLists() {
                var lists = {};

                function get(scene, camera) {
                    var hash = scene.id + "," + camera.id;
                    var list = lists[hash];
                    if (list === undefined) {
                        list = new WebGLRenderList;
                        lists[hash] = list
                    }
                    return list
                }

                function dispose() {
                    lists = {}
                }
                return {
                    get: get,
                    dispose: dispose
                }
            }

            function UniformsCache() {
                var lights = {};
                return {
                    get: function(light) {
                        if (lights[light.id] !== undefined) {
                            return lights[light.id]
                        }
                        var uniforms;
                        switch (light.type) {
                            case "DirectionalLight":
                                uniforms = {
                                    direction: new Vector3,
                                    color: new Color,
                                    shadow: false,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Vector2
                                };
                                break;
                            case "SpotLight":
                                uniforms = {
                                    position: new Vector3,
                                    direction: new Vector3,
                                    color: new Color,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: false,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Vector2
                                };
                                break;
                            case "PointLight":
                                uniforms = {
                                    position: new Vector3,
                                    color: new Color,
                                    distance: 0,
                                    decay: 0,
                                    shadow: false,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Vector2,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                uniforms = {
                                    direction: new Vector3,
                                    skyColor: new Color,
                                    groundColor: new Color
                                };
                                break;
                            case "RectAreaLight":
                                uniforms = {
                                    color: new Color,
                                    position: new Vector3,
                                    halfWidth: new Vector3,
                                    halfHeight: new Vector3
                                };
                                break
                        }
                        lights[light.id] = uniforms;
                        return uniforms
                    }
                }
            }
            var count = 0;

            function WebGLLights() {
                var cache = new UniformsCache;
                var state = {
                    id: count++,
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                };
                var vector3 = new Vector3;
                var matrix4 = new Matrix4;
                var matrix42 = new Matrix4;

                function setup(lights, shadows, camera) {
                    var r = 0,
                        g = 0,
                        b = 0;
                    var directionalLength = 0;
                    var pointLength = 0;
                    var spotLength = 0;
                    var rectAreaLength = 0;
                    var hemiLength = 0;
                    var viewMatrix = camera.matrixWorldInverse;
                    for (var i = 0, l = lights.length; i < l; i++) {
                        var light = lights[i];
                        var color = light.color;
                        var intensity = light.intensity;
                        var distance = light.distance;
                        var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                        if (light.isAmbientLight) {
                            r += color.r * intensity;
                            g += color.g * intensity;
                            b += color.b * intensity
                        } else if (light.isDirectionalLight) {
                            var uniforms = cache.get(light);
                            uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                            vector3.setFromMatrixPosition(light.target.matrixWorld);
                            uniforms.direction.sub(vector3);
                            uniforms.direction.transformDirection(viewMatrix);
                            uniforms.shadow = light.castShadow;
                            if (light.castShadow) {
                                var shadow = light.shadow;
                                uniforms.shadowBias = shadow.bias;
                                uniforms.shadowRadius = shadow.radius;
                                uniforms.shadowMapSize = shadow.mapSize
                            }
                            state.directionalShadowMap[directionalLength] = shadowMap;
                            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                            state.directional[directionalLength] = uniforms;
                            directionalLength++
                        } else if (light.isSpotLight) {
                            var uniforms = cache.get(light);
                            uniforms.position.setFromMatrixPosition(light.matrixWorld);
                            uniforms.position.applyMatrix4(viewMatrix);
                            uniforms.color.copy(color).multiplyScalar(intensity);
                            uniforms.distance = distance;
                            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                            vector3.setFromMatrixPosition(light.target.matrixWorld);
                            uniforms.direction.sub(vector3);
                            uniforms.direction.transformDirection(viewMatrix);
                            uniforms.coneCos = Math.cos(light.angle);
                            uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                            uniforms.decay = light.distance === 0 ? 0 : light.decay;
                            uniforms.shadow = light.castShadow;
                            if (light.castShadow) {
                                var shadow = light.shadow;
                                uniforms.shadowBias = shadow.bias;
                                uniforms.shadowRadius = shadow.radius;
                                uniforms.shadowMapSize = shadow.mapSize
                            }
                            state.spotShadowMap[spotLength] = shadowMap;
                            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                            state.spot[spotLength] = uniforms;
                            spotLength++
                        } else if (light.isRectAreaLight) {
                            var uniforms = cache.get(light);
                            uniforms.color.copy(color).multiplyScalar(intensity);
                            uniforms.position.setFromMatrixPosition(light.matrixWorld);
                            uniforms.position.applyMatrix4(viewMatrix);
                            matrix42.identity();
                            matrix4.copy(light.matrixWorld);
                            matrix4.premultiply(viewMatrix);
                            matrix42.extractRotation(matrix4);
                            uniforms.halfWidth.set(light.width * .5, 0, 0);
                            uniforms.halfHeight.set(0, light.height * .5, 0);
                            uniforms.halfWidth.applyMatrix4(matrix42);
                            uniforms.halfHeight.applyMatrix4(matrix42);
                            state.rectArea[rectAreaLength] = uniforms;
                            rectAreaLength++
                        } else if (light.isPointLight) {
                            var uniforms = cache.get(light);
                            uniforms.position.setFromMatrixPosition(light.matrixWorld);
                            uniforms.position.applyMatrix4(viewMatrix);
                            uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                            uniforms.distance = light.distance;
                            uniforms.decay = light.distance === 0 ? 0 : light.decay;
                            uniforms.shadow = light.castShadow;
                            if (light.castShadow) {
                                var shadow = light.shadow;
                                uniforms.shadowBias = shadow.bias;
                                uniforms.shadowRadius = shadow.radius;
                                uniforms.shadowMapSize = shadow.mapSize;
                                uniforms.shadowCameraNear = shadow.camera.near;
                                uniforms.shadowCameraFar = shadow.camera.far
                            }
                            state.pointShadowMap[pointLength] = shadowMap;
                            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                            state.point[pointLength] = uniforms;
                            pointLength++
                        } else if (light.isHemisphereLight) {
                            var uniforms = cache.get(light);
                            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                            uniforms.direction.transformDirection(viewMatrix);
                            uniforms.direction.normalize();
                            uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                            uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                            state.hemi[hemiLength] = uniforms;
                            hemiLength++
                        }
                    }
                    state.ambient[0] = r;
                    state.ambient[1] = g;
                    state.ambient[2] = b;
                    state.directional.length = directionalLength;
                    state.spot.length = spotLength;
                    state.rectArea.length = rectAreaLength;
                    state.point.length = pointLength;
                    state.hemi.length = hemiLength;
                    state.hash = state.id + "," + directionalLength + "," + pointLength + "," + spotLength + "," + rectAreaLength + "," + hemiLength + "," + shadows.length
                }
                return {
                    setup: setup,
                    state: state
                }
            }

            function WebGLRenderState() {
                var lights = new WebGLLights;
                var lightsArray = [];
                var shadowsArray = [];
                var spritesArray = [];

                function init() {
                    lightsArray.length = 0;
                    shadowsArray.length = 0;
                    spritesArray.length = 0
                }

                function pushLight(light) {
                    lightsArray.push(light)
                }

                function pushShadow(shadowLight) {
                    shadowsArray.push(shadowLight)
                }

                function pushSprite(shadowLight) {
                    spritesArray.push(shadowLight)
                }

                function setupLights(camera) {
                    lights.setup(lightsArray, shadowsArray, camera)
                }
                var state = {
                    lightsArray: lightsArray,
                    shadowsArray: shadowsArray,
                    spritesArray: spritesArray,
                    lights: lights
                };
                return {
                    init: init,
                    state: state,
                    setupLights: setupLights,
                    pushLight: pushLight,
                    pushShadow: pushShadow,
                    pushSprite: pushSprite
                }
            }

            function WebGLRenderStates() {
                var renderStates = {};

                function get(scene, camera) {
                    var hash = scene.id + "," + camera.id;
                    var renderState = renderStates[hash];
                    if (renderState === undefined) {
                        renderState = new WebGLRenderState;
                        renderStates[hash] = renderState
                    }
                    return renderState
                }

                function dispose() {
                    renderStates = {}
                }
                return {
                    get: get,
                    dispose: dispose
                }
            }

            function MeshDepthMaterial(parameters) {
                Material.call(this);
                this.type = "MeshDepthMaterial";
                this.depthPacking = BasicDepthPacking;
                this.skinning = false;
                this.morphTargets = false;
                this.map = null;
                this.alphaMap = null;
                this.displacementMap = null;
                this.displacementScale = 1;
                this.displacementBias = 0;
                this.wireframe = false;
                this.wireframeLinewidth = 1;
                this.fog = false;
                this.lights = false;
                this.setValues(parameters)
            }
            MeshDepthMaterial.prototype = Object.create(Material.prototype);
            MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
            MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
            MeshDepthMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.depthPacking = source.depthPacking;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                return this
            };

            function MeshDistanceMaterial(parameters) {
                Material.call(this);
                this.type = "MeshDistanceMaterial";
                this.referencePosition = new Vector3;
                this.nearDistance = 1;
                this.farDistance = 1e3;
                this.skinning = false;
                this.morphTargets = false;
                this.map = null;
                this.alphaMap = null;
                this.displacementMap = null;
                this.displacementScale = 1;
                this.displacementBias = 0;
                this.fog = false;
                this.lights = false;
                this.setValues(parameters)
            }
            MeshDistanceMaterial.prototype = Object.create(Material.prototype);
            MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
            MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
            MeshDistanceMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.referencePosition.copy(source.referencePosition);
                this.nearDistance = source.nearDistance;
                this.farDistance = source.farDistance;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.map = source.map;
                this.alphaMap = source.alphaMap;
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                return this
            };

            function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
                var _frustum = new Frustum,
                    _projScreenMatrix = new Matrix4,
                    _shadowMapSize = new Vector2,
                    _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize),
                    _lookTarget = new Vector3,
                    _lightPositionWorld = new Vector3,
                    _MorphingFlag = 1,
                    _SkinningFlag = 2,
                    _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
                    _depthMaterials = new Array(_NumberOfMaterialVariants),
                    _distanceMaterials = new Array(_NumberOfMaterialVariants),
                    _materialCache = {};
                var shadowSide = {
                    0: BackSide,
                    1: FrontSide,
                    2: DoubleSide
                };
                var cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
                var cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
                var cube2DViewPorts = [new Vector4, new Vector4, new Vector4, new Vector4, new Vector4, new Vector4];
                for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
                    var useMorphing = (i & _MorphingFlag) !== 0;
                    var useSkinning = (i & _SkinningFlag) !== 0;
                    var depthMaterial = new MeshDepthMaterial({
                        depthPacking: RGBADepthPacking,
                        morphTargets: useMorphing,
                        skinning: useSkinning
                    });
                    _depthMaterials[i] = depthMaterial;
                    var distanceMaterial = new MeshDistanceMaterial({
                        morphTargets: useMorphing,
                        skinning: useSkinning
                    });
                    _distanceMaterials[i] = distanceMaterial
                }
                var scope = this;
                this.enabled = false;
                this.autoUpdate = true;
                this.needsUpdate = false;
                this.type = PCFShadowMap;
                this.render = function(lights, scene, camera) {
                    if (scope.enabled === false) return;
                    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
                    if (lights.length === 0) return;
                    var _gl = _renderer.context;
                    var _state = _renderer.state;
                    _state.disable(_gl.BLEND);
                    _state.buffers.color.setClear(1, 1, 1, 1);
                    _state.buffers.depth.setTest(true);
                    _state.setScissorTest(false);
                    var faceCount;
                    for (var i = 0, il = lights.length; i < il; i++) {
                        var light = lights[i];
                        var shadow = light.shadow;
                        var isPointLight = light && light.isPointLight;
                        if (shadow === undefined) {
                            console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                            continue
                        }
                        var shadowCamera = shadow.camera;
                        _shadowMapSize.copy(shadow.mapSize);
                        _shadowMapSize.min(_maxShadowMapSize);
                        if (isPointLight) {
                            var vpWidth = _shadowMapSize.x;
                            var vpHeight = _shadowMapSize.y;
                            cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                            cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                            cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                            cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                            cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                            cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                            _shadowMapSize.x *= 4;
                            _shadowMapSize.y *= 2
                        }
                        if (shadow.map === null) {
                            var pars = {
                                minFilter: NearestFilter,
                                magFilter: NearestFilter,
                                format: RGBAFormat
                            };
                            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                            shadow.map.texture.name = light.name + ".shadowMap";
                            shadowCamera.updateProjectionMatrix()
                        }
                        if (shadow.isSpotLightShadow) {
                            shadow.update(light)
                        }
                        var shadowMap = shadow.map;
                        var shadowMatrix = shadow.matrix;
                        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                        shadowCamera.position.copy(_lightPositionWorld);
                        if (isPointLight) {
                            faceCount = 6;
                            shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z)
                        } else {
                            faceCount = 1;
                            _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                            shadowCamera.lookAt(_lookTarget);
                            shadowCamera.updateMatrixWorld();
                            shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
                            shadowMatrix.multiply(shadowCamera.projectionMatrix);
                            shadowMatrix.multiply(shadowCamera.matrixWorldInverse)
                        }
                        _renderer.setRenderTarget(shadowMap);
                        _renderer.clear();
                        for (var face = 0; face < faceCount; face++) {
                            if (isPointLight) {
                                _lookTarget.copy(shadowCamera.position);
                                _lookTarget.add(cubeDirections[face]);
                                shadowCamera.up.copy(cubeUps[face]);
                                shadowCamera.lookAt(_lookTarget);
                                shadowCamera.updateMatrixWorld();
                                var vpDimensions = cube2DViewPorts[face];
                                _state.viewport(vpDimensions)
                            }
                            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                            _frustum.setFromMatrix(_projScreenMatrix);
                            renderObject(scene, camera, shadowCamera, isPointLight)
                        }
                    }
                    scope.needsUpdate = false
                };

                function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
                    var geometry = object.geometry;
                    var result = null;
                    var materialVariants = _depthMaterials;
                    var customMaterial = object.customDepthMaterial;
                    if (isPointLight) {
                        materialVariants = _distanceMaterials;
                        customMaterial = object.customDistanceMaterial
                    }
                    if (!customMaterial) {
                        var useMorphing = false;
                        if (material.morphTargets) {
                            if (geometry && geometry.isBufferGeometry) {
                                useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0
                            } else if (geometry && geometry.isGeometry) {
                                useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0
                            }
                        }
                        if (object.isSkinnedMesh && material.skinning === false) {
                            console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object)
                        }
                        var useSkinning = object.isSkinnedMesh && material.skinning;
                        var variantIndex = 0;
                        if (useMorphing) variantIndex |= _MorphingFlag;
                        if (useSkinning) variantIndex |= _SkinningFlag;
                        result = materialVariants[variantIndex]
                    } else {
                        result = customMaterial
                    }
                    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
                        var keyA = result.uuid,
                            keyB = material.uuid;
                        var materialsForVariant = _materialCache[keyA];
                        if (materialsForVariant === undefined) {
                            materialsForVariant = {};
                            _materialCache[keyA] = materialsForVariant
                        }
                        var cachedMaterial = materialsForVariant[keyB];
                        if (cachedMaterial === undefined) {
                            cachedMaterial = result.clone();
                            materialsForVariant[keyB] = cachedMaterial
                        }
                        result = cachedMaterial
                    }
                    result.visible = material.visible;
                    result.wireframe = material.wireframe;
                    result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
                    result.clipShadows = material.clipShadows;
                    result.clippingPlanes = material.clippingPlanes;
                    result.clipIntersection = material.clipIntersection;
                    result.wireframeLinewidth = material.wireframeLinewidth;
                    result.linewidth = material.linewidth;
                    if (isPointLight && result.isMeshDistanceMaterial) {
                        result.referencePosition.copy(lightPositionWorld);
                        result.nearDistance = shadowCameraNear;
                        result.farDistance = shadowCameraFar
                    }
                    return result
                }

                function renderObject(object, camera, shadowCamera, isPointLight) {
                    if (object.visible === false) return;
                    var visible = object.layers.test(camera.layers);
                    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                        if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                            object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                            var geometry = _objects.update(object);
                            var material = object.material;
                            if (Array.isArray(material)) {
                                var groups = geometry.groups;
                                for (var k = 0, kl = groups.length; k < kl; k++) {
                                    var group = groups[k];
                                    var groupMaterial = material[group.materialIndex];
                                    if (groupMaterial && groupMaterial.visible) {
                                        var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group)
                                    }
                                }
                            } else if (material.visible) {
                                var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null)
                            }
                        }
                    }
                    var children = object.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        renderObject(children[i], camera, shadowCamera, isPointLight)
                    }
                }
            }

            function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
                Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
                this.needsUpdate = true
            }
            CanvasTexture.prototype = Object.create(Texture.prototype);
            CanvasTexture.prototype.constructor = CanvasTexture;

            function WebGLSpriteRenderer(renderer, gl, state, textures, capabilities) {
                var vertexBuffer, elementBuffer;
                var program, attributes, uniforms;
                var texture;
                var spritePosition = new Vector3;
                var spriteRotation = new Quaternion;
                var spriteScale = new Vector3;

                function init() {
                    var vertices = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]);
                    var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    vertexBuffer = gl.createBuffer();
                    elementBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
                    program = createProgram();
                    attributes = {
                        position: gl.getAttribLocation(program, "position"),
                        uv: gl.getAttribLocation(program, "uv")
                    };
                    uniforms = {
                        uvOffset: gl.getUniformLocation(program, "uvOffset"),
                        uvScale: gl.getUniformLocation(program, "uvScale"),
                        rotation: gl.getUniformLocation(program, "rotation"),
                        center: gl.getUniformLocation(program, "center"),
                        scale: gl.getUniformLocation(program, "scale"),
                        color: gl.getUniformLocation(program, "color"),
                        map: gl.getUniformLocation(program, "map"),
                        opacity: gl.getUniformLocation(program, "opacity"),
                        modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
                        projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
                        fogType: gl.getUniformLocation(program, "fogType"),
                        fogDensity: gl.getUniformLocation(program, "fogDensity"),
                        fogNear: gl.getUniformLocation(program, "fogNear"),
                        fogFar: gl.getUniformLocation(program, "fogFar"),
                        fogColor: gl.getUniformLocation(program, "fogColor"),
                        fogDepth: gl.getUniformLocation(program, "fogDepth"),
                        alphaTest: gl.getUniformLocation(program, "alphaTest")
                    };
                    var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    canvas.width = 8;
                    canvas.height = 8;
                    var context = canvas.getContext("2d");
                    context.fillStyle = "white";
                    context.fillRect(0, 0, 8, 8);
                    texture = new CanvasTexture(canvas)
                }
                this.render = function(sprites, scene, camera) {
                    if (sprites.length === 0) return;
                    if (program === undefined) {
                        init()
                    }
                    state.useProgram(program);
                    state.initAttributes();
                    state.enableAttribute(attributes.position);
                    state.enableAttribute(attributes.uv);
                    state.disableUnusedAttributes();
                    state.disable(gl.CULL_FACE);
                    state.enable(gl.BLEND);
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                    gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
                    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
                    gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
                    state.activeTexture(gl.TEXTURE0);
                    gl.uniform1i(uniforms.map, 0);
                    var oldFogType = 0;
                    var sceneFogType = 0;
                    var fog = scene.fog;
                    if (fog) {
                        gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                        if (fog.isFog) {
                            gl.uniform1f(uniforms.fogNear, fog.near);
                            gl.uniform1f(uniforms.fogFar, fog.far);
                            gl.uniform1i(uniforms.fogType, 1);
                            oldFogType = 1;
                            sceneFogType = 1
                        } else if (fog.isFogExp2) {
                            gl.uniform1f(uniforms.fogDensity, fog.density);
                            gl.uniform1i(uniforms.fogType, 2);
                            oldFogType = 2;
                            sceneFogType = 2
                        }
                    } else {
                        gl.uniform1i(uniforms.fogType, 0);
                        oldFogType = 0;
                        sceneFogType = 0
                    }
                    for (var i = 0, l = sprites.length; i < l; i++) {
                        var sprite = sprites[i];
                        sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                        sprite.z = -sprite.modelViewMatrix.elements[14]
                    }
                    sprites.sort(painterSortStable);
                    var scale = [];
                    var center = [];
                    for (var i = 0, l = sprites.length; i < l; i++) {
                        var sprite = sprites[i];
                        var material = sprite.material;
                        if (material.visible === false) continue;
                        sprite.onBeforeRender(renderer, scene, camera, undefined, material, undefined);
                        gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                        gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
                        sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
                        scale[0] = spriteScale.x;
                        scale[1] = spriteScale.y;
                        center[0] = sprite.center.x - .5;
                        center[1] = sprite.center.y - .5;
                        var fogType = 0;
                        if (scene.fog && material.fog) {
                            fogType = sceneFogType
                        }
                        if (oldFogType !== fogType) {
                            gl.uniform1i(uniforms.fogType, fogType);
                            oldFogType = fogType
                        }
                        if (material.map !== null) {
                            gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                            gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y)
                        } else {
                            gl.uniform2f(uniforms.uvOffset, 0, 0);
                            gl.uniform2f(uniforms.uvScale, 1, 1)
                        }
                        gl.uniform1f(uniforms.opacity, material.opacity);
                        gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
                        gl.uniform1f(uniforms.rotation, material.rotation);
                        gl.uniform2fv(uniforms.center, center);
                        gl.uniform2fv(uniforms.scale, scale);
                        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
                        state.buffers.depth.setTest(material.depthTest);
                        state.buffers.depth.setMask(material.depthWrite);
                        state.buffers.color.setMask(material.colorWrite);
                        textures.setTexture2D(material.map || texture, 0);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                        sprite.onAfterRender(renderer, scene, camera, undefined, material, undefined)
                    }
                    state.enable(gl.CULL_FACE);
                    state.reset()
                };

                function createProgram() {
                    var program = gl.createProgram();
                    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
                    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(vertexShader, ["precision " + capabilities.precision + " float;", "#define SHADER_NAME " + "SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 center;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = ( position - center ) * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n"));
                    gl.shaderSource(fragmentShader, ["precision " + capabilities.precision + " float;", "#define SHADER_NAME " + "SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n"));
                    gl.compileShader(vertexShader);
                    gl.compileShader(fragmentShader);
                    gl.attachShader(program, vertexShader);
                    gl.attachShader(program, fragmentShader);
                    gl.linkProgram(program);
                    return program
                }

                function painterSortStable(a, b) {
                    if (a.renderOrder !== b.renderOrder) {
                        return a.renderOrder - b.renderOrder
                    } else if (a.z !== b.z) {
                        return b.z - a.z
                    } else {
                        return b.id - a.id
                    }
                }
            }

            function WebGLState(gl, extensions, utils) {
                function ColorBuffer() {
                    var locked = false;
                    var color = new Vector4;
                    var currentColorMask = null;
                    var currentColorClear = new Vector4(0, 0, 0, 0);
                    return {
                        setMask: function(colorMask) {
                            if (currentColorMask !== colorMask && !locked) {
                                gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                                currentColorMask = colorMask
                            }
                        },
                        setLocked: function(lock) {
                            locked = lock
                        },
                        setClear: function(r, g, b, a, premultipliedAlpha) {
                            if (premultipliedAlpha === true) {
                                r *= a;
                                g *= a;
                                b *= a
                            }
                            color.set(r, g, b, a);
                            if (currentColorClear.equals(color) === false) {
                                gl.clearColor(r, g, b, a);
                                currentColorClear.copy(color)
                            }
                        },
                        reset: function() {
                            locked = false;
                            currentColorMask = null;
                            currentColorClear.set(-1, 0, 0, 0)
                        }
                    }
                }

                function DepthBuffer() {
                    var locked = false;
                    var currentDepthMask = null;
                    var currentDepthFunc = null;
                    var currentDepthClear = null;
                    return {
                        setTest: function(depthTest) {
                            if (depthTest) {
                                enable(gl.DEPTH_TEST)
                            } else {
                                disable(gl.DEPTH_TEST)
                            }
                        },
                        setMask: function(depthMask) {
                            if (currentDepthMask !== depthMask && !locked) {
                                gl.depthMask(depthMask);
                                currentDepthMask = depthMask
                            }
                        },
                        setFunc: function(depthFunc) {
                            if (currentDepthFunc !== depthFunc) {
                                if (depthFunc) {
                                    switch (depthFunc) {
                                        case NeverDepth:
                                            gl.depthFunc(gl.NEVER);
                                            break;
                                        case AlwaysDepth:
                                            gl.depthFunc(gl.ALWAYS);
                                            break;
                                        case LessDepth:
                                            gl.depthFunc(gl.LESS);
                                            break;
                                        case LessEqualDepth:
                                            gl.depthFunc(gl.LEQUAL);
                                            break;
                                        case EqualDepth:
                                            gl.depthFunc(gl.EQUAL);
                                            break;
                                        case GreaterEqualDepth:
                                            gl.depthFunc(gl.GEQUAL);
                                            break;
                                        case GreaterDepth:
                                            gl.depthFunc(gl.GREATER);
                                            break;
                                        case NotEqualDepth:
                                            gl.depthFunc(gl.NOTEQUAL);
                                            break;
                                        default:
                                            gl.depthFunc(gl.LEQUAL)
                                    }
                                } else {
                                    gl.depthFunc(gl.LEQUAL)
                                }
                                currentDepthFunc = depthFunc
                            }
                        },
                        setLocked: function(lock) {
                            locked = lock
                        },
                        setClear: function(depth) {
                            if (currentDepthClear !== depth) {
                                gl.clearDepth(depth);
                                currentDepthClear = depth
                            }
                        },
                        reset: function() {
                            locked = false;
                            currentDepthMask = null;
                            currentDepthFunc = null;
                            currentDepthClear = null
                        }
                    }
                }

                function StencilBuffer() {
                    var locked = false;
                    var currentStencilMask = null;
                    var currentStencilFunc = null;
                    var currentStencilRef = null;
                    var currentStencilFuncMask = null;
                    var currentStencilFail = null;
                    var currentStencilZFail = null;
                    var currentStencilZPass = null;
                    var currentStencilClear = null;
                    return {
                        setTest: function(stencilTest) {
                            if (stencilTest) {
                                enable(gl.STENCIL_TEST)
                            } else {
                                disable(gl.STENCIL_TEST)
                            }
                        },
                        setMask: function(stencilMask) {
                            if (currentStencilMask !== stencilMask && !locked) {
                                gl.stencilMask(stencilMask);
                                currentStencilMask = stencilMask
                            }
                        },
                        setFunc: function(stencilFunc, stencilRef, stencilMask) {
                            if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                                gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                                currentStencilFunc = stencilFunc;
                                currentStencilRef = stencilRef;
                                currentStencilFuncMask = stencilMask
                            }
                        },
                        setOp: function(stencilFail, stencilZFail, stencilZPass) {
                            if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                                gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                                currentStencilFail = stencilFail;
                                currentStencilZFail = stencilZFail;
                                currentStencilZPass = stencilZPass
                            }
                        },
                        setLocked: function(lock) {
                            locked = lock
                        },
                        setClear: function(stencil) {
                            if (currentStencilClear !== stencil) {
                                gl.clearStencil(stencil);
                                currentStencilClear = stencil
                            }
                        },
                        reset: function() {
                            locked = false;
                            currentStencilMask = null;
                            currentStencilFunc = null;
                            currentStencilRef = null;
                            currentStencilFuncMask = null;
                            currentStencilFail = null;
                            currentStencilZFail = null;
                            currentStencilZPass = null;
                            currentStencilClear = null
                        }
                    }
                }
                var colorBuffer = new ColorBuffer;
                var depthBuffer = new DepthBuffer;
                var stencilBuffer = new StencilBuffer;
                var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                var newAttributes = new Uint8Array(maxVertexAttributes);
                var enabledAttributes = new Uint8Array(maxVertexAttributes);
                var attributeDivisors = new Uint8Array(maxVertexAttributes);
                var capabilities = {};
                var compressedTextureFormats = null;
                var currentProgram = null;
                var currentBlending = null;
                var currentBlendEquation = null;
                var currentBlendSrc = null;
                var currentBlendDst = null;
                var currentBlendEquationAlpha = null;
                var currentBlendSrcAlpha = null;
                var currentBlendDstAlpha = null;
                var currentPremultipledAlpha = false;
                var currentFlipSided = null;
                var currentCullFace = null;
                var currentLineWidth = null;
                var currentPolygonOffsetFactor = null;
                var currentPolygonOffsetUnits = null;
                var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                var lineWidthAvailable = false;
                var version = 0;
                var glVersion = gl.getParameter(gl.VERSION);
                if (glVersion.indexOf("WebGL") !== -1) {
                    version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
                    lineWidthAvailable = version >= 1
                } else if (glVersion.indexOf("OpenGL ES") !== -1) {
                    version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
                    lineWidthAvailable = version >= 2
                }
                var currentTextureSlot = null;
                var currentBoundTextures = {};
                var currentScissor = new Vector4;
                var currentViewport = new Vector4;

                function createTexture(type, target, count) {
                    var data = new Uint8Array(4);
                    var texture = gl.createTexture();
                    gl.bindTexture(type, texture);
                    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    for (var i = 0; i < count; i++) {
                        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data)
                    }
                    return texture
                }
                var emptyTextures = {};
                emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
                emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
                colorBuffer.setClear(0, 0, 0, 1);
                depthBuffer.setClear(1);
                stencilBuffer.setClear(0);
                enable(gl.DEPTH_TEST);
                depthBuffer.setFunc(LessEqualDepth);
                setFlipSided(false);
                setCullFace(CullFaceBack);
                enable(gl.CULL_FACE);
                enable(gl.BLEND);
                setBlending(NormalBlending);

                function initAttributes() {
                    for (var i = 0, l = newAttributes.length; i < l; i++) {
                        newAttributes[i] = 0
                    }
                }

                function enableAttribute(attribute) {
                    newAttributes[attribute] = 1;
                    if (enabledAttributes[attribute] === 0) {
                        gl.enableVertexAttribArray(attribute);
                        enabledAttributes[attribute] = 1
                    }
                    if (attributeDivisors[attribute] !== 0) {
                        var extension = extensions.get("ANGLE_instanced_arrays");
                        extension.vertexAttribDivisorANGLE(attribute, 0);
                        attributeDivisors[attribute] = 0
                    }
                }

                function enableAttributeAndDivisor(attribute, meshPerAttribute) {
                    newAttributes[attribute] = 1;
                    if (enabledAttributes[attribute] === 0) {
                        gl.enableVertexAttribArray(attribute);
                        enabledAttributes[attribute] = 1
                    }
                    if (attributeDivisors[attribute] !== meshPerAttribute) {
                        var extension = extensions.get("ANGLE_instanced_arrays");
                        extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                        attributeDivisors[attribute] = meshPerAttribute
                    }
                }

                function disableUnusedAttributes() {
                    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
                        if (enabledAttributes[i] !== newAttributes[i]) {
                            gl.disableVertexAttribArray(i);
                            enabledAttributes[i] = 0
                        }
                    }
                }

                function enable(id) {
                    if (capabilities[id] !== true) {
                        gl.enable(id);
                        capabilities[id] = true
                    }
                }

                function disable(id) {
                    if (capabilities[id] !== false) {
                        gl.disable(id);
                        capabilities[id] = false
                    }
                }

                function getCompressedTextureFormats() {
                    if (compressedTextureFormats === null) {
                        compressedTextureFormats = [];
                        if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1") || extensions.get("WEBGL_compressed_texture_astc")) {
                            var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                            for (var i = 0; i < formats.length; i++) {
                                compressedTextureFormats.push(formats[i])
                            }
                        }
                    }
                    return compressedTextureFormats
                }

                function useProgram(program) {
                    if (currentProgram !== program) {
                        gl.useProgram(program);
                        currentProgram = program;
                        return true
                    }
                    return false
                }

                function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
                    if (blending !== NoBlending) {
                        enable(gl.BLEND)
                    } else {
                        disable(gl.BLEND)
                    }
                    if (blending !== CustomBlending) {
                        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                            switch (blending) {
                                case AdditiveBlending:
                                    if (premultipliedAlpha) {
                                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE)
                                    } else {
                                        gl.blendEquation(gl.FUNC_ADD);
                                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
                                    }
                                    break;
                                case SubtractiveBlending:
                                    if (premultipliedAlpha) {
                                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                        gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA)
                                    } else {
                                        gl.blendEquation(gl.FUNC_ADD);
                                        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR)
                                    }
                                    break;
                                case MultiplyBlending:
                                    if (premultipliedAlpha) {
                                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA)
                                    } else {
                                        gl.blendEquation(gl.FUNC_ADD);
                                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR)
                                    }
                                    break;
                                default:
                                    if (premultipliedAlpha) {
                                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
                                    } else {
                                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
                                    }
                            }
                        }
                        currentBlendEquation = null;
                        currentBlendSrc = null;
                        currentBlendDst = null;
                        currentBlendEquationAlpha = null;
                        currentBlendSrcAlpha = null;
                        currentBlendDstAlpha = null
                    } else {
                        blendEquationAlpha = blendEquationAlpha || blendEquation;
                        blendSrcAlpha = blendSrcAlpha || blendSrc;
                        blendDstAlpha = blendDstAlpha || blendDst;
                        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                            gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
                            currentBlendEquation = blendEquation;
                            currentBlendEquationAlpha = blendEquationAlpha
                        }
                        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                            gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
                            currentBlendSrc = blendSrc;
                            currentBlendDst = blendDst;
                            currentBlendSrcAlpha = blendSrcAlpha;
                            currentBlendDstAlpha = blendDstAlpha
                        }
                    }
                    currentBlending = blending;
                    currentPremultipledAlpha = premultipliedAlpha
                }

                function setMaterial(material, frontFaceCW) {
                    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
                    var flipSided = material.side === BackSide;
                    if (frontFaceCW) flipSided = !flipSided;
                    setFlipSided(flipSided);
                    material.transparent === true ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : setBlending(NoBlending);
                    depthBuffer.setFunc(material.depthFunc);
                    depthBuffer.setTest(material.depthTest);
                    depthBuffer.setMask(material.depthWrite);
                    colorBuffer.setMask(material.colorWrite);
                    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits)
                }

                function setFlipSided(flipSided) {
                    if (currentFlipSided !== flipSided) {
                        if (flipSided) {
                            gl.frontFace(gl.CW)
                        } else {
                            gl.frontFace(gl.CCW)
                        }
                        currentFlipSided = flipSided
                    }
                }

                function setCullFace(cullFace) {
                    if (cullFace !== CullFaceNone) {
                        enable(gl.CULL_FACE);
                        if (cullFace !== currentCullFace) {
                            if (cullFace === CullFaceBack) {
                                gl.cullFace(gl.BACK)
                            } else if (cullFace === CullFaceFront) {
                                gl.cullFace(gl.FRONT)
                            } else {
                                gl.cullFace(gl.FRONT_AND_BACK)
                            }
                        }
                    } else {
                        disable(gl.CULL_FACE)
                    }
                    currentCullFace = cullFace
                }

                function setLineWidth(width) {
                    if (width !== currentLineWidth) {
                        if (lineWidthAvailable) gl.lineWidth(width);
                        currentLineWidth = width
                    }
                }

                function setPolygonOffset(polygonOffset, factor, units) {
                    if (polygonOffset) {
                        enable(gl.POLYGON_OFFSET_FILL);
                        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                            gl.polygonOffset(factor, units);
                            currentPolygonOffsetFactor = factor;
                            currentPolygonOffsetUnits = units
                        }
                    } else {
                        disable(gl.POLYGON_OFFSET_FILL)
                    }
                }

                function setScissorTest(scissorTest) {
                    if (scissorTest) {
                        enable(gl.SCISSOR_TEST)
                    } else {
                        disable(gl.SCISSOR_TEST)
                    }
                }

                function activeTexture(webglSlot) {
                    if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
                    if (currentTextureSlot !== webglSlot) {
                        gl.activeTexture(webglSlot);
                        currentTextureSlot = webglSlot
                    }
                }

                function bindTexture(webglType, webglTexture) {
                    if (currentTextureSlot === null) {
                        activeTexture()
                    }
                    var boundTexture = currentBoundTextures[currentTextureSlot];
                    if (boundTexture === undefined) {
                        boundTexture = {
                            type: undefined,
                            texture: undefined
                        };
                        currentBoundTextures[currentTextureSlot] = boundTexture
                    }
                    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                        boundTexture.type = webglType;
                        boundTexture.texture = webglTexture
                    }
                }

                function compressedTexImage2D() {
                    try {
                        gl.compressedTexImage2D.apply(gl, arguments)
                    } catch (error) {
                        console.error("THREE.WebGLState:", error)
                    }
                }

                function texImage2D() {
                    try {
                        gl.texImage2D.apply(gl, arguments)
                    } catch (error) {
                        console.error("THREE.WebGLState:", error)
                    }
                }

                function scissor(scissor) {
                    if (currentScissor.equals(scissor) === false) {
                        gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                        currentScissor.copy(scissor)
                    }
                }

                function viewport(viewport) {
                    if (currentViewport.equals(viewport) === false) {
                        gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                        currentViewport.copy(viewport)
                    }
                }

                function reset() {
                    for (var i = 0; i < enabledAttributes.length; i++) {
                        if (enabledAttributes[i] === 1) {
                            gl.disableVertexAttribArray(i);
                            enabledAttributes[i] = 0
                        }
                    }
                    capabilities = {};
                    compressedTextureFormats = null;
                    currentTextureSlot = null;
                    currentBoundTextures = {};
                    currentProgram = null;
                    currentBlending = null;
                    currentFlipSided = null;
                    currentCullFace = null;
                    colorBuffer.reset();
                    depthBuffer.reset();
                    stencilBuffer.reset()
                }
                return {
                    buffers: {
                        color: colorBuffer,
                        depth: depthBuffer,
                        stencil: stencilBuffer
                    },
                    initAttributes: initAttributes,
                    enableAttribute: enableAttribute,
                    enableAttributeAndDivisor: enableAttributeAndDivisor,
                    disableUnusedAttributes: disableUnusedAttributes,
                    enable: enable,
                    disable: disable,
                    getCompressedTextureFormats: getCompressedTextureFormats,
                    useProgram: useProgram,
                    setBlending: setBlending,
                    setMaterial: setMaterial,
                    setFlipSided: setFlipSided,
                    setCullFace: setCullFace,
                    setLineWidth: setLineWidth,
                    setPolygonOffset: setPolygonOffset,
                    setScissorTest: setScissorTest,
                    activeTexture: activeTexture,
                    bindTexture: bindTexture,
                    compressedTexImage2D: compressedTexImage2D,
                    texImage2D: texImage2D,
                    scissor: scissor,
                    viewport: viewport,
                    reset: reset
                }
            }

            function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
                var _isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && _gl instanceof WebGL2RenderingContext;
                var _videoTextures = {};
                var _canvas;

                function clampToMaxSize(image, maxSize) {
                    if (image.width > maxSize || image.height > maxSize) {
                        if ("data" in image) {
                            console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + image.width + "x" + image.height + ").");
                            return
                        }
                        var scale = maxSize / Math.max(image.width, image.height);
                        var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        canvas.width = Math.floor(image.width * scale);
                        canvas.height = Math.floor(image.height * scale);
                        var context = canvas.getContext("2d");
                        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                        console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
                        return canvas
                    }
                    return image
                }

                function isPowerOfTwo(image) {
                    return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height)
                }

                function makePowerOfTwo(image) {
                    if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
                        if (_canvas === undefined) _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        _canvas.width = _Math.floorPowerOfTwo(image.width);
                        _canvas.height = _Math.floorPowerOfTwo(image.height);
                        var context = _canvas.getContext("2d");
                        context.drawImage(image, 0, 0, _canvas.width, _canvas.height);
                        console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + _canvas.width + "x" + _canvas.height, image);
                        return _canvas
                    }
                    return image
                }

                function textureNeedsPowerOfTwo(texture) {
                    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter
                }

                function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
                    return texture.generateMipmaps && isPowerOfTwo && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter
                }

                function generateMipmap(target, texture, width, height) {
                    _gl.generateMipmap(target);
                    var textureProperties = properties.get(texture);
                    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height))
                }

                function filterFallback(f) {
                    if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
                        return _gl.NEAREST
                    }
                    return _gl.LINEAR
                }

                function onTextureDispose(event) {
                    var texture = event.target;
                    texture.removeEventListener("dispose", onTextureDispose);
                    deallocateTexture(texture);
                    if (texture.isVideoTexture) {
                        delete _videoTextures[texture.id]
                    }
                    info.memory.textures--
                }

                function onRenderTargetDispose(event) {
                    var renderTarget = event.target;
                    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
                    deallocateRenderTarget(renderTarget);
                    info.memory.textures--
                }

                function deallocateTexture(texture) {
                    var textureProperties = properties.get(texture);
                    if (texture.image && textureProperties.__image__webglTextureCube) {
                        _gl.deleteTexture(textureProperties.__image__webglTextureCube)
                    } else {
                        if (textureProperties.__webglInit === undefined) return;
                        _gl.deleteTexture(textureProperties.__webglTexture)
                    }
                    properties.remove(texture)
                }

                function deallocateRenderTarget(renderTarget) {
                    var renderTargetProperties = properties.get(renderTarget);
                    var textureProperties = properties.get(renderTarget.texture);
                    if (!renderTarget) return;
                    if (textureProperties.__webglTexture !== undefined) {
                        _gl.deleteTexture(textureProperties.__webglTexture)
                    }
                    if (renderTarget.depthTexture) {
                        renderTarget.depthTexture.dispose()
                    }
                    if (renderTarget.isWebGLRenderTargetCube) {
                        for (var i = 0; i < 6; i++) {
                            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i])
                        }
                    } else {
                        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer)
                    }
                    properties.remove(renderTarget.texture);
                    properties.remove(renderTarget)
                }

                function setTexture2D(texture, slot) {
                    var textureProperties = properties.get(texture);
                    if (texture.isVideoTexture) updateVideoTexture(texture);
                    if (texture.version > 0 && textureProperties.__version !== texture.version) {
                        var image = texture.image;
                        if (image === undefined) {
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", texture)
                        } else if (image.complete === false) {
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", texture)
                        } else {
                            uploadTexture(textureProperties, texture, slot);
                            return
                        }
                    }
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture)
                }

                function setTextureCube(texture, slot) {
                    var textureProperties = properties.get(texture);
                    if (texture.image.length === 6) {
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            if (!textureProperties.__image__webglTextureCube) {
                                texture.addEventListener("dispose", onTextureDispose);
                                textureProperties.__image__webglTextureCube = _gl.createTexture();
                                info.memory.textures++
                            }
                            state.activeTexture(_gl.TEXTURE0 + slot);
                            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                            var isCompressed = texture && texture.isCompressedTexture;
                            var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
                            var cubeImage = [];
                            for (var i = 0; i < 6; i++) {
                                if (!isCompressed && !isDataTexture) {
                                    cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize)
                                } else {
                                    cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i]
                                }
                            }
                            var image = cubeImage[0],
                                isPowerOfTwoImage = isPowerOfTwo(image),
                                glFormat = utils.convert(texture.format),
                                glType = utils.convert(texture.type);
                            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                            for (var i = 0; i < 6; i++) {
                                if (!isCompressed) {
                                    if (isDataTexture) {
                                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data)
                                    } else {
                                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i])
                                    }
                                } else {
                                    var mipmap, mipmaps = cubeImage[i].mipmaps;
                                    for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                                        mipmap = mipmaps[j];
                                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                            if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                                state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data)
                                            } else {
                                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()")
                                            }
                                        } else {
                                            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
                                        }
                                    }
                                }
                            }
                            if (!isCompressed) {
                                textureProperties.__maxMipLevel = 0
                            } else {
                                textureProperties.__maxMipLevel = mipmaps.length - 1
                            }
                            if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
                                generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height)
                            }
                            textureProperties.__version = texture.version;
                            if (texture.onUpdate) texture.onUpdate(texture)
                        } else {
                            state.activeTexture(_gl.TEXTURE0 + slot);
                            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube)
                        }
                    }
                }

                function setTextureCubeDynamic(texture, slot) {
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture)
                }

                function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
                    var extension;
                    if (isPowerOfTwoImage) {
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS));
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT));
                        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter));
                        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter))
                    } else {
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
                        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", texture)
                        }
                        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
                        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
                        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", texture)
                        }
                    }
                    extension = extensions.get("EXT_texture_filter_anisotropic");
                    if (extension) {
                        if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null) return;
                        if (texture.type === HalfFloatType && extensions.get("OES_texture_half_float_linear") === null) return;
                        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                            properties.get(texture).__currentAnisotropy = texture.anisotropy
                        }
                    }
                }

                function uploadTexture(textureProperties, texture, slot) {
                    if (textureProperties.__webglInit === undefined) {
                        textureProperties.__webglInit = true;
                        texture.addEventListener("dispose", onTextureDispose);
                        textureProperties.__webglTexture = _gl.createTexture();
                        info.memory.textures++
                    }
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
                    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
                    var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
                    if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
                        image = makePowerOfTwo(image)
                    }
                    var isPowerOfTwoImage = isPowerOfTwo(image),
                        glFormat = utils.convert(texture.format),
                        glType = utils.convert(texture.type);
                    setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
                    var mipmap, mipmaps = texture.mipmaps;
                    if (texture.isDepthTexture) {
                        var internalFormat = _gl.DEPTH_COMPONENT;
                        if (texture.type === FloatType) {
                            if (!_isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            internalFormat = _gl.DEPTH_COMPONENT32F
                        } else if (_isWebGL2) {
                            internalFormat = _gl.DEPTH_COMPONENT16
                        }
                        if (texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT) {
                            if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                                console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                                texture.type = UnsignedShortType;
                                glType = utils.convert(texture.type)
                            }
                        }
                        if (texture.format === DepthStencilFormat) {
                            internalFormat = _gl.DEPTH_STENCIL;
                            if (texture.type !== UnsignedInt248Type) {
                                console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                                texture.type = UnsignedInt248Type;
                                glType = utils.convert(texture.type)
                            }
                        }
                        state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null)
                    } else if (texture.isDataTexture) {
                        if (mipmaps.length > 0 && isPowerOfTwoImage) {
                            for (var i = 0, il = mipmaps.length; i < il; i++) {
                                mipmap = mipmaps[i];
                                state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
                            }
                            texture.generateMipmaps = false;
                            textureProperties.__maxMipLevel = mipmaps.length - 1
                        } else {
                            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                            textureProperties.__maxMipLevel = 0
                        }
                    } else if (texture.isCompressedTexture) {
                        for (var i = 0, il = mipmaps.length; i < il; i++) {
                            mipmap = mipmaps[i];
                            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                    state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data)
                                } else {
                                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()")
                                }
                            } else {
                                state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
                            }
                        }
                        textureProperties.__maxMipLevel = mipmaps.length - 1
                    } else {
                        if (mipmaps.length > 0 && isPowerOfTwoImage) {
                            for (var i = 0, il = mipmaps.length; i < il; i++) {
                                mipmap = mipmaps[i];
                                state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap)
                            }
                            texture.generateMipmaps = false;
                            textureProperties.__maxMipLevel = mipmaps.length - 1
                        } else {
                            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                            textureProperties.__maxMipLevel = 0
                        }
                    }
                    if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
                        generateMipmap(_gl.TEXTURE_2D, texture, image.width, image.height)
                    }
                    textureProperties.__version = texture.version;
                    if (texture.onUpdate) texture.onUpdate(texture)
                }

                function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
                    var glFormat = utils.convert(renderTarget.texture.format);
                    var glType = utils.convert(renderTarget.texture.type);
                    state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null)
                }

                function setupRenderBufferStorage(renderbuffer, renderTarget) {
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
                    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)
                    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)
                    } else {
                        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height)
                    }
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
                }

                function setupDepthTexture(framebuffer, renderTarget) {
                    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
                    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture")
                    }
                    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                        renderTarget.depthTexture.image.width = renderTarget.width;
                        renderTarget.depthTexture.image.height = renderTarget.height;
                        renderTarget.depthTexture.needsUpdate = true
                    }
                    setTexture2D(renderTarget.depthTexture, 0);
                    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
                    if (renderTarget.depthTexture.format === DepthFormat) {
                        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0)
                    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0)
                    } else {
                        throw new Error("Unknown depthTexture format")
                    }
                }

                function setupDepthRenderbuffer(renderTarget) {
                    var renderTargetProperties = properties.get(renderTarget);
                    var isCube = renderTarget.isWebGLRenderTargetCube === true;
                    if (renderTarget.depthTexture) {
                        if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
                        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget)
                    } else {
                        if (isCube) {
                            renderTargetProperties.__webglDepthbuffer = [];
                            for (var i = 0; i < 6; i++) {
                                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget)
                            }
                        } else {
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget)
                        }
                    }
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null)
                }

                function setupRenderTarget(renderTarget) {
                    var renderTargetProperties = properties.get(renderTarget);
                    var textureProperties = properties.get(renderTarget.texture);
                    renderTarget.addEventListener("dispose", onRenderTargetDispose);
                    textureProperties.__webglTexture = _gl.createTexture();
                    info.memory.textures++;
                    var isCube = renderTarget.isWebGLRenderTargetCube === true;
                    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
                    if (isCube) {
                        renderTargetProperties.__webglFramebuffer = [];
                        for (var i = 0; i < 6; i++) {
                            renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer()
                        }
                    } else {
                        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer()
                    }
                    if (isCube) {
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                        setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                        for (var i = 0; i < 6; i++) {
                            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i)
                        }
                        if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
                            generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height)
                        }
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, null)
                    } else {
                        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                        setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
                        if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
                            generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height)
                        }
                        state.bindTexture(_gl.TEXTURE_2D, null)
                    }
                    if (renderTarget.depthBuffer) {
                        setupDepthRenderbuffer(renderTarget)
                    }
                }

                function updateRenderTargetMipmap(renderTarget) {
                    var texture = renderTarget.texture;
                    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
                    if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
                        var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                        var webglTexture = properties.get(texture).__webglTexture;
                        state.bindTexture(target, webglTexture);
                        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
                        state.bindTexture(target, null)
                    }
                }

                function updateVideoTexture(texture) {
                    var id = texture.id;
                    var frame = info.render.frame;
                    if (_videoTextures[id] !== frame) {
                        _videoTextures[id] = frame;
                        texture.update()
                    }
                }
                this.setTexture2D = setTexture2D;
                this.setTextureCube = setTextureCube;
                this.setTextureCubeDynamic = setTextureCubeDynamic;
                this.setupRenderTarget = setupRenderTarget;
                this.updateRenderTargetMipmap = updateRenderTargetMipmap
            }

            function WebGLUtils(gl, extensions) {
                function convert(p) {
                    var extension;
                    if (p === RepeatWrapping) return gl.REPEAT;
                    if (p === ClampToEdgeWrapping) return gl.CLAMP_TO_EDGE;
                    if (p === MirroredRepeatWrapping) return gl.MIRRORED_REPEAT;
                    if (p === NearestFilter) return gl.NEAREST;
                    if (p === NearestMipMapNearestFilter) return gl.NEAREST_MIPMAP_NEAREST;
                    if (p === NearestMipMapLinearFilter) return gl.NEAREST_MIPMAP_LINEAR;
                    if (p === LinearFilter) return gl.LINEAR;
                    if (p === LinearMipMapNearestFilter) return gl.LINEAR_MIPMAP_NEAREST;
                    if (p === LinearMipMapLinearFilter) return gl.LINEAR_MIPMAP_LINEAR;
                    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
                    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
                    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
                    if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
                    if (p === ByteType) return gl.BYTE;
                    if (p === ShortType) return gl.SHORT;
                    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
                    if (p === IntType) return gl.INT;
                    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
                    if (p === FloatType) return gl.FLOAT;
                    if (p === HalfFloatType) {
                        extension = extensions.get("OES_texture_half_float");
                        if (extension !== null) return extension.HALF_FLOAT_OES
                    }
                    if (p === AlphaFormat) return gl.ALPHA;
                    if (p === RGBFormat) return gl.RGB;
                    if (p === RGBAFormat) return gl.RGBA;
                    if (p === LuminanceFormat) return gl.LUMINANCE;
                    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
                    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
                    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
                    if (p === AddEquation) return gl.FUNC_ADD;
                    if (p === SubtractEquation) return gl.FUNC_SUBTRACT;
                    if (p === ReverseSubtractEquation) return gl.FUNC_REVERSE_SUBTRACT;
                    if (p === ZeroFactor) return gl.ZERO;
                    if (p === OneFactor) return gl.ONE;
                    if (p === SrcColorFactor) return gl.SRC_COLOR;
                    if (p === OneMinusSrcColorFactor) return gl.ONE_MINUS_SRC_COLOR;
                    if (p === SrcAlphaFactor) return gl.SRC_ALPHA;
                    if (p === OneMinusSrcAlphaFactor) return gl.ONE_MINUS_SRC_ALPHA;
                    if (p === DstAlphaFactor) return gl.DST_ALPHA;
                    if (p === OneMinusDstAlphaFactor) return gl.ONE_MINUS_DST_ALPHA;
                    if (p === DstColorFactor) return gl.DST_COLOR;
                    if (p === OneMinusDstColorFactor) return gl.ONE_MINUS_DST_COLOR;
                    if (p === SrcAlphaSaturateFactor) return gl.SRC_ALPHA_SATURATE;
                    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                        extension = extensions.get("WEBGL_compressed_texture_s3tc");
                        if (extension !== null) {
                            if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    }
                    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
                        if (extension !== null) {
                            if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                    }
                    if (p === RGB_ETC1_Format) {
                        extension = extensions.get("WEBGL_compressed_texture_etc1");
                        if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL
                    }
                    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
                        extension = extensions.get("WEBGL_compressed_texture_astc");
                        if (extension !== null) {
                            return p
                        }
                    }
                    if (p === MinEquation || p === MaxEquation) {
                        extension = extensions.get("EXT_blend_minmax");
                        if (extension !== null) {
                            if (p === MinEquation) return extension.MIN_EXT;
                            if (p === MaxEquation) return extension.MAX_EXT
                        }
                    }
                    if (p === UnsignedInt248Type) {
                        extension = extensions.get("WEBGL_depth_texture");
                        if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL
                    }
                    return 0
                }
                return {
                    convert: convert
                }
            }

            function PerspectiveCamera(fov, aspect, near, far) {
                Camera.call(this);
                this.type = "PerspectiveCamera";
                this.fov = fov !== undefined ? fov : 50;
                this.zoom = 1;
                this.near = near !== undefined ? near : .1;
                this.far = far !== undefined ? far : 2e3;
                this.focus = 10;
                this.aspect = aspect !== undefined ? aspect : 1;
                this.view = null;
                this.filmGauge = 35;
                this.filmOffset = 0;
                this.updateProjectionMatrix()
            }
            PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
                constructor: PerspectiveCamera,
                isPerspectiveCamera: true,
                copy: function(source, recursive) {
                    Camera.prototype.copy.call(this, source, recursive);
                    this.fov = source.fov;
                    this.zoom = source.zoom;
                    this.near = source.near;
                    this.far = source.far;
                    this.focus = source.focus;
                    this.aspect = source.aspect;
                    this.view = source.view === null ? null : Object.assign({}, source.view);
                    this.filmGauge = source.filmGauge;
                    this.filmOffset = source.filmOffset;
                    return this
                },
                setFocalLength: function(focalLength) {
                    var vExtentSlope = .5 * this.getFilmHeight() / focalLength;
                    this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
                    this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var vExtentSlope = Math.tan(_Math.DEG2RAD * .5 * this.fov);
                    return .5 * this.getFilmHeight() / vExtentSlope
                },
                getEffectiveFOV: function() {
                    return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * .5 * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
                    this.aspect = fullWidth / fullHeight;
                    if (this.view === null) {
                        this.view = {
                            enabled: true,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }
                    }
                    this.view.enabled = true;
                    this.view.fullWidth = fullWidth;
                    this.view.fullHeight = fullHeight;
                    this.view.offsetX = x;
                    this.view.offsetY = y;
                    this.view.width = width;
                    this.view.height = height;
                    this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    if (this.view !== null) {
                        this.view.enabled = false
                    }
                    this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var near = this.near,
                        top = near * Math.tan(_Math.DEG2RAD * .5 * this.fov) / this.zoom,
                        height = 2 * top,
                        width = this.aspect * height,
                        left = -.5 * width,
                        view = this.view;
                    if (this.view !== null && this.view.enabled) {
                        var fullWidth = view.fullWidth,
                            fullHeight = view.fullHeight;
                        left += view.offsetX * width / fullWidth;
                        top -= view.offsetY * height / fullHeight;
                        width *= view.width / fullWidth;
                        height *= view.height / fullHeight
                    }
                    var skew = this.filmOffset;
                    if (skew !== 0) left += near * skew / this.getFilmWidth();
                    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far)
                },
                toJSON: function(meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    data.object.fov = this.fov;
                    data.object.zoom = this.zoom;
                    data.object.near = this.near;
                    data.object.far = this.far;
                    data.object.focus = this.focus;
                    data.object.aspect = this.aspect;
                    if (this.view !== null) data.object.view = Object.assign({}, this.view);
                    data.object.filmGauge = this.filmGauge;
                    data.object.filmOffset = this.filmOffset;
                    return data
                }
            });

            function ArrayCamera(array) {
                PerspectiveCamera.call(this);
                this.cameras = array || []
            }
            ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
                constructor: ArrayCamera,
                isArrayCamera: true
            });

            function WebVRManager(renderer) {
                var scope = this;
                var device = null;
                var frameData = null;
                var poseTarget = null;
                var standingMatrix = new Matrix4;
                var standingMatrixInverse = new Matrix4;
                if (typeof window !== "undefined" && "VRFrameData" in window) {
                    frameData = new window.VRFrameData
                }
                var matrixWorldInverse = new Matrix4;
                var tempQuaternion = new Quaternion;
                var tempPosition = new Vector3;
                var cameraL = new PerspectiveCamera;
                cameraL.bounds = new Vector4(0, 0, .5, 1);
                cameraL.layers.enable(1);
                var cameraR = new PerspectiveCamera;
                cameraR.bounds = new Vector4(.5, 0, .5, 1);
                cameraR.layers.enable(2);
                var cameraVR = new ArrayCamera([cameraL, cameraR]);
                cameraVR.layers.enable(1);
                cameraVR.layers.enable(2);
                var currentSize, currentPixelRatio;

                function onVRDisplayPresentChange() {
                    if (device !== null && device.isPresenting) {
                        var eyeParameters = device.getEyeParameters("left");
                        var renderWidth = eyeParameters.renderWidth;
                        var renderHeight = eyeParameters.renderHeight;
                        currentPixelRatio = renderer.getPixelRatio();
                        currentSize = renderer.getSize();
                        renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1)
                    } else if (scope.enabled) {
                        renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio)
                    }
                }
                if (typeof window !== "undefined") {
                    window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false)
                }
                this.enabled = false;
                this.userHeight = 1.6;
                this.getDevice = function() {
                    return device
                };
                this.setDevice = function(value) {
                    if (value !== undefined) device = value
                };
                this.setPoseTarget = function(object) {
                    if (object !== undefined) poseTarget = object
                };
                this.getCamera = function(camera) {
                    if (device === null) return camera;
                    device.depthNear = camera.near;
                    device.depthFar = camera.far;
                    device.getFrameData(frameData);
                    var stageParameters = device.stageParameters;
                    if (stageParameters) {
                        standingMatrix.fromArray(stageParameters.sittingToStandingTransform)
                    } else {
                        standingMatrix.makeTranslation(0, scope.userHeight, 0)
                    }
                    var pose = frameData.pose;
                    var poseObject = poseTarget !== null ? poseTarget : camera;
                    poseObject.matrix.copy(standingMatrix);
                    poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);
                    if (pose.orientation !== null) {
                        tempQuaternion.fromArray(pose.orientation);
                        poseObject.quaternion.multiply(tempQuaternion)
                    }
                    if (pose.position !== null) {
                        tempQuaternion.setFromRotationMatrix(standingMatrix);
                        tempPosition.fromArray(pose.position);
                        tempPosition.applyQuaternion(tempQuaternion);
                        poseObject.position.add(tempPosition)
                    }
                    poseObject.updateMatrixWorld();
                    if (device.isPresenting === false) return camera;
                    cameraL.near = camera.near;
                    cameraR.near = camera.near;
                    cameraL.far = camera.far;
                    cameraR.far = camera.far;
                    cameraVR.matrixWorld.copy(camera.matrixWorld);
                    cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);
                    cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
                    cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);
                    standingMatrixInverse.getInverse(standingMatrix);
                    cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
                    cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
                    var parent = poseObject.parent;
                    if (parent !== null) {
                        matrixWorldInverse.getInverse(parent.matrixWorld);
                        cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
                        cameraR.matrixWorldInverse.multiply(matrixWorldInverse)
                    }
                    cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
                    cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
                    cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
                    cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
                    cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
                    var layers = device.getLayers();
                    if (layers.length) {
                        var layer = layers[0];
                        if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
                            cameraL.bounds.fromArray(layer.leftBounds)
                        }
                        if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
                            cameraR.bounds.fromArray(layer.rightBounds)
                        }
                    }
                    return cameraVR
                };
                this.getStandingMatrix = function() {
                    return standingMatrix
                };
                this.submitFrame = function() {
                    if (device && device.isPresenting) device.submitFrame()
                };
                this.dispose = function() {
                    if (typeof window !== "undefined") {
                        window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange)
                    }
                }
            }

            function WebGLRenderer(parameters) {
                console.log("THREE.WebGLRenderer", REVISION);
                parameters = parameters || {};
                var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    _context = parameters.context !== undefined ? parameters.context : null,
                    _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
                    _depth = parameters.depth !== undefined ? parameters.depth : true,
                    _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
                    _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
                    _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
                    _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
                    _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : "default";
                var currentRenderList = null;
                var currentRenderState = null;
                this.domElement = _canvas;
                this.context = null;
                this.autoClear = true;
                this.autoClearColor = true;
                this.autoClearDepth = true;
                this.autoClearStencil = true;
                this.sortObjects = true;
                this.clippingPlanes = [];
                this.localClippingEnabled = false;
                this.gammaFactor = 2;
                this.gammaInput = false;
                this.gammaOutput = false;
                this.physicallyCorrectLights = false;
                this.toneMapping = LinearToneMapping;
                this.toneMappingExposure = 1;
                this.toneMappingWhitePoint = 1;
                this.maxMorphTargets = 8;
                this.maxMorphNormals = 4;
                var _this = this,
                    _isContextLost = false,
                    _currentRenderTarget = null,
                    _currentFramebuffer = null,
                    _currentMaterialId = -1,
                    _currentGeometryProgram = "",
                    _currentCamera = null,
                    _currentArrayCamera = null,
                    _currentViewport = new Vector4,
                    _currentScissor = new Vector4,
                    _currentScissorTest = null,
                    _usedTextureUnits = 0,
                    _width = _canvas.width,
                    _height = _canvas.height,
                    _pixelRatio = 1,
                    _viewport = new Vector4(0, 0, _width, _height),
                    _scissor = new Vector4(0, 0, _width, _height),
                    _scissorTest = false,
                    _frustum = new Frustum,
                    _clipping = new WebGLClipping,
                    _clippingEnabled = false,
                    _localClippingEnabled = false,
                    _projScreenMatrix = new Matrix4,
                    _vector3 = new Vector3;

                function getTargetPixelRatio() {
                    return _currentRenderTarget === null ? _pixelRatio : 1
                }
                var _gl;
                try {
                    var contextAttributes = {
                        alpha: _alpha,
                        depth: _depth,
                        stencil: _stencil,
                        antialias: _antialias,
                        premultipliedAlpha: _premultipliedAlpha,
                        preserveDrawingBuffer: _preserveDrawingBuffer,
                        powerPreference: _powerPreference
                    };
                    _canvas.addEventListener("webglcontextlost", onContextLost, false);
                    _canvas.addEventListener("webglcontextrestored", onContextRestore, false);
                    _gl = _context || _canvas.getContext("webgl", contextAttributes) || _canvas.getContext("experimental-webgl", contextAttributes);
                    if (_gl === null) {
                        if (_canvas.getContext("webgl") !== null) {
                            throw new Error("Error creating WebGL context with your selected attributes.")
                        } else {
                            throw new Error("Error creating WebGL context.")
                        }
                    }
                    if (_gl.getShaderPrecisionFormat === undefined) {
                        _gl.getShaderPrecisionFormat = function() {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        }
                    }
                } catch (error) {
                    console.error("THREE.WebGLRenderer: " + error.message)
                }
                var extensions, capabilities, state, info;
                var properties, textures, attributes, geometries, objects;
                var programCache, renderLists, renderStates;
                var background, morphtargets, bufferRenderer, indexedBufferRenderer;
                var spriteRenderer;
                var utils;

                function initGLContext() {
                    extensions = new WebGLExtensions(_gl);
                    extensions.get("WEBGL_depth_texture");
                    extensions.get("OES_texture_float");
                    extensions.get("OES_texture_float_linear");
                    extensions.get("OES_texture_half_float");
                    extensions.get("OES_texture_half_float_linear");
                    extensions.get("OES_standard_derivatives");
                    extensions.get("OES_element_index_uint");
                    extensions.get("ANGLE_instanced_arrays");
                    utils = new WebGLUtils(_gl, extensions);
                    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
                    state = new WebGLState(_gl, extensions, utils);
                    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
                    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
                    info = new WebGLInfo(_gl);
                    properties = new WebGLProperties;
                    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
                    attributes = new WebGLAttributes(_gl);
                    geometries = new WebGLGeometries(_gl, attributes, info);
                    objects = new WebGLObjects(geometries, info);
                    morphtargets = new WebGLMorphtargets(_gl);
                    programCache = new WebGLPrograms(_this, extensions, capabilities);
                    renderLists = new WebGLRenderLists;
                    renderStates = new WebGLRenderStates;
                    background = new WebGLBackground(_this, state, geometries, _premultipliedAlpha);
                    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
                    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
                    spriteRenderer = new WebGLSpriteRenderer(_this, _gl, state, textures, capabilities);
                    info.programs = programCache.programs;
                    _this.context = _gl;
                    _this.capabilities = capabilities;
                    _this.extensions = extensions;
                    _this.properties = properties;
                    _this.renderLists = renderLists;
                    _this.state = state;
                    _this.info = info
                }
                initGLContext();
                var vr = new WebVRManager(_this);
                this.vr = vr;
                var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
                this.shadowMap = shadowMap;
                this.getContext = function() {
                    return _gl
                };
                this.getContextAttributes = function() {
                    return _gl.getContextAttributes()
                };
                this.forceContextLoss = function() {
                    var extension = extensions.get("WEBGL_lose_context");
                    if (extension) extension.loseContext()
                };
                this.forceContextRestore = function() {
                    var extension = extensions.get("WEBGL_lose_context");
                    if (extension) extension.restoreContext()
                };
                this.getPixelRatio = function() {
                    return _pixelRatio
                };
                this.setPixelRatio = function(value) {
                    if (value === undefined) return;
                    _pixelRatio = value;
                    this.setSize(_width, _height, false)
                };
                this.getSize = function() {
                    return {
                        width: _width,
                        height: _height
                    }
                };
                this.setSize = function(width, height, updateStyle) {
                    var device = vr.getDevice();
                    if (device && device.isPresenting) {
                        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                        return
                    }
                    _width = width;
                    _height = height;
                    _canvas.width = width * _pixelRatio;
                    _canvas.height = height * _pixelRatio;
                    if (updateStyle !== false) {
                        _canvas.style.width = width + "px";
                        _canvas.style.height = height + "px"
                    }
                    this.setViewport(0, 0, width, height)
                };
                this.getDrawingBufferSize = function() {
                    return {
                        width: _width * _pixelRatio,
                        height: _height * _pixelRatio
                    }
                };
                this.setDrawingBufferSize = function(width, height, pixelRatio) {
                    _width = width;
                    _height = height;
                    _pixelRatio = pixelRatio;
                    _canvas.width = width * pixelRatio;
                    _canvas.height = height * pixelRatio;
                    this.setViewport(0, 0, width, height)
                };
                this.getCurrentViewport = function() {
                    return _currentViewport
                };
                this.setViewport = function(x, y, width, height) {
                    _viewport.set(x, _height - y - height, width, height);
                    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio))
                };
                this.setScissor = function(x, y, width, height) {
                    _scissor.set(x, _height - y - height, width, height);
                    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio))
                };
                this.setScissorTest = function(boolean) {
                    state.setScissorTest(_scissorTest = boolean)
                };
                this.getClearColor = function() {
                    return background.getClearColor()
                };
                this.setClearColor = function() {
                    background.setClearColor.apply(background, arguments)
                };
                this.getClearAlpha = function() {
                    return background.getClearAlpha()
                };
                this.setClearAlpha = function() {
                    background.setClearAlpha.apply(background, arguments)
                };
                this.clear = function(color, depth, stencil) {
                    var bits = 0;
                    if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
                    if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
                    if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
                    _gl.clear(bits)
                };
                this.clearColor = function() {
                    this.clear(true, false, false)
                };
                this.clearDepth = function() {
                    this.clear(false, true, false)
                };
                this.clearStencil = function() {
                    this.clear(false, false, true)
                };
                this.clearTarget = function(renderTarget, color, depth, stencil) {
                    this.setRenderTarget(renderTarget);
                    this.clear(color, depth, stencil)
                };
                this.dispose = function() {
                    _canvas.removeEventListener("webglcontextlost", onContextLost, false);
                    _canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
                    renderLists.dispose();
                    renderStates.dispose();
                    properties.dispose();
                    objects.dispose();
                    vr.dispose();
                    stopAnimation()
                };

                function onContextLost(event) {
                    event.preventDefault();
                    console.log("THREE.WebGLRenderer: Context Lost.");
                    _isContextLost = true
                }

                function onContextRestore() {
                    console.log("THREE.WebGLRenderer: Context Restored.");
                    _isContextLost = false;
                    initGLContext()
                }

                function onMaterialDispose(event) {
                    var material = event.target;
                    material.removeEventListener("dispose", onMaterialDispose);
                    deallocateMaterial(material)
                }

                function deallocateMaterial(material) {
                    releaseMaterialProgramReference(material);
                    properties.remove(material)
                }

                function releaseMaterialProgramReference(material) {
                    var programInfo = properties.get(material).program;
                    material.program = undefined;
                    if (programInfo !== undefined) {
                        programCache.releaseProgram(programInfo)
                    }
                }

                function renderObjectImmediate(object, program, material) {
                    object.render(function(object) {
                        _this.renderBufferImmediate(object, program, material)
                    })
                }
                this.renderBufferImmediate = function(object, program, material) {
                    state.initAttributes();
                    var buffers = properties.get(object);
                    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
                    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
                    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
                    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
                    var programAttributes = program.getAttributes();
                    if (object.hasPositions) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                        _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
                        state.enableAttribute(programAttributes.position);
                        _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0)
                    }
                    if (object.hasNormals) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
                        if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && material.flatShading === true) {
                            for (var i = 0, l = object.count * 3; i < l; i += 9) {
                                var array = object.normalArray;
                                var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                                var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                                var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                                array[i + 0] = nx;
                                array[i + 1] = ny;
                                array[i + 2] = nz;
                                array[i + 3] = nx;
                                array[i + 4] = ny;
                                array[i + 5] = nz;
                                array[i + 6] = nx;
                                array[i + 7] = ny;
                                array[i + 8] = nz
                            }
                        }
                        _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
                        state.enableAttribute(programAttributes.normal);
                        _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0)
                    }
                    if (object.hasUvs && material.map) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                        _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
                        state.enableAttribute(programAttributes.uv);
                        _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0)
                    }
                    if (object.hasColors && material.vertexColors !== NoColors) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                        _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
                        state.enableAttribute(programAttributes.color);
                        _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0)
                    }
                    state.disableUnusedAttributes();
                    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
                    object.count = 0
                };
                this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
                    var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
                    state.setMaterial(material, frontFaceCW);
                    var program = setProgram(camera, fog, material, object);
                    var geometryProgram = geometry.id + "_" + program.id + "_" + (material.wireframe === true);
                    var updateBuffers = false;
                    if (geometryProgram !== _currentGeometryProgram) {
                        _currentGeometryProgram = geometryProgram;
                        updateBuffers = true
                    }
                    if (object.morphTargetInfluences) {
                        morphtargets.update(object, geometry, material, program);
                        updateBuffers = true
                    }
                    var index = geometry.index;
                    var position = geometry.attributes.position;
                    var rangeFactor = 1;
                    if (material.wireframe === true) {
                        index = geometries.getWireframeAttribute(geometry);
                        rangeFactor = 2
                    }
                    var attribute;
                    var renderer = bufferRenderer;
                    if (index !== null) {
                        attribute = attributes.get(index);
                        renderer = indexedBufferRenderer;
                        renderer.setIndex(attribute)
                    }
                    if (updateBuffers) {
                        setupVertexAttributes(material, program, geometry);
                        if (index !== null) {
                            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer)
                        }
                    }
                    var dataCount = Infinity;
                    if (index !== null) {
                        dataCount = index.count
                    } else if (position !== undefined) {
                        dataCount = position.count
                    }
                    var rangeStart = geometry.drawRange.start * rangeFactor;
                    var rangeCount = geometry.drawRange.count * rangeFactor;
                    var groupStart = group !== null ? group.start * rangeFactor : 0;
                    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
                    var drawStart = Math.max(rangeStart, groupStart);
                    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
                    var drawCount = Math.max(0, drawEnd - drawStart + 1);
                    if (drawCount === 0) return;
                    if (object.isMesh) {
                        if (material.wireframe === true) {
                            state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                            renderer.setMode(_gl.LINES)
                        } else {
                            switch (object.drawMode) {
                                case TrianglesDrawMode:
                                    renderer.setMode(_gl.TRIANGLES);
                                    break;
                                case TriangleStripDrawMode:
                                    renderer.setMode(_gl.TRIANGLE_STRIP);
                                    break;
                                case TriangleFanDrawMode:
                                    renderer.setMode(_gl.TRIANGLE_FAN);
                                    break
                            }
                        }
                    } else if (object.isLine) {
                        var lineWidth = material.linewidth;
                        if (lineWidth === undefined) lineWidth = 1;
                        state.setLineWidth(lineWidth * getTargetPixelRatio());
                        if (object.isLineSegments) {
                            renderer.setMode(_gl.LINES)
                        } else if (object.isLineLoop) {
                            renderer.setMode(_gl.LINE_LOOP)
                        } else {
                            renderer.setMode(_gl.LINE_STRIP)
                        }
                    } else if (object.isPoints) {
                        renderer.setMode(_gl.POINTS)
                    }
                    if (geometry && geometry.isInstancedBufferGeometry) {
                        if (geometry.maxInstancedCount > 0) {
                            renderer.renderInstances(geometry, drawStart, drawCount)
                        }
                    } else {
                        renderer.render(drawStart, drawCount)
                    }
                };

                function setupVertexAttributes(material, program, geometry, startIndex) {
                    if (geometry && geometry.isInstancedBufferGeometry) {
                        if (extensions.get("ANGLE_instanced_arrays") === null) {
                            console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            return
                        }
                    }
                    if (startIndex === undefined) startIndex = 0;
                    state.initAttributes();
                    var geometryAttributes = geometry.attributes;
                    var programAttributes = program.getAttributes();
                    var materialDefaultAttributeValues = material.defaultAttributeValues;
                    for (var name in programAttributes) {
                        var programAttribute = programAttributes[name];
                        if (programAttribute >= 0) {
                            var geometryAttribute = geometryAttributes[name];
                            if (geometryAttribute !== undefined) {
                                var normalized = geometryAttribute.normalized;
                                var size = geometryAttribute.itemSize;
                                var attribute = attributes.get(geometryAttribute);
                                if (attribute === undefined) continue;
                                var buffer = attribute.buffer;
                                var type = attribute.type;
                                var bytesPerElement = attribute.bytesPerElement;
                                if (geometryAttribute.isInterleavedBufferAttribute) {
                                    var data = geometryAttribute.data;
                                    var stride = data.stride;
                                    var offset = geometryAttribute.offset;
                                    if (data && data.isInstancedInterleavedBuffer) {
                                        state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                                        if (geometry.maxInstancedCount === undefined) {
                                            geometry.maxInstancedCount = data.meshPerAttribute * data.count
                                        }
                                    } else {
                                        state.enableAttribute(programAttribute)
                                    }
                                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                                    _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement)
                                } else {
                                    if (geometryAttribute.isInstancedBufferAttribute) {
                                        state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                                        if (geometry.maxInstancedCount === undefined) {
                                            geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count
                                        }
                                    } else {
                                        state.enableAttribute(programAttribute)
                                    }
                                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                                    _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement)
                                }
                            } else if (materialDefaultAttributeValues !== undefined) {
                                var value = materialDefaultAttributeValues[name];
                                if (value !== undefined) {
                                    switch (value.length) {
                                        case 2:
                                            _gl.vertexAttrib2fv(programAttribute, value);
                                            break;
                                        case 3:
                                            _gl.vertexAttrib3fv(programAttribute, value);
                                            break;
                                        case 4:
                                            _gl.vertexAttrib4fv(programAttribute, value);
                                            break;
                                        default:
                                            _gl.vertexAttrib1fv(programAttribute, value)
                                    }
                                }
                            }
                        }
                    }
                    state.disableUnusedAttributes()
                }
                this.compile = function(scene, camera) {
                    currentRenderState = renderStates.get(scene, camera);
                    currentRenderState.init();
                    scene.traverse(function(object) {
                        if (object.isLight) {
                            currentRenderState.pushLight(object);
                            if (object.castShadow) {
                                currentRenderState.pushShadow(object)
                            }
                        }
                    });
                    currentRenderState.setupLights(camera);
                    scene.traverse(function(object) {
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                for (var i = 0; i < object.material.length; i++) {
                                    initMaterial(object.material[i], scene.fog, object)
                                }
                            } else {
                                initMaterial(object.material, scene.fog, object)
                            }
                        }
                    })
                };
                var isAnimating = false;
                var onAnimationFrame = null;

                function startAnimation() {
                    if (isAnimating) return;
                    requestAnimationLoopFrame();
                    isAnimating = true
                }

                function stopAnimation() {
                    isAnimating = false
                }

                function requestAnimationLoopFrame() {
                    var device = vr.getDevice();
                    if (device && device.isPresenting) {
                        device.requestAnimationFrame(animationLoop)
                    } else {
                        window.requestAnimationFrame(animationLoop)
                    }
                }

                function animationLoop(time) {
                    if (isAnimating === false) return;
                    onAnimationFrame(time);
                    requestAnimationLoopFrame()
                }
                this.animate = function(callback) {
                    onAnimationFrame = callback;
                    onAnimationFrame !== null ? startAnimation() : stopAnimation()
                };
                this.render = function(scene, camera, renderTarget, forceClear) {
                    if (!(camera && camera.isCamera)) {
                        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        return
                    }
                    if (_isContextLost) return;
                    _currentGeometryProgram = "";
                    _currentMaterialId = -1;
                    _currentCamera = null;
                    if (scene.autoUpdate === true) scene.updateMatrixWorld();
                    if (camera.parent === null) camera.updateMatrixWorld();
                    if (vr.enabled) {
                        camera = vr.getCamera(camera)
                    }
                    currentRenderState = renderStates.get(scene, camera);
                    currentRenderState.init();
                    scene.onBeforeRender(_this, scene, camera, renderTarget);
                    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                    _frustum.setFromMatrix(_projScreenMatrix);
                    _localClippingEnabled = this.localClippingEnabled;
                    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
                    currentRenderList = renderLists.get(scene, camera);
                    currentRenderList.init();
                    projectObject(scene, camera, _this.sortObjects);
                    if (_this.sortObjects === true) {
                        currentRenderList.sort()
                    }
                    if (_clippingEnabled) _clipping.beginShadows();
                    var shadowsArray = currentRenderState.state.shadowsArray;
                    shadowMap.render(shadowsArray, scene, camera);
                    currentRenderState.setupLights(camera);
                    if (_clippingEnabled) _clipping.endShadows();
                    if (this.info.autoReset) this.info.reset();
                    if (renderTarget === undefined) {
                        renderTarget = null
                    }
                    this.setRenderTarget(renderTarget);
                    background.render(currentRenderList, scene, camera, forceClear);
                    var opaqueObjects = currentRenderList.opaque;
                    var transparentObjects = currentRenderList.transparent;
                    if (scene.overrideMaterial) {
                        var overrideMaterial = scene.overrideMaterial;
                        if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                        if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial)
                    } else {
                        if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);
                        if (transparentObjects.length) renderObjects(transparentObjects, scene, camera)
                    }
                    var spritesArray = currentRenderState.state.spritesArray;
                    spriteRenderer.render(spritesArray, scene, camera);
                    if (renderTarget) {
                        textures.updateRenderTargetMipmap(renderTarget)
                    }
                    state.buffers.depth.setTest(true);
                    state.buffers.depth.setMask(true);
                    state.buffers.color.setMask(true);
                    state.setPolygonOffset(false);
                    scene.onAfterRender(_this, scene, camera);
                    if (vr.enabled) {
                        vr.submitFrame()
                    }
                    currentRenderList = null;
                    currentRenderState = null
                };

                function projectObject(object, camera, sortObjects) {
                    if (object.visible === false) return;
                    var visible = object.layers.test(camera.layers);
                    if (visible) {
                        if (object.isLight) {
                            currentRenderState.pushLight(object);
                            if (object.castShadow) {
                                currentRenderState.pushShadow(object)
                            }
                        } else if (object.isSprite) {
                            if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                                currentRenderState.pushSprite(object)
                            }
                        } else if (object.isImmediateRenderObject) {
                            if (sortObjects) {
                                _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix)
                            }
                            currentRenderList.push(object, null, object.material, _vector3.z, null)
                        } else if (object.isMesh || object.isLine || object.isPoints) {
                            if (object.isSkinnedMesh) {
                                object.skeleton.update()
                            }
                            if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                                if (sortObjects) {
                                    _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix)
                                }
                                var geometry = objects.update(object);
                                var material = object.material;
                                if (Array.isArray(material)) {
                                    var groups = geometry.groups;
                                    for (var i = 0, l = groups.length; i < l; i++) {
                                        var group = groups[i];
                                        var groupMaterial = material[group.materialIndex];
                                        if (groupMaterial && groupMaterial.visible) {
                                            currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group)
                                        }
                                    }
                                } else if (material.visible) {
                                    currentRenderList.push(object, geometry, material, _vector3.z, null)
                                }
                            }
                        }
                    }
                    var children = object.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        projectObject(children[i], camera, sortObjects)
                    }
                }

                function renderObjects(renderList, scene, camera, overrideMaterial) {
                    for (var i = 0, l = renderList.length; i < l; i++) {
                        var renderItem = renderList[i];
                        var object = renderItem.object;
                        var geometry = renderItem.geometry;
                        var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                        var group = renderItem.group;
                        if (camera.isArrayCamera) {
                            _currentArrayCamera = camera;
                            var cameras = camera.cameras;
                            for (var j = 0, jl = cameras.length; j < jl; j++) {
                                var camera2 = cameras[j];
                                if (object.layers.test(camera2.layers)) {
                                    var bounds = camera2.bounds;
                                    var x = bounds.x * _width;
                                    var y = bounds.y * _height;
                                    var width = bounds.z * _width;
                                    var height = bounds.w * _height;
                                    state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
                                    renderObject(object, scene, camera2, geometry, material, group)
                                }
                            }
                        } else {
                            _currentArrayCamera = null;
                            renderObject(object, scene, camera, geometry, material, group)
                        }
                    }
                }

                function renderObject(object, scene, camera, geometry, material, group) {
                    object.onBeforeRender(_this, scene, camera, geometry, material, group);
                    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
                    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
                    if (object.isImmediateRenderObject) {
                        var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
                        state.setMaterial(material, frontFaceCW);
                        var program = setProgram(camera, scene.fog, material, object);
                        _currentGeometryProgram = "";
                        renderObjectImmediate(object, program, material)
                    } else {
                        _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group)
                    }
                    object.onAfterRender(_this, scene, camera, geometry, material, group);
                    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera)
                }

                function initMaterial(material, fog, object) {
                    var materialProperties = properties.get(material);
                    var lights = currentRenderState.state.lights;
                    var shadowsArray = currentRenderState.state.shadowsArray;
                    var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
                    var code = programCache.getProgramCode(material, parameters);
                    var program = materialProperties.program;
                    var programChange = true;
                    if (program === undefined) {
                        material.addEventListener("dispose", onMaterialDispose)
                    } else if (program.code !== code) {
                        releaseMaterialProgramReference(material)
                    } else if (materialProperties.lightsHash !== lights.state.hash) {
                        properties.update(material, "lightsHash", lights.state.hash);
                        programChange = false
                    } else if (parameters.shaderID !== undefined) {
                        return
                    } else {
                        programChange = false
                    }
                    if (programChange) {
                        if (parameters.shaderID) {
                            var shader = ShaderLib[parameters.shaderID];
                            materialProperties.shader = {
                                name: material.type,
                                uniforms: UniformsUtils.clone(shader.uniforms),
                                vertexShader: shader.vertexShader,
                                fragmentShader: shader.fragmentShader
                            }
                        } else {
                            materialProperties.shader = {
                                name: material.type,
                                uniforms: material.uniforms,
                                vertexShader: material.vertexShader,
                                fragmentShader: material.fragmentShader
                            }
                        }
                        material.onBeforeCompile(materialProperties.shader, _this);
                        program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);
                        materialProperties.program = program;
                        material.program = program
                    }
                    var programAttributes = program.getAttributes();
                    if (material.morphTargets) {
                        material.numSupportedMorphTargets = 0;
                        for (var i = 0; i < _this.maxMorphTargets; i++) {
                            if (programAttributes["morphTarget" + i] >= 0) {
                                material.numSupportedMorphTargets++
                            }
                        }
                    }
                    if (material.morphNormals) {
                        material.numSupportedMorphNormals = 0;
                        for (var i = 0; i < _this.maxMorphNormals; i++) {
                            if (programAttributes["morphNormal" + i] >= 0) {
                                material.numSupportedMorphNormals++
                            }
                        }
                    }
                    var uniforms = materialProperties.shader.uniforms;
                    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                        materialProperties.numClippingPlanes = _clipping.numPlanes;
                        materialProperties.numIntersection = _clipping.numIntersection;
                        uniforms.clippingPlanes = _clipping.uniform
                    }
                    materialProperties.fog = fog;
                    materialProperties.lightsHash = lights.state.hash;
                    if (material.lights) {
                        uniforms.ambientLightColor.value = lights.state.ambient;
                        uniforms.directionalLights.value = lights.state.directional;
                        uniforms.spotLights.value = lights.state.spot;
                        uniforms.rectAreaLights.value = lights.state.rectArea;
                        uniforms.pointLights.value = lights.state.point;
                        uniforms.hemisphereLights.value = lights.state.hemi;
                        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix
                    }
                    var progUniforms = materialProperties.program.getUniforms(),
                        uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
                    materialProperties.uniformsList = uniformsList
                }

                function setProgram(camera, fog, material, object) {
                    _usedTextureUnits = 0;
                    var materialProperties = properties.get(material);
                    var lights = currentRenderState.state.lights;
                    if (_clippingEnabled) {
                        if (_localClippingEnabled || camera !== _currentCamera) {
                            var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                            _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache)
                        }
                    }
                    if (material.needsUpdate === false) {
                        if (materialProperties.program === undefined) {
                            material.needsUpdate = true
                        } else if (material.fog && materialProperties.fog !== fog) {
                            material.needsUpdate = true
                        } else if (material.lights && materialProperties.lightsHash !== lights.state.hash) {
                            material.needsUpdate = true
                        } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
                            material.needsUpdate = true
                        }
                    }
                    if (material.needsUpdate) {
                        initMaterial(material, fog, object);
                        material.needsUpdate = false
                    }
                    var refreshProgram = false;
                    var refreshMaterial = false;
                    var refreshLights = false;
                    var program = materialProperties.program,
                        p_uniforms = program.getUniforms(),
                        m_uniforms = materialProperties.shader.uniforms;
                    if (state.useProgram(program.program)) {
                        refreshProgram = true;
                        refreshMaterial = true;
                        refreshLights = true
                    }
                    if (material.id !== _currentMaterialId) {
                        _currentMaterialId = material.id;
                        refreshMaterial = true
                    }
                    if (refreshProgram || camera !== _currentCamera) {
                        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
                        if (capabilities.logarithmicDepthBuffer) {
                            p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2))
                        }
                        if (_currentCamera !== (_currentArrayCamera || camera)) {
                            _currentCamera = _currentArrayCamera || camera;
                            refreshMaterial = true;
                            refreshLights = true
                        }
                        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                            var uCamPos = p_uniforms.map.cameraPosition;
                            if (uCamPos !== undefined) {
                                uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld))
                            }
                        }
                        if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
                            p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse)
                        }
                    }
                    if (material.skinning) {
                        p_uniforms.setOptional(_gl, object, "bindMatrix");
                        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                        var skeleton = object.skeleton;
                        if (skeleton) {
                            var bones = skeleton.bones;
                            if (capabilities.floatVertexTextures) {
                                if (skeleton.boneTexture === undefined) {
                                    var size = Math.sqrt(bones.length * 4);
                                    size = _Math.ceilPowerOfTwo(size);
                                    size = Math.max(size, 4);
                                    var boneMatrices = new Float32Array(size * size * 4);
                                    boneMatrices.set(skeleton.boneMatrices);
                                    var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                                    boneTexture.needsUpdate = true;
                                    skeleton.boneMatrices = boneMatrices;
                                    skeleton.boneTexture = boneTexture;
                                    skeleton.boneTextureSize = size
                                }
                                p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture);
                                p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize)
                            } else {
                                p_uniforms.setOptional(_gl, skeleton, "boneMatrices")
                            }
                        }
                    }
                    if (refreshMaterial) {
                        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
                        p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
                        if (material.lights) {
                            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights)
                        }
                        if (fog && material.fog) {
                            refreshUniformsFog(m_uniforms, fog)
                        }
                        if (material.isMeshBasicMaterial) {
                            refreshUniformsCommon(m_uniforms, material)
                        } else if (material.isMeshLambertMaterial) {
                            refreshUniformsCommon(m_uniforms, material);
                            refreshUniformsLambert(m_uniforms, material)
                        } else if (material.isMeshPhongMaterial) {
                            refreshUniformsCommon(m_uniforms, material);
                            if (material.isMeshToonMaterial) {
                                refreshUniformsToon(m_uniforms, material)
                            } else {
                                refreshUniformsPhong(m_uniforms, material)
                            }
                        } else if (material.isMeshStandardMaterial) {
                            refreshUniformsCommon(m_uniforms, material);
                            if (material.isMeshPhysicalMaterial) {
                                refreshUniformsPhysical(m_uniforms, material)
                            } else {
                                refreshUniformsStandard(m_uniforms, material)
                            }
                        } else if (material.isMeshDepthMaterial) {
                            refreshUniformsCommon(m_uniforms, material);
                            refreshUniformsDepth(m_uniforms, material)
                        } else if (material.isMeshDistanceMaterial) {
                            refreshUniformsCommon(m_uniforms, material);
                            refreshUniformsDistance(m_uniforms, material)
                        } else if (material.isMeshNormalMaterial) {
                            refreshUniformsCommon(m_uniforms, material);
                            refreshUniformsNormal(m_uniforms, material)
                        } else if (material.isLineBasicMaterial) {
                            refreshUniformsLine(m_uniforms, material);
                            if (material.isLineDashedMaterial) {
                                refreshUniformsDash(m_uniforms, material)
                            }
                        } else if (material.isPointsMaterial) {
                            refreshUniformsPoints(m_uniforms, material)
                        } else if (material.isShadowMaterial) {
                            m_uniforms.color.value = material.color;
                            m_uniforms.opacity.value = material.opacity
                        }
                        if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
                        if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
                        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this)
                    }
                    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
                        material.uniformsNeedUpdate = false
                    }
                    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
                    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
                    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
                    return program
                }

                function refreshUniformsCommon(uniforms, material) {
                    uniforms.opacity.value = material.opacity;
                    if (material.color) {
                        uniforms.diffuse.value = material.color
                    }
                    if (material.emissive) {
                        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity)
                    }
                    if (material.map) {
                        uniforms.map.value = material.map
                    }
                    if (material.alphaMap) {
                        uniforms.alphaMap.value = material.alphaMap
                    }
                    if (material.specularMap) {
                        uniforms.specularMap.value = material.specularMap
                    }
                    if (material.envMap) {
                        uniforms.envMap.value = material.envMap;
                        uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;
                        uniforms.reflectivity.value = material.reflectivity;
                        uniforms.refractionRatio.value = material.refractionRatio;
                        uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel
                    }
                    if (material.lightMap) {
                        uniforms.lightMap.value = material.lightMap;
                        uniforms.lightMapIntensity.value = material.lightMapIntensity
                    }
                    if (material.aoMap) {
                        uniforms.aoMap.value = material.aoMap;
                        uniforms.aoMapIntensity.value = material.aoMapIntensity
                    }
                    var uvScaleMap;
                    if (material.map) {
                        uvScaleMap = material.map
                    } else if (material.specularMap) {
                        uvScaleMap = material.specularMap
                    } else if (material.displacementMap) {
                        uvScaleMap = material.displacementMap
                    } else if (material.normalMap) {
                        uvScaleMap = material.normalMap
                    } else if (material.bumpMap) {
                        uvScaleMap = material.bumpMap
                    } else if (material.roughnessMap) {
                        uvScaleMap = material.roughnessMap
                    } else if (material.metalnessMap) {
                        uvScaleMap = material.metalnessMap
                    } else if (material.alphaMap) {
                        uvScaleMap = material.alphaMap
                    } else if (material.emissiveMap) {
                        uvScaleMap = material.emissiveMap
                    }
                    if (uvScaleMap !== undefined) {
                        if (uvScaleMap.isWebGLRenderTarget) {
                            uvScaleMap = uvScaleMap.texture
                        }
                        if (uvScaleMap.matrixAutoUpdate === true) {
                            var offset = uvScaleMap.offset;
                            var repeat = uvScaleMap.repeat;
                            var rotation = uvScaleMap.rotation;
                            var center = uvScaleMap.center;
                            uvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y)
                        }
                        uniforms.uvTransform.value.copy(uvScaleMap.matrix)
                    }
                }

                function refreshUniformsLine(uniforms, material) {
                    uniforms.diffuse.value = material.color;
                    uniforms.opacity.value = material.opacity
                }

                function refreshUniformsDash(uniforms, material) {
                    uniforms.dashSize.value = material.dashSize;
                    uniforms.totalSize.value = material.dashSize + material.gapSize;
                    uniforms.scale.value = material.scale
                }

                function refreshUniformsPoints(uniforms, material) {
                    uniforms.diffuse.value = material.color;
                    uniforms.opacity.value = material.opacity;
                    uniforms.size.value = material.size * _pixelRatio;
                    uniforms.scale.value = _height * .5;
                    uniforms.map.value = material.map;
                    if (material.map !== null) {
                        if (material.map.matrixAutoUpdate === true) {
                            var offset = material.map.offset;
                            var repeat = material.map.repeat;
                            var rotation = material.map.rotation;
                            var center = material.map.center;
                            material.map.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y)
                        }
                        uniforms.uvTransform.value.copy(material.map.matrix)
                    }
                }

                function refreshUniformsFog(uniforms, fog) {
                    uniforms.fogColor.value = fog.color;
                    if (fog.isFog) {
                        uniforms.fogNear.value = fog.near;
                        uniforms.fogFar.value = fog.far
                    } else if (fog.isFogExp2) {
                        uniforms.fogDensity.value = fog.density
                    }
                }

                function refreshUniformsLambert(uniforms, material) {
                    if (material.emissiveMap) {
                        uniforms.emissiveMap.value = material.emissiveMap
                    }
                }

                function refreshUniformsPhong(uniforms, material) {
                    uniforms.specular.value = material.specular;
                    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
                    if (material.emissiveMap) {
                        uniforms.emissiveMap.value = material.emissiveMap
                    }
                    if (material.bumpMap) {
                        uniforms.bumpMap.value = material.bumpMap;
                        uniforms.bumpScale.value = material.bumpScale
                    }
                    if (material.normalMap) {
                        uniforms.normalMap.value = material.normalMap;
                        uniforms.normalScale.value.copy(material.normalScale)
                    }
                    if (material.displacementMap) {
                        uniforms.displacementMap.value = material.displacementMap;
                        uniforms.displacementScale.value = material.displacementScale;
                        uniforms.displacementBias.value = material.displacementBias
                    }
                }

                function refreshUniformsToon(uniforms, material) {
                    refreshUniformsPhong(uniforms, material);
                    if (material.gradientMap) {
                        uniforms.gradientMap.value = material.gradientMap
                    }
                }

                function refreshUniformsStandard(uniforms, material) {
                    uniforms.roughness.value = material.roughness;
                    uniforms.metalness.value = material.metalness;
                    if (material.roughnessMap) {
                        uniforms.roughnessMap.value = material.roughnessMap
                    }
                    if (material.metalnessMap) {
                        uniforms.metalnessMap.value = material.metalnessMap
                    }
                    if (material.emissiveMap) {
                        uniforms.emissiveMap.value = material.emissiveMap
                    }
                    if (material.bumpMap) {
                        uniforms.bumpMap.value = material.bumpMap;
                        uniforms.bumpScale.value = material.bumpScale
                    }
                    if (material.normalMap) {
                        uniforms.normalMap.value = material.normalMap;
                        uniforms.normalScale.value.copy(material.normalScale)
                    }
                    if (material.displacementMap) {
                        uniforms.displacementMap.value = material.displacementMap;
                        uniforms.displacementScale.value = material.displacementScale;
                        uniforms.displacementBias.value = material.displacementBias
                    }
                    if (material.envMap) {
                        uniforms.envMapIntensity.value = material.envMapIntensity
                    }
                }

                function refreshUniformsPhysical(uniforms, material) {
                    uniforms.clearCoat.value = material.clearCoat;
                    uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
                    refreshUniformsStandard(uniforms, material)
                }

                function refreshUniformsDepth(uniforms, material) {
                    if (material.displacementMap) {
                        uniforms.displacementMap.value = material.displacementMap;
                        uniforms.displacementScale.value = material.displacementScale;
                        uniforms.displacementBias.value = material.displacementBias
                    }
                }

                function refreshUniformsDistance(uniforms, material) {
                    if (material.displacementMap) {
                        uniforms.displacementMap.value = material.displacementMap;
                        uniforms.displacementScale.value = material.displacementScale;
                        uniforms.displacementBias.value = material.displacementBias
                    }
                    uniforms.referencePosition.value.copy(material.referencePosition);
                    uniforms.nearDistance.value = material.nearDistance;
                    uniforms.farDistance.value = material.farDistance
                }

                function refreshUniformsNormal(uniforms, material) {
                    if (material.bumpMap) {
                        uniforms.bumpMap.value = material.bumpMap;
                        uniforms.bumpScale.value = material.bumpScale
                    }
                    if (material.normalMap) {
                        uniforms.normalMap.value = material.normalMap;
                        uniforms.normalScale.value.copy(material.normalScale)
                    }
                    if (material.displacementMap) {
                        uniforms.displacementMap.value = material.displacementMap;
                        uniforms.displacementScale.value = material.displacementScale;
                        uniforms.displacementBias.value = material.displacementBias
                    }
                }

                function markUniformsLightsNeedsUpdate(uniforms, value) {
                    uniforms.ambientLightColor.needsUpdate = value;
                    uniforms.directionalLights.needsUpdate = value;
                    uniforms.pointLights.needsUpdate = value;
                    uniforms.spotLights.needsUpdate = value;
                    uniforms.rectAreaLights.needsUpdate = value;
                    uniforms.hemisphereLights.needsUpdate = value
                }

                function allocTextureUnit() {
                    var textureUnit = _usedTextureUnits;
                    if (textureUnit >= capabilities.maxTextures) {
                        console.warn("THREE.WebGLRenderer: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures)
                    }
                    _usedTextureUnits += 1;
                    return textureUnit
                }
                this.allocTextureUnit = allocTextureUnit;
                this.setTexture2D = function() {
                    var warned = false;
                    return function setTexture2D(texture, slot) {
                        if (texture && texture.isWebGLRenderTarget) {
                            if (!warned) {
                                console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                                warned = true
                            }
                            texture = texture.texture
                        }
                        textures.setTexture2D(texture, slot)
                    }
                }();
                this.setTexture = function() {
                    var warned = false;
                    return function setTexture(texture, slot) {
                        if (!warned) {
                            console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                            warned = true
                        }
                        textures.setTexture2D(texture, slot)
                    }
                }();
                this.setTextureCube = function() {
                    var warned = false;
                    return function setTextureCube(texture, slot) {
                        if (texture && texture.isWebGLRenderTargetCube) {
                            if (!warned) {
                                console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                                warned = true
                            }
                            texture = texture.texture
                        }
                        if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
                            textures.setTextureCube(texture, slot)
                        } else {
                            textures.setTextureCubeDynamic(texture, slot)
                        }
                    }
                }();
                this.getRenderTarget = function() {
                    return _currentRenderTarget
                };
                this.setRenderTarget = function(renderTarget) {
                    _currentRenderTarget = renderTarget;
                    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
                        textures.setupRenderTarget(renderTarget)
                    }
                    var framebuffer = null;
                    var isCube = false;
                    if (renderTarget) {
                        var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                        if (renderTarget.isWebGLRenderTargetCube) {
                            framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
                            isCube = true
                        } else {
                            framebuffer = __webglFramebuffer
                        }
                        _currentViewport.copy(renderTarget.viewport);
                        _currentScissor.copy(renderTarget.scissor);
                        _currentScissorTest = renderTarget.scissorTest
                    } else {
                        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
                        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                        _currentScissorTest = _scissorTest
                    }
                    if (_currentFramebuffer !== framebuffer) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                        _currentFramebuffer = framebuffer
                    }
                    state.viewport(_currentViewport);
                    state.scissor(_currentScissor);
                    state.setScissorTest(_currentScissorTest);
                    if (isCube) {
                        var textureProperties = properties.get(renderTarget.texture);
                        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel)
                    }
                };
                this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
                    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        return
                    }
                    var framebuffer = properties.get(renderTarget).__webglFramebuffer;
                    if (framebuffer) {
                        var restore = false;
                        if (framebuffer !== _currentFramebuffer) {
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                            restore = true
                        }
                        try {
                            var texture = renderTarget.texture;
                            var textureFormat = texture.format;
                            var textureType = texture.type;
                            if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                return
                            }
                            if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && extensions.get("EXT_color_buffer_half_float"))) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                return
                            }
                            if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                                if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
                                    _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer)
                                }
                            } else {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            }
                        } finally {
                            if (restore) {
                                _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer)
                            }
                        }
                    }
                };
                this.copyFramebufferToTexture = function(position, texture, level) {
                    var width = texture.image.width;
                    var height = texture.image.height;
                    var glFormat = utils.convert(texture.format);
                    this.setTexture2D(texture, 0);
                    _gl.copyTexImage2D(_gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0)
                };
                this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
                    var width = srcTexture.image.width;
                    var height = srcTexture.image.height;
                    var glFormat = utils.convert(dstTexture.format);
                    var glType = utils.convert(dstTexture.type);
                    var pixels = srcTexture.isDataTexture ? srcTexture.image.data : srcTexture.image;
                    this.setTexture2D(dstTexture, 0);
                    _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, pixels)
                }
            }

            function FogExp2(color, density) {
                this.name = "";
                this.color = new Color(color);
                this.density = density !== undefined ? density : 25e-5
            }
            FogExp2.prototype.isFogExp2 = true;
            FogExp2.prototype.clone = function() {
                return new FogExp2(this.color.getHex(), this.density)
            };
            FogExp2.prototype.toJSON = function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            };

            function Fog(color, near, far) {
                this.name = "";
                this.color = new Color(color);
                this.near = near !== undefined ? near : 1;
                this.far = far !== undefined ? far : 1e3
            }
            Fog.prototype.isFog = true;
            Fog.prototype.clone = function() {
                return new Fog(this.color.getHex(), this.near, this.far)
            };
            Fog.prototype.toJSON = function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            };

            function Scene() {
                Object3D.call(this);
                this.type = "Scene";
                this.background = null;
                this.fog = null;
                this.overrideMaterial = null;
                this.autoUpdate = true
            }
            Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Scene,
                copy: function(source, recursive) {
                    Object3D.prototype.copy.call(this, source, recursive);
                    if (source.background !== null) this.background = source.background.clone();
                    if (source.fog !== null) this.fog = source.fog.clone();
                    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
                    this.autoUpdate = source.autoUpdate;
                    this.matrixAutoUpdate = source.matrixAutoUpdate;
                    return this
                },
                toJSON: function(meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    if (this.background !== null) data.object.background = this.background.toJSON(meta);
                    if (this.fog !== null) data.object.fog = this.fog.toJSON();
                    return data
                }
            });

            function SpriteMaterial(parameters) {
                Material.call(this);
                this.type = "SpriteMaterial";
                this.color = new Color(16777215);
                this.map = null;
                this.rotation = 0;
                this.fog = false;
                this.lights = false;
                this.setValues(parameters)
            }
            SpriteMaterial.prototype = Object.create(Material.prototype);
            SpriteMaterial.prototype.constructor = SpriteMaterial;
            SpriteMaterial.prototype.isSpriteMaterial = true;
            SpriteMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.rotation = source.rotation;
                return this
            };

            function Sprite(material) {
                Object3D.call(this);
                this.type = "Sprite";
                this.material = material !== undefined ? material : new SpriteMaterial;
                this.center = new Vector2(.5, .5)
            }
            Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Sprite,
                isSprite: true,
                raycast: function() {
                    var intersectPoint = new Vector3;
                    var worldPosition = new Vector3;
                    var worldScale = new Vector3;
                    return function raycast(raycaster, intersects) {
                        worldPosition.setFromMatrixPosition(this.matrixWorld);
                        raycaster.ray.closestPointToPoint(worldPosition, intersectPoint);
                        worldScale.setFromMatrixScale(this.matrixWorld);
                        var guessSizeSq = worldScale.x * worldScale.y / 4;
                        if (worldPosition.distanceToSquared(intersectPoint) > guessSizeSq) return;
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            point: intersectPoint.clone(),
                            face: null,
                            object: this
                        })
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(source) {
                    Object3D.prototype.copy.call(this, source);
                    if (source.center !== undefined) this.center.copy(source.center);
                    return this
                }
            });

            function LOD() {
                Object3D.call(this);
                this.type = "LOD";
                Object.defineProperties(this, {
                    levels: {
                        enumerable: true,
                        value: []
                    }
                })
            }
            LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: LOD,
                copy: function(source) {
                    Object3D.prototype.copy.call(this, source, false);
                    var levels = source.levels;
                    for (var i = 0, l = levels.length; i < l; i++) {
                        var level = levels[i];
                        this.addLevel(level.object.clone(), level.distance)
                    }
                    return this
                },
                addLevel: function(object, distance) {
                    if (distance === undefined) distance = 0;
                    distance = Math.abs(distance);
                    var levels = this.levels;
                    for (var l = 0; l < levels.length; l++) {
                        if (distance < levels[l].distance) {
                            break
                        }
                    }
                    levels.splice(l, 0, {
                        distance: distance,
                        object: object
                    });
                    this.add(object)
                },
                getObjectForDistance: function(distance) {
                    var levels = this.levels;
                    for (var i = 1, l = levels.length; i < l; i++) {
                        if (distance < levels[i].distance) {
                            break
                        }
                    }
                    return levels[i - 1].object
                },
                raycast: function() {
                    var matrixPosition = new Vector3;
                    return function raycast(raycaster, intersects) {
                        matrixPosition.setFromMatrixPosition(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                        this.getObjectForDistance(distance).raycast(raycaster, intersects)
                    }
                }(),
                update: function() {
                    var v1 = new Vector3;
                    var v2 = new Vector3;
                    return function update(camera) {
                        var levels = this.levels;
                        if (levels.length > 1) {
                            v1.setFromMatrixPosition(camera.matrixWorld);
                            v2.setFromMatrixPosition(this.matrixWorld);
                            var distance = v1.distanceTo(v2);
                            levels[0].object.visible = true;
                            for (var i = 1, l = levels.length; i < l; i++) {
                                if (distance >= levels[i].distance) {
                                    levels[i - 1].object.visible = false;
                                    levels[i].object.visible = true
                                } else {
                                    break
                                }
                            }
                            for (; i < l; i++) {
                                levels[i].object.visible = false
                            }
                        }
                    }
                }(),
                toJSON: function(meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    data.object.levels = [];
                    var levels = this.levels;
                    for (var i = 0, l = levels.length; i < l; i++) {
                        var level = levels[i];
                        data.object.levels.push({
                            object: level.object.uuid,
                            distance: level.distance
                        })
                    }
                    return data
                }
            });

            function Skeleton(bones, boneInverses) {
                bones = bones || [];
                this.bones = bones.slice(0);
                this.boneMatrices = new Float32Array(this.bones.length * 16);
                if (boneInverses === undefined) {
                    this.calculateInverses()
                } else {
                    if (this.bones.length === boneInverses.length) {
                        this.boneInverses = boneInverses.slice(0)
                    } else {
                        console.warn("THREE.Skeleton boneInverses is the wrong length.");
                        this.boneInverses = [];
                        for (var i = 0, il = this.bones.length; i < il; i++) {
                            this.boneInverses.push(new Matrix4)
                        }
                    }
                }
            }
            Object.assign(Skeleton.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var i = 0, il = this.bones.length; i < il; i++) {
                        var inverse = new Matrix4;
                        if (this.bones[i]) {
                            inverse.getInverse(this.bones[i].matrixWorld)
                        }
                        this.boneInverses.push(inverse)
                    }
                },
                pose: function() {
                    var bone, i, il;
                    for (i = 0, il = this.bones.length; i < il; i++) {
                        bone = this.bones[i];
                        if (bone) {
                            bone.matrixWorld.getInverse(this.boneInverses[i])
                        }
                    }
                    for (i = 0, il = this.bones.length; i < il; i++) {
                        bone = this.bones[i];
                        if (bone) {
                            if (bone.parent && bone.parent.isBone) {
                                bone.matrix.getInverse(bone.parent.matrixWorld);
                                bone.matrix.multiply(bone.matrixWorld)
                            } else {
                                bone.matrix.copy(bone.matrixWorld)
                            }
                            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)
                        }
                    }
                },
                update: function() {
                    var offsetMatrix = new Matrix4;
                    var identityMatrix = new Matrix4;
                    return function update() {
                        var bones = this.bones;
                        var boneInverses = this.boneInverses;
                        var boneMatrices = this.boneMatrices;
                        var boneTexture = this.boneTexture;
                        for (var i = 0, il = bones.length; i < il; i++) {
                            var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
                            offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                            offsetMatrix.toArray(boneMatrices, i * 16)
                        }
                        if (boneTexture !== undefined) {
                            boneTexture.needsUpdate = true
                        }
                    }
                }(),
                clone: function() {
                    return new Skeleton(this.bones, this.boneInverses)
                },
                getBoneByName: function(name) {
                    for (var i = 0, il = this.bones.length; i < il; i++) {
                        var bone = this.bones[i];
                        if (bone.name === name) {
                            return bone
                        }
                    }
                    return undefined
                }
            });

            function Bone() {
                Object3D.call(this);
                this.type = "Bone"
            }
            Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Bone,
                isBone: true
            });

            function SkinnedMesh(geometry, material) {
                Mesh.call(this, geometry, material);
                this.type = "SkinnedMesh";
                this.bindMode = "attached";
                this.bindMatrix = new Matrix4;
                this.bindMatrixInverse = new Matrix4;
                var bones = this.initBones();
                var skeleton = new Skeleton(bones);
                this.bind(skeleton, this.matrixWorld);
                this.normalizeSkinWeights()
            }
            SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
                constructor: SkinnedMesh,
                isSkinnedMesh: true,
                initBones: function() {
                    var bones = [],
                        bone, gbone;
                    var i, il;
                    if (this.geometry && this.geometry.bones !== undefined) {
                        for (i = 0, il = this.geometry.bones.length; i < il; i++) {
                            gbone = this.geometry.bones[i];
                            bone = new Bone;
                            bones.push(bone);
                            bone.name = gbone.name;
                            bone.position.fromArray(gbone.pos);
                            bone.quaternion.fromArray(gbone.rotq);
                            if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl)
                        }
                        for (i = 0, il = this.geometry.bones.length; i < il; i++) {
                            gbone = this.geometry.bones[i];
                            if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {
                                bones[gbone.parent].add(bones[i])
                            } else {
                                this.add(bones[i])
                            }
                        }
                    }
                    this.updateMatrixWorld(true);
                    return bones
                },
                bind: function(skeleton, bindMatrix) {
                    this.skeleton = skeleton;
                    if (bindMatrix === undefined) {
                        this.updateMatrixWorld(true);
                        this.skeleton.calculateInverses();
                        bindMatrix = this.matrixWorld
                    }
                    this.bindMatrix.copy(bindMatrix);
                    this.bindMatrixInverse.getInverse(bindMatrix)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    var scale, i;
                    if (this.geometry && this.geometry.isGeometry) {
                        for (i = 0; i < this.geometry.skinWeights.length; i++) {
                            var sw = this.geometry.skinWeights[i];
                            scale = 1 / sw.manhattanLength();
                            if (scale !== Infinity) {
                                sw.multiplyScalar(scale)
                            } else {
                                sw.set(1, 0, 0, 0)
                            }
                        }
                    } else if (this.geometry && this.geometry.isBufferGeometry) {
                        var vec = new Vector4;
                        var skinWeight = this.geometry.attributes.skinWeight;
                        for (i = 0; i < skinWeight.count; i++) {
                            vec.x = skinWeight.getX(i);
                            vec.y = skinWeight.getY(i);
                            vec.z = skinWeight.getZ(i);
                            vec.w = skinWeight.getW(i);
                            scale = 1 / vec.manhattanLength();
                            if (scale !== Infinity) {
                                vec.multiplyScalar(scale)
                            } else {
                                vec.set(1, 0, 0, 0)
                            }
                            skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w)
                        }
                    }
                },
                updateMatrixWorld: function(force) {
                    Mesh.prototype.updateMatrixWorld.call(this, force);
                    if (this.bindMode === "attached") {
                        this.bindMatrixInverse.getInverse(this.matrixWorld)
                    } else if (this.bindMode === "detached") {
                        this.bindMatrixInverse.getInverse(this.bindMatrix)
                    } else {
                        console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });

            function LineBasicMaterial(parameters) {
                Material.call(this);
                this.type = "LineBasicMaterial";
                this.color = new Color(16777215);
                this.linewidth = 1;
                this.linecap = "round";
                this.linejoin = "round";
                this.lights = false;
                this.setValues(parameters)
            }
            LineBasicMaterial.prototype = Object.create(Material.prototype);
            LineBasicMaterial.prototype.constructor = LineBasicMaterial;
            LineBasicMaterial.prototype.isLineBasicMaterial = true;
            LineBasicMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.linewidth = source.linewidth;
                this.linecap = source.linecap;
                this.linejoin = source.linejoin;
                return this
            };

            function Line(geometry, material, mode) {
                if (mode === 1) {
                    console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.");
                    return new LineSegments(geometry, material)
                }
                Object3D.call(this);
                this.type = "Line";
                this.geometry = geometry !== undefined ? geometry : new BufferGeometry;
                this.material = material !== undefined ? material : new LineBasicMaterial({
                    color: Math.random() * 16777215
                })
            }
            Line.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Line,
                isLine: true,
                computeLineDistances: function() {
                    var start = new Vector3;
                    var end = new Vector3;
                    return function computeLineDistances() {
                        var geometry = this.geometry;
                        if (geometry.isBufferGeometry) {
                            if (geometry.index === null) {
                                var positionAttribute = geometry.attributes.position;
                                var lineDistances = [0];
                                for (var i = 1, l = positionAttribute.count; i < l; i++) {
                                    start.fromBufferAttribute(positionAttribute, i - 1);
                                    end.fromBufferAttribute(positionAttribute, i);
                                    lineDistances[i] = lineDistances[i - 1];
                                    lineDistances[i] += start.distanceTo(end)
                                }
                                geometry.addAttribute("lineDistance", new THREE.Float32BufferAttribute(lineDistances, 1))
                            } else {
                                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")
                            }
                        } else if (geometry.isGeometry) {
                            var vertices = geometry.vertices;
                            var lineDistances = geometry.lineDistances;
                            lineDistances[0] = 0;
                            for (var i = 1, l = vertices.length; i < l; i++) {
                                lineDistances[i] = lineDistances[i - 1];
                                lineDistances[i] += vertices[i - 1].distanceTo(vertices[i])
                            }
                        }
                        return this
                    }
                }(),
                raycast: function() {
                    var inverseMatrix = new Matrix4;
                    var ray = new Ray;
                    var sphere = new Sphere;
                    return function raycast(raycaster, intersects) {
                        var precision = raycaster.linePrecision;
                        var precisionSq = precision * precision;
                        var geometry = this.geometry;
                        var matrixWorld = this.matrixWorld;
                        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                        sphere.copy(geometry.boundingSphere);
                        sphere.applyMatrix4(matrixWorld);
                        if (raycaster.ray.intersectsSphere(sphere) === false) return;
                        inverseMatrix.getInverse(matrixWorld);
                        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                        var vStart = new Vector3;
                        var vEnd = new Vector3;
                        var interSegment = new Vector3;
                        var interRay = new Vector3;
                        var step = this && this.isLineSegments ? 2 : 1;
                        if (geometry.isBufferGeometry) {
                            var index = geometry.index;
                            var attributes = geometry.attributes;
                            var positions = attributes.position.array;
                            if (index !== null) {
                                var indices = index.array;
                                for (var i = 0, l = indices.length - 1; i < l; i += step) {
                                    var a = indices[i];
                                    var b = indices[i + 1];
                                    vStart.fromArray(positions, a * 3);
                                    vEnd.fromArray(positions, b * 3);
                                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                    if (distSq > precisionSq) continue;
                                    interRay.applyMatrix4(this.matrixWorld);
                                    var distance = raycaster.ray.origin.distanceTo(interRay);
                                    if (distance < raycaster.near || distance > raycaster.far) continue;
                                    intersects.push({
                                        distance: distance,
                                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                        index: i,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            } else {
                                for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                                    vStart.fromArray(positions, 3 * i);
                                    vEnd.fromArray(positions, 3 * i + 3);
                                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                    if (distSq > precisionSq) continue;
                                    interRay.applyMatrix4(this.matrixWorld);
                                    var distance = raycaster.ray.origin.distanceTo(interRay);
                                    if (distance < raycaster.near || distance > raycaster.far) continue;
                                    intersects.push({
                                        distance: distance,
                                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                        index: i,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                        } else if (geometry.isGeometry) {
                            var vertices = geometry.vertices;
                            var nbVertices = vertices.length;
                            for (var i = 0; i < nbVertices - 1; i += step) {
                                var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                                if (distSq > precisionSq) continue;
                                interRay.applyMatrix4(this.matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                if (distance < raycaster.near || distance > raycaster.far) continue;
                                intersects.push({
                                    distance: distance,
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });

            function LineSegments(geometry, material) {
                Line.call(this, geometry, material);
                this.type = "LineSegments"
            }
            LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
                constructor: LineSegments,
                isLineSegments: true,
                computeLineDistances: function() {
                    var start = new Vector3;
                    var end = new Vector3;
                    return function computeLineDistances() {
                        var geometry = this.geometry;
                        if (geometry.isBufferGeometry) {
                            if (geometry.index === null) {
                                var positionAttribute = geometry.attributes.position;
                                var lineDistances = [];
                                for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
                                    start.fromBufferAttribute(positionAttribute, i);
                                    end.fromBufferAttribute(positionAttribute, i + 1);
                                    lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
                                    lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end)
                                }
                                geometry.addAttribute("lineDistance", new THREE.Float32BufferAttribute(lineDistances, 1))
                            } else {
                                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")
                            }
                        } else if (geometry.isGeometry) {
                            var vertices = geometry.vertices;
                            var lineDistances = geometry.lineDistances;
                            for (var i = 0, l = vertices.length; i < l; i += 2) {
                                start.copy(vertices[i]);
                                end.copy(vertices[i + 1]);
                                lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
                                lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end)
                            }
                        }
                        return this
                    }
                }()
            });

            function LineLoop(geometry, material) {
                Line.call(this, geometry, material);
                this.type = "LineLoop"
            }
            LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
                constructor: LineLoop,
                isLineLoop: true
            });

            function PointsMaterial(parameters) {
                Material.call(this);
                this.type = "PointsMaterial";
                this.color = new Color(16777215);
                this.map = null;
                this.size = 1;
                this.sizeAttenuation = true;
                this.lights = false;
                this.setValues(parameters)
            }
            PointsMaterial.prototype = Object.create(Material.prototype);
            PointsMaterial.prototype.constructor = PointsMaterial;
            PointsMaterial.prototype.isPointsMaterial = true;
            PointsMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.size = source.size;
                this.sizeAttenuation = source.sizeAttenuation;
                return this
            };

            function Points(geometry, material) {
                Object3D.call(this);
                this.type = "Points";
                this.geometry = geometry !== undefined ? geometry : new BufferGeometry;
                this.material = material !== undefined ? material : new PointsMaterial({
                    color: Math.random() * 16777215
                })
            }
            Points.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Points,
                isPoints: true,
                raycast: function() {
                    var inverseMatrix = new Matrix4;
                    var ray = new Ray;
                    var sphere = new Sphere;
                    return function raycast(raycaster, intersects) {
                        var object = this;
                        var geometry = this.geometry;
                        var matrixWorld = this.matrixWorld;
                        var threshold = raycaster.params.Points.threshold;
                        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                        sphere.copy(geometry.boundingSphere);
                        sphere.applyMatrix4(matrixWorld);
                        sphere.radius += threshold;
                        if (raycaster.ray.intersectsSphere(sphere) === false) return;
                        inverseMatrix.getInverse(matrixWorld);
                        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                        var localThresholdSq = localThreshold * localThreshold;
                        var position = new Vector3;
                        var intersectPoint = new Vector3;

                        function testPoint(point, index) {
                            var rayPointDistanceSq = ray.distanceSqToPoint(point);
                            if (rayPointDistanceSq < localThresholdSq) {
                                ray.closestPointToPoint(point, intersectPoint);
                                intersectPoint.applyMatrix4(matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                                if (distance < raycaster.near || distance > raycaster.far) return;
                                intersects.push({
                                    distance: distance,
                                    distanceToRay: Math.sqrt(rayPointDistanceSq),
                                    point: intersectPoint.clone(),
                                    index: index,
                                    face: null,
                                    object: object
                                })
                            }
                        }
                        if (geometry.isBufferGeometry) {
                            var index = geometry.index;
                            var attributes = geometry.attributes;
                            var positions = attributes.position.array;
                            if (index !== null) {
                                var indices = index.array;
                                for (var i = 0, il = indices.length; i < il; i++) {
                                    var a = indices[i];
                                    position.fromArray(positions, a * 3);
                                    testPoint(position, a)
                                }
                            } else {
                                for (var i = 0, l = positions.length / 3; i < l; i++) {
                                    position.fromArray(positions, i * 3);
                                    testPoint(position, i)
                                }
                            }
                        } else {
                            var vertices = geometry.vertices;
                            for (var i = 0, l = vertices.length; i < l; i++) {
                                testPoint(vertices[i], i)
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });

            function Group() {
                Object3D.call(this);
                this.type = "Group"
            }
            Group.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Group,
                isGroup: true
            });

            function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
                Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
                this.generateMipmaps = false
            }
            VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
                constructor: VideoTexture,
                isVideoTexture: true,
                update: function() {
                    var video = this.image;
                    if (video.readyState >= video.HAVE_CURRENT_DATA) {
                        this.needsUpdate = true
                    }
                }
            });

            function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
                Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
                this.image = {
                    width: width,
                    height: height
                };
                this.mipmaps = mipmaps;
                this.flipY = false;
                this.generateMipmaps = false
            }
            CompressedTexture.prototype = Object.create(Texture.prototype);
            CompressedTexture.prototype.constructor = CompressedTexture;
            CompressedTexture.prototype.isCompressedTexture = true;

            function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
                format = format !== undefined ? format : DepthFormat;
                if (format !== DepthFormat && format !== DepthStencilFormat) {
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat")
                }
                if (type === undefined && format === DepthFormat) type = UnsignedShortType;
                if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
                Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
                this.image = {
                    width: width,
                    height: height
                };
                this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
                this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
                this.flipY = false;
                this.generateMipmaps = false
            }
            DepthTexture.prototype = Object.create(Texture.prototype);
            DepthTexture.prototype.constructor = DepthTexture;
            DepthTexture.prototype.isDepthTexture = true;

            function WireframeGeometry(geometry) {
                BufferGeometry.call(this);
                this.type = "WireframeGeometry";
                var vertices = [];
                var i, j, l, o, ol;
                var edge = [0, 0],
                    edges = {},
                    e, edge1, edge2;
                var key, keys = ["a", "b", "c"];
                var vertex;
                if (geometry && geometry.isGeometry) {
                    var faces = geometry.faces;
                    for (i = 0, l = faces.length; i < l; i++) {
                        var face = faces[i];
                        for (j = 0; j < 3; j++) {
                            edge1 = face[keys[j]];
                            edge2 = face[keys[(j + 1) % 3]];
                            edge[0] = Math.min(edge1, edge2);
                            edge[1] = Math.max(edge1, edge2);
                            key = edge[0] + "," + edge[1];
                            if (edges[key] === undefined) {
                                edges[key] = {
                                    index1: edge[0],
                                    index2: edge[1]
                                }
                            }
                        }
                    }
                    for (key in edges) {
                        e = edges[key];
                        vertex = geometry.vertices[e.index1];
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        vertex = geometry.vertices[e.index2];
                        vertices.push(vertex.x, vertex.y, vertex.z)
                    }
                } else if (geometry && geometry.isBufferGeometry) {
                    var position, indices, groups;
                    var group, start, count;
                    var index1, index2;
                    vertex = new Vector3;
                    if (geometry.index !== null) {
                        position = geometry.attributes.position;
                        indices = geometry.index;
                        groups = geometry.groups;
                        if (groups.length === 0) {
                            groups = [{
                                start: 0,
                                count: indices.count,
                                materialIndex: 0
                            }]
                        }
                        for (o = 0, ol = groups.length; o < ol; ++o) {
                            group = groups[o];
                            start = group.start;
                            count = group.count;
                            for (i = start, l = start + count; i < l; i += 3) {
                                for (j = 0; j < 3; j++) {
                                    edge1 = indices.getX(i + j);
                                    edge2 = indices.getX(i + (j + 1) % 3);
                                    edge[0] = Math.min(edge1, edge2);
                                    edge[1] = Math.max(edge1, edge2);
                                    key = edge[0] + "," + edge[1];
                                    if (edges[key] === undefined) {
                                        edges[key] = {
                                            index1: edge[0],
                                            index2: edge[1]
                                        }
                                    }
                                }
                            }
                        }
                        for (key in edges) {
                            e = edges[key];
                            vertex.fromBufferAttribute(position, e.index1);
                            vertices.push(vertex.x, vertex.y, vertex.z);
                            vertex.fromBufferAttribute(position, e.index2);
                            vertices.push(vertex.x, vertex.y, vertex.z)
                        }
                    } else {
                        position = geometry.attributes.position;
                        for (i = 0, l = position.count / 3; i < l; i++) {
                            for (j = 0; j < 3; j++) {
                                index1 = 3 * i + j;
                                vertex.fromBufferAttribute(position, index1);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                index2 = 3 * i + (j + 1) % 3;
                                vertex.fromBufferAttribute(position, index2);
                                vertices.push(vertex.x, vertex.y, vertex.z)
                            }
                        }
                    }
                }
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3))
            }
            WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
            WireframeGeometry.prototype.constructor = WireframeGeometry;

            function ParametricGeometry(func, slices, stacks) {
                Geometry.call(this);
                this.type = "ParametricGeometry";
                this.parameters = {
                    func: func,
                    slices: slices,
                    stacks: stacks
                };
                this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
                this.mergeVertices()
            }
            ParametricGeometry.prototype = Object.create(Geometry.prototype);
            ParametricGeometry.prototype.constructor = ParametricGeometry;

            function ParametricBufferGeometry(func, slices, stacks) {
                BufferGeometry.call(this);
                this.type = "ParametricBufferGeometry";
                this.parameters = {
                    func: func,
                    slices: slices,
                    stacks: stacks
                };
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var EPS = 1e-5;
                var normal = new Vector3;
                var p0 = new Vector3,
                    p1 = new Vector3;
                var pu = new Vector3,
                    pv = new Vector3;
                var i, j;
                var sliceCount = slices + 1;
                for (i = 0; i <= stacks; i++) {
                    var v = i / stacks;
                    for (j = 0; j <= slices; j++) {
                        var u = j / slices;
                        func(u, v, p0);
                        vertices.push(p0.x, p0.y, p0.z);
                        if (u - EPS >= 0) {
                            func(u - EPS, v, p1);
                            pu.subVectors(p0, p1)
                        } else {
                            func(u + EPS, v, p1);
                            pu.subVectors(p1, p0)
                        }
                        if (v - EPS >= 0) {
                            func(u, v - EPS, p1);
                            pv.subVectors(p0, p1)
                        } else {
                            func(u, v + EPS, p1);
                            pv.subVectors(p1, p0)
                        }
                        normal.crossVectors(pu, pv).normalize();
                        normals.push(normal.x, normal.y, normal.z);
                        uvs.push(u, v)
                    }
                }
                for (i = 0; i < stacks; i++) {
                    for (j = 0; j < slices; j++) {
                        var a = i * sliceCount + j;
                        var b = i * sliceCount + j + 1;
                        var c = (i + 1) * sliceCount + j + 1;
                        var d = (i + 1) * sliceCount + j;
                        indices.push(a, b, d);
                        indices.push(b, c, d)
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2))
            }
            ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

            function PolyhedronGeometry(vertices, indices, radius, detail) {
                Geometry.call(this);
                this.type = "PolyhedronGeometry";
                this.parameters = {
                    vertices: vertices,
                    indices: indices,
                    radius: radius,
                    detail: detail
                };
                this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
                this.mergeVertices()
            }
            PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
            PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

            function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
                BufferGeometry.call(this);
                this.type = "PolyhedronBufferGeometry";
                this.parameters = {
                    vertices: vertices,
                    indices: indices,
                    radius: radius,
                    detail: detail
                };
                radius = radius || 1;
                detail = detail || 0;
                var vertexBuffer = [];
                var uvBuffer = [];
                subdivide(detail);
                appplyRadius(radius);
                generateUVs();
                this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
                this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
                if (detail === 0) {
                    this.computeVertexNormals()
                } else {
                    this.normalizeNormals()
                }

                function subdivide(detail) {
                    var a = new Vector3;
                    var b = new Vector3;
                    var c = new Vector3;
                    for (var i = 0; i < indices.length; i += 3) {
                        getVertexByIndex(indices[i + 0], a);
                        getVertexByIndex(indices[i + 1], b);
                        getVertexByIndex(indices[i + 2], c);
                        subdivideFace(a, b, c, detail)
                    }
                }

                function subdivideFace(a, b, c, detail) {
                    var cols = Math.pow(2, detail);
                    var v = [];
                    var i, j;
                    for (i = 0; i <= cols; i++) {
                        v[i] = [];
                        var aj = a.clone().lerp(c, i / cols);
                        var bj = b.clone().lerp(c, i / cols);
                        var rows = cols - i;
                        for (j = 0; j <= rows; j++) {
                            if (j === 0 && i === cols) {
                                v[i][j] = aj
                            } else {
                                v[i][j] = aj.clone().lerp(bj, j / rows)
                            }
                        }
                    }
                    for (i = 0; i < cols; i++) {
                        for (j = 0; j < 2 * (cols - i) - 1; j++) {
                            var k = Math.floor(j / 2);
                            if (j % 2 === 0) {
                                pushVertex(v[i][k + 1]);
                                pushVertex(v[i + 1][k]);
                                pushVertex(v[i][k])
                            } else {
                                pushVertex(v[i][k + 1]);
                                pushVertex(v[i + 1][k + 1]);
                                pushVertex(v[i + 1][k])
                            }
                        }
                    }
                }

                function appplyRadius(radius) {
                    var vertex = new Vector3;
                    for (var i = 0; i < vertexBuffer.length; i += 3) {
                        vertex.x = vertexBuffer[i + 0];
                        vertex.y = vertexBuffer[i + 1];
                        vertex.z = vertexBuffer[i + 2];
                        vertex.normalize().multiplyScalar(radius);
                        vertexBuffer[i + 0] = vertex.x;
                        vertexBuffer[i + 1] = vertex.y;
                        vertexBuffer[i + 2] = vertex.z
                    }
                }

                function generateUVs() {
                    var vertex = new Vector3;
                    for (var i = 0; i < vertexBuffer.length; i += 3) {
                        vertex.x = vertexBuffer[i + 0];
                        vertex.y = vertexBuffer[i + 1];
                        vertex.z = vertexBuffer[i + 2];
                        var u = azimuth(vertex) / 2 / Math.PI + .5;
                        var v = inclination(vertex) / Math.PI + .5;
                        uvBuffer.push(u, 1 - v)
                    }
                    correctUVs();
                    correctSeam()
                }

                function correctSeam() {
                    for (var i = 0; i < uvBuffer.length; i += 6) {
                        var x0 = uvBuffer[i + 0];
                        var x1 = uvBuffer[i + 2];
                        var x2 = uvBuffer[i + 4];
                        var max = Math.max(x0, x1, x2);
                        var min = Math.min(x0, x1, x2);
                        if (max > .9 && min < .1) {
                            if (x0 < .2) uvBuffer[i + 0] += 1;
                            if (x1 < .2) uvBuffer[i + 2] += 1;
                            if (x2 < .2) uvBuffer[i + 4] += 1
                        }
                    }
                }

                function pushVertex(vertex) {
                    vertexBuffer.push(vertex.x, vertex.y, vertex.z)
                }

                function getVertexByIndex(index, vertex) {
                    var stride = index * 3;
                    vertex.x = vertices[stride + 0];
                    vertex.y = vertices[stride + 1];
                    vertex.z = vertices[stride + 2]
                }

                function correctUVs() {
                    var a = new Vector3;
                    var b = new Vector3;
                    var c = new Vector3;
                    var centroid = new Vector3;
                    var uvA = new Vector2;
                    var uvB = new Vector2;
                    var uvC = new Vector2;
                    for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                        centroid.copy(a).add(b).add(c).divideScalar(3);
                        var azi = azimuth(centroid);
                        correctUV(uvA, j + 0, a, azi);
                        correctUV(uvB, j + 2, b, azi);
                        correctUV(uvC, j + 4, c, azi)
                    }
                }

                function correctUV(uv, stride, vector, azimuth) {
                    if (azimuth < 0 && uv.x === 1) {
                        uvBuffer[stride] = uv.x - 1
                    }
                    if (vector.x === 0 && vector.z === 0) {
                        uvBuffer[stride] = azimuth / 2 / Math.PI + .5
                    }
                }

                function azimuth(vector) {
                    return Math.atan2(vector.z, -vector.x)
                }

                function inclination(vector) {
                    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z))
                }
            }
            PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

            function TetrahedronGeometry(radius, detail) {
                Geometry.call(this);
                this.type = "TetrahedronGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                };
                this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
                this.mergeVertices()
            }
            TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
            TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

            function TetrahedronBufferGeometry(radius, detail) {
                var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
                var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
                this.type = "TetrahedronBufferGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                }
            }
            TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

            function OctahedronGeometry(radius, detail) {
                Geometry.call(this);
                this.type = "OctahedronGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                };
                this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
                this.mergeVertices()
            }
            OctahedronGeometry.prototype = Object.create(Geometry.prototype);
            OctahedronGeometry.prototype.constructor = OctahedronGeometry;

            function OctahedronBufferGeometry(radius, detail) {
                var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
                var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
                this.type = "OctahedronBufferGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                }
            }
            OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

            function IcosahedronGeometry(radius, detail) {
                Geometry.call(this);
                this.type = "IcosahedronGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                };
                this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
                this.mergeVertices()
            }
            IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
            IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

            function IcosahedronBufferGeometry(radius, detail) {
                var t = (1 + Math.sqrt(5)) / 2;
                var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
                var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
                this.type = "IcosahedronBufferGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                }
            }
            IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

            function DodecahedronGeometry(radius, detail) {
                Geometry.call(this);
                this.type = "DodecahedronGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                };
                this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
                this.mergeVertices()
            }
            DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
            DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

            function DodecahedronBufferGeometry(radius, detail) {
                var t = (1 + Math.sqrt(5)) / 2;
                var r = 1 / t;
                var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
                var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
                this.type = "DodecahedronBufferGeometry";
                this.parameters = {
                    radius: radius,
                    detail: detail
                }
            }
            DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
            DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

            function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
                Geometry.call(this);
                this.type = "TubeGeometry";
                this.parameters = {
                    path: path,
                    tubularSegments: tubularSegments,
                    radius: radius,
                    radialSegments: radialSegments,
                    closed: closed
                };
                if (taper !== undefined) console.warn("THREE.TubeGeometry: taper has been removed.");
                var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
                this.tangents = bufferGeometry.tangents;
                this.normals = bufferGeometry.normals;
                this.binormals = bufferGeometry.binormals;
                this.fromBufferGeometry(bufferGeometry);
                this.mergeVertices()
            }
            TubeGeometry.prototype = Object.create(Geometry.prototype);
            TubeGeometry.prototype.constructor = TubeGeometry;

            function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
                BufferGeometry.call(this);
                this.type = "TubeBufferGeometry";
                this.parameters = {
                    path: path,
                    tubularSegments: tubularSegments,
                    radius: radius,
                    radialSegments: radialSegments,
                    closed: closed
                };
                tubularSegments = tubularSegments || 64;
                radius = radius || 1;
                radialSegments = radialSegments || 8;
                closed = closed || false;
                var frames = path.computeFrenetFrames(tubularSegments, closed);
                this.tangents = frames.tangents;
                this.normals = frames.normals;
                this.binormals = frames.binormals;
                var vertex = new Vector3;
                var normal = new Vector3;
                var uv = new Vector2;
                var P = new Vector3;
                var i, j;
                var vertices = [];
                var normals = [];
                var uvs = [];
                var indices = [];
                generateBufferData();
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));

                function generateBufferData() {
                    for (i = 0; i < tubularSegments; i++) {
                        generateSegment(i)
                    }
                    generateSegment(closed === false ? tubularSegments : 0);
                    generateUVs();
                    generateIndices()
                }

                function generateSegment(i) {
                    P = path.getPointAt(i / tubularSegments, P);
                    var N = frames.normals[i];
                    var B = frames.binormals[i];
                    for (j = 0; j <= radialSegments; j++) {
                        var v = j / radialSegments * Math.PI * 2;
                        var sin = Math.sin(v);
                        var cos = -Math.cos(v);
                        normal.x = cos * N.x + sin * B.x;
                        normal.y = cos * N.y + sin * B.y;
                        normal.z = cos * N.z + sin * B.z;
                        normal.normalize();
                        normals.push(normal.x, normal.y, normal.z);
                        vertex.x = P.x + radius * normal.x;
                        vertex.y = P.y + radius * normal.y;
                        vertex.z = P.z + radius * normal.z;
                        vertices.push(vertex.x, vertex.y, vertex.z)
                    }
                }

                function generateIndices() {
                    for (j = 1; j <= tubularSegments; j++) {
                        for (i = 1; i <= radialSegments; i++) {
                            var a = (radialSegments + 1) * (j - 1) + (i - 1);
                            var b = (radialSegments + 1) * j + (i - 1);
                            var c = (radialSegments + 1) * j + i;
                            var d = (radialSegments + 1) * (j - 1) + i;
                            indices.push(a, b, d);
                            indices.push(b, c, d)
                        }
                    }
                }

                function generateUVs() {
                    for (i = 0; i <= tubularSegments; i++) {
                        for (j = 0; j <= radialSegments; j++) {
                            uv.x = i / tubularSegments;
                            uv.y = j / radialSegments;
                            uvs.push(uv.x, uv.y)
                        }
                    }
                }
            }
            TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

            function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
                Geometry.call(this);
                this.type = "TorusKnotGeometry";
                this.parameters = {
                    radius: radius,
                    tube: tube,
                    tubularSegments: tubularSegments,
                    radialSegments: radialSegments,
                    p: p,
                    q: q
                };
                if (heightScale !== undefined) console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
                this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
                this.mergeVertices()
            }
            TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
            TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

            function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
                BufferGeometry.call(this);
                this.type = "TorusKnotBufferGeometry";
                this.parameters = {
                    radius: radius,
                    tube: tube,
                    tubularSegments: tubularSegments,
                    radialSegments: radialSegments,
                    p: p,
                    q: q
                };
                radius = radius || 1;
                tube = tube || .4;
                tubularSegments = Math.floor(tubularSegments) || 64;
                radialSegments = Math.floor(radialSegments) || 8;
                p = p || 2;
                q = q || 3;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var i, j;
                var vertex = new Vector3;
                var normal = new Vector3;
                var P1 = new Vector3;
                var P2 = new Vector3;
                var B = new Vector3;
                var T = new Vector3;
                var N = new Vector3;
                for (i = 0; i <= tubularSegments; ++i) {
                    var u = i / tubularSegments * p * Math.PI * 2;
                    calculatePositionOnCurve(u, p, q, radius, P1);
                    calculatePositionOnCurve(u + .01, p, q, radius, P2);
                    T.subVectors(P2, P1);
                    N.addVectors(P2, P1);
                    B.crossVectors(T, N);
                    N.crossVectors(B, T);
                    B.normalize();
                    N.normalize();
                    for (j = 0; j <= radialSegments; ++j) {
                        var v = j / radialSegments * Math.PI * 2;
                        var cx = -tube * Math.cos(v);
                        var cy = tube * Math.sin(v);
                        vertex.x = P1.x + (cx * N.x + cy * B.x);
                        vertex.y = P1.y + (cx * N.y + cy * B.y);
                        vertex.z = P1.z + (cx * N.z + cy * B.z);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        normal.subVectors(vertex, P1).normalize();
                        normals.push(normal.x, normal.y, normal.z);
                        uvs.push(i / tubularSegments);
                        uvs.push(j / radialSegments)
                    }
                }
                for (j = 1; j <= tubularSegments; j++) {
                    for (i = 1; i <= radialSegments; i++) {
                        var a = (radialSegments + 1) * (j - 1) + (i - 1);
                        var b = (radialSegments + 1) * j + (i - 1);
                        var c = (radialSegments + 1) * j + i;
                        var d = (radialSegments + 1) * (j - 1) + i;
                        indices.push(a, b, d);
                        indices.push(b, c, d)
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));

                function calculatePositionOnCurve(u, p, q, radius, position) {
                    var cu = Math.cos(u);
                    var su = Math.sin(u);
                    var quOverP = q / p * u;
                    var cs = Math.cos(quOverP);
                    position.x = radius * (2 + cs) * .5 * cu;
                    position.y = radius * (2 + cs) * su * .5;
                    position.z = radius * Math.sin(quOverP) * .5
                }
            }
            TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

            function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
                Geometry.call(this);
                this.type = "TorusGeometry";
                this.parameters = {
                    radius: radius,
                    tube: tube,
                    radialSegments: radialSegments,
                    tubularSegments: tubularSegments,
                    arc: arc
                };
                this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
                this.mergeVertices()
            }
            TorusGeometry.prototype = Object.create(Geometry.prototype);
            TorusGeometry.prototype.constructor = TorusGeometry;

            function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
                BufferGeometry.call(this);
                this.type = "TorusBufferGeometry";
                this.parameters = {
                    radius: radius,
                    tube: tube,
                    radialSegments: radialSegments,
                    tubularSegments: tubularSegments,
                    arc: arc
                };
                radius = radius || 1;
                tube = tube || .4;
                radialSegments = Math.floor(radialSegments) || 8;
                tubularSegments = Math.floor(tubularSegments) || 6;
                arc = arc || Math.PI * 2;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var center = new Vector3;
                var vertex = new Vector3;
                var normal = new Vector3;
                var j, i;
                for (j = 0; j <= radialSegments; j++) {
                    for (i = 0; i <= tubularSegments; i++) {
                        var u = i / tubularSegments * arc;
                        var v = j / radialSegments * Math.PI * 2;
                        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                        vertex.z = tube * Math.sin(v);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        center.x = radius * Math.cos(u);
                        center.y = radius * Math.sin(u);
                        normal.subVectors(vertex, center).normalize();
                        normals.push(normal.x, normal.y, normal.z);
                        uvs.push(i / tubularSegments);
                        uvs.push(j / radialSegments)
                    }
                }
                for (j = 1; j <= radialSegments; j++) {
                    for (i = 1; i <= tubularSegments; i++) {
                        var a = (tubularSegments + 1) * j + i - 1;
                        var b = (tubularSegments + 1) * (j - 1) + i - 1;
                        var c = (tubularSegments + 1) * (j - 1) + i;
                        var d = (tubularSegments + 1) * j + i;
                        indices.push(a, b, d);
                        indices.push(b, c, d)
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2))
            }
            TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
            var Earcut = {
                triangulate: function(data, holeIndices, dim) {
                    dim = dim || 2;
                    var hasHoles = holeIndices && holeIndices.length,
                        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
                        outerNode = linkedList(data, 0, outerLen, dim, true),
                        triangles = [];
                    if (!outerNode) return triangles;
                    var minX, minY, maxX, maxY, x, y, invSize;
                    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
                    if (data.length > 80 * dim) {
                        minX = maxX = data[0];
                        minY = maxY = data[1];
                        for (var i = dim; i < outerLen; i += dim) {
                            x = data[i];
                            y = data[i + 1];
                            if (x < minX) minX = x;
                            if (y < minY) minY = y;
                            if (x > maxX) maxX = x;
                            if (y > maxY) maxY = y
                        }
                        invSize = Math.max(maxX - minX, maxY - minY);
                        invSize = invSize !== 0 ? 1 / invSize : 0
                    }
                    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
                    return triangles
                }
            };

            function linkedList(data, start, end, dim, clockwise) {
                var i, last;
                if (clockwise === signedArea(data, start, end, dim) > 0) {
                    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last)
                } else {
                    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last)
                }
                if (last && equals(last, last.next)) {
                    removeNode(last);
                    last = last.next
                }
                return last
            }

            function filterPoints(start, end) {
                if (!start) return start;
                if (!end) end = start;
                var p = start,
                    again;
                do {
                    again = false;
                    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                        removeNode(p);
                        p = end = p.prev;
                        if (p === p.next) break;
                        again = true
                    } else {
                        p = p.next
                    }
                } while (again || p !== end);
                return end
            }

            function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
                if (!ear) return;
                if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
                var stop = ear,
                    prev, next;
                while (ear.prev !== ear.next) {
                    prev = ear.prev;
                    next = ear.next;
                    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                        triangles.push(prev.i / dim);
                        triangles.push(ear.i / dim);
                        triangles.push(next.i / dim);
                        removeNode(ear);
                        ear = next.next;
                        stop = next.next;
                        continue
                    }
                    ear = next;
                    if (ear === stop) {
                        if (!pass) {
                            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1)
                        } else if (pass === 1) {
                            ear = cureLocalIntersections(ear, triangles, dim);
                            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2)
                        } else if (pass === 2) {
                            splitEarcut(ear, triangles, dim, minX, minY, invSize)
                        }
                        break
                    }
                }
            }

            function isEar(ear) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;
                if (area(a, b, c) >= 0) return false;
                var p = ear.next.next;
                while (p !== ear.prev) {
                    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                        return false
                    }
                    p = p.next
                }
                return true
            }

            function isEarHashed(ear, minX, minY, invSize) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;
                if (area(a, b, c) >= 0) return false;
                var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
                    minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
                    maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
                    maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
                var minZ = zOrder(minTX, minTY, minX, minY, invSize),
                    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
                var p = ear.nextZ;
                while (p && p.z <= maxZ) {
                    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
                    p = p.nextZ
                }
                p = ear.prevZ;
                while (p && p.z >= minZ) {
                    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
                    p = p.prevZ
                }
                return true
            }

            function cureLocalIntersections(start, triangles, dim) {
                var p = start;
                do {
                    var a = p.prev,
                        b = p.next.next;
                    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                        triangles.push(a.i / dim);
                        triangles.push(p.i / dim);
                        triangles.push(b.i / dim);
                        removeNode(p);
                        removeNode(p.next);
                        p = start = b
                    }
                    p = p.next
                } while (p !== start);
                return p
            }

            function splitEarcut(start, triangles, dim, minX, minY, invSize) {
                var a = start;
                do {
                    var b = a.next.next;
                    while (b !== a.prev) {
                        if (a.i !== b.i && isValidDiagonal(a, b)) {
                            var c = splitPolygon(a, b);
                            a = filterPoints(a, a.next);
                            c = filterPoints(c, c.next);
                            earcutLinked(a, triangles, dim, minX, minY, invSize);
                            earcutLinked(c, triangles, dim, minX, minY, invSize);
                            return
                        }
                        b = b.next
                    }
                    a = a.next
                } while (a !== start)
            }

            function eliminateHoles(data, holeIndices, outerNode, dim) {
                var queue = [],
                    i, len, start, end, list;
                for (i = 0, len = holeIndices.length; i < len; i++) {
                    start = holeIndices[i] * dim;
                    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                    list = linkedList(data, start, end, dim, false);
                    if (list === list.next) list.steiner = true;
                    queue.push(getLeftmost(list))
                }
                queue.sort(compareX);
                for (i = 0; i < queue.length; i++) {
                    eliminateHole(queue[i], outerNode);
                    outerNode = filterPoints(outerNode, outerNode.next)
                }
                return outerNode
            }

            function compareX(a, b) {
                return a.x - b.x
            }

            function eliminateHole(hole, outerNode) {
                outerNode = findHoleBridge(hole, outerNode);
                if (outerNode) {
                    var b = splitPolygon(outerNode, hole);
                    filterPoints(b, b.next)
                }
            }

            function findHoleBridge(hole, outerNode) {
                var p = outerNode,
                    hx = hole.x,
                    hy = hole.y,
                    qx = -Infinity,
                    m;
                do {
                    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                        if (x <= hx && x > qx) {
                            qx = x;
                            if (x === hx) {
                                if (hy === p.y) return p;
                                if (hy === p.next.y) return p.next
                            }
                            m = p.x < p.next.x ? p : p.next
                        }
                    }
                    p = p.next
                } while (p !== outerNode);
                if (!m) return null;
                if (hx === qx) return m.prev;
                var stop = m,
                    mx = m.x,
                    my = m.y,
                    tanMin = Infinity,
                    tan;
                p = m.next;
                while (p !== stop) {
                    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                        tan = Math.abs(hy - p.y) / (hx - p.x);
                        if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
                            m = p;
                            tanMin = tan
                        }
                    }
                    p = p.next
                }
                return m
            }

            function indexCurve(start, minX, minY, invSize) {
                var p = start;
                do {
                    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
                    p.prevZ = p.prev;
                    p.nextZ = p.next;
                    p = p.next
                } while (p !== start);
                p.prevZ.nextZ = null;
                p.prevZ = null;
                sortLinked(p)
            }

            function sortLinked(list) {
                var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
                do {
                    p = list;
                    list = null;
                    tail = null;
                    numMerges = 0;
                    while (p) {
                        numMerges++;
                        q = p;
                        pSize = 0;
                        for (i = 0; i < inSize; i++) {
                            pSize++;
                            q = q.nextZ;
                            if (!q) break
                        }
                        qSize = inSize;
                        while (pSize > 0 || qSize > 0 && q) {
                            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                                e = p;
                                p = p.nextZ;
                                pSize--
                            } else {
                                e = q;
                                q = q.nextZ;
                                qSize--
                            }
                            if (tail) tail.nextZ = e;
                            else list = e;
                            e.prevZ = tail;
                            tail = e
                        }
                        p = q
                    }
                    tail.nextZ = null;
                    inSize *= 2
                } while (numMerges > 1);
                return list
            }

            function zOrder(x, y, minX, minY, invSize) {
                x = 32767 * (x - minX) * invSize;
                y = 32767 * (y - minY) * invSize;
                x = (x | x << 8) & 16711935;
                x = (x | x << 4) & 252645135;
                x = (x | x << 2) & 858993459;
                x = (x | x << 1) & 1431655765;
                y = (y | y << 8) & 16711935;
                y = (y | y << 4) & 252645135;
                y = (y | y << 2) & 858993459;
                y = (y | y << 1) & 1431655765;
                return x | y << 1
            }

            function getLeftmost(start) {
                var p = start,
                    leftmost = start;
                do {
                    if (p.x < leftmost.x) leftmost = p;
                    p = p.next
                } while (p !== start);
                return leftmost
            }

            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
                return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0
            }

            function isValidDiagonal(a, b) {
                return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b)
            }

            function area(p, q, r) {
                return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
            }

            function equals(p1, p2) {
                return p1.x === p2.x && p1.y === p2.y
            }

            function intersects(p1, q1, p2, q2) {
                if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
                return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0
            }

            function intersectsPolygon(a, b) {
                var p = a;
                do {
                    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
                        return true
                    }
                    p = p.next
                } while (p !== a);
                return false
            }

            function locallyInside(a, b) {
                return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0
            }

            function middleInside(a, b) {
                var p = a,
                    inside = false,
                    px = (a.x + b.x) / 2,
                    py = (a.y + b.y) / 2;
                do {
                    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
                        inside = !inside
                    }
                    p = p.next
                } while (p !== a);
                return inside
            }

            function splitPolygon(a, b) {
                var a2 = new Node(a.i, a.x, a.y),
                    b2 = new Node(b.i, b.x, b.y),
                    an = a.next,
                    bp = b.prev;
                a.next = b;
                b.prev = a;
                a2.next = an;
                an.prev = a2;
                b2.next = a2;
                a2.prev = b2;
                bp.next = b2;
                b2.prev = bp;
                return b2
            }

            function insertNode(i, x, y, last) {
                var p = new Node(i, x, y);
                if (!last) {
                    p.prev = p;
                    p.next = p
                } else {
                    p.next = last.next;
                    p.prev = last;
                    last.next.prev = p;
                    last.next = p
                }
                return p
            }

            function removeNode(p) {
                p.next.prev = p.prev;
                p.prev.next = p.next;
                if (p.prevZ) p.prevZ.nextZ = p.nextZ;
                if (p.nextZ) p.nextZ.prevZ = p.prevZ
            }

            function Node(i, x, y) {
                this.i = i;
                this.x = x;
                this.y = y;
                this.prev = null;
                this.next = null;
                this.z = null;
                this.prevZ = null;
                this.nextZ = null;
                this.steiner = false
            }

            function signedArea(data, start, end, dim) {
                var sum = 0;
                for (var i = start, j = end - dim; i < end; i += dim) {
                    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                    j = i
                }
                return sum
            }
            var ShapeUtils = {
                area: function(contour) {
                    var n = contour.length;
                    var a = 0;
                    for (var p = n - 1, q = 0; q < n; p = q++) {
                        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y
                    }
                    return a * .5
                },
                isClockWise: function(pts) {
                    return ShapeUtils.area(pts) < 0
                },
                triangulateShape: function(contour, holes) {
                    var vertices = [];
                    var holeIndices = [];
                    var faces = [];
                    removeDupEndPts(contour);
                    addContour(vertices, contour);
                    var holeIndex = contour.length;
                    holes.forEach(removeDupEndPts);
                    for (var i = 0; i < holes.length; i++) {
                        holeIndices.push(holeIndex);
                        holeIndex += holes[i].length;
                        addContour(vertices, holes[i])
                    }
                    var triangles = Earcut.triangulate(vertices, holeIndices);
                    for (var i = 0; i < triangles.length; i += 3) {
                        faces.push(triangles.slice(i, i + 3))
                    }
                    return faces
                }
            };

            function removeDupEndPts(points) {
                var l = points.length;
                if (l > 2 && points[l - 1].equals(points[0])) {
                    points.pop()
                }
            }

            function addContour(vertices, contour) {
                for (var i = 0; i < contour.length; i++) {
                    vertices.push(contour[i].x);
                    vertices.push(contour[i].y)
                }
            }

            function ExtrudeGeometry(shapes, options) {
                Geometry.call(this);
                this.type = "ExtrudeGeometry";
                this.parameters = {
                    shapes: shapes,
                    options: options
                };
                this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
                this.mergeVertices()
            }
            ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
            ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

            function ExtrudeBufferGeometry(shapes, options) {
                if (typeof shapes === "undefined") {
                    return
                }
                BufferGeometry.call(this);
                this.type = "ExtrudeBufferGeometry";
                shapes = Array.isArray(shapes) ? shapes : [shapes];
                this.addShapeList(shapes, options);
                this.computeVertexNormals()
            }
            ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
            ExtrudeBufferGeometry.prototype.getArrays = function() {
                var positionAttribute = this.getAttribute("position");
                var verticesArray = positionAttribute ? Array.prototype.slice.call(positionAttribute.array) : [];
                var uvAttribute = this.getAttribute("uv");
                var uvArray = uvAttribute ? Array.prototype.slice.call(uvAttribute.array) : [];
                var IndexAttribute = this.index;
                var indicesArray = IndexAttribute ? Array.prototype.slice.call(IndexAttribute.array) : [];
                return {
                    position: verticesArray,
                    uv: uvArray,
                    index: indicesArray
                }
            };
            ExtrudeBufferGeometry.prototype.addShapeList = function(shapes, options) {
                var sl = shapes.length;
                options.arrays = this.getArrays();
                for (var s = 0; s < sl; s++) {
                    var shape = shapes[s];
                    this.addShape(shape, options)
                }
                this.setIndex(options.arrays.index);
                this.addAttribute("position", new Float32BufferAttribute(options.arrays.position, 3));
                this.addAttribute("uv", new Float32BufferAttribute(options.arrays.uv, 2))
            };
            ExtrudeBufferGeometry.prototype.addShape = function(shape, options) {
                var arrays = options.arrays ? options.arrays : this.getArrays();
                var verticesArray = arrays.position;
                var indicesArray = arrays.index;
                var uvArray = arrays.uv;
                var placeholder = [];
                var amount = options.amount !== undefined ? options.amount : 100;
                var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
                var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
                var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
                var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
                var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
                var steps = options.steps !== undefined ? options.steps : 1;
                var extrudePath = options.extrudePath;
                var extrudePts, extrudeByPath = false;
                var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
                var splineTube, binormal, normal, position2;
                if (extrudePath) {
                    extrudePts = extrudePath.getSpacedPoints(steps);
                    extrudeByPath = true;
                    bevelEnabled = false;
                    splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames(steps, false);
                    binormal = new Vector3;
                    normal = new Vector3;
                    position2 = new Vector3
                }
                if (!bevelEnabled) {
                    bevelSegments = 0;
                    bevelThickness = 0;
                    bevelSize = 0
                }
                var ahole, h, hl;
                var scope = this;
                var shapePoints = shape.extractPoints(curveSegments);
                var vertices = shapePoints.shape;
                var holes = shapePoints.holes;
                var reverse = !ShapeUtils.isClockWise(vertices);
                if (reverse) {
                    vertices = vertices.reverse();
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        if (ShapeUtils.isClockWise(ahole)) {
                            holes[h] = ahole.reverse()
                        }
                    }
                }
                var faces = ShapeUtils.triangulateShape(vertices, holes);
                var contour = vertices;
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    vertices = vertices.concat(ahole)
                }

                function scalePt2(pt, vec, size) {
                    if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
                    return vec.clone().multiplyScalar(size).add(pt)
                }
                var b, bs, t, z, vert, vlen = vertices.length,
                    face, flen = faces.length;

                function getBevelVec(inPt, inPrev, inNext) {
                    var v_trans_x, v_trans_y, shrink_by;
                    var v_prev_x = inPt.x - inPrev.x,
                        v_prev_y = inPt.y - inPrev.y;
                    var v_next_x = inNext.x - inPt.x,
                        v_next_y = inNext.y - inPt.y;
                    var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
                    var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                    if (Math.abs(collinear0) > Number.EPSILON) {
                        var v_prev_len = Math.sqrt(v_prev_lensq);
                        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
                        var ptNextShift_y = inNext.y + v_next_x / v_next_len;
                        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                        if (v_trans_lensq <= 2) {
                            return new Vector2(v_trans_x, v_trans_y)
                        } else {
                            shrink_by = Math.sqrt(v_trans_lensq / 2)
                        }
                    } else {
                        var direction_eq = false;
                        if (v_prev_x > Number.EPSILON) {
                            if (v_next_x > Number.EPSILON) {
                                direction_eq = true
                            }
                        } else {
                            if (v_prev_x < -Number.EPSILON) {
                                if (v_next_x < -Number.EPSILON) {
                                    direction_eq = true
                                }
                            } else {
                                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                    direction_eq = true
                                }
                            }
                        }
                        if (direction_eq) {
                            v_trans_x = -v_prev_y;
                            v_trans_y = v_prev_x;
                            shrink_by = Math.sqrt(v_prev_lensq)
                        } else {
                            v_trans_x = v_prev_x;
                            v_trans_y = v_prev_y;
                            shrink_by = Math.sqrt(v_prev_lensq / 2)
                        }
                    }
                    return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by)
                }
                var contourMovements = [];
                for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                    if (j === il) j = 0;
                    if (k === il) k = 0;
                    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k])
                }
                var holesMovements = [],
                    oneHoleMovements, verticesMovements = contourMovements.concat();
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = [];
                    for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                        if (j === il) j = 0;
                        if (k === il) k = 0;
                        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k])
                    }
                    holesMovements.push(oneHoleMovements);
                    verticesMovements = verticesMovements.concat(oneHoleMovements)
                }
                for (b = 0; b < bevelSegments; b++) {
                    t = b / bevelSegments;
                    z = bevelThickness * Math.cos(t * Math.PI / 2);
                    bs = bevelSize * Math.sin(t * Math.PI / 2);
                    for (i = 0, il = contour.length; i < il; i++) {
                        vert = scalePt2(contour[i], contourMovements[i], bs);
                        v(vert.x, vert.y, -z)
                    }
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        oneHoleMovements = holesMovements[h];
                        for (i = 0, il = ahole.length; i < il; i++) {
                            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                            v(vert.x, vert.y, -z)
                        }
                    }
                }
                bs = bevelSize;
                for (i = 0; i < vlen; i++) {
                    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, 0)
                    } else {
                        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                        position2.copy(extrudePts[0]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z)
                    }
                }
                var s;
                for (s = 1; s <= steps; s++) {
                    for (i = 0; i < vlen; i++) {
                        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                        if (!extrudeByPath) {
                            v(vert.x, vert.y, amount / steps * s)
                        } else {
                            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                            position2.copy(extrudePts[s]).add(normal).add(binormal);
                            v(position2.x, position2.y, position2.z)
                        }
                    }
                }
                for (b = bevelSegments - 1; b >= 0; b--) {
                    t = b / bevelSegments;
                    z = bevelThickness * Math.cos(t * Math.PI / 2);
                    bs = bevelSize * Math.sin(t * Math.PI / 2);
                    for (i = 0, il = contour.length; i < il; i++) {
                        vert = scalePt2(contour[i], contourMovements[i], bs);
                        v(vert.x, vert.y, amount + z)
                    }
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        oneHoleMovements = holesMovements[h];
                        for (i = 0, il = ahole.length; i < il; i++) {
                            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                            if (!extrudeByPath) {
                                v(vert.x, vert.y, amount + z)
                            } else {
                                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z)
                            }
                        }
                    }
                }
                buildLidFaces();
                buildSideFaces();

                function buildLidFaces() {
                    var start = verticesArray.length / 3;
                    if (bevelEnabled) {
                        var layer = 0;
                        var offset = vlen * layer;
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[2] + offset, face[1] + offset, face[0] + offset)
                        }
                        layer = steps + bevelSegments * 2;
                        offset = vlen * layer;
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[0] + offset, face[1] + offset, face[2] + offset)
                        }
                    } else {
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[2], face[1], face[0])
                        }
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps)
                        }
                    }
                    scope.addGroup(start, verticesArray.length / 3 - start, 0)
                }

                function buildSideFaces() {
                    var start = verticesArray.length / 3;
                    var layeroffset = 0;
                    sidewalls(contour, layeroffset);
                    layeroffset += contour.length;
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        sidewalls(ahole, layeroffset);
                        layeroffset += ahole.length
                    }
                    scope.addGroup(start, verticesArray.length / 3 - start, 1)
                }

                function sidewalls(contour, layeroffset) {
                    var j, k;
                    i = contour.length;
                    while (--i >= 0) {
                        j = i;
                        k = i - 1;
                        if (k < 0) k = contour.length - 1;
                        var s = 0,
                            sl = steps + bevelSegments * 2;
                        for (s = 0; s < sl; s++) {
                            var slen1 = vlen * s;
                            var slen2 = vlen * (s + 1);
                            var a = layeroffset + j + slen1,
                                b = layeroffset + k + slen1,
                                c = layeroffset + k + slen2,
                                d = layeroffset + j + slen2;
                            f4(a, b, c, d)
                        }
                    }
                }

                function v(x, y, z) {
                    placeholder.push(x);
                    placeholder.push(y);
                    placeholder.push(z)
                }

                function f3(a, b, c) {
                    addVertex(a);
                    addVertex(b);
                    addVertex(c);
                    var nextIndex = verticesArray.length / 3;
                    var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[2])
                }

                function f4(a, b, c, d) {
                    addVertex(a);
                    addVertex(b);
                    addVertex(d);
                    addVertex(b);
                    addVertex(c);
                    addVertex(d);
                    var nextIndex = verticesArray.length / 3;
                    var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[3]);
                    addUV(uvs[1]);
                    addUV(uvs[2]);
                    addUV(uvs[3])
                }

                function addVertex(index) {
                    indicesArray.push(verticesArray.length / 3);
                    verticesArray.push(placeholder[index * 3 + 0]);
                    verticesArray.push(placeholder[index * 3 + 1]);
                    verticesArray.push(placeholder[index * 3 + 2])
                }

                function addUV(vector2) {
                    uvArray.push(vector2.x);
                    uvArray.push(vector2.y)
                }
                if (!options.arrays) {
                    this.setIndex(indicesArray);
                    this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3));
                    this.addAttribute("uv", new Float32BufferAttribute(uvArray, 2))
                }
            };
            ExtrudeGeometry.WorldUVGenerator = {
                generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
                    var a_x = vertices[indexA * 3];
                    var a_y = vertices[indexA * 3 + 1];
                    var b_x = vertices[indexB * 3];
                    var b_y = vertices[indexB * 3 + 1];
                    var c_x = vertices[indexC * 3];
                    var c_y = vertices[indexC * 3 + 1];
                    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)]
                },
                generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
                    var a_x = vertices[indexA * 3];
                    var a_y = vertices[indexA * 3 + 1];
                    var a_z = vertices[indexA * 3 + 2];
                    var b_x = vertices[indexB * 3];
                    var b_y = vertices[indexB * 3 + 1];
                    var b_z = vertices[indexB * 3 + 2];
                    var c_x = vertices[indexC * 3];
                    var c_y = vertices[indexC * 3 + 1];
                    var c_z = vertices[indexC * 3 + 2];
                    var d_x = vertices[indexD * 3];
                    var d_y = vertices[indexD * 3 + 1];
                    var d_z = vertices[indexD * 3 + 2];
                    if (Math.abs(a_y - b_y) < .01) {
                        return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)]
                    } else {
                        return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)]
                    }
                }
            };

            function TextGeometry(text, parameters) {
                Geometry.call(this);
                this.type = "TextGeometry";
                this.parameters = {
                    text: text,
                    parameters: parameters
                };
                this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
                this.mergeVertices()
            }
            TextGeometry.prototype = Object.create(Geometry.prototype);
            TextGeometry.prototype.constructor = TextGeometry;

            function TextBufferGeometry(text, parameters) {
                parameters = parameters || {};
                var font = parameters.font;
                if (!(font && font.isFont)) {
                    console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
                    return new Geometry
                }
                var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
                parameters.amount = parameters.height !== undefined ? parameters.height : 50;
                if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
                if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
                if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
                ExtrudeBufferGeometry.call(this, shapes, parameters);
                this.type = "TextBufferGeometry"
            }
            TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
            TextBufferGeometry.prototype.constructor = TextBufferGeometry;

            function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
                Geometry.call(this);
                this.type = "SphereGeometry";
                this.parameters = {
                    radius: radius,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments,
                    phiStart: phiStart,
                    phiLength: phiLength,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
                this.mergeVertices()
            }
            SphereGeometry.prototype = Object.create(Geometry.prototype);
            SphereGeometry.prototype.constructor = SphereGeometry;

            function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
                BufferGeometry.call(this);
                this.type = "SphereBufferGeometry";
                this.parameters = {
                    radius: radius,
                    widthSegments: widthSegments,
                    heightSegments: heightSegments,
                    phiStart: phiStart,
                    phiLength: phiLength,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                radius = radius || 1;
                widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
                heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
                phiStart = phiStart !== undefined ? phiStart : 0;
                phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
                thetaStart = thetaStart !== undefined ? thetaStart : 0;
                thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
                var thetaEnd = thetaStart + thetaLength;
                var ix, iy;
                var index = 0;
                var grid = [];
                var vertex = new Vector3;
                var normal = new Vector3;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                for (iy = 0; iy <= heightSegments; iy++) {
                    var verticesRow = [];
                    var v = iy / heightSegments;
                    for (ix = 0; ix <= widthSegments; ix++) {
                        var u = ix / widthSegments;
                        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        normal.set(vertex.x, vertex.y, vertex.z).normalize();
                        normals.push(normal.x, normal.y, normal.z);
                        uvs.push(u, 1 - v);
                        verticesRow.push(index++)
                    }
                    grid.push(verticesRow)
                }
                for (iy = 0; iy < heightSegments; iy++) {
                    for (ix = 0; ix < widthSegments; ix++) {
                        var a = grid[iy][ix + 1];
                        var b = grid[iy][ix];
                        var c = grid[iy + 1][ix];
                        var d = grid[iy + 1][ix + 1];
                        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d)
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2))
            }
            SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

            function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
                Geometry.call(this);
                this.type = "RingGeometry";
                this.parameters = {
                    innerRadius: innerRadius,
                    outerRadius: outerRadius,
                    thetaSegments: thetaSegments,
                    phiSegments: phiSegments,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
                this.mergeVertices()
            }
            RingGeometry.prototype = Object.create(Geometry.prototype);
            RingGeometry.prototype.constructor = RingGeometry;

            function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
                BufferGeometry.call(this);
                this.type = "RingBufferGeometry";
                this.parameters = {
                    innerRadius: innerRadius,
                    outerRadius: outerRadius,
                    thetaSegments: thetaSegments,
                    phiSegments: phiSegments,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                innerRadius = innerRadius || .5;
                outerRadius = outerRadius || 1;
                thetaStart = thetaStart !== undefined ? thetaStart : 0;
                thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
                thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
                phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var segment;
                var radius = innerRadius;
                var radiusStep = (outerRadius - innerRadius) / phiSegments;
                var vertex = new Vector3;
                var uv = new Vector2;
                var j, i;
                for (j = 0; j <= phiSegments; j++) {
                    for (i = 0; i <= thetaSegments; i++) {
                        segment = thetaStart + i / thetaSegments * thetaLength;
                        vertex.x = radius * Math.cos(segment);
                        vertex.y = radius * Math.sin(segment);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        normals.push(0, 0, 1);
                        uv.x = (vertex.x / outerRadius + 1) / 2;
                        uv.y = (vertex.y / outerRadius + 1) / 2;
                        uvs.push(uv.x, uv.y)
                    }
                    radius += radiusStep
                }
                for (j = 0; j < phiSegments; j++) {
                    var thetaSegmentLevel = j * (thetaSegments + 1);
                    for (i = 0; i < thetaSegments; i++) {
                        segment = i + thetaSegmentLevel;
                        var a = segment;
                        var b = segment + thetaSegments + 1;
                        var c = segment + thetaSegments + 2;
                        var d = segment + 1;
                        indices.push(a, b, d);
                        indices.push(b, c, d)
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2))
            }
            RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            RingBufferGeometry.prototype.constructor = RingBufferGeometry;

            function LatheGeometry(points, segments, phiStart, phiLength) {
                Geometry.call(this);
                this.type = "LatheGeometry";
                this.parameters = {
                    points: points,
                    segments: segments,
                    phiStart: phiStart,
                    phiLength: phiLength
                };
                this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
                this.mergeVertices()
            }
            LatheGeometry.prototype = Object.create(Geometry.prototype);
            LatheGeometry.prototype.constructor = LatheGeometry;

            function LatheBufferGeometry(points, segments, phiStart, phiLength) {
                BufferGeometry.call(this);
                this.type = "LatheBufferGeometry";
                this.parameters = {
                    points: points,
                    segments: segments,
                    phiStart: phiStart,
                    phiLength: phiLength
                };
                segments = Math.floor(segments) || 12;
                phiStart = phiStart || 0;
                phiLength = phiLength || Math.PI * 2;
                phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
                var indices = [];
                var vertices = [];
                var uvs = [];
                var base;
                var inverseSegments = 1 / segments;
                var vertex = new Vector3;
                var uv = new Vector2;
                var i, j;
                for (i = 0; i <= segments; i++) {
                    var phi = phiStart + i * inverseSegments * phiLength;
                    var sin = Math.sin(phi);
                    var cos = Math.cos(phi);
                    for (j = 0; j <= points.length - 1; j++) {
                        vertex.x = points[j].x * sin;
                        vertex.y = points[j].y;
                        vertex.z = points[j].x * cos;
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        uv.x = i / segments;
                        uv.y = j / (points.length - 1);
                        uvs.push(uv.x, uv.y)
                    }
                }
                for (i = 0; i < segments; i++) {
                    for (j = 0; j < points.length - 1; j++) {
                        base = j + i * points.length;
                        var a = base;
                        var b = base + points.length;
                        var c = base + points.length + 1;
                        var d = base + 1;
                        indices.push(a, b, d);
                        indices.push(b, c, d)
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
                this.computeVertexNormals();
                if (phiLength === Math.PI * 2) {
                    var normals = this.attributes.normal.array;
                    var n1 = new Vector3;
                    var n2 = new Vector3;
                    var n = new Vector3;
                    base = segments * points.length * 3;
                    for (i = 0, j = 0; i < points.length; i++, j += 3) {
                        n1.x = normals[j + 0];
                        n1.y = normals[j + 1];
                        n1.z = normals[j + 2];
                        n2.x = normals[base + j + 0];
                        n2.y = normals[base + j + 1];
                        n2.z = normals[base + j + 2];
                        n.addVectors(n1, n2).normalize();
                        normals[j + 0] = normals[base + j + 0] = n.x;
                        normals[j + 1] = normals[base + j + 1] = n.y;
                        normals[j + 2] = normals[base + j + 2] = n.z
                    }
                }
            }
            LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

            function ShapeGeometry(shapes, curveSegments) {
                Geometry.call(this);
                this.type = "ShapeGeometry";
                if (typeof curveSegments === "object") {
                    console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
                    curveSegments = curveSegments.curveSegments
                }
                this.parameters = {
                    shapes: shapes,
                    curveSegments: curveSegments
                };
                this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
                this.mergeVertices()
            }
            ShapeGeometry.prototype = Object.create(Geometry.prototype);
            ShapeGeometry.prototype.constructor = ShapeGeometry;
            ShapeGeometry.prototype.toJSON = function() {
                var data = Geometry.prototype.toJSON.call(this);
                var shapes = this.parameters.shapes;
                return toJSON(shapes, data)
            };

            function ShapeBufferGeometry(shapes, curveSegments) {
                BufferGeometry.call(this);
                this.type = "ShapeBufferGeometry";
                this.parameters = {
                    shapes: shapes,
                    curveSegments: curveSegments
                };
                curveSegments = curveSegments || 12;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var groupStart = 0;
                var groupCount = 0;
                if (Array.isArray(shapes) === false) {
                    addShape(shapes)
                } else {
                    for (var i = 0; i < shapes.length; i++) {
                        addShape(shapes[i]);
                        this.addGroup(groupStart, groupCount, i);
                        groupStart += groupCount;
                        groupCount = 0
                    }
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));

                function addShape(shape) {
                    var i, l, shapeHole;
                    var indexOffset = vertices.length / 3;
                    var points = shape.extractPoints(curveSegments);
                    var shapeVertices = points.shape;
                    var shapeHoles = points.holes;
                    if (ShapeUtils.isClockWise(shapeVertices) === false) {
                        shapeVertices = shapeVertices.reverse();
                        for (i = 0, l = shapeHoles.length; i < l; i++) {
                            shapeHole = shapeHoles[i];
                            if (ShapeUtils.isClockWise(shapeHole) === true) {
                                shapeHoles[i] = shapeHole.reverse()
                            }
                        }
                    }
                    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
                    for (i = 0, l = shapeHoles.length; i < l; i++) {
                        shapeHole = shapeHoles[i];
                        shapeVertices = shapeVertices.concat(shapeHole)
                    }
                    for (i = 0, l = shapeVertices.length; i < l; i++) {
                        var vertex = shapeVertices[i];
                        vertices.push(vertex.x, vertex.y, 0);
                        normals.push(0, 0, 1);
                        uvs.push(vertex.x, vertex.y)
                    }
                    for (i = 0, l = faces.length; i < l; i++) {
                        var face = faces[i];
                        var a = face[0] + indexOffset;
                        var b = face[1] + indexOffset;
                        var c = face[2] + indexOffset;
                        indices.push(a, b, c);
                        groupCount += 3
                    }
                }
            }
            ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
            ShapeBufferGeometry.prototype.toJSON = function() {
                var data = BufferGeometry.prototype.toJSON.call(this);
                var shapes = this.parameters.shapes;
                return toJSON(shapes, data)
            };

            function toJSON(shapes, data) {
                data.shapes = [];
                if (Array.isArray(shapes)) {
                    for (var i = 0, l = shapes.length; i < l; i++) {
                        var shape = shapes[i];
                        data.shapes.push(shape.uuid)
                    }
                } else {
                    data.shapes.push(shapes.uuid)
                }
                return data
            }

            function EdgesGeometry(geometry, thresholdAngle) {
                BufferGeometry.call(this);
                this.type = "EdgesGeometry";
                this.parameters = {
                    thresholdAngle: thresholdAngle
                };
                thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
                var vertices = [];
                var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
                var edge = [0, 0],
                    edges = {},
                    edge1, edge2;
                var key, keys = ["a", "b", "c"];
                var geometry2;
                if (geometry.isBufferGeometry) {
                    geometry2 = new Geometry;
                    geometry2.fromBufferGeometry(geometry)
                } else {
                    geometry2 = geometry.clone()
                }
                geometry2.mergeVertices();
                geometry2.computeFaceNormals();
                var sourceVertices = geometry2.vertices;
                var faces = geometry2.faces;
                for (var i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (var j = 0; j < 3; j++) {
                        edge1 = face[keys[j]];
                        edge2 = face[keys[(j + 1) % 3]];
                        edge[0] = Math.min(edge1, edge2);
                        edge[1] = Math.max(edge1, edge2);
                        key = edge[0] + "," + edge[1];
                        if (edges[key] === undefined) {
                            edges[key] = {
                                index1: edge[0],
                                index2: edge[1],
                                face1: i,
                                face2: undefined
                            }
                        } else {
                            edges[key].face2 = i
                        }
                    }
                }
                for (key in edges) {
                    var e = edges[key];
                    if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                        var vertex = sourceVertices[e.index1];
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        vertex = sourceVertices[e.index2];
                        vertices.push(vertex.x, vertex.y, vertex.z)
                    }
                }
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3))
            }
            EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
            EdgesGeometry.prototype.constructor = EdgesGeometry;

            function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
                Geometry.call(this);
                this.type = "CylinderGeometry";
                this.parameters = {
                    radiusTop: radiusTop,
                    radiusBottom: radiusBottom,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    openEnded: openEnded,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
                this.mergeVertices()
            }
            CylinderGeometry.prototype = Object.create(Geometry.prototype);
            CylinderGeometry.prototype.constructor = CylinderGeometry;

            function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
                BufferGeometry.call(this);
                this.type = "CylinderBufferGeometry";
                this.parameters = {
                    radiusTop: radiusTop,
                    radiusBottom: radiusBottom,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    openEnded: openEnded,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                var scope = this;
                radiusTop = radiusTop !== undefined ? radiusTop : 1;
                radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
                height = height || 1;
                radialSegments = Math.floor(radialSegments) || 8;
                heightSegments = Math.floor(heightSegments) || 1;
                openEnded = openEnded !== undefined ? openEnded : false;
                thetaStart = thetaStart !== undefined ? thetaStart : 0;
                thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var index = 0;
                var indexArray = [];
                var halfHeight = height / 2;
                var groupStart = 0;
                generateTorso();
                if (openEnded === false) {
                    if (radiusTop > 0) generateCap(true);
                    if (radiusBottom > 0) generateCap(false)
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));

                function generateTorso() {
                    var x, y;
                    var normal = new Vector3;
                    var vertex = new Vector3;
                    var groupCount = 0;
                    var slope = (radiusBottom - radiusTop) / height;
                    for (y = 0; y <= heightSegments; y++) {
                        var indexRow = [];
                        var v = y / heightSegments;
                        var radius = v * (radiusBottom - radiusTop) + radiusTop;
                        for (x = 0; x <= radialSegments; x++) {
                            var u = x / radialSegments;
                            var theta = u * thetaLength + thetaStart;
                            var sinTheta = Math.sin(theta);
                            var cosTheta = Math.cos(theta);
                            vertex.x = radius * sinTheta;
                            vertex.y = -v * height + halfHeight;
                            vertex.z = radius * cosTheta;
                            vertices.push(vertex.x, vertex.y, vertex.z);
                            normal.set(sinTheta, slope, cosTheta).normalize();
                            normals.push(normal.x, normal.y, normal.z);
                            uvs.push(u, 1 - v);
                            indexRow.push(index++)
                        }
                        indexArray.push(indexRow)
                    }
                    for (x = 0; x < radialSegments; x++) {
                        for (y = 0; y < heightSegments; y++) {
                            var a = indexArray[y][x];
                            var b = indexArray[y + 1][x];
                            var c = indexArray[y + 1][x + 1];
                            var d = indexArray[y][x + 1];
                            indices.push(a, b, d);
                            indices.push(b, c, d);
                            groupCount += 6
                        }
                    }
                    scope.addGroup(groupStart, groupCount, 0);
                    groupStart += groupCount
                }

                function generateCap(top) {
                    var x, centerIndexStart, centerIndexEnd;
                    var uv = new Vector2;
                    var vertex = new Vector3;
                    var groupCount = 0;
                    var radius = top === true ? radiusTop : radiusBottom;
                    var sign = top === true ? 1 : -1;
                    centerIndexStart = index;
                    for (x = 1; x <= radialSegments; x++) {
                        vertices.push(0, halfHeight * sign, 0);
                        normals.push(0, sign, 0);
                        uvs.push(.5, .5);
                        index++
                    }
                    centerIndexEnd = index;
                    for (x = 0; x <= radialSegments; x++) {
                        var u = x / radialSegments;
                        var theta = u * thetaLength + thetaStart;
                        var cosTheta = Math.cos(theta);
                        var sinTheta = Math.sin(theta);
                        vertex.x = radius * sinTheta;
                        vertex.y = halfHeight * sign;
                        vertex.z = radius * cosTheta;
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        normals.push(0, sign, 0);
                        uv.x = cosTheta * .5 + .5;
                        uv.y = sinTheta * .5 * sign + .5;
                        uvs.push(uv.x, uv.y);
                        index++
                    }
                    for (x = 0; x < radialSegments; x++) {
                        var c = centerIndexStart + x;
                        var i = centerIndexEnd + x;
                        if (top === true) {
                            indices.push(i, i + 1, c)
                        } else {
                            indices.push(i + 1, i, c)
                        }
                        groupCount += 3
                    }
                    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
                    groupStart += groupCount
                }
            }
            CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

            function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
                CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
                this.type = "ConeGeometry";
                this.parameters = {
                    radius: radius,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    openEnded: openEnded,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                }
            }
            ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
            ConeGeometry.prototype.constructor = ConeGeometry;

            function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
                CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
                this.type = "ConeBufferGeometry";
                this.parameters = {
                    radius: radius,
                    height: height,
                    radialSegments: radialSegments,
                    heightSegments: heightSegments,
                    openEnded: openEnded,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                }
            }
            ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
            ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

            function CircleGeometry(radius, segments, thetaStart, thetaLength) {
                Geometry.call(this);
                this.type = "CircleGeometry";
                this.parameters = {
                    radius: radius,
                    segments: segments,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
                this.mergeVertices()
            }
            CircleGeometry.prototype = Object.create(Geometry.prototype);
            CircleGeometry.prototype.constructor = CircleGeometry;

            function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
                BufferGeometry.call(this);
                this.type = "CircleBufferGeometry";
                this.parameters = {
                    radius: radius,
                    segments: segments,
                    thetaStart: thetaStart,
                    thetaLength: thetaLength
                };
                radius = radius || 1;
                segments = segments !== undefined ? Math.max(3, segments) : 8;
                thetaStart = thetaStart !== undefined ? thetaStart : 0;
                thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
                var indices = [];
                var vertices = [];
                var normals = [];
                var uvs = [];
                var i, s;
                var vertex = new Vector3;
                var uv = new Vector2;
                vertices.push(0, 0, 0);
                normals.push(0, 0, 1);
                uvs.push(.5, .5);
                for (s = 0, i = 3; s <= segments; s++, i += 3) {
                    var segment = thetaStart + s / segments * thetaLength;
                    vertex.x = radius * Math.cos(segment);
                    vertex.y = radius * Math.sin(segment);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    normals.push(0, 0, 1);
                    uv.x = (vertices[i] / radius + 1) / 2;
                    uv.y = (vertices[i + 1] / radius + 1) / 2;
                    uvs.push(uv.x, uv.y)
                }
                for (i = 1; i <= segments; i++) {
                    indices.push(i, i + 1, 0)
                }
                this.setIndex(indices);
                this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
                this.addAttribute("uv", new Float32BufferAttribute(uvs, 2))
            }
            CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
            CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
            var Geometries = Object.freeze({
                WireframeGeometry: WireframeGeometry,
                ParametricGeometry: ParametricGeometry,
                ParametricBufferGeometry: ParametricBufferGeometry,
                TetrahedronGeometry: TetrahedronGeometry,
                TetrahedronBufferGeometry: TetrahedronBufferGeometry,
                OctahedronGeometry: OctahedronGeometry,
                OctahedronBufferGeometry: OctahedronBufferGeometry,
                IcosahedronGeometry: IcosahedronGeometry,
                IcosahedronBufferGeometry: IcosahedronBufferGeometry,
                DodecahedronGeometry: DodecahedronGeometry,
                DodecahedronBufferGeometry: DodecahedronBufferGeometry,
                PolyhedronGeometry: PolyhedronGeometry,
                PolyhedronBufferGeometry: PolyhedronBufferGeometry,
                TubeGeometry: TubeGeometry,
                TubeBufferGeometry: TubeBufferGeometry,
                TorusKnotGeometry: TorusKnotGeometry,
                TorusKnotBufferGeometry: TorusKnotBufferGeometry,
                TorusGeometry: TorusGeometry,
                TorusBufferGeometry: TorusBufferGeometry,
                TextGeometry: TextGeometry,
                TextBufferGeometry: TextBufferGeometry,
                SphereGeometry: SphereGeometry,
                SphereBufferGeometry: SphereBufferGeometry,
                RingGeometry: RingGeometry,
                RingBufferGeometry: RingBufferGeometry,
                PlaneGeometry: PlaneGeometry,
                PlaneBufferGeometry: PlaneBufferGeometry,
                LatheGeometry: LatheGeometry,
                LatheBufferGeometry: LatheBufferGeometry,
                ShapeGeometry: ShapeGeometry,
                ShapeBufferGeometry: ShapeBufferGeometry,
                ExtrudeGeometry: ExtrudeGeometry,
                ExtrudeBufferGeometry: ExtrudeBufferGeometry,
                EdgesGeometry: EdgesGeometry,
                ConeGeometry: ConeGeometry,
                ConeBufferGeometry: ConeBufferGeometry,
                CylinderGeometry: CylinderGeometry,
                CylinderBufferGeometry: CylinderBufferGeometry,
                CircleGeometry: CircleGeometry,
                CircleBufferGeometry: CircleBufferGeometry,
                BoxGeometry: BoxGeometry,
                BoxBufferGeometry: BoxBufferGeometry
            });

            function ShadowMaterial(parameters) {
                Material.call(this);
                this.type = "ShadowMaterial";
                this.color = new Color(0);
                this.transparent = true;
                this.setValues(parameters)
            }
            ShadowMaterial.prototype = Object.create(Material.prototype);
            ShadowMaterial.prototype.constructor = ShadowMaterial;
            ShadowMaterial.prototype.isShadowMaterial = true;
            ShadowMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                return this
            };

            function RawShaderMaterial(parameters) {
                ShaderMaterial.call(this, parameters);
                this.type = "RawShaderMaterial"
            }
            RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
            RawShaderMaterial.prototype.constructor = RawShaderMaterial;
            RawShaderMaterial.prototype.isRawShaderMaterial = true;

            function MeshStandardMaterial(parameters) {
                Material.call(this);
                this.defines = {
                    STANDARD: ""
                };
                this.type = "MeshStandardMaterial";
                this.color = new Color(16777215);
                this.roughness = .5;
                this.metalness = .5;
                this.map = null;
                this.lightMap = null;
                this.lightMapIntensity = 1;
                this.aoMap = null;
                this.aoMapIntensity = 1;
                this.emissive = new Color(0);
                this.emissiveIntensity = 1;
                this.emissiveMap = null;
                this.bumpMap = null;
                this.bumpScale = 1;
                this.normalMap = null;
                this.normalScale = new Vector2(1, 1);
                this.displacementMap = null;
                this.displacementScale = 1;
                this.displacementBias = 0;
                this.roughnessMap = null;
                this.metalnessMap = null;
                this.alphaMap = null;
                this.envMap = null;
                this.envMapIntensity = 1;
                this.refractionRatio = .98;
                this.wireframe = false;
                this.wireframeLinewidth = 1;
                this.wireframeLinecap = "round";
                this.wireframeLinejoin = "round";
                this.skinning = false;
                this.morphTargets = false;
                this.morphNormals = false;
                this.setValues(parameters)
            }
            MeshStandardMaterial.prototype = Object.create(Material.prototype);
            MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
            MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
            MeshStandardMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.defines = {
                    STANDARD: ""
                };
                this.color.copy(source.color);
                this.roughness = source.roughness;
                this.metalness = source.metalness;
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy(source.emissive);
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.roughnessMap = source.roughnessMap;
                this.metalnessMap = source.metalnessMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.envMapIntensity = source.envMapIntensity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this
            };

            function MeshPhysicalMaterial(parameters) {
                MeshStandardMaterial.call(this);
                this.defines = {
                    PHYSICAL: ""
                };
                this.type = "MeshPhysicalMaterial";
                this.reflectivity = .5;
                this.clearCoat = 0;
                this.clearCoatRoughness = 0;
                this.setValues(parameters)
            }
            MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
            MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
            MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
            MeshPhysicalMaterial.prototype.copy = function(source) {
                MeshStandardMaterial.prototype.copy.call(this, source);
                this.defines = {
                    PHYSICAL: ""
                };
                this.reflectivity = source.reflectivity;
                this.clearCoat = source.clearCoat;
                this.clearCoatRoughness = source.clearCoatRoughness;
                return this
            };

            function MeshPhongMaterial(parameters) {
                Material.call(this);
                this.type = "MeshPhongMaterial";
                this.color = new Color(16777215);
                this.specular = new Color(1118481);
                this.shininess = 30;
                this.map = null;
                this.lightMap = null;
                this.lightMapIntensity = 1;
                this.aoMap = null;
                this.aoMapIntensity = 1;
                this.emissive = new Color(0);
                this.emissiveIntensity = 1;
                this.emissiveMap = null;
                this.bumpMap = null;
                this.bumpScale = 1;
                this.normalMap = null;
                this.normalScale = new Vector2(1, 1);
                this.displacementMap = null;
                this.displacementScale = 1;
                this.displacementBias = 0;
                this.specularMap = null;
                this.alphaMap = null;
                this.envMap = null;
                this.combine = MultiplyOperation;
                this.reflectivity = 1;
                this.refractionRatio = .98;
                this.wireframe = false;
                this.wireframeLinewidth = 1;
                this.wireframeLinecap = "round";
                this.wireframeLinejoin = "round";
                this.skinning = false;
                this.morphTargets = false;
                this.morphNormals = false;
                this.setValues(parameters)
            }
            MeshPhongMaterial.prototype = Object.create(Material.prototype);
            MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
            MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
            MeshPhongMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.specular.copy(source.specular);
                this.shininess = source.shininess;
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy(source.emissive);
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.combine = source.combine;
                this.reflectivity = source.reflectivity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this
            };

            function MeshToonMaterial(parameters) {
                MeshPhongMaterial.call(this);
                this.defines = {
                    TOON: ""
                };
                this.type = "MeshToonMaterial";
                this.gradientMap = null;
                this.setValues(parameters)
            }
            MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
            MeshToonMaterial.prototype.constructor = MeshToonMaterial;
            MeshToonMaterial.prototype.isMeshToonMaterial = true;
            MeshToonMaterial.prototype.copy = function(source) {
                MeshPhongMaterial.prototype.copy.call(this, source);
                this.gradientMap = source.gradientMap;
                return this
            };

            function MeshNormalMaterial(parameters) {
                Material.call(this);
                this.type = "MeshNormalMaterial";
                this.bumpMap = null;
                this.bumpScale = 1;
                this.normalMap = null;
                this.normalScale = new Vector2(1, 1);
                this.displacementMap = null;
                this.displacementScale = 1;
                this.displacementBias = 0;
                this.wireframe = false;
                this.wireframeLinewidth = 1;
                this.fog = false;
                this.lights = false;
                this.skinning = false;
                this.morphTargets = false;
                this.morphNormals = false;
                this.setValues(parameters)
            }
            MeshNormalMaterial.prototype = Object.create(Material.prototype);
            MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
            MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
            MeshNormalMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.bumpMap = source.bumpMap;
                this.bumpScale = source.bumpScale;
                this.normalMap = source.normalMap;
                this.normalScale.copy(source.normalScale);
                this.displacementMap = source.displacementMap;
                this.displacementScale = source.displacementScale;
                this.displacementBias = source.displacementBias;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this
            };

            function MeshLambertMaterial(parameters) {
                Material.call(this);
                this.type = "MeshLambertMaterial";
                this.color = new Color(16777215);
                this.map = null;
                this.lightMap = null;
                this.lightMapIntensity = 1;
                this.aoMap = null;
                this.aoMapIntensity = 1;
                this.emissive = new Color(0);
                this.emissiveIntensity = 1;
                this.emissiveMap = null;
                this.specularMap = null;
                this.alphaMap = null;
                this.envMap = null;
                this.combine = MultiplyOperation;
                this.reflectivity = 1;
                this.refractionRatio = .98;
                this.wireframe = false;
                this.wireframeLinewidth = 1;
                this.wireframeLinecap = "round";
                this.wireframeLinejoin = "round";
                this.skinning = false;
                this.morphTargets = false;
                this.morphNormals = false;
                this.setValues(parameters)
            }
            MeshLambertMaterial.prototype = Object.create(Material.prototype);
            MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
            MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
            MeshLambertMaterial.prototype.copy = function(source) {
                Material.prototype.copy.call(this, source);
                this.color.copy(source.color);
                this.map = source.map;
                this.lightMap = source.lightMap;
                this.lightMapIntensity = source.lightMapIntensity;
                this.aoMap = source.aoMap;
                this.aoMapIntensity = source.aoMapIntensity;
                this.emissive.copy(source.emissive);
                this.emissiveMap = source.emissiveMap;
                this.emissiveIntensity = source.emissiveIntensity;
                this.specularMap = source.specularMap;
                this.alphaMap = source.alphaMap;
                this.envMap = source.envMap;
                this.combine = source.combine;
                this.reflectivity = source.reflectivity;
                this.refractionRatio = source.refractionRatio;
                this.wireframe = source.wireframe;
                this.wireframeLinewidth = source.wireframeLinewidth;
                this.wireframeLinecap = source.wireframeLinecap;
                this.wireframeLinejoin = source.wireframeLinejoin;
                this.skinning = source.skinning;
                this.morphTargets = source.morphTargets;
                this.morphNormals = source.morphNormals;
                return this
            };

            function LineDashedMaterial(parameters) {
                LineBasicMaterial.call(this);
                this.type = "LineDashedMaterial";
                this.scale = 1;
                this.dashSize = 3;
                this.gapSize = 1;
                this.setValues(parameters)
            }
            LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
            LineDashedMaterial.prototype.constructor = LineDashedMaterial;
            LineDashedMaterial.prototype.isLineDashedMaterial = true;
            LineDashedMaterial.prototype.copy = function(source) {
                LineBasicMaterial.prototype.copy.call(this, source);
                this.scale = source.scale;
                this.dashSize = source.dashSize;
                this.gapSize = source.gapSize;
                return this
            };
            var Materials = Object.freeze({
                ShadowMaterial: ShadowMaterial,
                SpriteMaterial: SpriteMaterial,
                RawShaderMaterial: RawShaderMaterial,
                ShaderMaterial: ShaderMaterial,
                PointsMaterial: PointsMaterial,
                MeshPhysicalMaterial: MeshPhysicalMaterial,
                MeshStandardMaterial: MeshStandardMaterial,
                MeshPhongMaterial: MeshPhongMaterial,
                MeshToonMaterial: MeshToonMaterial,
                MeshNormalMaterial: MeshNormalMaterial,
                MeshLambertMaterial: MeshLambertMaterial,
                MeshDepthMaterial: MeshDepthMaterial,
                MeshDistanceMaterial: MeshDistanceMaterial,
                MeshBasicMaterial: MeshBasicMaterial,
                LineDashedMaterial: LineDashedMaterial,
                LineBasicMaterial: LineBasicMaterial,
                Material: Material
            });
            var Cache = {
                enabled: false,
                files: {},
                add: function(key, file) {
                    if (this.enabled === false) return;
                    this.files[key] = file
                },
                get: function(key) {
                    if (this.enabled === false) return;
                    return this.files[key]
                },
                remove: function(key) {
                    delete this.files[key]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function LoadingManager(onLoad, onProgress, onError) {
                var scope = this;
                var isLoading = false;
                var itemsLoaded = 0;
                var itemsTotal = 0;
                var urlModifier = undefined;
                this.onStart = undefined;
                this.onLoad = onLoad;
                this.onProgress = onProgress;
                this.onError = onError;
                this.itemStart = function(url) {
                    itemsTotal++;
                    if (isLoading === false) {
                        if (scope.onStart !== undefined) {
                            scope.onStart(url, itemsLoaded, itemsTotal)
                        }
                    }
                    isLoading = true
                };
                this.itemEnd = function(url) {
                    itemsLoaded++;
                    if (scope.onProgress !== undefined) {
                        scope.onProgress(url, itemsLoaded, itemsTotal)
                    }
                    if (itemsLoaded === itemsTotal) {
                        isLoading = false;
                        if (scope.onLoad !== undefined) {
                            scope.onLoad()
                        }
                    }
                };
                this.itemError = function(url) {
                    if (scope.onError !== undefined) {
                        scope.onError(url)
                    }
                };
                this.resolveURL = function(url) {
                    if (urlModifier) {
                        return urlModifier(url)
                    }
                    return url
                };
                this.setURLModifier = function(transform) {
                    urlModifier = transform;
                    return this
                }
            }
            var DefaultLoadingManager = new LoadingManager;
            var loading = {};

            function FileLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager
            }
            Object.assign(FileLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    if (url === undefined) url = "";
                    if (this.path !== undefined) url = this.path + url;
                    url = this.manager.resolveURL(url);
                    var scope = this;
                    var cached = Cache.get(url);
                    if (cached !== undefined) {
                        scope.manager.itemStart(url);
                        setTimeout(function() {
                            if (onLoad) onLoad(cached);
                            scope.manager.itemEnd(url)
                        }, 0);
                        return cached
                    }
                    if (loading[url] !== undefined) {
                        loading[url].push({
                            onLoad: onLoad,
                            onProgress: onProgress,
                            onError: onError
                        });
                        return
                    }
                    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
                    var dataUriRegexResult = url.match(dataUriRegex);
                    if (dataUriRegexResult) {
                        var mimeType = dataUriRegexResult[1];
                        var isBase64 = !!dataUriRegexResult[2];
                        var data = dataUriRegexResult[3];
                        data = window.decodeURIComponent(data);
                        if (isBase64) data = window.atob(data);
                        try {
                            var response;
                            var responseType = (this.responseType || "").toLowerCase();
                            switch (responseType) {
                                case "arraybuffer":
                                case "blob":
                                    var view = new Uint8Array(data.length);
                                    for (var i = 0; i < data.length; i++) {
                                        view[i] = data.charCodeAt(i)
                                    }
                                    if (responseType === "blob") {
                                        response = new Blob([view.buffer], {
                                            type: mimeType
                                        })
                                    } else {
                                        response = view.buffer
                                    }
                                    break;
                                case "document":
                                    var parser = new DOMParser;
                                    response = parser.parseFromString(data, mimeType);
                                    break;
                                case "json":
                                    response = JSON.parse(data);
                                    break;
                                default:
                                    response = data;
                                    break
                            }
                            window.setTimeout(function() {
                                if (onLoad) onLoad(response);
                                scope.manager.itemEnd(url)
                            }, 0)
                        } catch (error) {
                            window.setTimeout(function() {
                                if (onError) onError(error);
                                scope.manager.itemEnd(url);
                                scope.manager.itemError(url)
                            }, 0)
                        }
                    } else {
                        loading[url] = [];
                        loading[url].push({
                            onLoad: onLoad,
                            onProgress: onProgress,
                            onError: onError
                        });
                        var request = new XMLHttpRequest;
                        request.open("GET", url, true);
                        request.addEventListener("load", function(event) {
                            var response = this.response;
                            Cache.add(url, response);
                            var callbacks = loading[url];
                            delete loading[url];
                            if (this.status === 200) {
                                for (var i = 0, il = callbacks.length; i < il; i++) {
                                    var callback = callbacks[i];
                                    if (callback.onLoad) callback.onLoad(response)
                                }
                                scope.manager.itemEnd(url)
                            } else if (this.status === 0) {
                                console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var i = 0, il = callbacks.length; i < il; i++) {
                                    var callback = callbacks[i];
                                    if (callback.onLoad) callback.onLoad(response)
                                }
                                scope.manager.itemEnd(url)
                            } else {
                                for (var i = 0, il = callbacks.length; i < il; i++) {
                                    var callback = callbacks[i];
                                    if (callback.onError) callback.onError(event)
                                }
                                scope.manager.itemEnd(url);
                                scope.manager.itemError(url)
                            }
                        }, false);
                        request.addEventListener("progress", function(event) {
                            var callbacks = loading[url];
                            for (var i = 0, il = callbacks.length; i < il; i++) {
                                var callback = callbacks[i];
                                if (callback.onProgress) callback.onProgress(event)
                            }
                        }, false);
                        request.addEventListener("error", function(event) {
                            var callbacks = loading[url];
                            delete loading[url];
                            for (var i = 0, il = callbacks.length; i < il; i++) {
                                var callback = callbacks[i];
                                if (callback.onError) callback.onError(event)
                            }
                            scope.manager.itemEnd(url);
                            scope.manager.itemError(url)
                        }, false);
                        if (this.responseType !== undefined) request.responseType = this.responseType;
                        if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
                        if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : "text/plain");
                        for (var header in this.requestHeader) {
                            request.setRequestHeader(header, this.requestHeader[header])
                        }
                        request.send(null)
                    }
                    scope.manager.itemStart(url);
                    return request
                },
                setPath: function(value) {
                    this.path = value;
                    return this
                },
                setResponseType: function(value) {
                    this.responseType = value;
                    return this
                },
                setWithCredentials: function(value) {
                    this.withCredentials = value;
                    return this
                },
                setMimeType: function(value) {
                    this.mimeType = value;
                    return this
                },
                setRequestHeader: function(value) {
                    this.requestHeader = value;
                    return this
                }
            });

            function CompressedTextureLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager;
                this._parser = null
            }
            Object.assign(CompressedTextureLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this;
                    var images = [];
                    var texture = new CompressedTexture;
                    texture.image = images;
                    var loader = new FileLoader(this.manager);
                    loader.setPath(this.path);
                    loader.setResponseType("arraybuffer");

                    function loadTexture(i) {
                        loader.load(url[i], function(buffer) {
                            var texDatas = scope._parser(buffer, true);
                            images[i] = {
                                width: texDatas.width,
                                height: texDatas.height,
                                format: texDatas.format,
                                mipmaps: texDatas.mipmaps
                            };
                            loaded += 1;
                            if (loaded === 6) {
                                if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                                texture.format = texDatas.format;
                                texture.needsUpdate = true;
                                if (onLoad) onLoad(texture)
                            }
                        }, onProgress, onError)
                    }
                    if (Array.isArray(url)) {
                        var loaded = 0;
                        for (var i = 0, il = url.length; i < il; ++i) {
                            loadTexture(i)
                        }
                    } else {
                        loader.load(url, function(buffer) {
                            var texDatas = scope._parser(buffer, true);
                            if (texDatas.isCubemap) {
                                var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                                for (var f = 0; f < faces; f++) {
                                    images[f] = {
                                        mipmaps: []
                                    };
                                    for (var i = 0; i < texDatas.mipmapCount; i++) {
                                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                        images[f].format = texDatas.format;
                                        images[f].width = texDatas.width;
                                        images[f].height = texDatas.height
                                    }
                                }
                            } else {
                                texture.image.width = texDatas.width;
                                texture.image.height = texDatas.height;
                                texture.mipmaps = texDatas.mipmaps
                            }
                            if (texDatas.mipmapCount === 1) {
                                texture.minFilter = LinearFilter
                            }
                            texture.format = texDatas.format;
                            texture.needsUpdate = true;
                            if (onLoad) onLoad(texture)
                        }, onProgress, onError)
                    }
                    return texture
                },
                setPath: function(value) {
                    this.path = value;
                    return this
                }
            });

            function DataTextureLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager;
                this._parser = null
            }
            Object.assign(DataTextureLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this;
                    var texture = new DataTexture;
                    var loader = new FileLoader(this.manager);
                    loader.setResponseType("arraybuffer");
                    loader.load(url, function(buffer) {
                        var texData = scope._parser(buffer);
                        if (!texData) return;
                        if (undefined !== texData.image) {
                            texture.image = texData.image
                        } else if (undefined !== texData.data) {
                            texture.image.width = texData.width;
                            texture.image.height = texData.height;
                            texture.image.data = texData.data
                        }
                        texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
                        texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
                        texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
                        texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
                        texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
                        if (undefined !== texData.format) {
                            texture.format = texData.format
                        }
                        if (undefined !== texData.type) {
                            texture.type = texData.type
                        }
                        if (undefined !== texData.mipmaps) {
                            texture.mipmaps = texData.mipmaps
                        }
                        if (1 === texData.mipmapCount) {
                            texture.minFilter = LinearFilter
                        }
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture, texData)
                    }, onProgress, onError);
                    return texture
                }
            });

            function ImageLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager
            }
            Object.assign(ImageLoader.prototype, {
                crossOrigin: "Anonymous",
                load: function(url, onLoad, onProgress, onError) {
                    if (url === undefined) url = "";
                    if (this.path !== undefined) url = this.path + url;
                    url = this.manager.resolveURL(url);
                    var scope = this;
                    var cached = Cache.get(url);
                    if (cached !== undefined) {
                        scope.manager.itemStart(url);
                        setTimeout(function() {
                            if (onLoad) onLoad(cached);
                            scope.manager.itemEnd(url)
                        }, 0);
                        return cached
                    }
                    var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    image.addEventListener("load", function() {
                        Cache.add(url, this);
                        if (onLoad) onLoad(this);
                        scope.manager.itemEnd(url)
                    }, false);
                    image.addEventListener("error", function(event) {
                        if (onError) onError(event);
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url)
                    }, false);
                    if (url.substr(0, 5) !== "data:") {
                        if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin
                    }
                    scope.manager.itemStart(url);
                    image.src = url;
                    return image
                },
                setCrossOrigin: function(value) {
                    this.crossOrigin = value;
                    return this
                },
                setPath: function(value) {
                    this.path = value;
                    return this
                }
            });

            function CubeTextureLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager
            }
            Object.assign(CubeTextureLoader.prototype, {
                crossOrigin: "Anonymous",
                load: function(urls, onLoad, onProgress, onError) {
                    var texture = new CubeTexture;
                    var loader = new ImageLoader(this.manager);
                    loader.setCrossOrigin(this.crossOrigin);
                    loader.setPath(this.path);
                    var loaded = 0;

                    function loadTexture(i) {
                        loader.load(urls[i], function(image) {
                            texture.images[i] = image;
                            loaded++;
                            if (loaded === 6) {
                                texture.needsUpdate = true;
                                if (onLoad) onLoad(texture)
                            }
                        }, undefined, onError)
                    }
                    for (var i = 0; i < urls.length; ++i) {
                        loadTexture(i)
                    }
                    return texture
                },
                setCrossOrigin: function(value) {
                    this.crossOrigin = value;
                    return this
                },
                setPath: function(value) {
                    this.path = value;
                    return this
                }
            });

            function TextureLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager
            }
            Object.assign(TextureLoader.prototype, {
                crossOrigin: "Anonymous",
                load: function(url, onLoad, onProgress, onError) {
                    var texture = new Texture;
                    var loader = new ImageLoader(this.manager);
                    loader.setCrossOrigin(this.crossOrigin);
                    loader.setPath(this.path);
                    loader.load(url, function(image) {
                        texture.image = image;
                        var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                        texture.format = isJPEG ? RGBFormat : RGBAFormat;
                        texture.needsUpdate = true;
                        if (onLoad !== undefined) {
                            onLoad(texture)
                        }
                    }, onProgress, onError);
                    return texture
                },
                setCrossOrigin: function(value) {
                    this.crossOrigin = value;
                    return this
                },
                setPath: function(value) {
                    this.path = value;
                    return this
                }
            });

            function Curve() {
                this.type = "Curve";
                this.arcLengthDivisions = 200
            }
            Object.assign(Curve.prototype, {
                getPoint: function() {
                    console.warn("THREE.Curve: .getPoint() not implemented.");
                    return null
                },
                getPointAt: function(u, optionalTarget) {
                    var t = this.getUtoTmapping(u);
                    return this.getPoint(t, optionalTarget)
                },
                getPoints: function(divisions) {
                    if (divisions === undefined) divisions = 5;
                    var points = [];
                    for (var d = 0; d <= divisions; d++) {
                        points.push(this.getPoint(d / divisions))
                    }
                    return points
                },
                getSpacedPoints: function(divisions) {
                    if (divisions === undefined) divisions = 5;
                    var points = [];
                    for (var d = 0; d <= divisions; d++) {
                        points.push(this.getPointAt(d / divisions))
                    }
                    return points
                },
                getLength: function() {
                    var lengths = this.getLengths();
                    return lengths[lengths.length - 1]
                },
                getLengths: function(divisions) {
                    if (divisions === undefined) divisions = this.arcLengthDivisions;
                    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
                        return this.cacheArcLengths
                    }
                    this.needsUpdate = false;
                    var cache = [];
                    var current, last = this.getPoint(0);
                    var p, sum = 0;
                    cache.push(0);
                    for (p = 1; p <= divisions; p++) {
                        current = this.getPoint(p / divisions);
                        sum += current.distanceTo(last);
                        cache.push(sum);
                        last = current
                    }
                    this.cacheArcLengths = cache;
                    return cache
                },
                updateArcLengths: function() {
                    this.needsUpdate = true;
                    this.getLengths()
                },
                getUtoTmapping: function(u, distance) {
                    var arcLengths = this.getLengths();
                    var i = 0,
                        il = arcLengths.length;
                    var targetArcLength;
                    if (distance) {
                        targetArcLength = distance
                    } else {
                        targetArcLength = u * arcLengths[il - 1]
                    }
                    var low = 0,
                        high = il - 1,
                        comparison;
                    while (low <= high) {
                        i = Math.floor(low + (high - low) / 2);
                        comparison = arcLengths[i] - targetArcLength;
                        if (comparison < 0) {
                            low = i + 1
                        } else if (comparison > 0) {
                            high = i - 1
                        } else {
                            high = i;
                            break
                        }
                    }
                    i = high;
                    if (arcLengths[i] === targetArcLength) {
                        return i / (il - 1)
                    }
                    var lengthBefore = arcLengths[i];
                    var lengthAfter = arcLengths[i + 1];
                    var segmentLength = lengthAfter - lengthBefore;
                    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
                    var t = (i + segmentFraction) / (il - 1);
                    return t
                },
                getTangent: function(t) {
                    var delta = 1e-4;
                    var t1 = t - delta;
                    var t2 = t + delta;
                    if (t1 < 0) t1 = 0;
                    if (t2 > 1) t2 = 1;
                    var pt1 = this.getPoint(t1);
                    var pt2 = this.getPoint(t2);
                    var vec = pt2.clone().sub(pt1);
                    return vec.normalize()
                },
                getTangentAt: function(u) {
                    var t = this.getUtoTmapping(u);
                    return this.getTangent(t)
                },
                computeFrenetFrames: function(segments, closed) {
                    var normal = new Vector3;
                    var tangents = [];
                    var normals = [];
                    var binormals = [];
                    var vec = new Vector3;
                    var mat = new Matrix4;
                    var i, u, theta;
                    for (i = 0; i <= segments; i++) {
                        u = i / segments;
                        tangents[i] = this.getTangentAt(u);
                        tangents[i].normalize()
                    }
                    normals[0] = new Vector3;
                    binormals[0] = new Vector3;
                    var min = Number.MAX_VALUE;
                    var tx = Math.abs(tangents[0].x);
                    var ty = Math.abs(tangents[0].y);
                    var tz = Math.abs(tangents[0].z);
                    if (tx <= min) {
                        min = tx;
                        normal.set(1, 0, 0)
                    }
                    if (ty <= min) {
                        min = ty;
                        normal.set(0, 1, 0)
                    }
                    if (tz <= min) {
                        normal.set(0, 0, 1)
                    }
                    vec.crossVectors(tangents[0], normal).normalize();
                    normals[0].crossVectors(tangents[0], vec);
                    binormals[0].crossVectors(tangents[0], normals[0]);
                    for (i = 1; i <= segments; i++) {
                        normals[i] = normals[i - 1].clone();
                        binormals[i] = binormals[i - 1].clone();
                        vec.crossVectors(tangents[i - 1], tangents[i]);
                        if (vec.length() > Number.EPSILON) {
                            vec.normalize();
                            theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                            normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))
                        }
                        binormals[i].crossVectors(tangents[i], normals[i])
                    }
                    if (closed === true) {
                        theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                        theta /= segments;
                        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                            theta = -theta
                        }
                        for (i = 1; i <= segments; i++) {
                            normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                            binormals[i].crossVectors(tangents[i], normals[i])
                        }
                    }
                    return {
                        tangents: tangents,
                        normals: normals,
                        binormals: binormals
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(source) {
                    this.arcLengthDivisions = source.arcLengthDivisions;
                    return this
                },
                toJSON: function() {
                    var data = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    data.arcLengthDivisions = this.arcLengthDivisions;
                    data.type = this.type;
                    return data
                },
                fromJSON: function(json) {
                    this.arcLengthDivisions = json.arcLengthDivisions;
                    return this
                }
            });

            function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                Curve.call(this);
                this.type = "EllipseCurve";
                this.aX = aX || 0;
                this.aY = aY || 0;
                this.xRadius = xRadius || 1;
                this.yRadius = yRadius || 1;
                this.aStartAngle = aStartAngle || 0;
                this.aEndAngle = aEndAngle || 2 * Math.PI;
                this.aClockwise = aClockwise || false;
                this.aRotation = aRotation || 0
            }
            EllipseCurve.prototype = Object.create(Curve.prototype);
            EllipseCurve.prototype.constructor = EllipseCurve;
            EllipseCurve.prototype.isEllipseCurve = true;
            EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector2;
                var twoPi = Math.PI * 2;
                var deltaAngle = this.aEndAngle - this.aStartAngle;
                var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
                while (deltaAngle < 0) deltaAngle += twoPi;
                while (deltaAngle > twoPi) deltaAngle -= twoPi;
                if (deltaAngle < Number.EPSILON) {
                    if (samePoints) {
                        deltaAngle = 0
                    } else {
                        deltaAngle = twoPi
                    }
                }
                if (this.aClockwise === true && !samePoints) {
                    if (deltaAngle === twoPi) {
                        deltaAngle = -twoPi
                    } else {
                        deltaAngle = deltaAngle - twoPi
                    }
                }
                var angle = this.aStartAngle + t * deltaAngle;
                var x = this.aX + this.xRadius * Math.cos(angle);
                var y = this.aY + this.yRadius * Math.sin(angle);
                if (this.aRotation !== 0) {
                    var cos = Math.cos(this.aRotation);
                    var sin = Math.sin(this.aRotation);
                    var tx = x - this.aX;
                    var ty = y - this.aY;
                    x = tx * cos - ty * sin + this.aX;
                    y = tx * sin + ty * cos + this.aY
                }
                return point.set(x, y)
            };
            EllipseCurve.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.aX = source.aX;
                this.aY = source.aY;
                this.xRadius = source.xRadius;
                this.yRadius = source.yRadius;
                this.aStartAngle = source.aStartAngle;
                this.aEndAngle = source.aEndAngle;
                this.aClockwise = source.aClockwise;
                this.aRotation = source.aRotation;
                return this
            };
            EllipseCurve.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.aX = this.aX;
                data.aY = this.aY;
                data.xRadius = this.xRadius;
                data.yRadius = this.yRadius;
                data.aStartAngle = this.aStartAngle;
                data.aEndAngle = this.aEndAngle;
                data.aClockwise = this.aClockwise;
                data.aRotation = this.aRotation;
                return data
            };
            EllipseCurve.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.aX = json.aX;
                this.aY = json.aY;
                this.xRadius = json.xRadius;
                this.yRadius = json.yRadius;
                this.aStartAngle = json.aStartAngle;
                this.aEndAngle = json.aEndAngle;
                this.aClockwise = json.aClockwise;
                this.aRotation = json.aRotation;
                return this
            };

            function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
                this.type = "ArcCurve"
            }
            ArcCurve.prototype = Object.create(EllipseCurve.prototype);
            ArcCurve.prototype.constructor = ArcCurve;
            ArcCurve.prototype.isArcCurve = true;

            function CubicPoly() {
                var c0 = 0,
                    c1 = 0,
                    c2 = 0,
                    c3 = 0;

                function init(x0, x1, t0, t1) {
                    c0 = x0;
                    c1 = t0;
                    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
                    c3 = 2 * x0 - 2 * x1 + t0 + t1
                }
                return {
                    initCatmullRom: function(x0, x1, x2, x3, tension) {
                        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1))
                    },
                    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
                        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                        t1 *= dt1;
                        t2 *= dt1;
                        init(x1, x2, t1, t2)
                    },
                    calc: function(t) {
                        var t2 = t * t;
                        var t3 = t2 * t;
                        return c0 + c1 * t + c2 * t2 + c3 * t3
                    }
                }
            }
            var tmp = new Vector3;
            var px = new CubicPoly;
            var py = new CubicPoly;
            var pz = new CubicPoly;

            function CatmullRomCurve3(points, closed, curveType, tension) {
                Curve.call(this);
                this.type = "CatmullRomCurve3";
                this.points = points || [];
                this.closed = closed || false;
                this.curveType = curveType || "centripetal";
                this.tension = tension || .5
            }
            CatmullRomCurve3.prototype = Object.create(Curve.prototype);
            CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
            CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
            CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector3;
                var points = this.points;
                var l = points.length;
                var p = (l - (this.closed ? 0 : 1)) * t;
                var intPoint = Math.floor(p);
                var weight = p - intPoint;
                if (this.closed) {
                    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length
                } else if (weight === 0 && intPoint === l - 1) {
                    intPoint = l - 2;
                    weight = 1
                }
                var p0, p1, p2, p3;
                if (this.closed || intPoint > 0) {
                    p0 = points[(intPoint - 1) % l]
                } else {
                    tmp.subVectors(points[0], points[1]).add(points[0]);
                    p0 = tmp
                }
                p1 = points[intPoint % l];
                p2 = points[(intPoint + 1) % l];
                if (this.closed || intPoint + 2 < l) {
                    p3 = points[(intPoint + 2) % l]
                } else {
                    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                    p3 = tmp
                }
                if (this.curveType === "centripetal" || this.curveType === "chordal") {
                    var pow = this.curveType === "chordal" ? .5 : .25;
                    var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                    var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                    var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                    if (dt1 < 1e-4) dt1 = 1;
                    if (dt0 < 1e-4) dt0 = dt1;
                    if (dt2 < 1e-4) dt2 = dt1;
                    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2)
                } else if (this.curveType === "catmullrom") {
                    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
                    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
                    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension)
                }
                point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
                return point
            };
            CatmullRomCurve3.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.points = [];
                for (var i = 0, l = source.points.length; i < l; i++) {
                    var point = source.points[i];
                    this.points.push(point.clone())
                }
                this.closed = source.closed;
                this.curveType = source.curveType;
                this.tension = source.tension;
                return this
            };
            CatmullRomCurve3.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.points = [];
                for (var i = 0, l = this.points.length; i < l; i++) {
                    var point = this.points[i];
                    data.points.push(point.toArray())
                }
                data.closed = this.closed;
                data.curveType = this.curveType;
                data.tension = this.tension;
                return data
            };
            CatmullRomCurve3.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.points = [];
                for (var i = 0, l = json.points.length; i < l; i++) {
                    var point = json.points[i];
                    this.points.push((new Vector3).fromArray(point))
                }
                this.closed = json.closed;
                this.curveType = json.curveType;
                this.tension = json.tension;
                return this
            };

            function CatmullRom(t, p0, p1, p2, p3) {
                var v0 = (p2 - p0) * .5;
                var v1 = (p3 - p1) * .5;
                var t2 = t * t;
                var t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1
            }

            function QuadraticBezierP0(t, p) {
                var k = 1 - t;
                return k * k * p
            }

            function QuadraticBezierP1(t, p) {
                return 2 * (1 - t) * t * p
            }

            function QuadraticBezierP2(t, p) {
                return t * t * p
            }

            function QuadraticBezier(t, p0, p1, p2) {
                return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2)
            }

            function CubicBezierP0(t, p) {
                var k = 1 - t;
                return k * k * k * p
            }

            function CubicBezierP1(t, p) {
                var k = 1 - t;
                return 3 * k * k * t * p
            }

            function CubicBezierP2(t, p) {
                return 3 * (1 - t) * t * t * p
            }

            function CubicBezierP3(t, p) {
                return t * t * t * p
            }

            function CubicBezier(t, p0, p1, p2, p3) {
                return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3)
            }

            function CubicBezierCurve(v0, v1, v2, v3) {
                Curve.call(this);
                this.type = "CubicBezierCurve";
                this.v0 = v0 || new Vector2;
                this.v1 = v1 || new Vector2;
                this.v2 = v2 || new Vector2;
                this.v3 = v3 || new Vector2
            }
            CubicBezierCurve.prototype = Object.create(Curve.prototype);
            CubicBezierCurve.prototype.constructor = CubicBezierCurve;
            CubicBezierCurve.prototype.isCubicBezierCurve = true;
            CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector2;
                var v0 = this.v0,
                    v1 = this.v1,
                    v2 = this.v2,
                    v3 = this.v3;
                point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
                return point
            };
            CubicBezierCurve.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                this.v3.copy(source.v3);
                return this
            };
            CubicBezierCurve.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                data.v3 = this.v3.toArray();
                return data
            };
            CubicBezierCurve.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                this.v3.fromArray(json.v3);
                return this
            };

            function CubicBezierCurve3(v0, v1, v2, v3) {
                Curve.call(this);
                this.type = "CubicBezierCurve3";
                this.v0 = v0 || new Vector3;
                this.v1 = v1 || new Vector3;
                this.v2 = v2 || new Vector3;
                this.v3 = v3 || new Vector3
            }
            CubicBezierCurve3.prototype = Object.create(Curve.prototype);
            CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
            CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
            CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector3;
                var v0 = this.v0,
                    v1 = this.v1,
                    v2 = this.v2,
                    v3 = this.v3;
                point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
                return point
            };
            CubicBezierCurve3.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                this.v3.copy(source.v3);
                return this
            };
            CubicBezierCurve3.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                data.v3 = this.v3.toArray();
                return data
            };
            CubicBezierCurve3.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                this.v3.fromArray(json.v3);
                return this
            };

            function LineCurve(v1, v2) {
                Curve.call(this);
                this.type = "LineCurve";
                this.v1 = v1 || new Vector2;
                this.v2 = v2 || new Vector2
            }
            LineCurve.prototype = Object.create(Curve.prototype);
            LineCurve.prototype.constructor = LineCurve;
            LineCurve.prototype.isLineCurve = true;
            LineCurve.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector2;
                if (t === 1) {
                    point.copy(this.v2)
                } else {
                    point.copy(this.v2).sub(this.v1);
                    point.multiplyScalar(t).add(this.v1)
                }
                return point
            };
            LineCurve.prototype.getPointAt = function(u, optionalTarget) {
                return this.getPoint(u, optionalTarget)
            };
            LineCurve.prototype.getTangent = function() {
                var tangent = this.v2.clone().sub(this.v1);
                return tangent.normalize()
            };
            LineCurve.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this
            };
            LineCurve.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data
            };
            LineCurve.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this
            };

            function LineCurve3(v1, v2) {
                Curve.call(this);
                this.type = "LineCurve3";
                this.v1 = v1 || new Vector3;
                this.v2 = v2 || new Vector3
            }
            LineCurve3.prototype = Object.create(Curve.prototype);
            LineCurve3.prototype.constructor = LineCurve3;
            LineCurve3.prototype.isLineCurve3 = true;
            LineCurve3.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector3;
                if (t === 1) {
                    point.copy(this.v2)
                } else {
                    point.copy(this.v2).sub(this.v1);
                    point.multiplyScalar(t).add(this.v1)
                }
                return point
            };
            LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
                return this.getPoint(u, optionalTarget)
            };
            LineCurve3.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this
            };
            LineCurve3.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data
            };
            LineCurve3.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this
            };

            function QuadraticBezierCurve(v0, v1, v2) {
                Curve.call(this);
                this.type = "QuadraticBezierCurve";
                this.v0 = v0 || new Vector2;
                this.v1 = v1 || new Vector2;
                this.v2 = v2 || new Vector2
            }
            QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
            QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
            QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
            QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector2;
                var v0 = this.v0,
                    v1 = this.v1,
                    v2 = this.v2;
                point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
                return point
            };
            QuadraticBezierCurve.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this
            };
            QuadraticBezierCurve.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data
            };
            QuadraticBezierCurve.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this
            };

            function QuadraticBezierCurve3(v0, v1, v2) {
                Curve.call(this);
                this.type = "QuadraticBezierCurve3";
                this.v0 = v0 || new Vector3;
                this.v1 = v1 || new Vector3;
                this.v2 = v2 || new Vector3
            }
            QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
            QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
            QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
            QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector3;
                var v0 = this.v0,
                    v1 = this.v1,
                    v2 = this.v2;
                point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
                return point
            };
            QuadraticBezierCurve3.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.v0.copy(source.v0);
                this.v1.copy(source.v1);
                this.v2.copy(source.v2);
                return this
            };
            QuadraticBezierCurve3.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.v0 = this.v0.toArray();
                data.v1 = this.v1.toArray();
                data.v2 = this.v2.toArray();
                return data
            };
            QuadraticBezierCurve3.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.v0.fromArray(json.v0);
                this.v1.fromArray(json.v1);
                this.v2.fromArray(json.v2);
                return this
            };

            function SplineCurve(points) {
                Curve.call(this);
                this.type = "SplineCurve";
                this.points = points || []
            }
            SplineCurve.prototype = Object.create(Curve.prototype);
            SplineCurve.prototype.constructor = SplineCurve;
            SplineCurve.prototype.isSplineCurve = true;
            SplineCurve.prototype.getPoint = function(t, optionalTarget) {
                var point = optionalTarget || new Vector2;
                var points = this.points;
                var p = (points.length - 1) * t;
                var intPoint = Math.floor(p);
                var weight = p - intPoint;
                var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
                var p1 = points[intPoint];
                var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
                var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
                point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
                return point
            };
            SplineCurve.prototype.copy = function(source) {
                Curve.prototype.copy.call(this, source);
                this.points = [];
                for (var i = 0, l = source.points.length; i < l; i++) {
                    var point = source.points[i];
                    this.points.push(point.clone())
                }
                return this
            };
            SplineCurve.prototype.toJSON = function() {
                var data = Curve.prototype.toJSON.call(this);
                data.points = [];
                for (var i = 0, l = this.points.length; i < l; i++) {
                    var point = this.points[i];
                    data.points.push(point.toArray())
                }
                return data
            };
            SplineCurve.prototype.fromJSON = function(json) {
                Curve.prototype.fromJSON.call(this, json);
                this.points = [];
                for (var i = 0, l = json.points.length; i < l; i++) {
                    var point = json.points[i];
                    this.points.push((new Vector2).fromArray(point))
                }
                return this
            };
            var Curves = Object.freeze({
                ArcCurve: ArcCurve,
                CatmullRomCurve3: CatmullRomCurve3,
                CubicBezierCurve: CubicBezierCurve,
                CubicBezierCurve3: CubicBezierCurve3,
                EllipseCurve: EllipseCurve,
                LineCurve: LineCurve,
                LineCurve3: LineCurve3,
                QuadraticBezierCurve: QuadraticBezierCurve,
                QuadraticBezierCurve3: QuadraticBezierCurve3,
                SplineCurve: SplineCurve
            });

            function CurvePath() {
                Curve.call(this);
                this.type = "CurvePath";
                this.curves = [];
                this.autoClose = false
            }
            CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
                constructor: CurvePath,
                add: function(curve) {
                    this.curves.push(curve)
                },
                closePath: function() {
                    var startPoint = this.curves[0].getPoint(0);
                    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
                    if (!startPoint.equals(endPoint)) {
                        this.curves.push(new LineCurve(endPoint, startPoint))
                    }
                },
                getPoint: function(t) {
                    var d = t * this.getLength();
                    var curveLengths = this.getCurveLengths();
                    var i = 0;
                    while (i < curveLengths.length) {
                        if (curveLengths[i] >= d) {
                            var diff = curveLengths[i] - d;
                            var curve = this.curves[i];
                            var segmentLength = curve.getLength();
                            var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                            return curve.getPointAt(u)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    var lens = this.getCurveLengths();
                    return lens[lens.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = true;
                    this.cacheLengths = null;
                    this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                        return this.cacheLengths
                    }
                    var lengths = [],
                        sums = 0;
                    for (var i = 0, l = this.curves.length; i < l; i++) {
                        sums += this.curves[i].getLength();
                        lengths.push(sums)
                    }
                    this.cacheLengths = lengths;
                    return lengths
                },
                getSpacedPoints: function(divisions) {
                    if (divisions === undefined) divisions = 40;
                    var points = [];
                    for (var i = 0; i <= divisions; i++) {
                        points.push(this.getPoint(i / divisions))
                    }
                    if (this.autoClose) {
                        points.push(points[0])
                    }
                    return points
                },
                getPoints: function(divisions) {
                    divisions = divisions || 12;
                    var points = [],
                        last;
                    for (var i = 0, curves = this.curves; i < curves.length; i++) {
                        var curve = curves[i];
                        var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
                        var pts = curve.getPoints(resolution);
                        for (var j = 0; j < pts.length; j++) {
                            var point = pts[j];
                            if (last && last.equals(point)) continue;
                            points.push(point);
                            last = point
                        }
                    }
                    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                        points.push(points[0])
                    }
                    return points
                },
                copy: function(source) {
                    Curve.prototype.copy.call(this, source);
                    this.curves = [];
                    for (var i = 0, l = source.curves.length; i < l; i++) {
                        var curve = source.curves[i];
                        this.curves.push(curve.clone())
                    }
                    this.autoClose = source.autoClose;
                    return this
                },
                toJSON: function() {
                    var data = Curve.prototype.toJSON.call(this);
                    data.autoClose = this.autoClose;
                    data.curves = [];
                    for (var i = 0, l = this.curves.length; i < l; i++) {
                        var curve = this.curves[i];
                        data.curves.push(curve.toJSON())
                    }
                    return data
                },
                fromJSON: function(json) {
                    Curve.prototype.fromJSON.call(this, json);
                    this.autoClose = json.autoClose;
                    this.curves = [];
                    for (var i = 0, l = json.curves.length; i < l; i++) {
                        var curve = json.curves[i];
                        this.curves.push((new Curves[curve.type]).fromJSON(curve))
                    }
                    return this
                }
            });

            function Path(points) {
                CurvePath.call(this);
                this.type = "Path";
                this.currentPoint = new Vector2;
                if (points) {
                    this.setFromPoints(points)
                }
            }
            Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
                constructor: Path,
                setFromPoints: function(points) {
                    this.moveTo(points[0].x, points[0].y);
                    for (var i = 1, l = points.length; i < l; i++) {
                        this.lineTo(points[i].x, points[i].y)
                    }
                },
                moveTo: function(x, y) {
                    this.currentPoint.set(x, y)
                },
                lineTo: function(x, y) {
                    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
                    this.curves.push(curve);
                    this.currentPoint.set(x, y)
                },
                quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
                    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
                    this.curves.push(curve);
                    this.currentPoint.set(aX, aY)
                },
                bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
                    this.curves.push(curve);
                    this.currentPoint.set(aX, aY)
                },
                splineThru: function(pts) {
                    var npts = [this.currentPoint.clone()].concat(pts);
                    var curve = new SplineCurve(npts);
                    this.curves.push(curve);
                    this.currentPoint.copy(pts[pts.length - 1])
                },
                arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                    var x0 = this.currentPoint.x;
                    var y0 = this.currentPoint.y;
                    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise)
                },
                absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise)
                },
                ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                    var x0 = this.currentPoint.x;
                    var y0 = this.currentPoint.y;
                    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation)
                },
                absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
                    if (this.curves.length > 0) {
                        var firstPoint = curve.getPoint(0);
                        if (!firstPoint.equals(this.currentPoint)) {
                            this.lineTo(firstPoint.x, firstPoint.y)
                        }
                    }
                    this.curves.push(curve);
                    var lastPoint = curve.getPoint(1);
                    this.currentPoint.copy(lastPoint)
                },
                copy: function(source) {
                    CurvePath.prototype.copy.call(this, source);
                    this.currentPoint.copy(source.currentPoint);
                    return this
                },
                toJSON: function() {
                    var data = CurvePath.prototype.toJSON.call(this);
                    data.currentPoint = this.currentPoint.toArray();
                    return data
                },
                fromJSON: function(json) {
                    CurvePath.prototype.fromJSON.call(this, json);
                    this.currentPoint.fromArray(json.currentPoint);
                    return this
                }
            });

            function Shape(points) {
                Path.call(this, points);
                this.uuid = _Math.generateUUID();
                this.type = "Shape";
                this.holes = []
            }
            Shape.prototype = Object.assign(Object.create(Path.prototype), {
                constructor: Shape,
                getPointsHoles: function(divisions) {
                    var holesPts = [];
                    for (var i = 0, l = this.holes.length; i < l; i++) {
                        holesPts[i] = this.holes[i].getPoints(divisions)
                    }
                    return holesPts
                },
                extractPoints: function(divisions) {
                    return {
                        shape: this.getPoints(divisions),
                        holes: this.getPointsHoles(divisions)
                    }
                },
                copy: function(source) {
                    Path.prototype.copy.call(this, source);
                    this.holes = [];
                    for (var i = 0, l = source.holes.length; i < l; i++) {
                        var hole = source.holes[i];
                        this.holes.push(hole.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var data = Path.prototype.toJSON.call(this);
                    data.uuid = this.uuid;
                    data.holes = [];
                    for (var i = 0, l = this.holes.length; i < l; i++) {
                        var hole = this.holes[i];
                        data.holes.push(hole.toJSON())
                    }
                    return data
                },
                fromJSON: function(json) {
                    Path.prototype.fromJSON.call(this, json);
                    this.uuid = json.uuid;
                    this.holes = [];
                    for (var i = 0, l = json.holes.length; i < l; i++) {
                        var hole = json.holes[i];
                        this.holes.push((new Path).fromJSON(hole))
                    }
                    return this
                }
            });

            function Light(color, intensity) {
                Object3D.call(this);
                this.type = "Light";
                this.color = new Color(color);
                this.intensity = intensity !== undefined ? intensity : 1;
                this.receiveShadow = undefined
            }
            Light.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Light,
                isLight: true,
                copy: function(source) {
                    Object3D.prototype.copy.call(this, source);
                    this.color.copy(source.color);
                    this.intensity = source.intensity;
                    return this
                },
                toJSON: function(meta) {
                    var data = Object3D.prototype.toJSON.call(this, meta);
                    data.object.color = this.color.getHex();
                    data.object.intensity = this.intensity;
                    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
                    if (this.distance !== undefined) data.object.distance = this.distance;
                    if (this.angle !== undefined) data.object.angle = this.angle;
                    if (this.decay !== undefined) data.object.decay = this.decay;
                    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
                    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
                    return data
                }
            });

            function HemisphereLight(skyColor, groundColor, intensity) {
                Light.call(this, skyColor, intensity);
                this.type = "HemisphereLight";
                this.castShadow = undefined;
                this.position.copy(Object3D.DefaultUp);
                this.updateMatrix();
                this.groundColor = new Color(groundColor)
            }
            HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: HemisphereLight,
                isHemisphereLight: true,
                copy: function(source) {
                    Light.prototype.copy.call(this, source);
                    this.groundColor.copy(source.groundColor);
                    return this
                }
            });

            function LightShadow(camera) {
                this.camera = camera;
                this.bias = 0;
                this.radius = 1;
                this.mapSize = new Vector2(512, 512);
                this.map = null;
                this.matrix = new Matrix4
            }
            Object.assign(LightShadow.prototype, {
                copy: function(source) {
                    this.camera = source.camera.clone();
                    this.bias = source.bias;
                    this.radius = source.radius;
                    this.mapSize.copy(source.mapSize);
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var object = {};
                    if (this.bias !== 0) object.bias = this.bias;
                    if (this.radius !== 1) object.radius = this.radius;
                    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
                    object.camera = this.camera.toJSON(false).object;
                    delete object.camera.matrix;
                    return object
                }
            });

            function SpotLightShadow() {
                LightShadow.call(this, new PerspectiveCamera(50, 1, .5, 500))
            }
            SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: SpotLightShadow,
                isSpotLightShadow: true,
                update: function(light) {
                    var camera = this.camera;
                    var fov = _Math.RAD2DEG * 2 * light.angle;
                    var aspect = this.mapSize.width / this.mapSize.height;
                    var far = light.distance || camera.far;
                    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                        camera.fov = fov;
                        camera.aspect = aspect;
                        camera.far = far;
                        camera.updateProjectionMatrix()
                    }
                }
            });

            function SpotLight(color, intensity, distance, angle, penumbra, decay) {
                Light.call(this, color, intensity);
                this.type = "SpotLight";
                this.position.copy(Object3D.DefaultUp);
                this.updateMatrix();
                this.target = new Object3D;
                Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(power) {
                        this.intensity = power / Math.PI
                    }
                });
                this.distance = distance !== undefined ? distance : 0;
                this.angle = angle !== undefined ? angle : Math.PI / 3;
                this.penumbra = penumbra !== undefined ? penumbra : 0;
                this.decay = decay !== undefined ? decay : 1;
                this.shadow = new SpotLightShadow
            }
            SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: SpotLight,
                isSpotLight: true,
                copy: function(source) {
                    Light.prototype.copy.call(this, source);
                    this.distance = source.distance;
                    this.angle = source.angle;
                    this.penumbra = source.penumbra;
                    this.decay = source.decay;
                    this.target = source.target.clone();
                    this.shadow = source.shadow.clone();
                    return this
                }
            });

            function PointLight(color, intensity, distance, decay) {
                Light.call(this, color, intensity);
                this.type = "PointLight";
                Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * 4 * Math.PI
                    },
                    set: function(power) {
                        this.intensity = power / (4 * Math.PI)
                    }
                });
                this.distance = distance !== undefined ? distance : 0;
                this.decay = decay !== undefined ? decay : 1;
                this.shadow = new LightShadow(new PerspectiveCamera(90, 1, .5, 500))
            }
            PointLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: PointLight,
                isPointLight: true,
                copy: function(source) {
                    Light.prototype.copy.call(this, source);
                    this.distance = source.distance;
                    this.decay = source.decay;
                    this.shadow = source.shadow.clone();
                    return this
                }
            });

            function DirectionalLightShadow() {
                LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, .5, 500))
            }
            DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
                constructor: DirectionalLightShadow
            });

            function DirectionalLight(color, intensity) {
                Light.call(this, color, intensity);
                this.type = "DirectionalLight";
                this.position.copy(Object3D.DefaultUp);
                this.updateMatrix();
                this.target = new Object3D;
                this.shadow = new DirectionalLightShadow
            }
            DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: DirectionalLight,
                isDirectionalLight: true,
                copy: function(source) {
                    Light.prototype.copy.call(this, source);
                    this.target = source.target.clone();
                    this.shadow = source.shadow.clone();
                    return this
                }
            });

            function AmbientLight(color, intensity) {
                Light.call(this, color, intensity);
                this.type = "AmbientLight";
                this.castShadow = undefined
            }
            AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: AmbientLight,
                isAmbientLight: true
            });

            function RectAreaLight(color, intensity, width, height) {
                Light.call(this, color, intensity);
                this.type = "RectAreaLight";
                this.width = width !== undefined ? width : 10;
                this.height = height !== undefined ? height : 10
            }
            RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
                constructor: RectAreaLight,
                isRectAreaLight: true,
                copy: function(source) {
                    Light.prototype.copy.call(this, source);
                    this.width = source.width;
                    this.height = source.height;
                    return this
                },
                toJSON: function(meta) {
                    var data = Light.prototype.toJSON.call(this, meta);
                    data.object.width = this.width;
                    data.object.height = this.height;
                    return data
                }
            });

            function StringKeyframeTrack(name, times, values, interpolation) {
                KeyframeTrack.call(this, name, times, values, interpolation)
            }
            StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: StringKeyframeTrack,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: InterpolateDiscrete,
                InterpolantFactoryMethodLinear: undefined,
                InterpolantFactoryMethodSmooth: undefined
            });

            function BooleanKeyframeTrack(name, times, values) {
                KeyframeTrack.call(this, name, times, values)
            }
            BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: BooleanKeyframeTrack,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: InterpolateDiscrete,
                InterpolantFactoryMethodLinear: undefined,
                InterpolantFactoryMethodSmooth: undefined
            });

            function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                this.parameterPositions = parameterPositions;
                this._cachedIndex = 0;
                this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
                this.sampleValues = sampleValues;
                this.valueSize = sampleSize
            }
            Object.assign(Interpolant.prototype, {
                evaluate: function(t) {
                    var pp = this.parameterPositions,
                        i1 = this._cachedIndex,
                        t1 = pp[i1],
                        t0 = pp[i1 - 1];
                    validate_interval: {
                        seek: {
                            var right;linear_scan: {
                                forward_scan: if (!(t < t1)) {
                                    for (var giveUpAt = i1 + 2;;) {
                                        if (t1 === undefined) {
                                            if (t < t0) break forward_scan;
                                            i1 = pp.length;
                                            this._cachedIndex = i1;
                                            return this.afterEnd_(i1 - 1, t, t0)
                                        }
                                        if (i1 === giveUpAt) break;
                                        t0 = t1;
                                        t1 = pp[++i1];
                                        if (t < t1) {
                                            break seek
                                        }
                                    }
                                    right = pp.length;
                                    break linear_scan
                                }if (!(t >= t0)) {
                                    var t1global = pp[1];
                                    if (t < t1global) {
                                        i1 = 2;
                                        t0 = t1global
                                    }
                                    for (var giveUpAt = i1 - 2;;) {
                                        if (t0 === undefined) {
                                            this._cachedIndex = 0;
                                            return this.beforeStart_(0, t, t1)
                                        }
                                        if (i1 === giveUpAt) break;
                                        t1 = t0;
                                        t0 = pp[--i1 - 1];
                                        if (t >= t0) {
                                            break seek
                                        }
                                    }
                                    right = i1;
                                    i1 = 0;
                                    break linear_scan
                                }
                                break validate_interval
                            }
                            while (i1 < right) {
                                var mid = i1 + right >>> 1;
                                if (t < pp[mid]) {
                                    right = mid
                                } else {
                                    i1 = mid + 1
                                }
                            }
                            t1 = pp[i1];t0 = pp[i1 - 1];
                            if (t0 === undefined) {
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1)
                            }
                            if (t1 === undefined) {
                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_(i1 - 1, t0, t)
                            }
                        }
                        this._cachedIndex = i1;this.intervalChanged_(i1, t0, t1)
                    }
                    return this.interpolate_(i1, t0, t, t1)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(index) {
                    var result = this.resultBuffer,
                        values = this.sampleValues,
                        stride = this.valueSize,
                        offset = index * stride;
                    for (var i = 0; i !== stride; ++i) {
                        result[i] = values[offset + i]
                    }
                    return result
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            });
            Object.assign(Interpolant.prototype, {
                beforeStart_: Interpolant.prototype.copySampleValue_,
                afterEnd_: Interpolant.prototype.copySampleValue_
            });

            function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer)
            }
            QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: QuaternionLinearInterpolant,
                interpolate_: function(i1, t0, t, t1) {
                    var result = this.resultBuffer,
                        values = this.sampleValues,
                        stride = this.valueSize,
                        offset = i1 * stride,
                        alpha = (t - t0) / (t1 - t0);
                    for (var end = offset + stride; offset !== end; offset += 4) {
                        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha)
                    }
                    return result
                }
            });

            function QuaternionKeyframeTrack(name, times, values, interpolation) {
                KeyframeTrack.call(this, name, times, values, interpolation)
            }
            QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: QuaternionKeyframeTrack,
                ValueTypeName: "quaternion",
                DefaultInterpolation: InterpolateLinear,
                InterpolantFactoryMethodLinear: function(result) {
                    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result)
                },
                InterpolantFactoryMethodSmooth: undefined
            });

            function ColorKeyframeTrack(name, times, values, interpolation) {
                KeyframeTrack.call(this, name, times, values, interpolation)
            }
            ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: ColorKeyframeTrack,
                ValueTypeName: "color"
            });

            function NumberKeyframeTrack(name, times, values, interpolation) {
                KeyframeTrack.call(this, name, times, values, interpolation)
            }
            NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: NumberKeyframeTrack,
                ValueTypeName: "number"
            });

            function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
                this._weightPrev = -0;
                this._offsetPrev = -0;
                this._weightNext = -0;
                this._offsetNext = -0
            }
            CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: CubicInterpolant,
                DefaultSettings_: {
                    endingStart: ZeroCurvatureEnding,
                    endingEnd: ZeroCurvatureEnding
                },
                intervalChanged_: function(i1, t0, t1) {
                    var pp = this.parameterPositions,
                        iPrev = i1 - 2,
                        iNext = i1 + 1,
                        tPrev = pp[iPrev],
                        tNext = pp[iNext];
                    if (tPrev === undefined) {
                        switch (this.getSettings_().endingStart) {
                            case ZeroSlopeEnding:
                                iPrev = i1;
                                tPrev = 2 * t0 - t1;
                                break;
                            case WrapAroundEnding:
                                iPrev = pp.length - 2;
                                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                                break;
                            default:
                                iPrev = i1;
                                tPrev = t1
                        }
                    }
                    if (tNext === undefined) {
                        switch (this.getSettings_().endingEnd) {
                            case ZeroSlopeEnding:
                                iNext = i1;
                                tNext = 2 * t1 - t0;
                                break;
                            case WrapAroundEnding:
                                iNext = 1;
                                tNext = t1 + pp[1] - pp[0];
                                break;
                            default:
                                iNext = i1 - 1;
                                tNext = t0
                        }
                    }
                    var halfDt = (t1 - t0) * .5,
                        stride = this.valueSize;
                    this._weightPrev = halfDt / (t0 - tPrev);
                    this._weightNext = halfDt / (tNext - t1);
                    this._offsetPrev = iPrev * stride;
                    this._offsetNext = iNext * stride
                },
                interpolate_: function(i1, t0, t, t1) {
                    var result = this.resultBuffer,
                        values = this.sampleValues,
                        stride = this.valueSize,
                        o1 = i1 * stride,
                        o0 = o1 - stride,
                        oP = this._offsetPrev,
                        oN = this._offsetNext,
                        wP = this._weightPrev,
                        wN = this._weightNext,
                        p = (t - t0) / (t1 - t0),
                        pp = p * p,
                        ppp = pp * p;
                    var sP = -wP * ppp + 2 * wP * pp - wP * p;
                    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p + 1;
                    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p;
                    var sN = wN * ppp - wN * pp;
                    for (var i = 0; i !== stride; ++i) {
                        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i]
                    }
                    return result
                }
            });

            function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer)
            }
            LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: LinearInterpolant,
                interpolate_: function(i1, t0, t, t1) {
                    var result = this.resultBuffer,
                        values = this.sampleValues,
                        stride = this.valueSize,
                        offset1 = i1 * stride,
                        offset0 = offset1 - stride,
                        weight1 = (t - t0) / (t1 - t0),
                        weight0 = 1 - weight1;
                    for (var i = 0; i !== stride; ++i) {
                        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1
                    }
                    return result
                }
            });

            function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer)
            }
            DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
                constructor: DiscreteInterpolant,
                interpolate_: function(i1) {
                    return this.copySampleValue_(i1 - 1)
                }
            });
            var AnimationUtils = {
                arraySlice: function(array, from, to) {
                    if (AnimationUtils.isTypedArray(array)) {
                        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length))
                    }
                    return array.slice(from, to)
                },
                convertArray: function(array, type, forceClone) {
                    if (!array || !forceClone && array.constructor === type) return array;
                    if (typeof type.BYTES_PER_ELEMENT === "number") {
                        return new type(array)
                    }
                    return Array.prototype.slice.call(array)
                },
                isTypedArray: function(object) {
                    return ArrayBuffer.isView(object) && !(object instanceof DataView)
                },
                getKeyframeOrder: function(times) {
                    function compareTime(i, j) {
                        return times[i] - times[j]
                    }
                    var n = times.length;
                    var result = new Array(n);
                    for (var i = 0; i !== n; ++i) result[i] = i;
                    result.sort(compareTime);
                    return result
                },
                sortedArray: function(values, stride, order) {
                    var nValues = values.length;
                    var result = new values.constructor(nValues);
                    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                        var srcOffset = order[i] * stride;
                        for (var j = 0; j !== stride; ++j) {
                            result[dstOffset++] = values[srcOffset + j]
                        }
                    }
                    return result
                },
                flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
                    var i = 1,
                        key = jsonKeys[0];
                    while (key !== undefined && key[valuePropertyName] === undefined) {
                        key = jsonKeys[i++]
                    }
                    if (key === undefined) return;
                    var value = key[valuePropertyName];
                    if (value === undefined) return;
                    if (Array.isArray(value)) {
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                values.push.apply(values, value)
                            }
                            key = jsonKeys[i++]
                        } while (key !== undefined)
                    } else if (value.toArray !== undefined) {
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                value.toArray(values, values.length)
                            }
                            key = jsonKeys[i++]
                        } while (key !== undefined)
                    } else {
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                values.push(value)
                            }
                            key = jsonKeys[i++]
                        } while (key !== undefined)
                    }
                }
            };

            function KeyframeTrack(name, times, values, interpolation) {
                if (name === undefined) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (times === undefined || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
                this.name = name;
                this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
                this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
                this.setInterpolation(interpolation || this.DefaultInterpolation);
                this.validate();
                this.optimize()
            }
            Object.assign(KeyframeTrack, {
                parse: function(json) {
                    if (json.type === undefined) {
                        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse")
                    }
                    var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
                    if (json.times === undefined) {
                        var times = [],
                            values = [];
                        AnimationUtils.flattenJSON(json.keys, times, values, "value");
                        json.times = times;
                        json.values = values
                    }
                    if (trackType.parse !== undefined) {
                        return trackType.parse(json)
                    } else {
                        return new trackType(json.name, json.times, json.values, json.interpolation)
                    }
                },
                toJSON: function(track) {
                    var trackType = track.constructor;
                    var json;
                    if (trackType.toJSON !== undefined) {
                        json = trackType.toJSON(track)
                    } else {
                        json = {
                            name: track.name,
                            times: AnimationUtils.convertArray(track.times, Array),
                            values: AnimationUtils.convertArray(track.values, Array)
                        };
                        var interpolation = track.getInterpolation();
                        if (interpolation !== track.DefaultInterpolation) {
                            json.interpolation = interpolation
                        }
                    }
                    json.type = track.ValueTypeName;
                    return json
                },
                _getTrackTypeForValueTypeName: function(typeName) {
                    switch (typeName.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return NumberKeyframeTrack;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return VectorKeyframeTrack;
                        case "color":
                            return ColorKeyframeTrack;
                        case "quaternion":
                            return QuaternionKeyframeTrack;
                        case "bool":
                        case "boolean":
                            return BooleanKeyframeTrack;
                        case "string":
                            return StringKeyframeTrack
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName)
                }
            });
            Object.assign(KeyframeTrack.prototype, {
                constructor: KeyframeTrack,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: InterpolateLinear,
                InterpolantFactoryMethodDiscrete: function(result) {
                    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result)
                },
                InterpolantFactoryMethodLinear: function(result) {
                    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result)
                },
                InterpolantFactoryMethodSmooth: function(result) {
                    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result)
                },
                setInterpolation: function(interpolation) {
                    var factoryMethod;
                    switch (interpolation) {
                        case InterpolateDiscrete:
                            factoryMethod = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case InterpolateLinear:
                            factoryMethod = this.InterpolantFactoryMethodLinear;
                            break;
                        case InterpolateSmooth:
                            factoryMethod = this.InterpolantFactoryMethodSmooth;
                            break
                    }
                    if (factoryMethod === undefined) {
                        var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (this.createInterpolant === undefined) {
                            if (interpolation !== this.DefaultInterpolation) {
                                this.setInterpolation(this.DefaultInterpolation)
                            } else {
                                throw new Error(message)
                            }
                        }
                        console.warn("THREE.KeyframeTrack:", message);
                        return
                    }
                    this.createInterpolant = factoryMethod
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return InterpolateDiscrete;
                        case this.InterpolantFactoryMethodLinear:
                            return InterpolateLinear;
                        case this.InterpolantFactoryMethodSmooth:
                            return InterpolateSmooth
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(timeOffset) {
                    if (timeOffset !== 0) {
                        var times = this.times;
                        for (var i = 0, n = times.length; i !== n; ++i) {
                            times[i] += timeOffset
                        }
                    }
                    return this
                },
                scale: function(timeScale) {
                    if (timeScale !== 1) {
                        var times = this.times;
                        for (var i = 0, n = times.length; i !== n; ++i) {
                            times[i] *= timeScale
                        }
                    }
                    return this
                },
                trim: function(startTime, endTime) {
                    var times = this.times,
                        nKeys = times.length,
                        from = 0,
                        to = nKeys - 1;
                    while (from !== nKeys && times[from] < startTime) {
                        ++from
                    }
                    while (to !== -1 && times[to] > endTime) {
                        --to
                    }++to;
                    if (from !== 0 || to !== nKeys) {
                        if (from >= to) to = Math.max(to, 1), from = to - 1;
                        var stride = this.getValueSize();
                        this.times = AnimationUtils.arraySlice(times, from, to);
                        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride)
                    }
                    return this
                },
                validate: function() {
                    var valid = true;
                    var valueSize = this.getValueSize();
                    if (valueSize - Math.floor(valueSize) !== 0) {
                        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
                        valid = false
                    }
                    var times = this.times,
                        values = this.values,
                        nKeys = times.length;
                    if (nKeys === 0) {
                        console.error("THREE.KeyframeTrack: Track is empty.", this);
                        valid = false
                    }
                    var prevTime = null;
                    for (var i = 0; i !== nKeys; i++) {
                        var currTime = times[i];
                        if (typeof currTime === "number" && isNaN(currTime)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
                            valid = false;
                            break
                        }
                        if (prevTime !== null && prevTime > currTime) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
                            valid = false;
                            break
                        }
                        prevTime = currTime
                    }
                    if (values !== undefined) {
                        if (AnimationUtils.isTypedArray(values)) {
                            for (var i = 0, n = values.length; i !== n; ++i) {
                                var value = values[i];
                                if (isNaN(value)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
                                    valid = false;
                                    break
                                }
                            }
                        }
                    }
                    return valid
                },
                optimize: function() {
                    var times = this.times,
                        values = this.values,
                        stride = this.getValueSize(),
                        smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
                        writeIndex = 1,
                        lastIndex = times.length - 1;
                    for (var i = 1; i < lastIndex; ++i) {
                        var keep = false;
                        var time = times[i];
                        var timeNext = times[i + 1];
                        if (time !== timeNext && (i !== 1 || time !== time[0])) {
                            if (!smoothInterpolation) {
                                var offset = i * stride,
                                    offsetP = offset - stride,
                                    offsetN = offset + stride;
                                for (var j = 0; j !== stride; ++j) {
                                    var value = values[offset + j];
                                    if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                                        keep = true;
                                        break
                                    }
                                }
                            } else {
                                keep = true
                            }
                        }
                        if (keep) {
                            if (i !== writeIndex) {
                                times[writeIndex] = times[i];
                                var readOffset = i * stride,
                                    writeOffset = writeIndex * stride;
                                for (var j = 0; j !== stride; ++j) {
                                    values[writeOffset + j] = values[readOffset + j]
                                }
                            }++writeIndex
                        }
                    }
                    if (lastIndex > 0) {
                        times[writeIndex] = times[lastIndex];
                        for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                            values[writeOffset + j] = values[readOffset + j]
                        }++writeIndex
                    }
                    if (writeIndex !== times.length) {
                        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride)
                    }
                    return this
                }
            });

            function VectorKeyframeTrack(name, times, values, interpolation) {
                KeyframeTrack.call(this, name, times, values, interpolation)
            }
            VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
                constructor: VectorKeyframeTrack,
                ValueTypeName: "vector"
            });

            function AnimationClip(name, duration, tracks) {
                this.name = name;
                this.tracks = tracks;
                this.duration = duration !== undefined ? duration : -1;
                this.uuid = _Math.generateUUID();
                if (this.duration < 0) {
                    this.resetDuration()
                }
                this.optimize()
            }
            Object.assign(AnimationClip, {
                parse: function(json) {
                    var tracks = [],
                        jsonTracks = json.tracks,
                        frameTime = 1 / (json.fps || 1);
                    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                        tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime))
                    }
                    return new AnimationClip(json.name, json.duration, tracks)
                },
                toJSON: function(clip) {
                    var tracks = [],
                        clipTracks = clip.tracks;
                    var json = {
                        name: clip.name,
                        duration: clip.duration,
                        tracks: tracks
                    };
                    for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                        tracks.push(KeyframeTrack.toJSON(clipTracks[i]))
                    }
                    return json
                },
                CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
                    var numMorphTargets = morphTargetSequence.length;
                    var tracks = [];
                    for (var i = 0; i < numMorphTargets; i++) {
                        var times = [];
                        var values = [];
                        times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                        values.push(0, 1, 0);
                        var order = AnimationUtils.getKeyframeOrder(times);
                        times = AnimationUtils.sortedArray(times, 1, order);
                        values = AnimationUtils.sortedArray(values, 1, order);
                        if (!noLoop && times[0] === 0) {
                            times.push(numMorphTargets);
                            values.push(values[0])
                        }
                        tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps))
                    }
                    return new AnimationClip(name, -1, tracks)
                },
                findByName: function(objectOrClipArray, name) {
                    var clipArray = objectOrClipArray;
                    if (!Array.isArray(objectOrClipArray)) {
                        var o = objectOrClipArray;
                        clipArray = o.geometry && o.geometry.animations || o.animations
                    }
                    for (var i = 0; i < clipArray.length; i++) {
                        if (clipArray[i].name === name) {
                            return clipArray[i]
                        }
                    }
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
                    var animationToMorphTargets = {};
                    var pattern = /^([\w-]*?)([\d]+)$/;
                    for (var i = 0, il = morphTargets.length; i < il; i++) {
                        var morphTarget = morphTargets[i];
                        var parts = morphTarget.name.match(pattern);
                        if (parts && parts.length > 1) {
                            var name = parts[1];
                            var animationMorphTargets = animationToMorphTargets[name];
                            if (!animationMorphTargets) {
                                animationToMorphTargets[name] = animationMorphTargets = []
                            }
                            animationMorphTargets.push(morphTarget)
                        }
                    }
                    var clips = [];
                    for (var name in animationToMorphTargets) {
                        clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop))
                    }
                    return clips
                },
                parseAnimation: function(animation, bones) {
                    if (!animation) {
                        console.error("THREE.AnimationClip: No animation in JSONLoader data.");
                        return null
                    }
                    var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                        if (animationKeys.length !== 0) {
                            var times = [];
                            var values = [];
                            AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                            if (times.length !== 0) {
                                destTracks.push(new trackType(trackName, times, values))
                            }
                        }
                    };
                    var tracks = [];
                    var clipName = animation.name || "default";
                    var duration = animation.length || -1;
                    var fps = animation.fps || 30;
                    var hierarchyTracks = animation.hierarchy || [];
                    for (var h = 0; h < hierarchyTracks.length; h++) {
                        var animationKeys = hierarchyTracks[h].keys;
                        if (!animationKeys || animationKeys.length === 0) continue;
                        if (animationKeys[0].morphTargets) {
                            var morphTargetNames = {};
                            for (var k = 0; k < animationKeys.length; k++) {
                                if (animationKeys[k].morphTargets) {
                                    for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                        morphTargetNames[animationKeys[k].morphTargets[m]] = -1
                                    }
                                }
                            }
                            for (var morphTargetName in morphTargetNames) {
                                var times = [];
                                var values = [];
                                for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                                    var animationKey = animationKeys[k];
                                    times.push(animationKey.time);
                                    values.push(animationKey.morphTarget === morphTargetName ? 1 : 0)
                                }
                                tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values))
                            }
                            duration = morphTargetNames.length * (fps || 1)
                        } else {
                            var boneName = ".bones[" + bones[h].name + "]";
                            addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
                            addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
                            addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks)
                        }
                    }
                    if (tracks.length === 0) {
                        return null
                    }
                    var clip = new AnimationClip(clipName, duration, tracks);
                    return clip
                }
            });
            Object.assign(AnimationClip.prototype, {
                resetDuration: function() {
                    var tracks = this.tracks,
                        duration = 0;
                    for (var i = 0, n = tracks.length; i !== n; ++i) {
                        var track = this.tracks[i];
                        duration = Math.max(duration, track.times[track.times.length - 1])
                    }
                    this.duration = duration
                },
                trim: function() {
                    for (var i = 0; i < this.tracks.length; i++) {
                        this.tracks[i].trim(0, this.duration)
                    }
                    return this
                },
                optimize: function() {
                    for (var i = 0; i < this.tracks.length; i++) {
                        this.tracks[i].optimize()
                    }
                    return this
                }
            });

            function MaterialLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager;
                this.textures = {}
            }
            Object.assign(MaterialLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this;
                    var loader = new FileLoader(scope.manager);
                    loader.load(url, function(text) {
                        onLoad(scope.parse(JSON.parse(text)))
                    }, onProgress, onError)
                },
                setTextures: function(value) {
                    this.textures = value
                },
                parse: function(json) {
                    var textures = this.textures;

                    function getTexture(name) {
                        if (textures[name] === undefined) {
                            console.warn("THREE.MaterialLoader: Undefined texture", name)
                        }
                        return textures[name]
                    }
                    var material = new Materials[json.type];
                    if (json.uuid !== undefined) material.uuid = json.uuid;
                    if (json.name !== undefined) material.name = json.name;
                    if (json.color !== undefined) material.color.setHex(json.color);
                    if (json.roughness !== undefined) material.roughness = json.roughness;
                    if (json.metalness !== undefined) material.metalness = json.metalness;
                    if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
                    if (json.specular !== undefined) material.specular.setHex(json.specular);
                    if (json.shininess !== undefined) material.shininess = json.shininess;
                    if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
                    if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
                    if (json.uniforms !== undefined) material.uniforms = json.uniforms;
                    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
                    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
                    if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
                    if (json.fog !== undefined) material.fog = json.fog;
                    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
                    if (json.blending !== undefined) material.blending = json.blending;
                    if (json.side !== undefined) material.side = json.side;
                    if (json.opacity !== undefined) material.opacity = json.opacity;
                    if (json.transparent !== undefined) material.transparent = json.transparent;
                    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
                    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
                    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
                    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
                    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
                    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
                    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
                    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
                    if (json.rotation !== undefined) material.rotation = json.rotation;
                    if (json.linewidth !== 1) material.linewidth = json.linewidth;
                    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
                    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
                    if (json.scale !== undefined) material.scale = json.scale;
                    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
                    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
                    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
                    if (json.skinning !== undefined) material.skinning = json.skinning;
                    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
                    if (json.dithering !== undefined) material.dithering = json.dithering;
                    if (json.visible !== undefined) material.visible = json.visible;
                    if (json.userData !== undefined) material.userData = json.userData;
                    if (json.shading !== undefined) material.flatShading = json.shading === 1;
                    if (json.size !== undefined) material.size = json.size;
                    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
                    if (json.map !== undefined) material.map = getTexture(json.map);
                    if (json.alphaMap !== undefined) {
                        material.alphaMap = getTexture(json.alphaMap);
                        material.transparent = true
                    }
                    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
                    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
                    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
                    if (json.normalScale !== undefined) {
                        var normalScale = json.normalScale;
                        if (Array.isArray(normalScale) === false) {
                            normalScale = [normalScale, normalScale]
                        }
                        material.normalScale = (new Vector2).fromArray(normalScale)
                    }
                    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
                    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
                    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
                    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
                    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
                    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
                    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
                    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
                    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
                    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
                    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
                    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
                    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
                    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
                    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
                    return material
                }
            });

            function BufferGeometryLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager
            }
            Object.assign(BufferGeometryLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this;
                    var loader = new FileLoader(scope.manager);
                    loader.load(url, function(text) {
                        onLoad(scope.parse(JSON.parse(text)))
                    }, onProgress, onError)
                },
                parse: function(json) {
                    var geometry = new BufferGeometry;
                    var index = json.data.index;
                    if (index !== undefined) {
                        var typedArray = new TYPED_ARRAYS[index.type](index.array);
                        geometry.setIndex(new BufferAttribute(typedArray, 1))
                    }
                    var attributes = json.data.attributes;
                    for (var key in attributes) {
                        var attribute = attributes[key];
                        var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                        geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized))
                    }
                    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
                    if (groups !== undefined) {
                        for (var i = 0, n = groups.length; i !== n; ++i) {
                            var group = groups[i];
                            geometry.addGroup(group.start, group.count, group.materialIndex)
                        }
                    }
                    var boundingSphere = json.data.boundingSphere;
                    if (boundingSphere !== undefined) {
                        var center = new Vector3;
                        if (boundingSphere.center !== undefined) {
                            center.fromArray(boundingSphere.center)
                        }
                        geometry.boundingSphere = new Sphere(center, boundingSphere.radius)
                    }
                    return geometry
                }
            });
            var TYPED_ARRAYS = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function Loader() {}
            Loader.Handlers = {
                handlers: [],
                add: function(regex, loader) {
                    this.handlers.push(regex, loader)
                },
                get: function(file) {
                    var handlers = this.handlers;
                    for (var i = 0, l = handlers.length; i < l; i += 2) {
                        var regex = handlers[i];
                        var loader = handlers[i + 1];
                        if (regex.test(file)) {
                            return loader
                        }
                    }
                    return null
                }
            };
            Object.assign(Loader.prototype, {
                crossOrigin: undefined,
                onLoadStart: function() {},
                onLoadProgress: function() {},
                onLoadComplete: function() {},
                initMaterials: function(materials, texturePath, crossOrigin) {
                    var array = [];
                    for (var i = 0; i < materials.length; ++i) {
                        array[i] = this.createMaterial(materials[i], texturePath, crossOrigin)
                    }
                    return array
                },
                createMaterial: function() {
                    var BlendingMode = {
                        NoBlending: NoBlending,
                        NormalBlending: NormalBlending,
                        AdditiveBlending: AdditiveBlending,
                        SubtractiveBlending: SubtractiveBlending,
                        MultiplyBlending: MultiplyBlending,
                        CustomBlending: CustomBlending
                    };
                    var color = new Color;
                    var textureLoader = new TextureLoader;
                    var materialLoader = new MaterialLoader;
                    return function createMaterial(m, texturePath, crossOrigin) {
                        var textures = {};

                        function loadTexture(path, repeat, offset, wrap, anisotropy) {
                            var fullPath = texturePath + path;
                            var loader = Loader.Handlers.get(fullPath);
                            var texture;
                            if (loader !== null) {
                                texture = loader.load(fullPath)
                            } else {
                                textureLoader.setCrossOrigin(crossOrigin);
                                texture = textureLoader.load(fullPath)
                            }
                            if (repeat !== undefined) {
                                texture.repeat.fromArray(repeat);
                                if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
                                if (repeat[1] !== 1) texture.wrapT = RepeatWrapping
                            }
                            if (offset !== undefined) {
                                texture.offset.fromArray(offset)
                            }
                            if (wrap !== undefined) {
                                if (wrap[0] === "repeat") texture.wrapS = RepeatWrapping;
                                if (wrap[0] === "mirror") texture.wrapS = MirroredRepeatWrapping;
                                if (wrap[1] === "repeat") texture.wrapT = RepeatWrapping;
                                if (wrap[1] === "mirror") texture.wrapT = MirroredRepeatWrapping
                            }
                            if (anisotropy !== undefined) {
                                texture.anisotropy = anisotropy
                            }
                            var uuid = _Math.generateUUID();
                            textures[uuid] = texture;
                            return uuid
                        }
                        var json = {
                            uuid: _Math.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                        for (var name in m) {
                            var value = m[name];
                            switch (name) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    json.name = value;
                                    break;
                                case "blending":
                                    json.blending = BlendingMode[value];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    json.color = color.fromArray(value).getHex();
                                    break;
                                case "colorSpecular":
                                    json.specular = color.fromArray(value).getHex();
                                    break;
                                case "colorEmissive":
                                    json.emissive = color.fromArray(value).getHex();
                                    break;
                                case "specularCoef":
                                    json.shininess = value;
                                    break;
                                case "shading":
                                    if (value.toLowerCase() === "basic") json.type = "MeshBasicMaterial";
                                    if (value.toLowerCase() === "phong") json.type = "MeshPhongMaterial";
                                    if (value.toLowerCase() === "standard") json.type = "MeshStandardMaterial";
                                    break;
                                case "mapDiffuse":
                                    json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    json.bumpScale = value;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    json.normalScale = value;
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    json.side = BackSide;
                                    break;
                                case "doubleSided":
                                    json.side = DoubleSide;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
                                    json.opacity = value;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    json[name] = value;
                                    break;
                                case "vertexColors":
                                    if (value === true) json.vertexColors = VertexColors;
                                    if (value === "face") json.vertexColors = FaceColors;
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", name, value);
                                    break
                            }
                        }
                        if (json.type === "MeshBasicMaterial") delete json.emissive;
                        if (json.type !== "MeshPhongMaterial") delete json.specular;
                        if (json.opacity < 1) json.transparent = true;
                        materialLoader.setTextures(textures);
                        return materialLoader.parse(json)
                    }
                }()
            });
            var LoaderUtils = {
                decodeText: function(array) {
                    if (typeof TextDecoder !== "undefined") {
                        return (new TextDecoder).decode(array)
                    }
                    var s = "";
                    for (var i = 0, il = array.length; i < il; i++) {
                        s += String.fromCharCode(array[i])
                    }
                    return decodeURIComponent(escape(s))
                },
                extractUrlBase: function(url) {
                    var parts = url.split("/");
                    if (parts.length === 1) return "./";
                    parts.pop();
                    return parts.join("/") + "/"
                }
            };

            function JSONLoader(manager) {
                if (typeof manager === "boolean") {
                    console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor.");
                    manager = undefined
                }
                this.manager = manager !== undefined ? manager : DefaultLoadingManager;
                this.withCredentials = false
            }
            Object.assign(JSONLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this;
                    var texturePath = this.texturePath && typeof this.texturePath === "string" ? this.texturePath : LoaderUtils.extractUrlBase(url);
                    var loader = new FileLoader(this.manager);
                    loader.setWithCredentials(this.withCredentials);
                    loader.load(url, function(text) {
                        var json = JSON.parse(text);
                        var metadata = json.metadata;
                        if (metadata !== undefined) {
                            var type = metadata.type;
                            if (type !== undefined) {
                                if (type.toLowerCase() === "object") {
                                    console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
                                    return
                                }
                            }
                        }
                        var object = scope.parse(json, texturePath);
                        onLoad(object.geometry, object.materials)
                    }, onProgress, onError)
                },
                setTexturePath: function(value) {
                    this.texturePath = value
                },
                parse: function() {
                    function parseModel(json, geometry) {
                        function isBitSet(value, position) {
                            return value & 1 << position
                        }
                        var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces,
                            vertices = json.vertices,
                            normals = json.normals,
                            colors = json.colors,
                            scale = json.scale,
                            nUvLayers = 0;
                        if (json.uvs !== undefined) {
                            for (i = 0; i < json.uvs.length; i++) {
                                if (json.uvs[i].length) nUvLayers++
                            }
                            for (i = 0; i < nUvLayers; i++) {
                                geometry.faceVertexUvs[i] = []
                            }
                        }
                        offset = 0;
                        zLength = vertices.length;
                        while (offset < zLength) {
                            vertex = new Vector3;
                            vertex.x = vertices[offset++] * scale;
                            vertex.y = vertices[offset++] * scale;
                            vertex.z = vertices[offset++] * scale;
                            geometry.vertices.push(vertex)
                        }
                        offset = 0;
                        zLength = faces.length;
                        while (offset < zLength) {
                            type = faces[offset++];
                            isQuad = isBitSet(type, 0);
                            hasMaterial = isBitSet(type, 1);
                            hasFaceVertexUv = isBitSet(type, 3);
                            hasFaceNormal = isBitSet(type, 4);
                            hasFaceVertexNormal = isBitSet(type, 5);
                            hasFaceColor = isBitSet(type, 6);
                            hasFaceVertexColor = isBitSet(type, 7);
                            if (isQuad) {
                                faceA = new Face3;
                                faceA.a = faces[offset];
                                faceA.b = faces[offset + 1];
                                faceA.c = faces[offset + 3];
                                faceB = new Face3;
                                faceB.a = faces[offset + 1];
                                faceB.b = faces[offset + 2];
                                faceB.c = faces[offset + 3];
                                offset += 4;
                                if (hasMaterial) {
                                    materialIndex = faces[offset++];
                                    faceA.materialIndex = materialIndex;
                                    faceB.materialIndex = materialIndex
                                }
                                fi = geometry.faces.length;
                                if (hasFaceVertexUv) {
                                    for (i = 0; i < nUvLayers; i++) {
                                        uvLayer = json.uvs[i];
                                        geometry.faceVertexUvs[i][fi] = [];
                                        geometry.faceVertexUvs[i][fi + 1] = [];
                                        for (j = 0; j < 4; j++) {
                                            uvIndex = faces[offset++];
                                            u = uvLayer[uvIndex * 2];
                                            v = uvLayer[uvIndex * 2 + 1];
                                            uv = new Vector2(u, v);
                                            if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                                            if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv)
                                        }
                                    }
                                }
                                if (hasFaceNormal) {
                                    normalIndex = faces[offset++] * 3;
                                    faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                    faceB.normal.copy(faceA.normal)
                                }
                                if (hasFaceVertexNormal) {
                                    for (i = 0; i < 4; i++) {
                                        normalIndex = faces[offset++] * 3;
                                        normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                        if (i !== 2) faceA.vertexNormals.push(normal);
                                        if (i !== 0) faceB.vertexNormals.push(normal)
                                    }
                                }
                                if (hasFaceColor) {
                                    colorIndex = faces[offset++];
                                    hex = colors[colorIndex];
                                    faceA.color.setHex(hex);
                                    faceB.color.setHex(hex)
                                }
                                if (hasFaceVertexColor) {
                                    for (i = 0; i < 4; i++) {
                                        colorIndex = faces[offset++];
                                        hex = colors[colorIndex];
                                        if (i !== 2) faceA.vertexColors.push(new Color(hex));
                                        if (i !== 0) faceB.vertexColors.push(new Color(hex))
                                    }
                                }
                                geometry.faces.push(faceA);
                                geometry.faces.push(faceB)
                            } else {
                                face = new Face3;
                                face.a = faces[offset++];
                                face.b = faces[offset++];
                                face.c = faces[offset++];
                                if (hasMaterial) {
                                    materialIndex = faces[offset++];
                                    face.materialIndex = materialIndex
                                }
                                fi = geometry.faces.length;
                                if (hasFaceVertexUv) {
                                    for (i = 0; i < nUvLayers; i++) {
                                        uvLayer = json.uvs[i];
                                        geometry.faceVertexUvs[i][fi] = [];
                                        for (j = 0; j < 3; j++) {
                                            uvIndex = faces[offset++];
                                            u = uvLayer[uvIndex * 2];
                                            v = uvLayer[uvIndex * 2 + 1];
                                            uv = new Vector2(u, v);
                                            geometry.faceVertexUvs[i][fi].push(uv)
                                        }
                                    }
                                }
                                if (hasFaceNormal) {
                                    normalIndex = faces[offset++] * 3;
                                    face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex])
                                }
                                if (hasFaceVertexNormal) {
                                    for (i = 0; i < 3; i++) {
                                        normalIndex = faces[offset++] * 3;
                                        normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                        face.vertexNormals.push(normal)
                                    }
                                }
                                if (hasFaceColor) {
                                    colorIndex = faces[offset++];
                                    face.color.setHex(colors[colorIndex])
                                }
                                if (hasFaceVertexColor) {
                                    for (i = 0; i < 3; i++) {
                                        colorIndex = faces[offset++];
                                        face.vertexColors.push(new Color(colors[colorIndex]))
                                    }
                                }
                                geometry.faces.push(face)
                            }
                        }
                    }

                    function parseSkin(json, geometry) {
                        var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;
                        if (json.skinWeights) {
                            for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                                var x = json.skinWeights[i];
                                var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
                                var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
                                var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                                geometry.skinWeights.push(new Vector4(x, y, z, w))
                            }
                        }
                        if (json.skinIndices) {
                            for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                                var a = json.skinIndices[i];
                                var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
                                var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
                                var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                                geometry.skinIndices.push(new Vector4(a, b, c, d))
                            }
                        }
                        geometry.bones = json.bones;
                        if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                            console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.")
                        }
                    }

                    function parseMorphing(json, geometry) {
                        var scale = json.scale;
                        if (json.morphTargets !== undefined) {
                            for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                                geometry.morphTargets[i] = {};
                                geometry.morphTargets[i].name = json.morphTargets[i].name;
                                geometry.morphTargets[i].vertices = [];
                                var dstVertices = geometry.morphTargets[i].vertices;
                                var srcVertices = json.morphTargets[i].vertices;
                                for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                                    var vertex = new Vector3;
                                    vertex.x = srcVertices[v] * scale;
                                    vertex.y = srcVertices[v + 1] * scale;
                                    vertex.z = srcVertices[v + 2] * scale;
                                    dstVertices.push(vertex)
                                }
                            }
                        }
                        if (json.morphColors !== undefined && json.morphColors.length > 0) {
                            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                            var faces = geometry.faces;
                            var morphColors = json.morphColors[0].colors;
                            for (var i = 0, l = faces.length; i < l; i++) {
                                faces[i].color.fromArray(morphColors, i * 3)
                            }
                        }
                    }

                    function parseAnimations(json, geometry) {
                        var outputAnimations = [];
                        var animations = [];
                        if (json.animation !== undefined) {
                            animations.push(json.animation)
                        }
                        if (json.animations !== undefined) {
                            if (json.animations.length) {
                                animations = animations.concat(json.animations)
                            } else {
                                animations.push(json.animations)
                            }
                        }
                        for (var i = 0; i < animations.length; i++) {
                            var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                            if (clip) outputAnimations.push(clip)
                        }
                        if (geometry.morphTargets) {
                            var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                            outputAnimations = outputAnimations.concat(morphAnimationClips)
                        }
                        if (outputAnimations.length > 0) geometry.animations = outputAnimations
                    }
                    return function parse(json, texturePath) {
                        if (json.data !== undefined) {
                            json = json.data
                        }
                        if (json.scale !== undefined) {
                            json.scale = 1 / json.scale
                        } else {
                            json.scale = 1
                        }
                        var geometry = new Geometry;
                        parseModel(json, geometry);
                        parseSkin(json, geometry);
                        parseMorphing(json, geometry);
                        parseAnimations(json, geometry);
                        geometry.computeFaceNormals();
                        geometry.computeBoundingSphere();
                        if (json.materials === undefined || json.materials.length === 0) {
                            return {
                                geometry: geometry
                            }
                        } else {
                            var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                            return {
                                geometry: geometry,
                                materials: materials
                            }
                        }
                    }
                }()
            });

            function ObjectLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager;
                this.texturePath = ""
            }
            Object.assign(ObjectLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    if (this.texturePath === "") {
                        this.texturePath = url.substring(0, url.lastIndexOf("/") + 1)
                    }
                    var scope = this;
                    var loader = new FileLoader(scope.manager);
                    loader.load(url, function(text) {
                        var json = null;
                        try {
                            json = JSON.parse(text)
                        } catch (error) {
                            if (onError !== undefined) onError(error);
                            console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
                            return
                        }
                        var metadata = json.metadata;
                        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === "geometry") {
                            console.error("THREE.ObjectLoader: Can't load " + url + ". Use THREE.JSONLoader instead.");
                            return
                        }
                        scope.parse(json, onLoad)
                    }, onProgress, onError)
                },
                setTexturePath: function(value) {
                    this.texturePath = value
                },
                setCrossOrigin: function(value) {
                    this.crossOrigin = value
                },
                parse: function(json, onLoad) {
                    var shapes = this.parseShape(json.shapes);
                    var geometries = this.parseGeometries(json.geometries, shapes);
                    var images = this.parseImages(json.images, function() {
                        if (onLoad !== undefined) onLoad(object)
                    });
                    var textures = this.parseTextures(json.textures, images);
                    var materials = this.parseMaterials(json.materials, textures);
                    var object = this.parseObject(json.object, geometries, materials);
                    if (json.animations) {
                        object.animations = this.parseAnimations(json.animations)
                    }
                    if (json.images === undefined || json.images.length === 0) {
                        if (onLoad !== undefined) onLoad(object)
                    }
                    return object
                },
                parseShape: function(json) {
                    var shapes = {};
                    if (json !== undefined) {
                        for (var i = 0, l = json.length; i < l; i++) {
                            var shape = (new Shape).fromJSON(json[i]);
                            shapes[shape.uuid] = shape
                        }
                    }
                    return shapes
                },
                parseGeometries: function(json, shapes) {
                    var geometries = {};
                    if (json !== undefined) {
                        var geometryLoader = new JSONLoader;
                        var bufferGeometryLoader = new BufferGeometryLoader;
                        for (var i = 0, l = json.length; i < l; i++) {
                            var geometry;
                            var data = json[i];
                            switch (data.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    geometry = new Geometries[data.type](data.radius, data.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    var geometryShapes = [];
                                    for (var i = 0, l = data.shapes.length; i < l; i++) {
                                        var shape = shapes[data.shapes[i]];
                                        geometryShapes.push(shape)
                                    }
                                    geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                                    break;
                                case "BufferGeometry":
                                    geometry = bufferGeometryLoader.parse(data);
                                    break;
                                case "Geometry":
                                    geometry = geometryLoader.parse(data, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                                    continue
                            }
                            geometry.uuid = data.uuid;
                            if (data.name !== undefined) geometry.name = data.name;
                            geometries[data.uuid] = geometry
                        }
                    }
                    return geometries
                },
                parseMaterials: function(json, textures) {
                    var materials = {};
                    if (json !== undefined) {
                        var loader = new MaterialLoader;
                        loader.setTextures(textures);
                        for (var i = 0, l = json.length; i < l; i++) {
                            var data = json[i];
                            if (data.type === "MultiMaterial") {
                                var array = [];
                                for (var j = 0; j < data.materials.length; j++) {
                                    array.push(loader.parse(data.materials[j]))
                                }
                                materials[data.uuid] = array
                            } else {
                                materials[data.uuid] = loader.parse(data)
                            }
                        }
                    }
                    return materials
                },
                parseAnimations: function(json) {
                    var animations = [];
                    for (var i = 0; i < json.length; i++) {
                        var clip = AnimationClip.parse(json[i]);
                        animations.push(clip)
                    }
                    return animations
                },
                parseImages: function(json, onLoad) {
                    var scope = this;
                    var images = {};

                    function loadImage(url) {
                        scope.manager.itemStart(url);
                        return loader.load(url, function() {
                            scope.manager.itemEnd(url)
                        }, undefined, function() {
                            scope.manager.itemEnd(url);
                            scope.manager.itemError(url)
                        })
                    }
                    if (json !== undefined && json.length > 0) {
                        var manager = new LoadingManager(onLoad);
                        var loader = new ImageLoader(manager);
                        loader.setCrossOrigin(this.crossOrigin);
                        for (var i = 0, l = json.length; i < l; i++) {
                            var image = json[i];
                            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                            images[image.uuid] = loadImage(path)
                        }
                    }
                    return images
                },
                parseTextures: function(json, images) {
                    function parseConstant(value, type) {
                        if (typeof value === "number") return value;
                        console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
                        return type[value]
                    }
                    var textures = {};
                    if (json !== undefined) {
                        for (var i = 0, l = json.length; i < l; i++) {
                            var data = json[i];
                            if (data.image === undefined) {
                                console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid)
                            }
                            if (images[data.image] === undefined) {
                                console.warn("THREE.ObjectLoader: Undefined image", data.image)
                            }
                            var texture = new Texture(images[data.image]);
                            texture.needsUpdate = true;
                            texture.uuid = data.uuid;
                            if (data.name !== undefined) texture.name = data.name;
                            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                            if (data.center !== undefined) texture.center.fromArray(data.center);
                            if (data.rotation !== undefined) texture.rotation = data.rotation;
                            if (data.wrap !== undefined) {
                                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING)
                            }
                            if (data.format !== undefined) texture.format = data.format;
                            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                            if (data.flipY !== undefined) texture.flipY = data.flipY;
                            textures[data.uuid] = texture
                        }
                    }
                    return textures
                },
                parseObject: function(data, geometries, materials) {
                    var object;

                    function getGeometry(name) {
                        if (geometries[name] === undefined) {
                            console.warn("THREE.ObjectLoader: Undefined geometry", name)
                        }
                        return geometries[name]
                    }

                    function getMaterial(name) {
                        if (name === undefined) return undefined;
                        if (Array.isArray(name)) {
                            var array = [];
                            for (var i = 0, l = name.length; i < l; i++) {
                                var uuid = name[i];
                                if (materials[uuid] === undefined) {
                                    console.warn("THREE.ObjectLoader: Undefined material", uuid)
                                }
                                array.push(materials[uuid])
                            }
                            return array
                        }
                        if (materials[name] === undefined) {
                            console.warn("THREE.ObjectLoader: Undefined material", name)
                        }
                        return materials[name]
                    }
                    switch (data.type) {
                        case "Scene":
                            object = new Scene;
                            if (data.background !== undefined) {
                                if (Number.isInteger(data.background)) {
                                    object.background = new Color(data.background)
                                }
                            }
                            if (data.fog !== undefined) {
                                if (data.fog.type === "Fog") {
                                    object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far)
                                } else if (data.fog.type === "FogExp2") {
                                    object.fog = new FogExp2(data.fog.color, data.fog.density)
                                }
                            }
                            break;
                        case "PerspectiveCamera":
                            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                            if (data.focus !== undefined) object.focus = data.focus;
                            if (data.zoom !== undefined) object.zoom = data.zoom;
                            if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                            if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                            if (data.view !== undefined) object.view = Object.assign({}, data.view);
                            break;
                        case "OrthographicCamera":
                            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                            if (data.zoom !== undefined) object.zoom = data.zoom;
                            if (data.view !== undefined) object.view = Object.assign({}, data.view);
                            break;
                        case "AmbientLight":
                            object = new AmbientLight(data.color, data.intensity);
                            break;
                        case "DirectionalLight":
                            object = new DirectionalLight(data.color, data.intensity);
                            break;
                        case "PointLight":
                            object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                            break;
                        case "RectAreaLight":
                            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                            break;
                        case "SpotLight":
                            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                            break;
                        case "HemisphereLight":
                            object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var geometry = getGeometry(data.geometry);
                            var material = getMaterial(data.material);
                            if (geometry.bones && geometry.bones.length > 0) {
                                object = new SkinnedMesh(geometry, material)
                            } else {
                                object = new Mesh(geometry, material)
                            }
                            break;
                        case "LOD":
                            object = new LOD;
                            break;
                        case "Line":
                            object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                            break;
                        case "LineLoop":
                            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                            break;
                        case "LineSegments":
                            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                            break;
                        case "Sprite":
                            object = new Sprite(getMaterial(data.material));
                            break;
                        case "Group":
                            object = new Group;
                            break;
                        default:
                            object = new Object3D
                    }
                    object.uuid = data.uuid;
                    if (data.name !== undefined) object.name = data.name;
                    if (data.matrix !== undefined) {
                        object.matrix.fromArray(data.matrix);
                        object.matrix.decompose(object.position, object.quaternion, object.scale)
                    } else {
                        if (data.position !== undefined) object.position.fromArray(data.position);
                        if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                        if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                        if (data.scale !== undefined) object.scale.fromArray(data.scale)
                    }
                    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
                    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
                    if (data.shadow) {
                        if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                        if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                        if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                        if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera)
                    }
                    if (data.visible !== undefined) object.visible = data.visible;
                    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
                    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
                    if (data.userData !== undefined) object.userData = data.userData;
                    if (data.children !== undefined) {
                        var children = data.children;
                        for (var i = 0; i < children.length; i++) {
                            object.add(this.parseObject(children[i], geometries, materials))
                        }
                    }
                    if (data.type === "LOD") {
                        var levels = data.levels;
                        for (var l = 0; l < levels.length; l++) {
                            var level = levels[l];
                            var child = object.getObjectByProperty("uuid", level.object);
                            if (child !== undefined) {
                                object.addLevel(child, level.distance)
                            }
                        }
                    }
                    return object
                }
            });
            var TEXTURE_MAPPING = {
                UVMapping: UVMapping,
                CubeReflectionMapping: CubeReflectionMapping,
                CubeRefractionMapping: CubeRefractionMapping,
                EquirectangularReflectionMapping: EquirectangularReflectionMapping,
                EquirectangularRefractionMapping: EquirectangularRefractionMapping,
                SphericalReflectionMapping: SphericalReflectionMapping,
                CubeUVReflectionMapping: CubeUVReflectionMapping,
                CubeUVRefractionMapping: CubeUVRefractionMapping
            };
            var TEXTURE_WRAPPING = {
                RepeatWrapping: RepeatWrapping,
                ClampToEdgeWrapping: ClampToEdgeWrapping,
                MirroredRepeatWrapping: MirroredRepeatWrapping
            };
            var TEXTURE_FILTER = {
                NearestFilter: NearestFilter,
                NearestMipMapNearestFilter: NearestMipMapNearestFilter,
                NearestMipMapLinearFilter: NearestMipMapLinearFilter,
                LinearFilter: LinearFilter,
                LinearMipMapNearestFilter: LinearMipMapNearestFilter,
                LinearMipMapLinearFilter: LinearMipMapLinearFilter
            };

            function ImageBitmapLoader(manager) {
                if (typeof createImageBitmap === "undefined") {
                    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.")
                }
                if (typeof fetch === "undefined") {
                    console.warn("THREE.ImageBitmapLoader: fetch() not supported.")
                }
                this.manager = manager !== undefined ? manager : DefaultLoadingManager;
                this.options = undefined
            }
            ImageBitmapLoader.prototype = {
                constructor: ImageBitmapLoader,
                setOptions: function setOptions(options) {
                    this.options = options;
                    return this
                },
                load: function load(url, onLoad, onProgress, onError) {
                    if (url === undefined) url = "";
                    if (this.path !== undefined) url = this.path + url;
                    var scope = this;
                    var cached = Cache.get(url);
                    if (cached !== undefined) {
                        scope.manager.itemStart(url);
                        setTimeout(function() {
                            if (onLoad) onLoad(cached);
                            scope.manager.itemEnd(url)
                        }, 0);
                        return cached
                    }
                    fetch(url).then(function(res) {
                        return res.blob()
                    }).then(function(blob) {
                        return createImageBitmap(blob, scope.options)
                    }).then(function(imageBitmap) {
                        Cache.add(url, imageBitmap);
                        if (onLoad) onLoad(imageBitmap);
                        scope.manager.itemEnd(url)
                    }).catch(function(e) {
                        if (onError) onError(e);
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url)
                    })
                },
                setCrossOrigin: function() {
                    return this
                },
                setPath: function(value) {
                    this.path = value;
                    return this
                }
            };

            function ShapePath() {
                this.type = "ShapePath";
                this.subPaths = [];
                this.currentPath = null
            }
            Object.assign(ShapePath.prototype, {
                moveTo: function(x, y) {
                    this.currentPath = new Path;
                    this.subPaths.push(this.currentPath);
                    this.currentPath.moveTo(x, y)
                },
                lineTo: function(x, y) {
                    this.currentPath.lineTo(x, y)
                },
                quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
                    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY)
                },
                bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY)
                },
                splineThru: function(pts) {
                    this.currentPath.splineThru(pts)
                },
                toShapes: function(isCCW, noHoles) {
                    function toShapesNoHoles(inSubpaths) {
                        var shapes = [];
                        for (var i = 0, l = inSubpaths.length; i < l; i++) {
                            var tmpPath = inSubpaths[i];
                            var tmpShape = new Shape;
                            tmpShape.curves = tmpPath.curves;
                            shapes.push(tmpShape)
                        }
                        return shapes
                    }

                    function isPointInsidePolygon(inPt, inPolygon) {
                        var polyLen = inPolygon.length;
                        var inside = false;
                        for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                            var edgeLowPt = inPolygon[p];
                            var edgeHighPt = inPolygon[q];
                            var edgeDx = edgeHighPt.x - edgeLowPt.x;
                            var edgeDy = edgeHighPt.y - edgeLowPt.y;
                            if (Math.abs(edgeDy) > Number.EPSILON) {
                                if (edgeDy < 0) {
                                    edgeLowPt = inPolygon[q];
                                    edgeDx = -edgeDx;
                                    edgeHighPt = inPolygon[p];
                                    edgeDy = -edgeDy
                                }
                                if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                                if (inPt.y === edgeLowPt.y) {
                                    if (inPt.x === edgeLowPt.x) return true
                                } else {
                                    var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                    if (perpEdge === 0) return true;
                                    if (perpEdge < 0) continue;
                                    inside = !inside
                                }
                            } else {
                                if (inPt.y !== edgeLowPt.y) continue;
                                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true
                            }
                        }
                        return inside
                    }
                    var isClockWise = ShapeUtils.isClockWise;
                    var subPaths = this.subPaths;
                    if (subPaths.length === 0) return [];
                    if (noHoles === true) return toShapesNoHoles(subPaths);
                    var solid, tmpPath, tmpShape, shapes = [];
                    if (subPaths.length === 1) {
                        tmpPath = subPaths[0];
                        tmpShape = new Shape;
                        tmpShape.curves = tmpPath.curves;
                        shapes.push(tmpShape);
                        return shapes
                    }
                    var holesFirst = !isClockWise(subPaths[0].getPoints());
                    holesFirst = isCCW ? !holesFirst : holesFirst;
                    var betterShapeHoles = [];
                    var newShapes = [];
                    var newShapeHoles = [];
                    var mainIdx = 0;
                    var tmpPoints;
                    newShapes[mainIdx] = undefined;
                    newShapeHoles[mainIdx] = [];
                    for (var i = 0, l = subPaths.length; i < l; i++) {
                        tmpPath = subPaths[i];
                        tmpPoints = tmpPath.getPoints();
                        solid = isClockWise(tmpPoints);
                        solid = isCCW ? !solid : solid;
                        if (solid) {
                            if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                            newShapes[mainIdx] = {
                                s: new Shape,
                                p: tmpPoints
                            };
                            newShapes[mainIdx].s.curves = tmpPath.curves;
                            if (holesFirst) mainIdx++;
                            newShapeHoles[mainIdx] = []
                        } else {
                            newShapeHoles[mainIdx].push({
                                h: tmpPath,
                                p: tmpPoints[0]
                            })
                        }
                    }
                    if (!newShapes[0]) return toShapesNoHoles(subPaths);
                    if (newShapes.length > 1) {
                        var ambiguous = false;
                        var toChange = [];
                        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                            betterShapeHoles[sIdx] = []
                        }
                        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                            var sho = newShapeHoles[sIdx];
                            for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                                var ho = sho[hIdx];
                                var hole_unassigned = true;
                                for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                                    if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                        if (sIdx !== s2Idx) toChange.push({
                                            froms: sIdx,
                                            tos: s2Idx,
                                            hole: hIdx
                                        });
                                        if (hole_unassigned) {
                                            hole_unassigned = false;
                                            betterShapeHoles[s2Idx].push(ho)
                                        } else {
                                            ambiguous = true
                                        }
                                    }
                                }
                                if (hole_unassigned) {
                                    betterShapeHoles[sIdx].push(ho)
                                }
                            }
                        }
                        if (toChange.length > 0) {
                            if (!ambiguous) newShapeHoles = betterShapeHoles
                        }
                    }
                    var tmpHoles;
                    for (var i = 0, il = newShapes.length; i < il; i++) {
                        tmpShape = newShapes[i].s;
                        shapes.push(tmpShape);
                        tmpHoles = newShapeHoles[i];
                        for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                            tmpShape.holes.push(tmpHoles[j].h)
                        }
                    }
                    return shapes
                }
            });

            function Font(data) {
                this.type = "Font";
                this.data = data
            }
            Object.assign(Font.prototype, {
                isFont: true,
                generateShapes: function(text, size, divisions) {
                    if (size === undefined) size = 100;
                    if (divisions === undefined) divisions = 4;
                    var shapes = [];
                    var paths = createPaths(text, size, divisions, this.data);
                    for (var p = 0, pl = paths.length; p < pl; p++) {
                        Array.prototype.push.apply(shapes, paths[p].toShapes())
                    }
                    return shapes
                }
            });

            function createPaths(text, size, divisions, data) {
                var chars = String(text).split("");
                var scale = size / data.resolution;
                var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
                var paths = [];
                var offsetX = 0,
                    offsetY = 0;
                for (var i = 0; i < chars.length; i++) {
                    var char = chars[i];
                    if (char === "\n") {
                        offsetX = 0;
                        offsetY -= line_height
                    } else {
                        var ret = createPath(char, divisions, scale, offsetX, offsetY, data);
                        offsetX += ret.offsetX;
                        paths.push(ret.path)
                    }
                }
                return paths
            }

            function createPath(char, divisions, scale, offsetX, offsetY, data) {
                var glyph = data.glyphs[char] || data.glyphs["?"];
                if (!glyph) return;
                var path = new ShapePath;
                var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
                if (glyph.o) {
                    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
                    for (var i = 0, l = outline.length; i < l;) {
                        var action = outline[i++];
                        switch (action) {
                            case "m":
                                x = outline[i++] * scale + offsetX;
                                y = outline[i++] * scale + offsetY;
                                path.moveTo(x, y);
                                break;
                            case "l":
                                x = outline[i++] * scale + offsetX;
                                y = outline[i++] * scale + offsetY;
                                path.lineTo(x, y);
                                break;
                            case "q":
                                cpx = outline[i++] * scale + offsetX;
                                cpy = outline[i++] * scale + offsetY;
                                cpx1 = outline[i++] * scale + offsetX;
                                cpy1 = outline[i++] * scale + offsetY;
                                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                                break;
                            case "b":
                                cpx = outline[i++] * scale + offsetX;
                                cpy = outline[i++] * scale + offsetY;
                                cpx1 = outline[i++] * scale + offsetX;
                                cpy1 = outline[i++] * scale + offsetY;
                                cpx2 = outline[i++] * scale + offsetX;
                                cpy2 = outline[i++] * scale + offsetY;
                                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                                break
                        }
                    }
                }
                return {
                    offsetX: glyph.ha * scale,
                    path: path
                }
            }

            function FontLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager
            }
            Object.assign(FontLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var scope = this;
                    var loader = new FileLoader(this.manager);
                    loader.setPath(this.path);
                    loader.load(url, function(text) {
                        var json;
                        try {
                            json = JSON.parse(text)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
                            json = JSON.parse(text.substring(65, text.length - 2))
                        }
                        var font = scope.parse(json);
                        if (onLoad) onLoad(font)
                    }, onProgress, onError)
                },
                parse: function(json) {
                    return new Font(json)
                },
                setPath: function(value) {
                    this.path = value;
                    return this
                }
            });
            var context;
            var AudioContext = {
                getContext: function() {
                    if (context === undefined) {
                        context = new(window.AudioContext || window.webkitAudioContext)
                    }
                    return context
                },
                setContext: function(value) {
                    context = value
                }
            };

            function AudioLoader(manager) {
                this.manager = manager !== undefined ? manager : DefaultLoadingManager
            }
            Object.assign(AudioLoader.prototype, {
                load: function(url, onLoad, onProgress, onError) {
                    var loader = new FileLoader(this.manager);
                    loader.setResponseType("arraybuffer");
                    loader.load(url, function(buffer) {
                        var context = AudioContext.getContext();
                        context.decodeAudioData(buffer, function(audioBuffer) {
                            onLoad(audioBuffer)
                        })
                    }, onProgress, onError)
                }
            });

            function StereoCamera() {
                this.type = "StereoCamera";
                this.aspect = 1;
                this.eyeSep = .064;
                this.cameraL = new PerspectiveCamera;
                this.cameraL.layers.enable(1);
                this.cameraL.matrixAutoUpdate = false;
                this.cameraR = new PerspectiveCamera;
                this.cameraR.layers.enable(2);
                this.cameraR.matrixAutoUpdate = false
            }
            Object.assign(StereoCamera.prototype, {
                update: function() {
                    var instance, focus, fov, aspect, near, far, zoom, eyeSep;
                    var eyeRight = new Matrix4;
                    var eyeLeft = new Matrix4;
                    return function update(camera) {
                        var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
                        if (needsUpdate) {
                            instance = this;
                            focus = camera.focus;
                            fov = camera.fov;
                            aspect = camera.aspect * this.aspect;
                            near = camera.near;
                            far = camera.far;
                            zoom = camera.zoom;
                            var projectionMatrix = camera.projectionMatrix.clone();
                            eyeSep = this.eyeSep / 2;
                            var eyeSepOnProjection = eyeSep * near / focus;
                            var ymax = near * Math.tan(_Math.DEG2RAD * fov * .5) / zoom;
                            var xmin, xmax;
                            eyeLeft.elements[12] = -eyeSep;
                            eyeRight.elements[12] = eyeSep;
                            xmin = -ymax * aspect + eyeSepOnProjection;
                            xmax = ymax * aspect + eyeSepOnProjection;
                            projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                            this.cameraL.projectionMatrix.copy(projectionMatrix);
                            xmin = -ymax * aspect - eyeSepOnProjection;
                            xmax = ymax * aspect - eyeSepOnProjection;
                            projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                            this.cameraR.projectionMatrix.copy(projectionMatrix)
                        }
                        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
                        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight)
                    }
                }()
            });

            function CubeCamera(near, far, cubeResolution) {
                Object3D.call(this);
                this.type = "CubeCamera";
                var fov = 90,
                    aspect = 1;
                var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
                cameraPX.up.set(0, -1, 0);
                cameraPX.lookAt(new Vector3(1, 0, 0));
                this.add(cameraPX);
                var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
                cameraNX.up.set(0, -1, 0);
                cameraNX.lookAt(new Vector3(-1, 0, 0));
                this.add(cameraNX);
                var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
                cameraPY.up.set(0, 0, 1);
                cameraPY.lookAt(new Vector3(0, 1, 0));
                this.add(cameraPY);
                var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
                cameraNY.up.set(0, 0, -1);
                cameraNY.lookAt(new Vector3(0, -1, 0));
                this.add(cameraNY);
                var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
                cameraPZ.up.set(0, -1, 0);
                cameraPZ.lookAt(new Vector3(0, 0, 1));
                this.add(cameraPZ);
                var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
                cameraNZ.up.set(0, -1, 0);
                cameraNZ.lookAt(new Vector3(0, 0, -1));
                this.add(cameraNZ);
                var options = {
                    format: RGBFormat,
                    magFilter: LinearFilter,
                    minFilter: LinearFilter
                };
                this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
                this.renderTarget.texture.name = "CubeCamera";
                this.update = function(renderer, scene) {
                    if (this.parent === null) this.updateMatrixWorld();
                    var renderTarget = this.renderTarget;
                    var generateMipmaps = renderTarget.texture.generateMipmaps;
                    renderTarget.texture.generateMipmaps = false;
                    renderTarget.activeCubeFace = 0;
                    renderer.render(scene, cameraPX, renderTarget);
                    renderTarget.activeCubeFace = 1;
                    renderer.render(scene, cameraNX, renderTarget);
                    renderTarget.activeCubeFace = 2;
                    renderer.render(scene, cameraPY, renderTarget);
                    renderTarget.activeCubeFace = 3;
                    renderer.render(scene, cameraNY, renderTarget);
                    renderTarget.activeCubeFace = 4;
                    renderer.render(scene, cameraPZ, renderTarget);
                    renderTarget.texture.generateMipmaps = generateMipmaps;
                    renderTarget.activeCubeFace = 5;
                    renderer.render(scene, cameraNZ, renderTarget);
                    renderer.setRenderTarget(null)
                };
                this.clear = function(renderer, color, depth, stencil) {
                    var renderTarget = this.renderTarget;
                    for (var i = 0; i < 6; i++) {
                        renderTarget.activeCubeFace = i;
                        renderer.setRenderTarget(renderTarget);
                        renderer.clear(color, depth, stencil)
                    }
                    renderer.setRenderTarget(null)
                }
            }
            CubeCamera.prototype = Object.create(Object3D.prototype);
            CubeCamera.prototype.constructor = CubeCamera;

            function AudioListener() {
                Object3D.call(this);
                this.type = "AudioListener";
                this.context = AudioContext.getContext();
                this.gain = this.context.createGain();
                this.gain.connect(this.context.destination);
                this.filter = null
            }
            AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: AudioListener,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    if (this.filter !== null) {
                        this.gain.disconnect(this.filter);
                        this.filter.disconnect(this.context.destination);
                        this.gain.connect(this.context.destination);
                        this.filter = null
                    }
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(value) {
                    if (this.filter !== null) {
                        this.gain.disconnect(this.filter);
                        this.filter.disconnect(this.context.destination)
                    } else {
                        this.gain.disconnect(this.context.destination)
                    }
                    this.filter = value;
                    this.gain.connect(this.filter);
                    this.filter.connect(this.context.destination)
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(value) {
                    this.gain.gain.value = value
                },
                updateMatrixWorld: function() {
                    var position = new Vector3;
                    var quaternion = new Quaternion;
                    var scale = new Vector3;
                    var orientation = new Vector3;
                    return function updateMatrixWorld(force) {
                        Object3D.prototype.updateMatrixWorld.call(this, force);
                        var listener = this.context.listener;
                        var up = this.up;
                        this.matrixWorld.decompose(position, quaternion, scale);
                        orientation.set(0, 0, -1).applyQuaternion(quaternion);
                        if (listener.positionX) {
                            listener.positionX.setValueAtTime(position.x, this.context.currentTime);
                            listener.positionY.setValueAtTime(position.y, this.context.currentTime);
                            listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
                            listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
                            listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
                            listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
                            listener.upX.setValueAtTime(up.x, this.context.currentTime);
                            listener.upY.setValueAtTime(up.y, this.context.currentTime);
                            listener.upZ.setValueAtTime(up.z, this.context.currentTime)
                        } else {
                            listener.setPosition(position.x, position.y, position.z);
                            listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z)
                        }
                    }
                }()
            });

            function Audio(listener) {
                Object3D.call(this);
                this.type = "Audio";
                this.context = listener.context;
                this.gain = this.context.createGain();
                this.gain.connect(listener.getInput());
                this.autoplay = false;
                this.buffer = null;
                this.loop = false;
                this.startTime = 0;
                this.offset = 0;
                this.playbackRate = 1;
                this.isPlaying = false;
                this.hasPlaybackControl = true;
                this.sourceType = "empty";
                this.filters = []
            }
            Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
                constructor: Audio,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(audioNode) {
                    this.hasPlaybackControl = false;
                    this.sourceType = "audioNode";
                    this.source = audioNode;
                    this.connect();
                    return this
                },
                setBuffer: function(audioBuffer) {
                    this.buffer = audioBuffer;
                    this.sourceType = "buffer";
                    if (this.autoplay) this.play();
                    return this
                },
                play: function() {
                    if (this.isPlaying === true) {
                        console.warn("THREE.Audio: Audio is already playing.");
                        return
                    }
                    if (this.hasPlaybackControl === false) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    var source = this.context.createBufferSource();
                    source.buffer = this.buffer;
                    source.loop = this.loop;
                    source.onended = this.onEnded.bind(this);
                    source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
                    this.startTime = this.context.currentTime;
                    source.start(this.startTime, this.offset);
                    this.isPlaying = true;
                    this.source = source;
                    return this.connect()
                },
                pause: function() {
                    if (this.hasPlaybackControl === false) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    if (this.isPlaying === true) {
                        this.source.stop();
                        this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
                        this.isPlaying = false
                    }
                    return this
                },
                stop: function() {
                    if (this.hasPlaybackControl === false) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    this.source.stop();
                    this.offset = 0;
                    this.isPlaying = false;
                    return this
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var i = 1, l = this.filters.length; i < l; i++) {
                            this.filters[i - 1].connect(this.filters[i])
                        }
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else {
                        this.source.connect(this.getOutput())
                    }
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var i = 1, l = this.filters.length; i < l; i++) {
                            this.filters[i - 1].disconnect(this.filters[i])
                        }
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else {
                        this.source.disconnect(this.getOutput())
                    }
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(value) {
                    if (!value) value = [];
                    if (this.isPlaying === true) {
                        this.disconnect();
                        this.filters = value;
                        this.connect()
                    } else {
                        this.filters = value
                    }
                    return this
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(filter) {
                    return this.setFilters(filter ? [filter] : [])
                },
                setPlaybackRate: function(value) {
                    if (this.hasPlaybackControl === false) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    this.playbackRate = value;
                    if (this.isPlaying === true) {
                        this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime)
                    }
                    return this
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = false
                },
                getLoop: function() {
                    if (this.hasPlaybackControl === false) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return false
                    }
                    return this.loop
                },
                setLoop: function(value) {
                    if (this.hasPlaybackControl === false) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    this.loop = value;
                    if (this.isPlaying === true) {
                        this.source.loop = this.loop
                    }
                    return this
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(value) {
                    this.gain.gain.value = value;
                    return this
                }
            });

            function PositionalAudio(listener) {
                Audio.call(this, listener);
                this.panner = this.context.createPanner();
                this.panner.connect(this.gain)
            }
            PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
                constructor: PositionalAudio,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(value) {
                    this.panner.refDistance = value
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(value) {
                    this.panner.rolloffFactor = value
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(value) {
                    this.panner.distanceModel = value
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(value) {
                    this.panner.maxDistance = value
                },
                updateMatrixWorld: function() {
                    var position = new Vector3;
                    return function updateMatrixWorld(force) {
                        Object3D.prototype.updateMatrixWorld.call(this, force);
                        position.setFromMatrixPosition(this.matrixWorld);
                        this.panner.setPosition(position.x, position.y, position.z)
                    }
                }()
            });

            function AudioAnalyser(audio, fftSize) {
                this.analyser = audio.context.createAnalyser();
                this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
                this.data = new Uint8Array(this.analyser.frequencyBinCount);
                audio.getOutput().connect(this.analyser)
            }
            Object.assign(AudioAnalyser.prototype, {
                getFrequencyData: function() {
                    this.analyser.getByteFrequencyData(this.data);
                    return this.data
                },
                getAverageFrequency: function() {
                    var value = 0,
                        data = this.getFrequencyData();
                    for (var i = 0; i < data.length; i++) {
                        value += data[i]
                    }
                    return value / data.length
                }
            });

            function PropertyMixer(binding, typeName, valueSize) {
                this.binding = binding;
                this.valueSize = valueSize;
                var bufferType = Float64Array,
                    mixFunction;
                switch (typeName) {
                    case "quaternion":
                        mixFunction = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        bufferType = Array;
                        mixFunction = this._select;
                        break;
                    default:
                        mixFunction = this._lerp
                }
                this.buffer = new bufferType(valueSize * 4);
                this._mixBufferRegion = mixFunction;
                this.cumulativeWeight = 0;
                this.useCount = 0;
                this.referenceCount = 0
            }
            Object.assign(PropertyMixer.prototype, {
                accumulate: function(accuIndex, weight) {
                    var buffer = this.buffer,
                        stride = this.valueSize,
                        offset = accuIndex * stride + stride,
                        currentWeight = this.cumulativeWeight;
                    if (currentWeight === 0) {
                        for (var i = 0; i !== stride; ++i) {
                            buffer[offset + i] = buffer[i]
                        }
                        currentWeight = weight
                    } else {
                        currentWeight += weight;
                        var mix = weight / currentWeight;
                        this._mixBufferRegion(buffer, offset, 0, mix, stride)
                    }
                    this.cumulativeWeight = currentWeight
                },
                apply: function(accuIndex) {
                    var stride = this.valueSize,
                        buffer = this.buffer,
                        offset = accuIndex * stride + stride,
                        weight = this.cumulativeWeight,
                        binding = this.binding;
                    this.cumulativeWeight = 0;
                    if (weight < 1) {
                        var originalValueOffset = stride * 3;
                        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride)
                    }
                    for (var i = stride, e = stride + stride; i !== e; ++i) {
                        if (buffer[i] !== buffer[i + stride]) {
                            binding.setValue(buffer, offset);
                            break
                        }
                    }
                },
                saveOriginalState: function() {
                    var binding = this.binding;
                    var buffer = this.buffer,
                        stride = this.valueSize,
                        originalValueOffset = stride * 3;
                    binding.getValue(buffer, originalValueOffset);
                    for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                        buffer[i] = buffer[originalValueOffset + i % stride]
                    }
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var originalValueOffset = this.valueSize * 3;
                    this.binding.setValue(this.buffer, originalValueOffset)
                },
                _select: function(buffer, dstOffset, srcOffset, t, stride) {
                    if (t >= .5) {
                        for (var i = 0; i !== stride; ++i) {
                            buffer[dstOffset + i] = buffer[srcOffset + i]
                        }
                    }
                },
                _slerp: function(buffer, dstOffset, srcOffset, t) {
                    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t)
                },
                _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
                    var s = 1 - t;
                    for (var i = 0; i !== stride; ++i) {
                        var j = dstOffset + i;
                        buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t
                    }
                }
            });
            var RESERVED_CHARS_RE = "\\[\\]\\.:\\/";

            function Composite(targetGroup, path, optionalParsedPath) {
                var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
                this._targetGroup = targetGroup;
                this._bindings = targetGroup.subscribe_(path, parsedPath)
            }
            Object.assign(Composite.prototype, {
                getValue: function(array, offset) {
                    this.bind();
                    var firstValidIndex = this._targetGroup.nCachedObjects_,
                        binding = this._bindings[firstValidIndex];
                    if (binding !== undefined) binding.getValue(array, offset)
                },
                setValue: function(array, offset) {
                    var bindings = this._bindings;
                    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                        bindings[i].setValue(array, offset)
                    }
                },
                bind: function() {
                    var bindings = this._bindings;
                    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                        bindings[i].bind()
                    }
                },
                unbind: function() {
                    var bindings = this._bindings;
                    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                        bindings[i].unbind()
                    }
                }
            });

            function PropertyBinding(rootNode, path, parsedPath) {
                this.path = path;
                this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
                this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
                this.rootNode = rootNode
            }
            Object.assign(PropertyBinding, {
                Composite: Composite,
                create: function(root, path, parsedPath) {
                    if (!(root && root.isAnimationObjectGroup)) {
                        return new PropertyBinding(root, path, parsedPath)
                    } else {
                        return new PropertyBinding.Composite(root, path, parsedPath)
                    }
                },
                sanitizeNodeName: function() {
                    var reservedRe = new RegExp("[" + RESERVED_CHARS_RE + "]", "g");
                    return function sanitizeNodeName(name) {
                        return name.replace(/\s/g, "_").replace(reservedRe, "")
                    }
                }(),
                parseTrackName: function() {
                    var wordChar = "[^" + RESERVED_CHARS_RE + "]";
                    var wordCharOrDot = "[^" + RESERVED_CHARS_RE.replace("\\.", "") + "]";
                    var directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", wordChar);
                    var nodeRe = /(WCOD+)?/.source.replace("WCOD", wordCharOrDot);
                    var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wordChar);
                    var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wordChar);
                    var trackRe = new RegExp("" + "^" + directoryRe + nodeRe + objectRe + propertyRe + "$");
                    var supportedObjectNames = ["material", "materials", "bones"];
                    return function parseTrackName(trackName) {
                        var matches = trackRe.exec(trackName);
                        if (!matches) {
                            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName)
                        }
                        var results = {
                            nodeName: matches[2],
                            objectName: matches[3],
                            objectIndex: matches[4],
                            propertyName: matches[5],
                            propertyIndex: matches[6]
                        };
                        var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
                        if (lastDot !== undefined && lastDot !== -1) {
                            var objectName = results.nodeName.substring(lastDot + 1);
                            if (supportedObjectNames.indexOf(objectName) !== -1) {
                                results.nodeName = results.nodeName.substring(0, lastDot);
                                results.objectName = objectName
                            }
                        }
                        if (results.propertyName === null || results.propertyName.length === 0) {
                            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName)
                        }
                        return results
                    }
                }(),
                findNode: function(root, nodeName) {
                    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                        return root
                    }
                    if (root.skeleton) {
                        var bone = root.skeleton.getBoneByName(nodeName);
                        if (bone !== undefined) {
                            return bone
                        }
                    }
                    if (root.children) {
                        var searchNodeSubtree = function(children) {
                            for (var i = 0; i < children.length; i++) {
                                var childNode = children[i];
                                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                                    return childNode
                                }
                                var result = searchNodeSubtree(childNode.children);
                                if (result) return result
                            }
                            return null
                        };
                        var subTreeNode = searchNodeSubtree(root.children);
                        if (subTreeNode) {
                            return subTreeNode
                        }
                    }
                    return null
                }
            });
            Object.assign(PropertyBinding.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function getValue_direct(buffer, offset) {
                    buffer[offset] = this.node[this.propertyName]
                }, function getValue_array(buffer, offset) {
                    var source = this.resolvedProperty;
                    for (var i = 0, n = source.length; i !== n; ++i) {
                        buffer[offset++] = source[i]
                    }
                }, function getValue_arrayElement(buffer, offset) {
                    buffer[offset] = this.resolvedProperty[this.propertyIndex]
                }, function getValue_toArray(buffer, offset) {
                    this.resolvedProperty.toArray(buffer, offset)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function setValue_direct(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset]
                    }, function setValue_direct_setNeedsUpdate(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.needsUpdate = true
                    }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true
                    }],
                    [function setValue_array(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++]
                        }
                    }, function setValue_array_setNeedsUpdate(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++]
                        }
                        this.targetObject.needsUpdate = true
                    }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++]
                        }
                        this.targetObject.matrixWorldNeedsUpdate = true
                    }],
                    [function setValue_arrayElement(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset]
                    }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.needsUpdate = true
                    }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true
                    }],
                    [function setValue_fromArray(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset)
                    }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.needsUpdate = true
                    }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.matrixWorldNeedsUpdate = true
                    }]
                ],
                getValue: function getValue_unbound(targetArray, offset) {
                    this.bind();
                    this.getValue(targetArray, offset)
                },
                setValue: function getValue_unbound(sourceArray, offset) {
                    this.bind();
                    this.setValue(sourceArray, offset)
                },
                bind: function() {
                    var targetObject = this.node,
                        parsedPath = this.parsedPath,
                        objectName = parsedPath.objectName,
                        propertyName = parsedPath.propertyName,
                        propertyIndex = parsedPath.propertyIndex;
                    if (!targetObject) {
                        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                        this.node = targetObject
                    }
                    this.getValue = this._getValue_unavailable;
                    this.setValue = this._setValue_unavailable;
                    if (!targetObject) {
                        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        return
                    }
                    if (objectName) {
                        var objectIndex = parsedPath.objectIndex;
                        switch (objectName) {
                            case "materials":
                                if (!targetObject.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!targetObject.material.materials) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                targetObject = targetObject.material.materials;
                                break;
                            case "bones":
                                if (!targetObject.skeleton) {
                                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                targetObject = targetObject.skeleton.bones;
                                for (var i = 0; i < targetObject.length; i++) {
                                    if (targetObject[i].name === objectIndex) {
                                        objectIndex = i;
                                        break
                                    }
                                }
                                break;
                            default:
                                if (targetObject[objectName] === undefined) {
                                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                targetObject = targetObject[objectName]
                        }
                        if (objectIndex !== undefined) {
                            if (targetObject[objectIndex] === undefined) {
                                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                                return
                            }
                            targetObject = targetObject[objectIndex]
                        }
                    }
                    var nodeProperty = targetObject[propertyName];
                    if (nodeProperty === undefined) {
                        var nodeName = parsedPath.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
                        return
                    }
                    var versioning = this.Versioning.None;
                    if (targetObject.needsUpdate !== undefined) {
                        versioning = this.Versioning.NeedsUpdate;
                        this.targetObject = targetObject
                    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                        versioning = this.Versioning.MatrixWorldNeedsUpdate;
                        this.targetObject = targetObject
                    }
                    var bindingType = this.BindingType.Direct;
                    if (propertyIndex !== undefined) {
                        if (propertyName === "morphTargetInfluences") {
                            if (!targetObject.geometry) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                return
                            }
                            if (targetObject.geometry.isBufferGeometry) {
                                if (!targetObject.geometry.morphAttributes) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    return
                                }
                                for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
                                    if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                                        propertyIndex = i;
                                        break
                                    }
                                }
                            } else {
                                if (!targetObject.geometry.morphTargets) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    return
                                }
                                for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                                    if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                                        propertyIndex = i;
                                        break
                                    }
                                }
                            }
                        }
                        bindingType = this.BindingType.ArrayElement;
                        this.resolvedProperty = nodeProperty;
                        this.propertyIndex = propertyIndex
                    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                        bindingType = this.BindingType.HasFromToArray;
                        this.resolvedProperty = nodeProperty
                    } else if (Array.isArray(nodeProperty)) {
                        bindingType = this.BindingType.EntireArray;
                        this.resolvedProperty = nodeProperty
                    } else {
                        this.propertyName = propertyName
                    }
                    this.getValue = this.GetterByBindingType[bindingType];
                    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning]
                },
                unbind: function() {
                    this.node = null;
                    this.getValue = this._getValue_unbound;
                    this.setValue = this._setValue_unbound
                }
            });
            Object.assign(PropertyBinding.prototype, {
                _getValue_unbound: PropertyBinding.prototype.getValue,
                _setValue_unbound: PropertyBinding.prototype.setValue
            });

            function AnimationObjectGroup() {
                this.uuid = _Math.generateUUID();
                this._objects = Array.prototype.slice.call(arguments);
                this.nCachedObjects_ = 0;
                var indices = {};
                this._indicesByUUID = indices;
                for (var i = 0, n = arguments.length; i !== n; ++i) {
                    indices[arguments[i].uuid] = i
                }
                this._paths = [];
                this._parsedPaths = [];
                this._bindings = [];
                this._bindingsIndicesByPath = {};
                var scope = this;
                this.stats = {
                    objects: {get total() {
                            return scope._objects.length
                        },
                        get inUse() {
                            return this.total - scope.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return scope._bindings.length
                    }
                }
            }
            Object.assign(AnimationObjectGroup.prototype, {
                isAnimationObjectGroup: true,
                add: function() {
                    var objects = this._objects,
                        nObjects = objects.length,
                        nCachedObjects = this.nCachedObjects_,
                        indicesByUUID = this._indicesByUUID,
                        paths = this._paths,
                        parsedPaths = this._parsedPaths,
                        bindings = this._bindings,
                        nBindings = bindings.length,
                        knownObject = undefined;
                    for (var i = 0, n = arguments.length; i !== n; ++i) {
                        var object = arguments[i],
                            uuid = object.uuid,
                            index = indicesByUUID[uuid];
                        if (index === undefined) {
                            index = nObjects++;
                            indicesByUUID[uuid] = index;
                            objects.push(object);
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]))
                            }
                        } else if (index < nCachedObjects) {
                            knownObject = objects[index];
                            var firstActiveIndex = --nCachedObjects,
                                lastCachedObject = objects[firstActiveIndex];
                            indicesByUUID[lastCachedObject.uuid] = index;
                            objects[index] = lastCachedObject;
                            indicesByUUID[uuid] = firstActiveIndex;
                            objects[firstActiveIndex] = object;
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                var bindingsForPath = bindings[j],
                                    lastCached = bindingsForPath[firstActiveIndex],
                                    binding = bindingsForPath[index];
                                bindingsForPath[index] = lastCached;
                                if (binding === undefined) {
                                    binding = new PropertyBinding(object, paths[j], parsedPaths[j])
                                }
                                bindingsForPath[firstActiveIndex] = binding
                            }
                        } else if (objects[index] !== knownObject) {
                            console.error("THREE.AnimationObjectGroup: Different objects with the same UUID " + "detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                    }
                    this.nCachedObjects_ = nCachedObjects
                },
                remove: function() {
                    var objects = this._objects,
                        nCachedObjects = this.nCachedObjects_,
                        indicesByUUID = this._indicesByUUID,
                        bindings = this._bindings,
                        nBindings = bindings.length;
                    for (var i = 0, n = arguments.length; i !== n; ++i) {
                        var object = arguments[i],
                            uuid = object.uuid,
                            index = indicesByUUID[uuid];
                        if (index !== undefined && index >= nCachedObjects) {
                            var lastCachedIndex = nCachedObjects++,
                                firstActiveObject = objects[lastCachedIndex];
                            indicesByUUID[firstActiveObject.uuid] = index;
                            objects[index] = firstActiveObject;
                            indicesByUUID[uuid] = lastCachedIndex;
                            objects[lastCachedIndex] = object;
                            for (var j = 0, m = nBindings; j !== m; ++j) {
                                var bindingsForPath = bindings[j],
                                    firstActive = bindingsForPath[lastCachedIndex],
                                    binding = bindingsForPath[index];
                                bindingsForPath[index] = firstActive;
                                bindingsForPath[lastCachedIndex] = binding
                            }
                        }
                    }
                    this.nCachedObjects_ = nCachedObjects
                },
                uncache: function() {
                    var objects = this._objects,
                        nObjects = objects.length,
                        nCachedObjects = this.nCachedObjects_,
                        indicesByUUID = this._indicesByUUID,
                        bindings = this._bindings,
                        nBindings = bindings.length;
                    for (var i = 0, n = arguments.length; i !== n; ++i) {
                        var object = arguments[i],
                            uuid = object.uuid,
                            index = indicesByUUID[uuid];
                        if (index !== undefined) {
                            delete indicesByUUID[uuid];
                            if (index < nCachedObjects) {
                                var firstActiveIndex = --nCachedObjects,
                                    lastCachedObject = objects[firstActiveIndex],
                                    lastIndex = --nObjects,
                                    lastObject = objects[lastIndex];
                                indicesByUUID[lastCachedObject.uuid] = index;
                                objects[index] = lastCachedObject;
                                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                                objects[firstActiveIndex] = lastObject;
                                objects.pop();
                                for (var j = 0, m = nBindings; j !== m; ++j) {
                                    var bindingsForPath = bindings[j],
                                        lastCached = bindingsForPath[firstActiveIndex],
                                        last = bindingsForPath[lastIndex];
                                    bindingsForPath[index] = lastCached;
                                    bindingsForPath[firstActiveIndex] = last;
                                    bindingsForPath.pop()
                                }
                            } else {
                                var lastIndex = --nObjects,
                                    lastObject = objects[lastIndex];
                                indicesByUUID[lastObject.uuid] = index;
                                objects[index] = lastObject;
                                objects.pop();
                                for (var j = 0, m = nBindings; j !== m; ++j) {
                                    var bindingsForPath = bindings[j];
                                    bindingsForPath[index] = bindingsForPath[lastIndex];
                                    bindingsForPath.pop()
                                }
                            }
                        }
                    }
                    this.nCachedObjects_ = nCachedObjects
                },
                subscribe_: function(path, parsedPath) {
                    var indicesByPath = this._bindingsIndicesByPath,
                        index = indicesByPath[path],
                        bindings = this._bindings;
                    if (index !== undefined) return bindings[index];
                    var paths = this._paths,
                        parsedPaths = this._parsedPaths,
                        objects = this._objects,
                        nObjects = objects.length,
                        nCachedObjects = this.nCachedObjects_,
                        bindingsForPath = new Array(nObjects);
                    index = bindings.length;
                    indicesByPath[path] = index;
                    paths.push(path);
                    parsedPaths.push(parsedPath);
                    bindings.push(bindingsForPath);
                    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                        var object = objects[i];
                        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath)
                    }
                    return bindingsForPath
                },
                unsubscribe_: function(path) {
                    var indicesByPath = this._bindingsIndicesByPath,
                        index = indicesByPath[path];
                    if (index !== undefined) {
                        var paths = this._paths,
                            parsedPaths = this._parsedPaths,
                            bindings = this._bindings,
                            lastBindingsIndex = bindings.length - 1,
                            lastBindings = bindings[lastBindingsIndex],
                            lastBindingsPath = path[lastBindingsIndex];
                        indicesByPath[lastBindingsPath] = index;
                        bindings[index] = lastBindings;
                        bindings.pop();
                        parsedPaths[index] = parsedPaths[lastBindingsIndex];
                        parsedPaths.pop();
                        paths[index] = paths[lastBindingsIndex];
                        paths.pop()
                    }
                }
            });

            function AnimationAction(mixer, clip, localRoot) {
                this._mixer = mixer;
                this._clip = clip;
                this._localRoot = localRoot || null;
                var tracks = clip.tracks,
                    nTracks = tracks.length,
                    interpolants = new Array(nTracks);
                var interpolantSettings = {
                    endingStart: ZeroCurvatureEnding,
                    endingEnd: ZeroCurvatureEnding
                };
                for (var i = 0; i !== nTracks; ++i) {
                    var interpolant = tracks[i].createInterpolant(null);
                    interpolants[i] = interpolant;
                    interpolant.settings = interpolantSettings
                }
                this._interpolantSettings = interpolantSettings;
                this._interpolants = interpolants;
                this._propertyBindings = new Array(nTracks);
                this._cacheIndex = null;
                this._byClipCacheIndex = null;
                this._timeScaleInterpolant = null;
                this._weightInterpolant = null;
                this.loop = LoopRepeat;
                this._loopCount = -1;
                this._startTime = null;
                this.time = 0;
                this.timeScale = 1;
                this._effectiveTimeScale = 1;
                this.weight = 1;
                this._effectiveWeight = 1;
                this.repetitions = Infinity;
                this.paused = false;
                this.enabled = true;
                this.clampWhenFinished = false;
                this.zeroSlopeAtStart = true;
                this.zeroSlopeAtEnd = true
            }
            Object.assign(AnimationAction.prototype, {
                play: function() {
                    this._mixer._activateAction(this);
                    return this
                },
                stop: function() {
                    this._mixer._deactivateAction(this);
                    return this.reset()
                },
                reset: function() {
                    this.paused = false;
                    this.enabled = true;
                    this.time = 0;
                    this._loopCount = -1;
                    this._startTime = null;
                    return this.stopFading().stopWarping()
                },
                isRunning: function() {
                    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
                },
                isScheduled: function() {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function(time) {
                    this._startTime = time;
                    return this
                },
                setLoop: function(mode, repetitions) {
                    this.loop = mode;
                    this.repetitions = repetitions;
                    return this
                },
                setEffectiveWeight: function(weight) {
                    this.weight = weight;
                    this._effectiveWeight = this.enabled ? weight : 0;
                    return this.stopFading()
                },
                getEffectiveWeight: function() {
                    return this._effectiveWeight
                },
                fadeIn: function(duration) {
                    return this._scheduleFading(duration, 0, 1)
                },
                fadeOut: function(duration) {
                    return this._scheduleFading(duration, 1, 0)
                },
                crossFadeFrom: function(fadeOutAction, duration, warp) {
                    fadeOutAction.fadeOut(duration);
                    this.fadeIn(duration);
                    if (warp) {
                        var fadeInDuration = this._clip.duration,
                            fadeOutDuration = fadeOutAction._clip.duration,
                            startEndRatio = fadeOutDuration / fadeInDuration,
                            endStartRatio = fadeInDuration / fadeOutDuration;
                        fadeOutAction.warp(1, startEndRatio, duration);
                        this.warp(endStartRatio, 1, duration)
                    }
                    return this
                },
                crossFadeTo: function(fadeInAction, duration, warp) {
                    return fadeInAction.crossFadeFrom(this, duration, warp)
                },
                stopFading: function() {
                    var weightInterpolant = this._weightInterpolant;
                    if (weightInterpolant !== null) {
                        this._weightInterpolant = null;
                        this._mixer._takeBackControlInterpolant(weightInterpolant)
                    }
                    return this
                },
                setEffectiveTimeScale: function(timeScale) {
                    this.timeScale = timeScale;
                    this._effectiveTimeScale = this.paused ? 0 : timeScale;
                    return this.stopWarping()
                },
                getEffectiveTimeScale: function() {
                    return this._effectiveTimeScale
                },
                setDuration: function(duration) {
                    this.timeScale = this._clip.duration / duration;
                    return this.stopWarping()
                },
                syncWith: function(action) {
                    this.time = action.time;
                    this.timeScale = action.timeScale;
                    return this.stopWarping()
                },
                halt: function(duration) {
                    return this.warp(this._effectiveTimeScale, 0, duration)
                },
                warp: function(startTimeScale, endTimeScale, duration) {
                    var mixer = this._mixer,
                        now = mixer.time,
                        interpolant = this._timeScaleInterpolant,
                        timeScale = this.timeScale;
                    if (interpolant === null) {
                        interpolant = mixer._lendControlInterpolant();
                        this._timeScaleInterpolant = interpolant
                    }
                    var times = interpolant.parameterPositions,
                        values = interpolant.sampleValues;
                    times[0] = now;
                    times[1] = now + duration;
                    values[0] = startTimeScale / timeScale;
                    values[1] = endTimeScale / timeScale;
                    return this
                },
                stopWarping: function() {
                    var timeScaleInterpolant = this._timeScaleInterpolant;
                    if (timeScaleInterpolant !== null) {
                        this._timeScaleInterpolant = null;
                        this._mixer._takeBackControlInterpolant(timeScaleInterpolant)
                    }
                    return this
                },
                getMixer: function() {
                    return this._mixer
                },
                getClip: function() {
                    return this._clip
                },
                getRoot: function() {
                    return this._localRoot || this._mixer._root
                },
                _update: function(time, deltaTime, timeDirection, accuIndex) {
                    if (!this.enabled) {
                        this._updateWeight(time);
                        return
                    }
                    var startTime = this._startTime;
                    if (startTime !== null) {
                        var timeRunning = (time - startTime) * timeDirection;
                        if (timeRunning < 0 || timeDirection === 0) {
                            return
                        }
                        this._startTime = null;
                        deltaTime = timeDirection * timeRunning
                    }
                    deltaTime *= this._updateTimeScale(time);
                    var clipTime = this._updateTime(deltaTime);
                    var weight = this._updateWeight(time);
                    if (weight > 0) {
                        var interpolants = this._interpolants;
                        var propertyMixers = this._propertyBindings;
                        for (var j = 0, m = interpolants.length; j !== m; ++j) {
                            interpolants[j].evaluate(clipTime);
                            propertyMixers[j].accumulate(accuIndex, weight)
                        }
                    }
                },
                _updateWeight: function(time) {
                    var weight = 0;
                    if (this.enabled) {
                        weight = this.weight;
                        var interpolant = this._weightInterpolant;
                        if (interpolant !== null) {
                            var interpolantValue = interpolant.evaluate(time)[0];
                            weight *= interpolantValue;
                            if (time > interpolant.parameterPositions[1]) {
                                this.stopFading();
                                if (interpolantValue === 0) {
                                    this.enabled = false
                                }
                            }
                        }
                    }
                    this._effectiveWeight = weight;
                    return weight
                },
                _updateTimeScale: function(time) {
                    var timeScale = 0;
                    if (!this.paused) {
                        timeScale = this.timeScale;
                        var interpolant = this._timeScaleInterpolant;
                        if (interpolant !== null) {
                            var interpolantValue = interpolant.evaluate(time)[0];
                            timeScale *= interpolantValue;
                            if (time > interpolant.parameterPositions[1]) {
                                this.stopWarping();
                                if (timeScale === 0) {
                                    this.paused = true
                                } else {
                                    this.timeScale = timeScale
                                }
                            }
                        }
                    }
                    this._effectiveTimeScale = timeScale;
                    return timeScale
                },
                _updateTime: function(deltaTime) {
                    var time = this.time + deltaTime;
                    if (deltaTime === 0) return time;
                    var duration = this._clip.duration,
                        loop = this.loop,
                        loopCount = this._loopCount;
                    if (loop === LoopOnce) {
                        if (loopCount === -1) {
                            this._loopCount = 0;
                            this._setEndings(true, true, false)
                        }
                        handle_stop: {
                            if (time >= duration) {
                                time = duration
                            } else if (time < 0) {
                                time = 0
                            } else break handle_stop;
                            if (this.clampWhenFinished) this.paused = true;
                            else this.enabled = false;this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: deltaTime < 0 ? -1 : 1
                            })
                        }
                    } else {
                        var pingPong = loop === LoopPingPong;
                        if (loopCount === -1) {
                            if (deltaTime >= 0) {
                                loopCount = 0;
                                this._setEndings(true, this.repetitions === 0, pingPong)
                            } else {
                                this._setEndings(this.repetitions === 0, true, pingPong)
                            }
                        }
                        if (time >= duration || time < 0) {
                            var loopDelta = Math.floor(time / duration);
                            time -= duration * loopDelta;
                            loopCount += Math.abs(loopDelta);
                            var pending = this.repetitions - loopCount;
                            if (pending <= 0) {
                                if (this.clampWhenFinished) this.paused = true;
                                else this.enabled = false;
                                time = deltaTime > 0 ? duration : 0;
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: deltaTime > 0 ? 1 : -1
                                })
                            } else {
                                if (pending === 1) {
                                    var atStart = deltaTime < 0;
                                    this._setEndings(atStart, !atStart, pingPong)
                                } else {
                                    this._setEndings(false, false, pingPong)
                                }
                                this._loopCount = loopCount;
                                this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: loopDelta
                                })
                            }
                        }
                        if (pingPong && (loopCount & 1) === 1) {
                            this.time = time;
                            return duration - time
                        }
                    }
                    this.time = time;
                    return time
                },
                _setEndings: function(atStart, atEnd, pingPong) {
                    var settings = this._interpolantSettings;
                    if (pingPong) {
                        settings.endingStart = ZeroSlopeEnding;
                        settings.endingEnd = ZeroSlopeEnding
                    } else {
                        if (atStart) {
                            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding
                        } else {
                            settings.endingStart = WrapAroundEnding
                        }
                        if (atEnd) {
                            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding
                        } else {
                            settings.endingEnd = WrapAroundEnding
                        }
                    }
                },
                _scheduleFading: function(duration, weightNow, weightThen) {
                    var mixer = this._mixer,
                        now = mixer.time,
                        interpolant = this._weightInterpolant;
                    if (interpolant === null) {
                        interpolant = mixer._lendControlInterpolant();
                        this._weightInterpolant = interpolant
                    }
                    var times = interpolant.parameterPositions,
                        values = interpolant.sampleValues;
                    times[0] = now;
                    values[0] = weightNow;
                    times[1] = now + duration;
                    values[1] = weightThen;
                    return this
                }
            });

            function AnimationMixer(root) {
                this._root = root;
                this._initMemoryManager();
                this._accuIndex = 0;
                this.time = 0;
                this.timeScale = 1
            }
            AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
                constructor: AnimationMixer,
                _bindAction: function(action, prototypeAction) {
                    var root = action._localRoot || this._root,
                        tracks = action._clip.tracks,
                        nTracks = tracks.length,
                        bindings = action._propertyBindings,
                        interpolants = action._interpolants,
                        rootUuid = root.uuid,
                        bindingsByRoot = this._bindingsByRootAndName,
                        bindingsByName = bindingsByRoot[rootUuid];
                    if (bindingsByName === undefined) {
                        bindingsByName = {};
                        bindingsByRoot[rootUuid] = bindingsByName
                    }
                    for (var i = 0; i !== nTracks; ++i) {
                        var track = tracks[i],
                            trackName = track.name,
                            binding = bindingsByName[trackName];
                        if (binding !== undefined) {
                            bindings[i] = binding
                        } else {
                            binding = bindings[i];
                            if (binding !== undefined) {
                                if (binding._cacheIndex === null) {
                                    ++binding.referenceCount;
                                    this._addInactiveBinding(binding, rootUuid, trackName)
                                }
                                continue
                            }
                            var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                            binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                            bindings[i] = binding
                        }
                        interpolants[i].resultBuffer = binding.buffer
                    }
                },
                _activateAction: function(action) {
                    if (!this._isActiveAction(action)) {
                        if (action._cacheIndex === null) {
                            var rootUuid = (action._localRoot || this._root).uuid,
                                clipUuid = action._clip.uuid,
                                actionsForClip = this._actionsByClip[clipUuid];
                            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                            this._addInactiveAction(action, clipUuid, rootUuid)
                        }
                        var bindings = action._propertyBindings;
                        for (var i = 0, n = bindings.length; i !== n; ++i) {
                            var binding = bindings[i];
                            if (binding.useCount++ === 0) {
                                this._lendBinding(binding);
                                binding.saveOriginalState()
                            }
                        }
                        this._lendAction(action)
                    }
                },
                _deactivateAction: function(action) {
                    if (this._isActiveAction(action)) {
                        var bindings = action._propertyBindings;
                        for (var i = 0, n = bindings.length; i !== n; ++i) {
                            var binding = bindings[i];
                            if (--binding.useCount === 0) {
                                binding.restoreOriginalState();
                                this._takeBackBinding(binding)
                            }
                        }
                        this._takeBackAction(action)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [];
                    this._nActiveActions = 0;
                    this._actionsByClip = {};
                    this._bindings = [];
                    this._nActiveBindings = 0;
                    this._bindingsByRootAndName = {};
                    this._controlInterpolants = [];
                    this._nActiveControlInterpolants = 0;
                    var scope = this;
                    this.stats = {
                        actions: {get total() {
                                return scope._actions.length
                            },
                            get inUse() {
                                return scope._nActiveActions
                            }
                        },
                        bindings: {get total() {
                                return scope._bindings.length
                            },
                            get inUse() {
                                return scope._nActiveBindings
                            }
                        },
                        controlInterpolants: {get total() {
                                return scope._controlInterpolants.length
                            },
                            get inUse() {
                                return scope._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(action) {
                    var index = action._cacheIndex;
                    return index !== null && index < this._nActiveActions
                },
                _addInactiveAction: function(action, clipUuid, rootUuid) {
                    var actions = this._actions,
                        actionsByClip = this._actionsByClip,
                        actionsForClip = actionsByClip[clipUuid];
                    if (actionsForClip === undefined) {
                        actionsForClip = {
                            knownActions: [action],
                            actionByRoot: {}
                        };
                        action._byClipCacheIndex = 0;
                        actionsByClip[clipUuid] = actionsForClip
                    } else {
                        var knownActions = actionsForClip.knownActions;
                        action._byClipCacheIndex = knownActions.length;
                        knownActions.push(action)
                    }
                    action._cacheIndex = actions.length;
                    actions.push(action);
                    actionsForClip.actionByRoot[rootUuid] = action
                },
                _removeInactiveAction: function(action) {
                    var actions = this._actions,
                        lastInactiveAction = actions[actions.length - 1],
                        cacheIndex = action._cacheIndex;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    action._cacheIndex = null;
                    var clipUuid = action._clip.uuid,
                        actionsByClip = this._actionsByClip,
                        actionsForClip = actionsByClip[clipUuid],
                        knownActionsForClip = actionsForClip.knownActions,
                        lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
                        byClipCacheIndex = action._byClipCacheIndex;
                    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
                    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
                    knownActionsForClip.pop();
                    action._byClipCacheIndex = null;
                    var actionByRoot = actionsForClip.actionByRoot,
                        rootUuid = (action._localRoot || this._root).uuid;
                    delete actionByRoot[rootUuid];
                    if (knownActionsForClip.length === 0) {
                        delete actionsByClip[clipUuid]
                    }
                    this._removeInactiveBindingsForAction(action)
                },
                _removeInactiveBindingsForAction: function(action) {
                    var bindings = action._propertyBindings;
                    for (var i = 0, n = bindings.length; i !== n; ++i) {
                        var binding = bindings[i];
                        if (--binding.referenceCount === 0) {
                            this._removeInactiveBinding(binding)
                        }
                    }
                },
                _lendAction: function(action) {
                    var actions = this._actions,
                        prevIndex = action._cacheIndex,
                        lastActiveIndex = this._nActiveActions++,
                        firstInactiveAction = actions[lastActiveIndex];
                    action._cacheIndex = lastActiveIndex;
                    actions[lastActiveIndex] = action;
                    firstInactiveAction._cacheIndex = prevIndex;
                    actions[prevIndex] = firstInactiveAction
                },
                _takeBackAction: function(action) {
                    var actions = this._actions,
                        prevIndex = action._cacheIndex,
                        firstInactiveIndex = --this._nActiveActions,
                        lastActiveAction = actions[firstInactiveIndex];
                    action._cacheIndex = firstInactiveIndex;
                    actions[firstInactiveIndex] = action;
                    lastActiveAction._cacheIndex = prevIndex;
                    actions[prevIndex] = lastActiveAction
                },
                _addInactiveBinding: function(binding, rootUuid, trackName) {
                    var bindingsByRoot = this._bindingsByRootAndName,
                        bindingByName = bindingsByRoot[rootUuid],
                        bindings = this._bindings;
                    if (bindingByName === undefined) {
                        bindingByName = {};
                        bindingsByRoot[rootUuid] = bindingByName
                    }
                    bindingByName[trackName] = binding;
                    binding._cacheIndex = bindings.length;
                    bindings.push(binding)
                },
                _removeInactiveBinding: function(binding) {
                    var bindings = this._bindings,
                        propBinding = binding.binding,
                        rootUuid = propBinding.rootNode.uuid,
                        trackName = propBinding.path,
                        bindingsByRoot = this._bindingsByRootAndName,
                        bindingByName = bindingsByRoot[rootUuid],
                        lastInactiveBinding = bindings[bindings.length - 1],
                        cacheIndex = binding._cacheIndex;
                    lastInactiveBinding._cacheIndex = cacheIndex;
                    bindings[cacheIndex] = lastInactiveBinding;
                    bindings.pop();
                    delete bindingByName[trackName];
                    remove_empty_map: {
                        for (var _ in bindingByName) break remove_empty_map;delete bindingsByRoot[rootUuid]
                    }
                },
                _lendBinding: function(binding) {
                    var bindings = this._bindings,
                        prevIndex = binding._cacheIndex,
                        lastActiveIndex = this._nActiveBindings++,
                        firstInactiveBinding = bindings[lastActiveIndex];
                    binding._cacheIndex = lastActiveIndex;
                    bindings[lastActiveIndex] = binding;
                    firstInactiveBinding._cacheIndex = prevIndex;
                    bindings[prevIndex] = firstInactiveBinding
                },
                _takeBackBinding: function(binding) {
                    var bindings = this._bindings,
                        prevIndex = binding._cacheIndex,
                        firstInactiveIndex = --this._nActiveBindings,
                        lastActiveBinding = bindings[firstInactiveIndex];
                    binding._cacheIndex = firstInactiveIndex;
                    bindings[firstInactiveIndex] = binding;
                    lastActiveBinding._cacheIndex = prevIndex;
                    bindings[prevIndex] = lastActiveBinding
                },
                _lendControlInterpolant: function() {
                    var interpolants = this._controlInterpolants,
                        lastActiveIndex = this._nActiveControlInterpolants++,
                        interpolant = interpolants[lastActiveIndex];
                    if (interpolant === undefined) {
                        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                        interpolant.__cacheIndex = lastActiveIndex;
                        interpolants[lastActiveIndex] = interpolant
                    }
                    return interpolant
                },
                _takeBackControlInterpolant: function(interpolant) {
                    var interpolants = this._controlInterpolants,
                        prevIndex = interpolant.__cacheIndex,
                        firstInactiveIndex = --this._nActiveControlInterpolants,
                        lastActiveInterpolant = interpolants[firstInactiveIndex];
                    interpolant.__cacheIndex = firstInactiveIndex;
                    interpolants[firstInactiveIndex] = interpolant;
                    lastActiveInterpolant.__cacheIndex = prevIndex;
                    interpolants[prevIndex] = lastActiveInterpolant
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(clip, optionalRoot) {
                    var root = optionalRoot || this._root,
                        rootUuid = root.uuid,
                        clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip,
                        clipUuid = clipObject !== null ? clipObject.uuid : clip,
                        actionsForClip = this._actionsByClip[clipUuid],
                        prototypeAction = null;
                    if (actionsForClip !== undefined) {
                        var existingAction = actionsForClip.actionByRoot[rootUuid];
                        if (existingAction !== undefined) {
                            return existingAction
                        }
                        prototypeAction = actionsForClip.knownActions[0];
                        if (clipObject === null) clipObject = prototypeAction._clip
                    }
                    if (clipObject === null) return null;
                    var newAction = new AnimationAction(this, clipObject, optionalRoot);
                    this._bindAction(newAction, prototypeAction);
                    this._addInactiveAction(newAction, clipUuid, rootUuid);
                    return newAction
                },
                existingAction: function(clip, optionalRoot) {
                    var root = optionalRoot || this._root,
                        rootUuid = root.uuid,
                        clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip,
                        clipUuid = clipObject ? clipObject.uuid : clip,
                        actionsForClip = this._actionsByClip[clipUuid];
                    if (actionsForClip !== undefined) {
                        return actionsForClip.actionByRoot[rootUuid] || null
                    }
                    return null
                },
                stopAllAction: function() {
                    var actions = this._actions,
                        nActions = this._nActiveActions,
                        bindings = this._bindings,
                        nBindings = this._nActiveBindings;
                    this._nActiveActions = 0;
                    this._nActiveBindings = 0;
                    for (var i = 0; i !== nActions; ++i) {
                        actions[i].reset()
                    }
                    for (var i = 0; i !== nBindings; ++i) {
                        bindings[i].useCount = 0
                    }
                    return this
                },
                update: function(deltaTime) {
                    deltaTime *= this.timeScale;
                    var actions = this._actions,
                        nActions = this._nActiveActions,
                        time = this.time += deltaTime,
                        timeDirection = Math.sign(deltaTime),
                        accuIndex = this._accuIndex ^= 1;
                    for (var i = 0; i !== nActions; ++i) {
                        var action = actions[i];
                        action._update(time, deltaTime, timeDirection, accuIndex)
                    }
                    var bindings = this._bindings,
                        nBindings = this._nActiveBindings;
                    for (var i = 0; i !== nBindings; ++i) {
                        bindings[i].apply(accuIndex)
                    }
                    return this
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(clip) {
                    var actions = this._actions,
                        clipUuid = clip.uuid,
                        actionsByClip = this._actionsByClip,
                        actionsForClip = actionsByClip[clipUuid];
                    if (actionsForClip !== undefined) {
                        var actionsToRemove = actionsForClip.knownActions;
                        for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                            var action = actionsToRemove[i];
                            this._deactivateAction(action);
                            var cacheIndex = action._cacheIndex,
                                lastInactiveAction = actions[actions.length - 1];
                            action._cacheIndex = null;
                            action._byClipCacheIndex = null;
                            lastInactiveAction._cacheIndex = cacheIndex;
                            actions[cacheIndex] = lastInactiveAction;
                            actions.pop();
                            this._removeInactiveBindingsForAction(action)
                        }
                        delete actionsByClip[clipUuid]
                    }
                },
                uncacheRoot: function(root) {
                    var rootUuid = root.uuid,
                        actionsByClip = this._actionsByClip;
                    for (var clipUuid in actionsByClip) {
                        var actionByRoot = actionsByClip[clipUuid].actionByRoot,
                            action = actionByRoot[rootUuid];
                        if (action !== undefined) {
                            this._deactivateAction(action);
                            this._removeInactiveAction(action)
                        }
                    }
                    var bindingsByRoot = this._bindingsByRootAndName,
                        bindingByName = bindingsByRoot[rootUuid];
                    if (bindingByName !== undefined) {
                        for (var trackName in bindingByName) {
                            var binding = bindingByName[trackName];
                            binding.restoreOriginalState();
                            this._removeInactiveBinding(binding)
                        }
                    }
                },
                uncacheAction: function(clip, optionalRoot) {
                    var action = this.existingAction(clip, optionalRoot);
                    if (action !== null) {
                        this._deactivateAction(action);
                        this._removeInactiveAction(action)
                    }
                }
            });

            function Uniform(value) {
                if (typeof value === "string") {
                    console.warn("THREE.Uniform: Type parameter is no longer needed.");
                    value = arguments[1]
                }
                this.value = value
            }
            Uniform.prototype.clone = function() {
                return new Uniform(this.value.clone === undefined ? this.value : this.value.clone())
            };

            function InstancedBufferGeometry() {
                BufferGeometry.call(this);
                this.type = "InstancedBufferGeometry";
                this.maxInstancedCount = undefined
            }
            InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
                constructor: InstancedBufferGeometry,
                isInstancedBufferGeometry: true,
                copy: function(source) {
                    BufferGeometry.prototype.copy.call(this, source);
                    this.maxInstancedCount = source.maxInstancedCount;
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            });

            function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
                this.data = interleavedBuffer;
                this.itemSize = itemSize;
                this.offset = offset;
                this.normalized = normalized === true
            }
            Object.defineProperties(InterleavedBufferAttribute.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            });
            Object.assign(InterleavedBufferAttribute.prototype, {
                isInterleavedBufferAttribute: true,
                setX: function(index, x) {
                    this.data.array[index * this.data.stride + this.offset] = x;
                    return this
                },
                setY: function(index, y) {
                    this.data.array[index * this.data.stride + this.offset + 1] = y;
                    return this
                },
                setZ: function(index, z) {
                    this.data.array[index * this.data.stride + this.offset + 2] = z;
                    return this
                },
                setW: function(index, w) {
                    this.data.array[index * this.data.stride + this.offset + 3] = w;
                    return this
                },
                getX: function(index) {
                    return this.data.array[index * this.data.stride + this.offset]
                },
                getY: function(index) {
                    return this.data.array[index * this.data.stride + this.offset + 1]
                },
                getZ: function(index) {
                    return this.data.array[index * this.data.stride + this.offset + 2]
                },
                getW: function(index) {
                    return this.data.array[index * this.data.stride + this.offset + 3]
                },
                setXY: function(index, x, y) {
                    index = index * this.data.stride + this.offset;
                    this.data.array[index + 0] = x;
                    this.data.array[index + 1] = y;
                    return this
                },
                setXYZ: function(index, x, y, z) {
                    index = index * this.data.stride + this.offset;
                    this.data.array[index + 0] = x;
                    this.data.array[index + 1] = y;
                    this.data.array[index + 2] = z;
                    return this
                },
                setXYZW: function(index, x, y, z, w) {
                    index = index * this.data.stride + this.offset;
                    this.data.array[index + 0] = x;
                    this.data.array[index + 1] = y;
                    this.data.array[index + 2] = z;
                    this.data.array[index + 3] = w;
                    return this
                }
            });

            function InterleavedBuffer(array, stride) {
                this.array = array;
                this.stride = stride;
                this.count = array !== undefined ? array.length / stride : 0;
                this.dynamic = false;
                this.updateRange = {
                    offset: 0,
                    count: -1
                };
                this.version = 0
            }
            Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
                set: function(value) {
                    if (value === true) this.version++
                }
            });
            Object.assign(InterleavedBuffer.prototype, {
                isInterleavedBuffer: true,
                onUploadCallback: function() {},
                setArray: function(array) {
                    if (Array.isArray(array)) {
                        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.")
                    }
                    this.count = array !== undefined ? array.length / this.stride : 0;
                    this.array = array
                },
                setDynamic: function(value) {
                    this.dynamic = value;
                    return this
                },
                copy: function(source) {
                    this.array = new source.array.constructor(source.array);
                    this.count = source.count;
                    this.stride = source.stride;
                    this.dynamic = source.dynamic;
                    return this
                },
                copyAt: function(index1, attribute, index2) {
                    index1 *= this.stride;
                    index2 *= attribute.stride;
                    for (var i = 0, l = this.stride; i < l; i++) {
                        this.array[index1 + i] = attribute.array[index2 + i]
                    }
                    return this
                },
                set: function(value, offset) {
                    if (offset === undefined) offset = 0;
                    this.array.set(value, offset);
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(callback) {
                    this.onUploadCallback = callback;
                    return this
                }
            });

            function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
                InterleavedBuffer.call(this, array, stride);
                this.meshPerAttribute = meshPerAttribute || 1
            }
            InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
                constructor: InstancedInterleavedBuffer,
                isInstancedInterleavedBuffer: true,
                copy: function(source) {
                    InterleavedBuffer.prototype.copy.call(this, source);
                    this.meshPerAttribute = source.meshPerAttribute;
                    return this
                }
            });

            function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
                BufferAttribute.call(this, array, itemSize);
                this.meshPerAttribute = meshPerAttribute || 1
            }
            InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
                constructor: InstancedBufferAttribute,
                isInstancedBufferAttribute: true,
                copy: function(source) {
                    BufferAttribute.prototype.copy.call(this, source);
                    this.meshPerAttribute = source.meshPerAttribute;
                    return this
                }
            });

            function Raycaster(origin, direction, near, far) {
                this.ray = new Ray(origin, direction);
                this.near = near || 0;
                this.far = far || Infinity;
                this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                };
                Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                            return this.Points
                        }
                    }
                })
            }

            function ascSort(a, b) {
                return a.distance - b.distance
            }

            function intersectObject(object, raycaster, intersects, recursive) {
                if (object.visible === false) return;
                object.raycast(raycaster, intersects);
                if (recursive === true) {
                    var children = object.children;
                    for (var i = 0, l = children.length; i < l; i++) {
                        intersectObject(children[i], raycaster, intersects, true)
                    }
                }
            }
            Object.assign(Raycaster.prototype, {
                linePrecision: 1,
                set: function(origin, direction) {
                    this.ray.set(origin, direction)
                },
                setFromCamera: function(coords, camera) {
                    if (camera && camera.isPerspectiveCamera) {
                        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                        this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize()
                    } else if (camera && camera.isOrthographicCamera) {
                        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld)
                    } else {
                        console.error("THREE.Raycaster: Unsupported camera type.")
                    }
                },
                intersectObject: function(object, recursive, optionalTarget) {
                    var intersects = optionalTarget || [];
                    intersectObject(object, this, intersects, recursive);
                    intersects.sort(ascSort);
                    return intersects
                },
                intersectObjects: function(objects, recursive, optionalTarget) {
                    var intersects = optionalTarget || [];
                    if (Array.isArray(objects) === false) {
                        console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
                        return intersects
                    }
                    for (var i = 0, l = objects.length; i < l; i++) {
                        intersectObject(objects[i], this, intersects, recursive)
                    }
                    intersects.sort(ascSort);
                    return intersects
                }
            });

            function Clock(autoStart) {
                this.autoStart = autoStart !== undefined ? autoStart : true;
                this.startTime = 0;
                this.oldTime = 0;
                this.elapsedTime = 0;
                this.running = false
            }
            Object.assign(Clock.prototype, {
                start: function() {
                    this.startTime = (typeof performance === "undefined" ? Date : performance).now();
                    this.oldTime = this.startTime;
                    this.elapsedTime = 0;
                    this.running = true
                },
                stop: function() {
                    this.getElapsedTime();
                    this.running = false;
                    this.autoStart = false
                },
                getElapsedTime: function() {
                    this.getDelta();
                    return this.elapsedTime
                },
                getDelta: function() {
                    var diff = 0;
                    if (this.autoStart && !this.running) {
                        this.start();
                        return 0
                    }
                    if (this.running) {
                        var newTime = (typeof performance === "undefined" ? Date : performance).now();
                        diff = (newTime - this.oldTime) / 1e3;
                        this.oldTime = newTime;
                        this.elapsedTime += diff
                    }
                    return diff
                }
            });

            function Spherical(radius, phi, theta) {
                this.radius = radius !== undefined ? radius : 1;
                this.phi = phi !== undefined ? phi : 0;
                this.theta = theta !== undefined ? theta : 0;
                return this
            }
            Object.assign(Spherical.prototype, {
                set: function(radius, phi, theta) {
                    this.radius = radius;
                    this.phi = phi;
                    this.theta = theta;
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(other) {
                    this.radius = other.radius;
                    this.phi = other.phi;
                    this.theta = other.theta;
                    return this
                },
                makeSafe: function() {
                    var EPS = 1e-6;
                    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
                    return this
                },
                setFromVector3: function(vec3) {
                    this.radius = vec3.length();
                    if (this.radius === 0) {
                        this.theta = 0;
                        this.phi = 0
                    } else {
                        this.theta = Math.atan2(vec3.x, vec3.z);
                        this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1))
                    }
                    return this
                }
            });

            function Cylindrical(radius, theta, y) {
                this.radius = radius !== undefined ? radius : 1;
                this.theta = theta !== undefined ? theta : 0;
                this.y = y !== undefined ? y : 0;
                return this
            }
            Object.assign(Cylindrical.prototype, {
                set: function(radius, theta, y) {
                    this.radius = radius;
                    this.theta = theta;
                    this.y = y;
                    return this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(other) {
                    this.radius = other.radius;
                    this.theta = other.theta;
                    this.y = other.y;
                    return this
                },
                setFromVector3: function(vec3) {
                    this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
                    this.theta = Math.atan2(vec3.x, vec3.z);
                    this.y = vec3.y;
                    return this
                }
            });

            function Box2(min, max) {
                this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
                this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity)
            }
            Object.assign(Box2.prototype, {
                set: function(min, max) {
                    this.min.copy(min);
                    this.max.copy(max);
                    return this
                },
                setFromPoints: function(points) {
                    this.makeEmpty();
                    for (var i = 0, il = points.length; i < il; i++) {
                        this.expandByPoint(points[i])
                    }
                    return this
                },
                setFromCenterAndSize: function() {
                    var v1 = new Vector2;
                    return function setFromCenterAndSize(center, size) {
                        var halfSize = v1.copy(size).multiplyScalar(.5);
                        this.min.copy(center).sub(halfSize);
                        this.max.copy(center).add(halfSize);
                        return this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(box) {
                    this.min.copy(box.min);
                    this.max.copy(box.max);
                    return this
                },
                makeEmpty: function() {
                    this.min.x = this.min.y = +Infinity;
                    this.max.x = this.max.y = -Infinity;
                    return this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Box2: .getCenter() target is now required");
                        target = new Vector2
                    }
                    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(target) {
                    if (target === undefined) {
                        console.warn("THREE.Box2: .getSize() target is now required");
                        target = new Vector2
                    }
                    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min)
                },
                expandByPoint: function(point) {
                    this.min.min(point);
                    this.max.max(point);
                    return this
                },
                expandByVector: function(vector) {
                    this.min.sub(vector);
                    this.max.add(vector);
                    return this
                },
                expandByScalar: function(scalar) {
                    this.min.addScalar(-scalar);
                    this.max.addScalar(scalar);
                    return this
                },
                containsPoint: function(point) {
                    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true
                },
                containsBox: function(box) {
                    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y
                },
                getParameter: function(point, target) {
                    if (target === undefined) {
                        console.warn("THREE.Box2: .getParameter() target is now required");
                        target = new Vector2
                    }
                    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(box) {
                    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true
                },
                clampPoint: function(point, target) {
                    if (target === undefined) {
                        console.warn("THREE.Box2: .clampPoint() target is now required");
                        target = new Vector2
                    }
                    return target.copy(point).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var v1 = new Vector2;
                    return function distanceToPoint(point) {
                        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                        return clampedPoint.sub(point).length()
                    }
                }(),
                intersect: function(box) {
                    this.min.max(box.min);
                    this.max.min(box.max);
                    return this
                },
                union: function(box) {
                    this.min.min(box.min);
                    this.max.max(box.max);
                    return this
                },
                translate: function(offset) {
                    this.min.add(offset);
                    this.max.add(offset);
                    return this
                },
                equals: function(box) {
                    return box.min.equals(this.min) && box.max.equals(this.max)
                }
            });

            function ImmediateRenderObject(material) {
                Object3D.call(this);
                this.material = material;
                this.render = function() {}
            }
            ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
            ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
            ImmediateRenderObject.prototype.isImmediateRenderObject = true;

            function VertexNormalsHelper(object, size, hex, linewidth) {
                this.object = object;
                this.size = size !== undefined ? size : 1;
                var color = hex !== undefined ? hex : 16711680;
                var width = linewidth !== undefined ? linewidth : 1;
                var nNormals = 0;
                var objGeometry = this.object.geometry;
                if (objGeometry && objGeometry.isGeometry) {
                    nNormals = objGeometry.faces.length * 3
                } else if (objGeometry && objGeometry.isBufferGeometry) {
                    nNormals = objGeometry.attributes.normal.count
                }
                var geometry = new BufferGeometry;
                var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
                geometry.addAttribute("position", positions);
                LineSegments.call(this, geometry, new LineBasicMaterial({
                    color: color,
                    linewidth: width
                }));
                this.matrixAutoUpdate = false;
                this.update()
            }
            VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
            VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
            VertexNormalsHelper.prototype.update = function() {
                var v1 = new Vector3;
                var v2 = new Vector3;
                var normalMatrix = new Matrix3;
                return function update() {
                    var keys = ["a", "b", "c"];
                    this.object.updateMatrixWorld(true);
                    normalMatrix.getNormalMatrix(this.object.matrixWorld);
                    var matrixWorld = this.object.matrixWorld;
                    var position = this.geometry.attributes.position;
                    var objGeometry = this.object.geometry;
                    if (objGeometry && objGeometry.isGeometry) {
                        var vertices = objGeometry.vertices;
                        var faces = objGeometry.faces;
                        var idx = 0;
                        for (var i = 0, l = faces.length; i < l; i++) {
                            var face = faces[i];
                            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                                var vertex = vertices[face[keys[j]]];
                                var normal = face.vertexNormals[j];
                                v1.copy(vertex).applyMatrix4(matrixWorld);
                                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                                position.setXYZ(idx, v1.x, v1.y, v1.z);
                                idx = idx + 1;
                                position.setXYZ(idx, v2.x, v2.y, v2.z);
                                idx = idx + 1
                            }
                        }
                    } else if (objGeometry && objGeometry.isBufferGeometry) {
                        var objPos = objGeometry.attributes.position;
                        var objNorm = objGeometry.attributes.normal;
                        var idx = 0;
                        for (var j = 0, jl = objPos.count; j < jl; j++) {
                            v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                            v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                            position.setXYZ(idx, v1.x, v1.y, v1.z);
                            idx = idx + 1;
                            position.setXYZ(idx, v2.x, v2.y, v2.z);
                            idx = idx + 1
                        }
                    }
                    position.needsUpdate = true
                }
            }();

            function SpotLightHelper(light, color) {
                Object3D.call(this);
                this.light = light;
                this.light.updateMatrixWorld();
                this.matrix = light.matrixWorld;
                this.matrixAutoUpdate = false;
                this.color = color;
                var geometry = new BufferGeometry;
                var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
                    var p1 = i / l * Math.PI * 2;
                    var p2 = j / l * Math.PI * 2;
                    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1)
                }
                geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
                var material = new LineBasicMaterial({
                    fog: false
                });
                this.cone = new LineSegments(geometry, material);
                this.add(this.cone);
                this.update()
            }
            SpotLightHelper.prototype = Object.create(Object3D.prototype);
            SpotLightHelper.prototype.constructor = SpotLightHelper;
            SpotLightHelper.prototype.dispose = function() {
                this.cone.geometry.dispose();
                this.cone.material.dispose()
            };
            SpotLightHelper.prototype.update = function() {
                var vector = new Vector3;
                var vector2 = new Vector3;
                return function update() {
                    this.light.updateMatrixWorld();
                    var coneLength = this.light.distance ? this.light.distance : 1e3;
                    var coneWidth = coneLength * Math.tan(this.light.angle);
                    this.cone.scale.set(coneWidth, coneWidth, coneLength);
                    vector.setFromMatrixPosition(this.light.matrixWorld);
                    vector2.setFromMatrixPosition(this.light.target.matrixWorld);
                    this.cone.lookAt(vector2.sub(vector));
                    if (this.color !== undefined) {
                        this.cone.material.color.set(this.color)
                    } else {
                        this.cone.material.color.copy(this.light.color)
                    }
                }
            }();

            function getBoneList(object) {
                var boneList = [];
                if (object && object.isBone) {
                    boneList.push(object)
                }
                for (var i = 0; i < object.children.length; i++) {
                    boneList.push.apply(boneList, getBoneList(object.children[i]))
                }
                return boneList
            }

            function SkeletonHelper(object) {
                var bones = getBoneList(object);
                var geometry = new BufferGeometry;
                var vertices = [];
                var colors = [];
                var color1 = new Color(0, 0, 1);
                var color2 = new Color(0, 1, 0);
                for (var i = 0; i < bones.length; i++) {
                    var bone = bones[i];
                    if (bone.parent && bone.parent.isBone) {
                        vertices.push(0, 0, 0);
                        vertices.push(0, 0, 0);
                        colors.push(color1.r, color1.g, color1.b);
                        colors.push(color2.r, color2.g, color2.b)
                    }
                }
                geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
                var material = new LineBasicMaterial({
                    vertexColors: VertexColors,
                    depthTest: false,
                    depthWrite: false,
                    transparent: true
                });
                LineSegments.call(this, geometry, material);
                this.root = object;
                this.bones = bones;
                this.matrix = object.matrixWorld;
                this.matrixAutoUpdate = false
            }
            SkeletonHelper.prototype = Object.create(LineSegments.prototype);
            SkeletonHelper.prototype.constructor = SkeletonHelper;
            SkeletonHelper.prototype.updateMatrixWorld = function() {
                var vector = new Vector3;
                var boneMatrix = new Matrix4;
                var matrixWorldInv = new Matrix4;
                return function updateMatrixWorld(force) {
                    var bones = this.bones;
                    var geometry = this.geometry;
                    var position = geometry.getAttribute("position");
                    matrixWorldInv.getInverse(this.root.matrixWorld);
                    for (var i = 0, j = 0; i < bones.length; i++) {
                        var bone = bones[i];
                        if (bone.parent && bone.parent.isBone) {
                            boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                            vector.setFromMatrixPosition(boneMatrix);
                            position.setXYZ(j, vector.x, vector.y, vector.z);
                            boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                            vector.setFromMatrixPosition(boneMatrix);
                            position.setXYZ(j + 1, vector.x, vector.y, vector.z);
                            j += 2
                        }
                    }
                    geometry.getAttribute("position").needsUpdate = true;
                    Object3D.prototype.updateMatrixWorld.call(this, force)
                }
            }();

            function PointLightHelper(light, sphereSize, color) {
                this.light = light;
                this.light.updateMatrixWorld();
                this.color = color;
                var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
                var material = new MeshBasicMaterial({
                    wireframe: true,
                    fog: false
                });
                Mesh.call(this, geometry, material);
                this.matrix = this.light.matrixWorld;
                this.matrixAutoUpdate = false;
                this.update()
            }
            PointLightHelper.prototype = Object.create(Mesh.prototype);
            PointLightHelper.prototype.constructor = PointLightHelper;
            PointLightHelper.prototype.dispose = function() {
                this.geometry.dispose();
                this.material.dispose()
            };
            PointLightHelper.prototype.update = function() {
                if (this.color !== undefined) {
                    this.material.color.set(this.color)
                } else {
                    this.material.color.copy(this.light.color)
                }
            };

            function RectAreaLightHelper(light, color) {
                Object3D.call(this);
                this.light = light;
                this.light.updateMatrixWorld();
                this.matrix = light.matrixWorld;
                this.matrixAutoUpdate = false;
                this.color = color;
                var material = new LineBasicMaterial({
                    fog: false
                });
                var geometry = new BufferGeometry;
                geometry.addAttribute("position", new BufferAttribute(new Float32Array(5 * 3), 3));
                this.line = new Line(geometry, material);
                this.add(this.line);
                this.update()
            }
            RectAreaLightHelper.prototype = Object.create(Object3D.prototype);
            RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
            RectAreaLightHelper.prototype.dispose = function() {
                this.children[0].geometry.dispose();
                this.children[0].material.dispose()
            };
            RectAreaLightHelper.prototype.update = function() {
                var hx = this.light.width * .5;
                var hy = this.light.height * .5;
                var position = this.line.geometry.attributes.position;
                var array = position.array;
                array[0] = hx;
                array[1] = -hy;
                array[2] = 0;
                array[3] = hx;
                array[4] = hy;
                array[5] = 0;
                array[6] = -hx;
                array[7] = hy;
                array[8] = 0;
                array[9] = -hx;
                array[10] = -hy;
                array[11] = 0;
                array[12] = hx;
                array[13] = -hy;
                array[14] = 0;
                position.needsUpdate = true;
                if (this.color !== undefined) {
                    this.line.material.color.set(this.color)
                } else {
                    this.line.material.color.copy(this.light.color)
                }
            };

            function HemisphereLightHelper(light, size, color) {
                Object3D.call(this);
                this.light = light;
                this.light.updateMatrixWorld();
                this.matrix = light.matrixWorld;
                this.matrixAutoUpdate = false;
                this.color = color;
                var geometry = new OctahedronBufferGeometry(size);
                geometry.rotateY(Math.PI * .5);
                this.material = new MeshBasicMaterial({
                    wireframe: true,
                    fog: false
                });
                if (this.color === undefined) this.material.vertexColors = VertexColors;
                var position = geometry.getAttribute("position");
                var colors = new Float32Array(position.count * 3);
                geometry.addAttribute("color", new BufferAttribute(colors, 3));
                this.add(new Mesh(geometry, this.material));
                this.update()
            }
            HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
            HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
            HemisphereLightHelper.prototype.dispose = function() {
                this.children[0].geometry.dispose();
                this.children[0].material.dispose()
            };
            HemisphereLightHelper.prototype.update = function() {
                var vector = new Vector3;
                var color1 = new Color;
                var color2 = new Color;
                return function update() {
                    var mesh = this.children[0];
                    if (this.color !== undefined) {
                        this.material.color.set(this.color)
                    } else {
                        var colors = mesh.geometry.getAttribute("color");
                        color1.copy(this.light.color);
                        color2.copy(this.light.groundColor);
                        for (var i = 0, l = colors.count; i < l; i++) {
                            var color = i < l / 2 ? color1 : color2;
                            colors.setXYZ(i, color.r, color.g, color.b)
                        }
                        colors.needsUpdate = true
                    }
                    mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }();

            function GridHelper(size, divisions, color1, color2) {
                size = size || 10;
                divisions = divisions || 10;
                color1 = new Color(color1 !== undefined ? color1 : 4473924);
                color2 = new Color(color2 !== undefined ? color2 : 8947848);
                var center = divisions / 2;
                var step = size / divisions;
                var halfSize = size / 2;
                var vertices = [],
                    colors = [];
                for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
                    vertices.push(-halfSize, 0, k, halfSize, 0, k);
                    vertices.push(k, 0, -halfSize, k, 0, halfSize);
                    var color = i === center ? color1 : color2;
                    color.toArray(colors, j);
                    j += 3;
                    color.toArray(colors, j);
                    j += 3;
                    color.toArray(colors, j);
                    j += 3;
                    color.toArray(colors, j);
                    j += 3
                }
                var geometry = new BufferGeometry;
                geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
                var material = new LineBasicMaterial({
                    vertexColors: VertexColors
                });
                LineSegments.call(this, geometry, material)
            }
            GridHelper.prototype = Object.create(LineSegments.prototype);
            GridHelper.prototype.constructor = GridHelper;

            function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
                radius = radius || 10;
                radials = radials || 16;
                circles = circles || 8;
                divisions = divisions || 64;
                color1 = new Color(color1 !== undefined ? color1 : 4473924);
                color2 = new Color(color2 !== undefined ? color2 : 8947848);
                var vertices = [];
                var colors = [];
                var x, z;
                var v, i, j, r, color;
                for (i = 0; i <= radials; i++) {
                    v = i / radials * (Math.PI * 2);
                    x = Math.sin(v) * radius;
                    z = Math.cos(v) * radius;
                    vertices.push(0, 0, 0);
                    vertices.push(x, 0, z);
                    color = i & 1 ? color1 : color2;
                    colors.push(color.r, color.g, color.b);
                    colors.push(color.r, color.g, color.b)
                }
                for (i = 0; i <= circles; i++) {
                    color = i & 1 ? color1 : color2;
                    r = radius - radius / circles * i;
                    for (j = 0; j < divisions; j++) {
                        v = j / divisions * (Math.PI * 2);
                        x = Math.sin(v) * r;
                        z = Math.cos(v) * r;
                        vertices.push(x, 0, z);
                        colors.push(color.r, color.g, color.b);
                        v = (j + 1) / divisions * (Math.PI * 2);
                        x = Math.sin(v) * r;
                        z = Math.cos(v) * r;
                        vertices.push(x, 0, z);
                        colors.push(color.r, color.g, color.b)
                    }
                }
                var geometry = new BufferGeometry;
                geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
                var material = new LineBasicMaterial({
                    vertexColors: VertexColors
                });
                LineSegments.call(this, geometry, material)
            }
            PolarGridHelper.prototype = Object.create(LineSegments.prototype);
            PolarGridHelper.prototype.constructor = PolarGridHelper;

            function FaceNormalsHelper(object, size, hex, linewidth) {
                this.object = object;
                this.size = size !== undefined ? size : 1;
                var color = hex !== undefined ? hex : 16776960;
                var width = linewidth !== undefined ? linewidth : 1;
                var nNormals = 0;
                var objGeometry = this.object.geometry;
                if (objGeometry && objGeometry.isGeometry) {
                    nNormals = objGeometry.faces.length
                } else {
                    console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.")
                }
                var geometry = new BufferGeometry;
                var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
                geometry.addAttribute("position", positions);
                LineSegments.call(this, geometry, new LineBasicMaterial({
                    color: color,
                    linewidth: width
                }));
                this.matrixAutoUpdate = false;
                this.update()
            }
            FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
            FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
            FaceNormalsHelper.prototype.update = function() {
                var v1 = new Vector3;
                var v2 = new Vector3;
                var normalMatrix = new Matrix3;
                return function update() {
                    this.object.updateMatrixWorld(true);
                    normalMatrix.getNormalMatrix(this.object.matrixWorld);
                    var matrixWorld = this.object.matrixWorld;
                    var position = this.geometry.attributes.position;
                    var objGeometry = this.object.geometry;
                    var vertices = objGeometry.vertices;
                    var faces = objGeometry.faces;
                    var idx = 0;
                    for (var i = 0, l = faces.length; i < l; i++) {
                        var face = faces[i];
                        var normal = face.normal;
                        v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
                        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                        position.setXYZ(idx, v1.x, v1.y, v1.z);
                        idx = idx + 1;
                        position.setXYZ(idx, v2.x, v2.y, v2.z);
                        idx = idx + 1
                    }
                    position.needsUpdate = true
                }
            }();

            function DirectionalLightHelper(light, size, color) {
                Object3D.call(this);
                this.light = light;
                this.light.updateMatrixWorld();
                this.matrix = light.matrixWorld;
                this.matrixAutoUpdate = false;
                this.color = color;
                if (size === undefined) size = 1;
                var geometry = new BufferGeometry;
                geometry.addAttribute("position", new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
                var material = new LineBasicMaterial({
                    fog: false
                });
                this.lightPlane = new Line(geometry, material);
                this.add(this.lightPlane);
                geometry = new BufferGeometry;
                geometry.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
                this.targetLine = new Line(geometry, material);
                this.add(this.targetLine);
                this.update()
            }
            DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
            DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
            DirectionalLightHelper.prototype.dispose = function() {
                this.lightPlane.geometry.dispose();
                this.lightPlane.material.dispose();
                this.targetLine.geometry.dispose();
                this.targetLine.material.dispose()
            };
            DirectionalLightHelper.prototype.update = function() {
                var v1 = new Vector3;
                var v2 = new Vector3;
                var v3 = new Vector3;
                return function update() {
                    v1.setFromMatrixPosition(this.light.matrixWorld);
                    v2.setFromMatrixPosition(this.light.target.matrixWorld);
                    v3.subVectors(v2, v1);
                    this.lightPlane.lookAt(v3);
                    if (this.color !== undefined) {
                        this.lightPlane.material.color.set(this.color);
                        this.targetLine.material.color.set(this.color)
                    } else {
                        this.lightPlane.material.color.copy(this.light.color);
                        this.targetLine.material.color.copy(this.light.color)
                    }
                    this.targetLine.lookAt(v3);
                    this.targetLine.scale.z = v3.length()
                }
            }();

            function CameraHelper(camera) {
                var geometry = new BufferGeometry;
                var material = new LineBasicMaterial({
                    color: 16777215,
                    vertexColors: FaceColors
                });
                var vertices = [];
                var colors = [];
                var pointMap = {};
                var colorFrustum = new Color(16755200);
                var colorCone = new Color(16711680);
                var colorUp = new Color(43775);
                var colorTarget = new Color(16777215);
                var colorCross = new Color(3355443);
                addLine("n1", "n2", colorFrustum);
                addLine("n2", "n4", colorFrustum);
                addLine("n4", "n3", colorFrustum);
                addLine("n3", "n1", colorFrustum);
                addLine("f1", "f2", colorFrustum);
                addLine("f2", "f4", colorFrustum);
                addLine("f4", "f3", colorFrustum);
                addLine("f3", "f1", colorFrustum);
                addLine("n1", "f1", colorFrustum);
                addLine("n2", "f2", colorFrustum);
                addLine("n3", "f3", colorFrustum);
                addLine("n4", "f4", colorFrustum);
                addLine("p", "n1", colorCone);
                addLine("p", "n2", colorCone);
                addLine("p", "n3", colorCone);
                addLine("p", "n4", colorCone);
                addLine("u1", "u2", colorUp);
                addLine("u2", "u3", colorUp);
                addLine("u3", "u1", colorUp);
                addLine("c", "t", colorTarget);
                addLine("p", "c", colorCross);
                addLine("cn1", "cn2", colorCross);
                addLine("cn3", "cn4", colorCross);
                addLine("cf1", "cf2", colorCross);
                addLine("cf3", "cf4", colorCross);

                function addLine(a, b, color) {
                    addPoint(a, color);
                    addPoint(b, color)
                }

                function addPoint(id, color) {
                    vertices.push(0, 0, 0);
                    colors.push(color.r, color.g, color.b);
                    if (pointMap[id] === undefined) {
                        pointMap[id] = []
                    }
                    pointMap[id].push(vertices.length / 3 - 1)
                }
                geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
                LineSegments.call(this, geometry, material);
                this.camera = camera;
                if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
                this.matrix = camera.matrixWorld;
                this.matrixAutoUpdate = false;
                this.pointMap = pointMap;
                this.update()
            }
            CameraHelper.prototype = Object.create(LineSegments.prototype);
            CameraHelper.prototype.constructor = CameraHelper;
            CameraHelper.prototype.update = function() {
                var geometry, pointMap;
                var vector = new Vector3;
                var camera = new Camera;

                function setPoint(point, x, y, z) {
                    vector.set(x, y, z).unproject(camera);
                    var points = pointMap[point];
                    if (points !== undefined) {
                        var position = geometry.getAttribute("position");
                        for (var i = 0, l = points.length; i < l; i++) {
                            position.setXYZ(points[i], vector.x, vector.y, vector.z)
                        }
                    }
                }
                return function update() {
                    geometry = this.geometry;
                    pointMap = this.pointMap;
                    var w = 1,
                        h = 1;
                    camera.projectionMatrix.copy(this.camera.projectionMatrix);
                    setPoint("c", 0, 0, -1);
                    setPoint("t", 0, 0, 1);
                    setPoint("n1", -w, -h, -1);
                    setPoint("n2", w, -h, -1);
                    setPoint("n3", -w, h, -1);
                    setPoint("n4", w, h, -1);
                    setPoint("f1", -w, -h, 1);
                    setPoint("f2", w, -h, 1);
                    setPoint("f3", -w, h, 1);
                    setPoint("f4", w, h, 1);
                    setPoint("u1", w * .7, h * 1.1, -1);
                    setPoint("u2", -w * .7, h * 1.1, -1);
                    setPoint("u3", 0, h * 2, -1);
                    setPoint("cf1", -w, 0, 1);
                    setPoint("cf2", w, 0, 1);
                    setPoint("cf3", 0, -h, 1);
                    setPoint("cf4", 0, h, 1);
                    setPoint("cn1", -w, 0, -1);
                    setPoint("cn2", w, 0, -1);
                    setPoint("cn3", 0, -h, -1);
                    setPoint("cn4", 0, h, -1);
                    geometry.getAttribute("position").needsUpdate = true
                }
            }();

            function BoxHelper(object, color) {
                this.object = object;
                if (color === undefined) color = 16776960;
                var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                var positions = new Float32Array(8 * 3);
                var geometry = new BufferGeometry;
                geometry.setIndex(new BufferAttribute(indices, 1));
                geometry.addAttribute("position", new BufferAttribute(positions, 3));
                LineSegments.call(this, geometry, new LineBasicMaterial({
                    color: color
                }));
                this.matrixAutoUpdate = false;
                this.update()
            }
            BoxHelper.prototype = Object.create(LineSegments.prototype);
            BoxHelper.prototype.constructor = BoxHelper;
            BoxHelper.prototype.update = function() {
                var box = new Box3;
                return function update(object) {
                    if (object !== undefined) {
                        console.warn("THREE.BoxHelper: .update() has no longer arguments.")
                    }
                    if (this.object !== undefined) {
                        box.setFromObject(this.object)
                    }
                    if (box.isEmpty()) return;
                    var min = box.min;
                    var max = box.max;
                    var position = this.geometry.attributes.position;
                    var array = position.array;
                    array[0] = max.x;
                    array[1] = max.y;
                    array[2] = max.z;
                    array[3] = min.x;
                    array[4] = max.y;
                    array[5] = max.z;
                    array[6] = min.x;
                    array[7] = min.y;
                    array[8] = max.z;
                    array[9] = max.x;
                    array[10] = min.y;
                    array[11] = max.z;
                    array[12] = max.x;
                    array[13] = max.y;
                    array[14] = min.z;
                    array[15] = min.x;
                    array[16] = max.y;
                    array[17] = min.z;
                    array[18] = min.x;
                    array[19] = min.y;
                    array[20] = min.z;
                    array[21] = max.x;
                    array[22] = min.y;
                    array[23] = min.z;
                    position.needsUpdate = true;
                    this.geometry.computeBoundingSphere()
                }
            }();
            BoxHelper.prototype.setFromObject = function(object) {
                this.object = object;
                this.update();
                return this
            };

            function Box3Helper(box, hex) {
                this.type = "Box3Helper";
                this.box = box;
                var color = hex !== undefined ? hex : 16776960;
                var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
                var geometry = new BufferGeometry;
                geometry.setIndex(new BufferAttribute(indices, 1));
                geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
                LineSegments.call(this, geometry, new LineBasicMaterial({
                    color: color
                }));
                this.geometry.computeBoundingSphere()
            }
            Box3Helper.prototype = Object.create(LineSegments.prototype);
            Box3Helper.prototype.constructor = Box3Helper;
            Box3Helper.prototype.updateMatrixWorld = function(force) {
                var box = this.box;
                if (box.isEmpty()) return;
                box.getCenter(this.position);
                box.getSize(this.scale);
                this.scale.multiplyScalar(.5);
                Object3D.prototype.updateMatrixWorld.call(this, force)
            };

            function PlaneHelper(plane, size, hex) {
                this.type = "PlaneHelper";
                this.plane = plane;
                this.size = size === undefined ? 1 : size;
                var color = hex !== undefined ? hex : 16776960;
                var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
                var geometry = new BufferGeometry;
                geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
                geometry.computeBoundingSphere();
                Line.call(this, geometry, new LineBasicMaterial({
                    color: color
                }));
                var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
                var geometry2 = new BufferGeometry;
                geometry2.addAttribute("position", new Float32BufferAttribute(positions2, 3));
                geometry2.computeBoundingSphere();
                this.add(new Mesh(geometry2, new MeshBasicMaterial({
                    color: color,
                    opacity: .2,
                    transparent: true,
                    depthWrite: false
                })))
            }
            PlaneHelper.prototype = Object.create(Line.prototype);
            PlaneHelper.prototype.constructor = PlaneHelper;
            PlaneHelper.prototype.updateMatrixWorld = function(force) {
                var scale = -this.plane.constant;
                if (Math.abs(scale) < 1e-8) scale = 1e-8;
                this.scale.set(.5 * this.size, .5 * this.size, scale);
                this.lookAt(this.plane.normal);
                Object3D.prototype.updateMatrixWorld.call(this, force)
            };
            var lineGeometry;
            var coneGeometry;

            function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
                Object3D.call(this);
                if (color === undefined) color = 16776960;
                if (length === undefined) length = 1;
                if (headLength === undefined) headLength = .2 * length;
                if (headWidth === undefined) headWidth = .2 * headLength;
                if (lineGeometry === undefined) {
                    lineGeometry = new BufferGeometry;
                    lineGeometry.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
                    coneGeometry = new CylinderBufferGeometry(0, .5, 1, 5, 1);
                    coneGeometry.translate(0, -.5, 0)
                }
                this.position.copy(origin);
                this.line = new Line(lineGeometry, new LineBasicMaterial({
                    color: color
                }));
                this.line.matrixAutoUpdate = false;
                this.add(this.line);
                this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
                    color: color
                }));
                this.cone.matrixAutoUpdate = false;
                this.add(this.cone);
                this.setDirection(dir);
                this.setLength(length, headLength, headWidth)
            }
            ArrowHelper.prototype = Object.create(Object3D.prototype);
            ArrowHelper.prototype.constructor = ArrowHelper;
            ArrowHelper.prototype.setDirection = function() {
                var axis = new Vector3;
                var radians;
                return function setDirection(dir) {
                    if (dir.y > .99999) {
                        this.quaternion.set(0, 0, 0, 1)
                    } else if (dir.y < -.99999) {
                        this.quaternion.set(1, 0, 0, 0)
                    } else {
                        axis.set(dir.z, 0, -dir.x).normalize();
                        radians = Math.acos(dir.y);
                        this.quaternion.setFromAxisAngle(axis, radians)
                    }
                }
            }();
            ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
                if (headLength === undefined) headLength = .2 * length;
                if (headWidth === undefined) headWidth = .2 * headLength;
                this.line.scale.set(1, Math.max(0, length - headLength), 1);
                this.line.updateMatrix();
                this.cone.scale.set(headWidth, headLength, headWidth);
                this.cone.position.y = length;
                this.cone.updateMatrix()
            };
            ArrowHelper.prototype.setColor = function(color) {
                this.line.material.color.copy(color);
                this.cone.material.color.copy(color)
            };

            function AxesHelper(size) {
                size = size || 1;
                var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
                var colors = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1];
                var geometry = new BufferGeometry;
                geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
                geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
                var material = new LineBasicMaterial({
                    vertexColors: VertexColors
                });
                LineSegments.call(this, geometry, material)
            }
            AxesHelper.prototype = Object.create(LineSegments.prototype);
            AxesHelper.prototype.constructor = AxesHelper;

            function Face4(a, b, c, d, normal, color, materialIndex) {
                console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
                return new Face3(a, b, c, normal, color, materialIndex)
            }
            var LineStrip = 0;
            var LinePieces = 1;

            function MeshFaceMaterial(materials) {
                console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
                return materials
            }

            function MultiMaterial(materials) {
                if (materials === undefined) materials = [];
                console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
                materials.isMultiMaterial = true;
                materials.materials = materials;
                materials.clone = function() {
                    return materials.slice()
                };
                return materials
            }

            function PointCloud(geometry, material) {
                console.warn("THREE.PointCloud has been renamed to THREE.Points.");
                return new Points(geometry, material)
            }

            function Particle(material) {
                console.warn("THREE.Particle has been renamed to THREE.Sprite.");
                return new Sprite(material)
            }

            function ParticleSystem(geometry, material) {
                console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
                return new Points(geometry, material)
            }

            function PointCloudMaterial(parameters) {
                console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
                return new PointsMaterial(parameters)
            }

            function ParticleBasicMaterial(parameters) {
                console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
                return new PointsMaterial(parameters)
            }

            function ParticleSystemMaterial(parameters) {
                console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
                return new PointsMaterial(parameters)
            }

            function Vertex(x, y, z) {
                console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
                return new Vector3(x, y, z)
            }

            function DynamicBufferAttribute(array, itemSize) {
                console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
                return new BufferAttribute(array, itemSize).setDynamic(true)
            }

            function Int8Attribute(array, itemSize) {
                console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
                return new Int8BufferAttribute(array, itemSize)
            }

            function Uint8Attribute(array, itemSize) {
                console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
                return new Uint8BufferAttribute(array, itemSize)
            }

            function Uint8ClampedAttribute(array, itemSize) {
                console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
                return new Uint8ClampedBufferAttribute(array, itemSize)
            }

            function Int16Attribute(array, itemSize) {
                console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
                return new Int16BufferAttribute(array, itemSize)
            }

            function Uint16Attribute(array, itemSize) {
                console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
                return new Uint16BufferAttribute(array, itemSize)
            }

            function Int32Attribute(array, itemSize) {
                console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
                return new Int32BufferAttribute(array, itemSize)
            }

            function Uint32Attribute(array, itemSize) {
                console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
                return new Uint32BufferAttribute(array, itemSize)
            }

            function Float32Attribute(array, itemSize) {
                console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
                return new Float32BufferAttribute(array, itemSize)
            }

            function Float64Attribute(array, itemSize) {
                console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
                return new Float64BufferAttribute(array, itemSize)
            }
            Curve.create = function(construct, getPoint) {
                console.log("THREE.Curve.create() has been deprecated");
                construct.prototype = Object.create(Curve.prototype);
                construct.prototype.constructor = construct;
                construct.prototype.getPoint = getPoint;
                return construct
            };
            Object.assign(CurvePath.prototype, {
                createPointsGeometry: function(divisions) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var pts = this.getPoints(divisions);
                    return this.createGeometry(pts)
                },
                createSpacedPointsGeometry: function(divisions) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var pts = this.getSpacedPoints(divisions);
                    return this.createGeometry(pts)
                },
                createGeometry: function(points) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var geometry = new Geometry;
                    for (var i = 0, l = points.length; i < l; i++) {
                        var point = points[i];
                        geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0))
                    }
                    return geometry
                }
            });
            Object.assign(Path.prototype, {
                fromPoints: function(points) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
                    this.setFromPoints(points)
                }
            });

            function ClosedSplineCurve3(points) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
                CatmullRomCurve3.call(this, points);
                this.type = "catmullrom";
                this.closed = true
            }
            ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

            function SplineCurve3(points) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
                CatmullRomCurve3.call(this, points);
                this.type = "catmullrom"
            }
            SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

            function Spline(points) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
                CatmullRomCurve3.call(this, points);
                this.type = "catmullrom"
            }
            Spline.prototype = Object.create(CatmullRomCurve3.prototype);
            Object.assign(Spline.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            });

            function AxisHelper(size) {
                console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
                return new AxesHelper(size)
            }

            function BoundingBoxHelper(object, color) {
                console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
                return new BoxHelper(object, color)
            }

            function EdgesHelper(object, hex) {
                console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
                return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
                    color: hex !== undefined ? hex : 16777215
                }))
            }
            GridHelper.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            };
            SkeletonHelper.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            };

            function WireframeHelper(object, hex) {
                console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
                return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
                    color: hex !== undefined ? hex : 16777215
                }))
            }
            Object.assign(Loader.prototype, {
                extractUrlBase: function(url) {
                    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
                    return LoaderUtils.extractUrlBase(url)
                }
            });

            function XHRLoader(manager) {
                console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
                return new FileLoader(manager)
            }

            function BinaryTextureLoader(manager) {
                console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
                return new DataTextureLoader(manager)
            }
            Object.assign(Box2.prototype, {
                center: function(optionalTarget) {
                    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
                    return this.getCenter(optionalTarget)
                },
                empty: function() {
                    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
                    return this.isEmpty()
                },
                isIntersectionBox: function(box) {
                    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
                    return this.intersectsBox(box)
                },
                size: function(optionalTarget) {
                    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
                    return this.getSize(optionalTarget)
                }
            });
            Object.assign(Box3.prototype, {
                center: function(optionalTarget) {
                    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
                    return this.getCenter(optionalTarget)
                },
                empty: function() {
                    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
                    return this.isEmpty()
                },
                isIntersectionBox: function(box) {
                    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
                    return this.intersectsBox(box)
                },
                isIntersectionSphere: function(sphere) {
                    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
                    return this.intersectsSphere(sphere)
                },
                size: function(optionalTarget) {
                    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
                    return this.getSize(optionalTarget)
                }
            });
            Line3.prototype.center = function(optionalTarget) {
                console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
                return this.getCenter(optionalTarget)
            };
            Object.assign(_Math, {
                random16: function() {
                    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
                    return Math.random()
                },
                nearestPowerOfTwo: function(value) {
                    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
                    return _Math.floorPowerOfTwo(value)
                },
                nextPowerOfTwo: function(value) {
                    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
                    return _Math.ceilPowerOfTwo(value)
                }
            });
            Object.assign(Matrix3.prototype, {
                flattenToArrayOffset: function(array, offset) {
                    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
                    return this.toArray(array, offset)
                },
                multiplyVector3: function(vector) {
                    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
                    return vector.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(buffer) {
                    console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
                    return this.applyToBufferAttribute(buffer)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            });
            Object.assign(Matrix4.prototype, {
                extractPosition: function(m) {
                    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
                    return this.copyPosition(m)
                },
                flattenToArrayOffset: function(array, offset) {
                    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
                    return this.toArray(array, offset)
                },
                getPosition: function() {
                    var v1;
                    return function getPosition() {
                        if (v1 === undefined) v1 = new Vector3;
                        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                        return v1.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function(q) {
                    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
                    return this.makeRotationFromQuaternion(q)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(vector) {
                    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
                    return vector.applyMatrix4(this)
                },
                multiplyVector4: function(vector) {
                    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
                    return vector.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(v) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
                    v.transformDirection(this)
                },
                crossVector: function(vector) {
                    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
                    return vector.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(buffer) {
                    console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
                    return this.applyToBufferAttribute(buffer)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(left, right, bottom, top, near, far) {
                    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
                    return this.makePerspective(left, right, top, bottom, near, far)
                }
            });
            Plane.prototype.isIntersectionLine = function(line) {
                console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
                return this.intersectsLine(line)
            };
            Quaternion.prototype.multiplyVector3 = function(vector) {
                console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
                return vector.applyQuaternion(this)
            };
            Object.assign(Ray.prototype, {
                isIntersectionBox: function(box) {
                    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
                    return this.intersectsBox(box)
                },
                isIntersectionPlane: function(plane) {
                    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
                    return this.intersectsPlane(plane)
                },
                isIntersectionSphere: function(sphere) {
                    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
                    return this.intersectsSphere(sphere)
                }
            });
            Object.assign(Triangle.prototype, {
                area: function() {
                    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
                    return this.getArea()
                },
                barycoordFromPoint: function(point, target) {
                    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
                    return this.getBarycoord(point, target)
                },
                midpoint: function(target) {
                    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
                    return this.getMidpoint(target)
                },
                normal: function(target) {
                    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
                    return this.getNormal(target)
                },
                plane: function(target) {
                    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
                    return this.getPlane(target)
                }
            });
            Object.assign(Triangle, {
                barycoordFromPoint: function(point, a, b, c, target) {
                    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
                    return Triangle.getBarycoord(point, a, b, c, target)
                },
                normal: function(a, b, c, target) {
                    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
                    return Triangle.getNormal(a, b, c, target)
                }
            });
            Object.assign(Shape.prototype, {
                extractAllPoints: function(divisions) {
                    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
                    return this.extractPoints(divisions)
                },
                extrude: function(options) {
                    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
                    return new ExtrudeGeometry(this, options)
                },
                makeGeometry: function(options) {
                    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
                    return new ShapeGeometry(this, options)
                }
            });
            Object.assign(Vector2.prototype, {
                fromAttribute: function(attribute, index, offset) {
                    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
                    return this.fromBufferAttribute(attribute, index, offset)
                },
                distanceToManhattan: function(v) {
                    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
                    return this.manhattanDistanceTo(v)
                },
                lengthManhattan: function() {
                    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
                    return this.manhattanLength()
                }
            });
            Object.assign(Vector3.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(m) {
                    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
                    return this.setFromMatrixPosition(m)
                },
                getScaleFromMatrix: function(m) {
                    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
                    return this.setFromMatrixScale(m)
                },
                getColumnFromMatrix: function(index, matrix) {
                    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
                    return this.setFromMatrixColumn(matrix, index)
                },
                applyProjection: function(m) {
                    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
                    return this.applyMatrix4(m)
                },
                fromAttribute: function(attribute, index, offset) {
                    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
                    return this.fromBufferAttribute(attribute, index, offset)
                },
                distanceToManhattan: function(v) {
                    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
                    return this.manhattanDistanceTo(v)
                },
                lengthManhattan: function() {
                    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
                    return this.manhattanLength()
                }
            });
            Object.assign(Vector4.prototype, {
                fromAttribute: function(attribute, index, offset) {
                    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
                    return this.fromBufferAttribute(attribute, index, offset)
                },
                lengthManhattan: function() {
                    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
                    return this.manhattanLength()
                }
            });
            Object.assign(Geometry.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            });
            Object.assign(Object3D.prototype, {
                getChildByName: function(name) {
                    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
                    return this.getObjectByName(name)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(distance, axis) {
                    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
                    return this.translateOnAxis(axis, distance)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            });
            Object.defineProperties(Object3D.prototype, {
                eulerOrder: {
                    get: function() {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                        return this.rotation.order
                    },
                    set: function(value) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                        this.rotation.order = value
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            });
            Object.defineProperties(LOD.prototype, {
                objects: {
                    get: function() {
                        console.warn("THREE.LOD: .objects has been renamed to .levels.");
                        return this.levels
                    }
                }
            });
            Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            });
            Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
                get: function() {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
                    return this.arcLengthDivisions
                },
                set: function(value) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
                    this.arcLengthDivisions = value
                }
            });
            PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
                if (filmGauge !== undefined) this.filmGauge = filmGauge;
                this.setFocalLength(focalLength)
            };
            Object.defineProperties(Light.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
                        this.shadow.camera.fov = value
                    }
                },
                shadowCameraLeft: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
                        this.shadow.camera.left = value
                    }
                },
                shadowCameraRight: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
                        this.shadow.camera.right = value
                    }
                },
                shadowCameraTop: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
                        this.shadow.camera.top = value
                    }
                },
                shadowCameraBottom: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
                        this.shadow.camera.bottom = value
                    }
                },
                shadowCameraNear: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
                        this.shadow.camera.near = value
                    }
                },
                shadowCameraFar: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
                        this.shadow.camera.far = value
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
                        this.shadow.bias = value
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
                        this.shadow.mapSize.width = value
                    }
                },
                shadowMapHeight: {
                    set: function(value) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
                        this.shadow.mapSize.height = value
                    }
                }
            });
            Object.defineProperties(BufferAttribute.prototype, {
                length: {
                    get: function() {
                        console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
                        return this.array.length
                    }
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            });
            Object.assign(BufferGeometry.prototype, {
                addIndex: function(index) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
                    this.setIndex(index)
                },
                addDrawCall: function(start, count, indexOffset) {
                    if (indexOffset !== undefined) {
                        console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.")
                    }
                    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
                    this.addGroup(start, count)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
                    this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            });
            Object.defineProperties(BufferGeometry.prototype, {
                drawcalls: {
                    get: function() {
                        console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
                        return this.groups
                    }
                },
                offsets: {
                    get: function() {
                        console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
                        return this.groups
                    }
                }
            });
            Object.defineProperties(Uniform.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
                        return this
                    }
                }
            });
            Object.defineProperties(Material.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        console.warn("THREE.Material: .wrapRGB has been removed.");
                        return new Color
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(value) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
                        this.flatShading = value === FlatShading
                    }
                }
            });
            Object.defineProperties(MeshPhongMaterial.prototype, {
                metal: {
                    get: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
                        return false
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            });
            Object.defineProperties(ShaderMaterial.prototype, {
                derivatives: {
                    get: function() {
                        console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                        return this.extensions.derivatives
                    },
                    set: function(value) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                        this.extensions.derivatives = value
                    }
                }
            });
            Object.assign(WebGLRenderer.prototype, {
                getCurrentRenderTarget: function() {
                    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
                    return this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
                    return this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
                    return this.capabilities.precision
                },
                resetGLState: function() {
                    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
                    return this.state.reset()
                },
                supportsFloatTextures: function() {
                    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
                    return this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
                    return this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
                    return this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
                    return this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
                    return this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
                    return this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
                    return this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
                    return this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(boolean) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
                    this.setScissorTest(boolean)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }
            });
            Object.defineProperties(WebGLRenderer.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
                        this.shadowMap.enabled = value
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
                        this.shadowMap.type = value
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
                        return undefined
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            });
            Object.defineProperties(WebGLShadowMap.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
                        return undefined
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
                        return undefined
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
                        return undefined
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            });
            Object.defineProperties(WebGLRenderTarget.prototype, {
                wrapS: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                        return this.texture.wrapS
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                        this.texture.wrapS = value
                    }
                },
                wrapT: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                        return this.texture.wrapT
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                        this.texture.wrapT = value
                    }
                },
                magFilter: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                        return this.texture.magFilter
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                        this.texture.magFilter = value
                    }
                },
                minFilter: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                        return this.texture.minFilter
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                        this.texture.minFilter = value
                    }
                },
                anisotropy: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                        return this.texture.anisotropy
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                        this.texture.anisotropy = value
                    }
                },
                offset: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                        return this.texture.offset
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                        this.texture.offset = value
                    }
                },
                repeat: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                        return this.texture.repeat
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                        this.texture.repeat = value
                    }
                },
                format: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                        return this.texture.format
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                        this.texture.format = value
                    }
                },
                type: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                        return this.texture.type
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                        this.texture.type = value
                    }
                },
                generateMipmaps: {
                    get: function() {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                        return this.texture.generateMipmaps
                    },
                    set: function(value) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                        this.texture.generateMipmaps = value
                    }
                }
            });
            Object.defineProperties(WebVRManager.prototype, {
                standing: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                }
            });
            Audio.prototype.load = function(file) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var scope = this;
                var audioLoader = new AudioLoader;
                audioLoader.load(file, function(buffer) {
                    scope.setBuffer(buffer)
                });
                return this
            };
            AudioAnalyser.prototype.getData = function() {
                console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
                return this.getFrequencyData()
            };
            CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
                console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
                return this.update(renderer, scene)
            };
            var GeometryUtils = {
                merge: function(geometry1, geometry2, materialIndexOffset) {
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var matrix;
                    if (geometry2.isMesh) {
                        geometry2.matrixAutoUpdate && geometry2.updateMatrix();
                        matrix = geometry2.matrix;
                        geometry2 = geometry2.geometry
                    }
                    geometry1.merge(geometry2, matrix, materialIndexOffset)
                },
                center: function(geometry) {
                    console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
                    return geometry.center()
                }
            };
            var ImageUtils = {
                crossOrigin: undefined,
                loadTexture: function(url, mapping, onLoad, onError) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    var loader = new TextureLoader;
                    loader.setCrossOrigin(this.crossOrigin);
                    var texture = loader.load(url, onLoad, undefined, onError);
                    if (mapping) texture.mapping = mapping;
                    return texture
                },
                loadTextureCube: function(urls, mapping, onLoad, onError) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    var loader = new CubeTextureLoader;
                    loader.setCrossOrigin(this.crossOrigin);
                    var texture = loader.load(urls, onLoad, undefined, onError);
                    if (mapping) texture.mapping = mapping;
                    return texture
                },
                loadCompressedTexture: function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                },
                loadCompressedTextureCube: function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }
            };

            function Projector() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
                this.projectVector = function(vector, camera) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project().");
                    vector.project(camera)
                };
                this.unprojectVector = function(vector, camera) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
                    vector.unproject(camera)
                };
                this.pickingRay = function() {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }

            function CanvasRenderer() {
                console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
                this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                this.clear = function() {};
                this.render = function() {};
                this.setClearColor = function() {};
                this.setSize = function() {}
            }
            var SceneUtils = {
                createMultiMaterialObject: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };

            function LensFlare() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }
            exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
            exports.WebGLRenderTarget = WebGLRenderTarget;
            exports.WebGLRenderer = WebGLRenderer;
            exports.ShaderLib = ShaderLib;
            exports.UniformsLib = UniformsLib;
            exports.UniformsUtils = UniformsUtils;
            exports.ShaderChunk = ShaderChunk;
            exports.FogExp2 = FogExp2;
            exports.Fog = Fog;
            exports.Scene = Scene;
            exports.Sprite = Sprite;
            exports.LOD = LOD;
            exports.SkinnedMesh = SkinnedMesh;
            exports.Skeleton = Skeleton;
            exports.Bone = Bone;
            exports.Mesh = Mesh;
            exports.LineSegments = LineSegments;
            exports.LineLoop = LineLoop;
            exports.Line = Line;
            exports.Points = Points;
            exports.Group = Group;
            exports.VideoTexture = VideoTexture;
            exports.DataTexture = DataTexture;
            exports.CompressedTexture = CompressedTexture;
            exports.CubeTexture = CubeTexture;
            exports.CanvasTexture = CanvasTexture;
            exports.DepthTexture = DepthTexture;
            exports.Texture = Texture;
            exports.CompressedTextureLoader = CompressedTextureLoader;
            exports.DataTextureLoader = DataTextureLoader;
            exports.CubeTextureLoader = CubeTextureLoader;
            exports.TextureLoader = TextureLoader;
            exports.ObjectLoader = ObjectLoader;
            exports.MaterialLoader = MaterialLoader;
            exports.BufferGeometryLoader = BufferGeometryLoader;
            exports.DefaultLoadingManager = DefaultLoadingManager;
            exports.LoadingManager = LoadingManager;
            exports.JSONLoader = JSONLoader;
            exports.ImageLoader = ImageLoader;
            exports.ImageBitmapLoader = ImageBitmapLoader;
            exports.FontLoader = FontLoader;
            exports.FileLoader = FileLoader;
            exports.Loader = Loader;
            exports.LoaderUtils = LoaderUtils;
            exports.Cache = Cache;
            exports.AudioLoader = AudioLoader;
            exports.SpotLightShadow = SpotLightShadow;
            exports.SpotLight = SpotLight;
            exports.PointLight = PointLight;
            exports.RectAreaLight = RectAreaLight;
            exports.HemisphereLight = HemisphereLight;
            exports.DirectionalLightShadow = DirectionalLightShadow;
            exports.DirectionalLight = DirectionalLight;
            exports.AmbientLight = AmbientLight;
            exports.LightShadow = LightShadow;
            exports.Light = Light;
            exports.StereoCamera = StereoCamera;
            exports.PerspectiveCamera = PerspectiveCamera;
            exports.OrthographicCamera = OrthographicCamera;
            exports.CubeCamera = CubeCamera;
            exports.ArrayCamera = ArrayCamera;
            exports.Camera = Camera;
            exports.AudioListener = AudioListener;
            exports.PositionalAudio = PositionalAudio;
            exports.AudioContext = AudioContext;
            exports.AudioAnalyser = AudioAnalyser;
            exports.Audio = Audio;
            exports.VectorKeyframeTrack = VectorKeyframeTrack;
            exports.StringKeyframeTrack = StringKeyframeTrack;
            exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
            exports.NumberKeyframeTrack = NumberKeyframeTrack;
            exports.ColorKeyframeTrack = ColorKeyframeTrack;
            exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
            exports.PropertyMixer = PropertyMixer;
            exports.PropertyBinding = PropertyBinding;
            exports.KeyframeTrack = KeyframeTrack;
            exports.AnimationUtils = AnimationUtils;
            exports.AnimationObjectGroup = AnimationObjectGroup;
            exports.AnimationMixer = AnimationMixer;
            exports.AnimationClip = AnimationClip;
            exports.Uniform = Uniform;
            exports.InstancedBufferGeometry = InstancedBufferGeometry;
            exports.BufferGeometry = BufferGeometry;
            exports.Geometry = Geometry;
            exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
            exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
            exports.InterleavedBuffer = InterleavedBuffer;
            exports.InstancedBufferAttribute = InstancedBufferAttribute;
            exports.Face3 = Face3;
            exports.Object3D = Object3D;
            exports.Raycaster = Raycaster;
            exports.Layers = Layers;
            exports.EventDispatcher = EventDispatcher;
            exports.Clock = Clock;
            exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
            exports.LinearInterpolant = LinearInterpolant;
            exports.DiscreteInterpolant = DiscreteInterpolant;
            exports.CubicInterpolant = CubicInterpolant;
            exports.Interpolant = Interpolant;
            exports.Triangle = Triangle;
            exports.Math = _Math;
            exports.Spherical = Spherical;
            exports.Cylindrical = Cylindrical;
            exports.Plane = Plane;
            exports.Frustum = Frustum;
            exports.Sphere = Sphere;
            exports.Ray = Ray;
            exports.Matrix4 = Matrix4;
            exports.Matrix3 = Matrix3;
            exports.Box3 = Box3;
            exports.Box2 = Box2;
            exports.Line3 = Line3;
            exports.Euler = Euler;
            exports.Vector4 = Vector4;
            exports.Vector3 = Vector3;
            exports.Vector2 = Vector2;
            exports.Quaternion = Quaternion;
            exports.Color = Color;
            exports.ImmediateRenderObject = ImmediateRenderObject;
            exports.VertexNormalsHelper = VertexNormalsHelper;
            exports.SpotLightHelper = SpotLightHelper;
            exports.SkeletonHelper = SkeletonHelper;
            exports.PointLightHelper = PointLightHelper;
            exports.RectAreaLightHelper = RectAreaLightHelper;
            exports.HemisphereLightHelper = HemisphereLightHelper;
            exports.GridHelper = GridHelper;
            exports.PolarGridHelper = PolarGridHelper;
            exports.FaceNormalsHelper = FaceNormalsHelper;
            exports.DirectionalLightHelper = DirectionalLightHelper;
            exports.CameraHelper = CameraHelper;
            exports.BoxHelper = BoxHelper;
            exports.Box3Helper = Box3Helper;
            exports.PlaneHelper = PlaneHelper;
            exports.ArrowHelper = ArrowHelper;
            exports.AxesHelper = AxesHelper;
            exports.Shape = Shape;
            exports.Path = Path;
            exports.ShapePath = ShapePath;
            exports.Font = Font;
            exports.CurvePath = CurvePath;
            exports.Curve = Curve;
            exports.ShapeUtils = ShapeUtils;
            exports.WebGLUtils = WebGLUtils;
            exports.WireframeGeometry = WireframeGeometry;
            exports.ParametricGeometry = ParametricGeometry;
            exports.ParametricBufferGeometry = ParametricBufferGeometry;
            exports.TetrahedronGeometry = TetrahedronGeometry;
            exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
            exports.OctahedronGeometry = OctahedronGeometry;
            exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
            exports.IcosahedronGeometry = IcosahedronGeometry;
            exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
            exports.DodecahedronGeometry = DodecahedronGeometry;
            exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
            exports.PolyhedronGeometry = PolyhedronGeometry;
            exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
            exports.TubeGeometry = TubeGeometry;
            exports.TubeBufferGeometry = TubeBufferGeometry;
            exports.TorusKnotGeometry = TorusKnotGeometry;
            exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
            exports.TorusGeometry = TorusGeometry;
            exports.TorusBufferGeometry = TorusBufferGeometry;
            exports.TextGeometry = TextGeometry;
            exports.TextBufferGeometry = TextBufferGeometry;
            exports.SphereGeometry = SphereGeometry;
            exports.SphereBufferGeometry = SphereBufferGeometry;
            exports.RingGeometry = RingGeometry;
            exports.RingBufferGeometry = RingBufferGeometry;
            exports.PlaneGeometry = PlaneGeometry;
            exports.PlaneBufferGeometry = PlaneBufferGeometry;
            exports.LatheGeometry = LatheGeometry;
            exports.LatheBufferGeometry = LatheBufferGeometry;
            exports.ShapeGeometry = ShapeGeometry;
            exports.ShapeBufferGeometry = ShapeBufferGeometry;
            exports.ExtrudeGeometry = ExtrudeGeometry;
            exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
            exports.EdgesGeometry = EdgesGeometry;
            exports.ConeGeometry = ConeGeometry;
            exports.ConeBufferGeometry = ConeBufferGeometry;
            exports.CylinderGeometry = CylinderGeometry;
            exports.CylinderBufferGeometry = CylinderBufferGeometry;
            exports.CircleGeometry = CircleGeometry;
            exports.CircleBufferGeometry = CircleBufferGeometry;
            exports.BoxGeometry = BoxGeometry;
            exports.BoxBufferGeometry = BoxBufferGeometry;
            exports.ShadowMaterial = ShadowMaterial;
            exports.SpriteMaterial = SpriteMaterial;
            exports.RawShaderMaterial = RawShaderMaterial;
            exports.ShaderMaterial = ShaderMaterial;
            exports.PointsMaterial = PointsMaterial;
            exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
            exports.MeshStandardMaterial = MeshStandardMaterial;
            exports.MeshPhongMaterial = MeshPhongMaterial;
            exports.MeshToonMaterial = MeshToonMaterial;
            exports.MeshNormalMaterial = MeshNormalMaterial;
            exports.MeshLambertMaterial = MeshLambertMaterial;
            exports.MeshDepthMaterial = MeshDepthMaterial;
            exports.MeshDistanceMaterial = MeshDistanceMaterial;
            exports.MeshBasicMaterial = MeshBasicMaterial;
            exports.LineDashedMaterial = LineDashedMaterial;
            exports.LineBasicMaterial = LineBasicMaterial;
            exports.Material = Material;
            exports.Float64BufferAttribute = Float64BufferAttribute;
            exports.Float32BufferAttribute = Float32BufferAttribute;
            exports.Uint32BufferAttribute = Uint32BufferAttribute;
            exports.Int32BufferAttribute = Int32BufferAttribute;
            exports.Uint16BufferAttribute = Uint16BufferAttribute;
            exports.Int16BufferAttribute = Int16BufferAttribute;
            exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
            exports.Uint8BufferAttribute = Uint8BufferAttribute;
            exports.Int8BufferAttribute = Int8BufferAttribute;
            exports.BufferAttribute = BufferAttribute;
            exports.ArcCurve = ArcCurve;
            exports.CatmullRomCurve3 = CatmullRomCurve3;
            exports.CubicBezierCurve = CubicBezierCurve;
            exports.CubicBezierCurve3 = CubicBezierCurve3;
            exports.EllipseCurve = EllipseCurve;
            exports.LineCurve = LineCurve;
            exports.LineCurve3 = LineCurve3;
            exports.QuadraticBezierCurve = QuadraticBezierCurve;
            exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
            exports.SplineCurve = SplineCurve;
            exports.REVISION = REVISION;
            exports.MOUSE = MOUSE;
            exports.CullFaceNone = CullFaceNone;
            exports.CullFaceBack = CullFaceBack;
            exports.CullFaceFront = CullFaceFront;
            exports.CullFaceFrontBack = CullFaceFrontBack;
            exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
            exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
            exports.BasicShadowMap = BasicShadowMap;
            exports.PCFShadowMap = PCFShadowMap;
            exports.PCFSoftShadowMap = PCFSoftShadowMap;
            exports.FrontSide = FrontSide;
            exports.BackSide = BackSide;
            exports.DoubleSide = DoubleSide;
            exports.FlatShading = FlatShading;
            exports.SmoothShading = SmoothShading;
            exports.NoColors = NoColors;
            exports.FaceColors = FaceColors;
            exports.VertexColors = VertexColors;
            exports.NoBlending = NoBlending;
            exports.NormalBlending = NormalBlending;
            exports.AdditiveBlending = AdditiveBlending;
            exports.SubtractiveBlending = SubtractiveBlending;
            exports.MultiplyBlending = MultiplyBlending;
            exports.CustomBlending = CustomBlending;
            exports.AddEquation = AddEquation;
            exports.SubtractEquation = SubtractEquation;
            exports.ReverseSubtractEquation = ReverseSubtractEquation;
            exports.MinEquation = MinEquation;
            exports.MaxEquation = MaxEquation;
            exports.ZeroFactor = ZeroFactor;
            exports.OneFactor = OneFactor;
            exports.SrcColorFactor = SrcColorFactor;
            exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
            exports.SrcAlphaFactor = SrcAlphaFactor;
            exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
            exports.DstAlphaFactor = DstAlphaFactor;
            exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
            exports.DstColorFactor = DstColorFactor;
            exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
            exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
            exports.NeverDepth = NeverDepth;
            exports.AlwaysDepth = AlwaysDepth;
            exports.LessDepth = LessDepth;
            exports.LessEqualDepth = LessEqualDepth;
            exports.EqualDepth = EqualDepth;
            exports.GreaterEqualDepth = GreaterEqualDepth;
            exports.GreaterDepth = GreaterDepth;
            exports.NotEqualDepth = NotEqualDepth;
            exports.MultiplyOperation = MultiplyOperation;
            exports.MixOperation = MixOperation;
            exports.AddOperation = AddOperation;
            exports.NoToneMapping = NoToneMapping;
            exports.LinearToneMapping = LinearToneMapping;
            exports.ReinhardToneMapping = ReinhardToneMapping;
            exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
            exports.CineonToneMapping = CineonToneMapping;
            exports.UVMapping = UVMapping;
            exports.CubeReflectionMapping = CubeReflectionMapping;
            exports.CubeRefractionMapping = CubeRefractionMapping;
            exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
            exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
            exports.SphericalReflectionMapping = SphericalReflectionMapping;
            exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
            exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
            exports.RepeatWrapping = RepeatWrapping;
            exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
            exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
            exports.NearestFilter = NearestFilter;
            exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
            exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
            exports.LinearFilter = LinearFilter;
            exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
            exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
            exports.UnsignedByteType = UnsignedByteType;
            exports.ByteType = ByteType;
            exports.ShortType = ShortType;
            exports.UnsignedShortType = UnsignedShortType;
            exports.IntType = IntType;
            exports.UnsignedIntType = UnsignedIntType;
            exports.FloatType = FloatType;
            exports.HalfFloatType = HalfFloatType;
            exports.UnsignedShort4444Type = UnsignedShort4444Type;
            exports.UnsignedShort5551Type = UnsignedShort5551Type;
            exports.UnsignedShort565Type = UnsignedShort565Type;
            exports.UnsignedInt248Type = UnsignedInt248Type;
            exports.AlphaFormat = AlphaFormat;
            exports.RGBFormat = RGBFormat;
            exports.RGBAFormat = RGBAFormat;
            exports.LuminanceFormat = LuminanceFormat;
            exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
            exports.RGBEFormat = RGBEFormat;
            exports.DepthFormat = DepthFormat;
            exports.DepthStencilFormat = DepthStencilFormat;
            exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
            exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
            exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
            exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
            exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
            exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
            exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
            exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
            exports.RGB_ETC1_Format = RGB_ETC1_Format;
            exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
            exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
            exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
            exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
            exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
            exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
            exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
            exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
            exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
            exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
            exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
            exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
            exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
            exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
            exports.LoopOnce = LoopOnce;
            exports.LoopRepeat = LoopRepeat;
            exports.LoopPingPong = LoopPingPong;
            exports.InterpolateDiscrete = InterpolateDiscrete;
            exports.InterpolateLinear = InterpolateLinear;
            exports.InterpolateSmooth = InterpolateSmooth;
            exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
            exports.ZeroSlopeEnding = ZeroSlopeEnding;
            exports.WrapAroundEnding = WrapAroundEnding;
            exports.TrianglesDrawMode = TrianglesDrawMode;
            exports.TriangleStripDrawMode = TriangleStripDrawMode;
            exports.TriangleFanDrawMode = TriangleFanDrawMode;
            exports.LinearEncoding = LinearEncoding;
            exports.sRGBEncoding = sRGBEncoding;
            exports.GammaEncoding = GammaEncoding;
            exports.RGBEEncoding = RGBEEncoding;
            exports.LogLuvEncoding = LogLuvEncoding;
            exports.RGBM7Encoding = RGBM7Encoding;
            exports.RGBM16Encoding = RGBM16Encoding;
            exports.RGBDEncoding = RGBDEncoding;
            exports.BasicDepthPacking = BasicDepthPacking;
            exports.RGBADepthPacking = RGBADepthPacking;
            exports.CubeGeometry = BoxGeometry;
            exports.Face4 = Face4;
            exports.LineStrip = LineStrip;
            exports.LinePieces = LinePieces;
            exports.MeshFaceMaterial = MeshFaceMaterial;
            exports.MultiMaterial = MultiMaterial;
            exports.PointCloud = PointCloud;
            exports.Particle = Particle;
            exports.ParticleSystem = ParticleSystem;
            exports.PointCloudMaterial = PointCloudMaterial;
            exports.ParticleBasicMaterial = ParticleBasicMaterial;
            exports.ParticleSystemMaterial = ParticleSystemMaterial;
            exports.Vertex = Vertex;
            exports.DynamicBufferAttribute = DynamicBufferAttribute;
            exports.Int8Attribute = Int8Attribute;
            exports.Uint8Attribute = Uint8Attribute;
            exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
            exports.Int16Attribute = Int16Attribute;
            exports.Uint16Attribute = Uint16Attribute;
            exports.Int32Attribute = Int32Attribute;
            exports.Uint32Attribute = Uint32Attribute;
            exports.Float32Attribute = Float32Attribute;
            exports.Float64Attribute = Float64Attribute;
            exports.ClosedSplineCurve3 = ClosedSplineCurve3;
            exports.SplineCurve3 = SplineCurve3;
            exports.Spline = Spline;
            exports.AxisHelper = AxisHelper;
            exports.BoundingBoxHelper = BoundingBoxHelper;
            exports.EdgesHelper = EdgesHelper;
            exports.WireframeHelper = WireframeHelper;
            exports.XHRLoader = XHRLoader;
            exports.BinaryTextureLoader = BinaryTextureLoader;
            exports.GeometryUtils = GeometryUtils;
            exports.ImageUtils = ImageUtils;
            exports.Projector = Projector;
            exports.CanvasRenderer = CanvasRenderer;
            exports.SceneUtils = SceneUtils;
            exports.LensFlare = LensFlare;
            Object.defineProperty(exports, "__esModule", {
                value: true
            })
        })
    }, {}],
    330: [function(require, module, exports) {
        (function(self) {
            "use strict";
            if (self.fetch) {
                return
            }
            var support = {
                searchParams: "URLSearchParams" in self,
                iterable: "Symbol" in self && "iterator" in Symbol,
                blob: "FileReader" in self && "Blob" in self && function() {
                    try {
                        new Blob;
                        return true
                    } catch (e) {
                        return false
                    }
                }(),
                formData: "FormData" in self,
                arrayBuffer: "ArrayBuffer" in self
            };
            if (support.arrayBuffer) {
                var viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"];
                var isDataView = function(obj) {
                    return obj && DataView.prototype.isPrototypeOf(obj)
                };
                var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                }
            }

            function normalizeName(name) {
                if (typeof name !== "string") {
                    name = String(name)
                }
                if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                    throw new TypeError("Invalid character in header field name")
                }
                return name.toLowerCase()
            }

            function normalizeValue(value) {
                if (typeof value !== "string") {
                    value = String(value)
                }
                return value
            }

            function iteratorFor(items) {
                var iterator = {
                    next: function() {
                        var value = items.shift();
                        return {
                            done: value === undefined,
                            value: value
                        }
                    }
                };
                if (support.iterable) {
                    iterator[Symbol.iterator] = function() {
                        return iterator
                    }
                }
                return iterator
            }

            function Headers(headers) {
                this.map = {};
                if (headers instanceof Headers) {
                    headers.forEach(function(value, name) {
                        this.append(name, value)
                    }, this)
                } else if (Array.isArray(headers)) {
                    headers.forEach(function(header) {
                        this.append(header[0], header[1])
                    }, this)
                } else if (headers) {
                    Object.getOwnPropertyNames(headers).forEach(function(name) {
                        this.append(name, headers[name])
                    }, this)
                }
            }
            Headers.prototype.append = function(name, value) {
                name = normalizeName(name);
                value = normalizeValue(value);
                var oldValue = this.map[name];
                this.map[name] = oldValue ? oldValue + "," + value : value
            };
            Headers.prototype["delete"] = function(name) {
                delete this.map[normalizeName(name)]
            };
            Headers.prototype.get = function(name) {
                name = normalizeName(name);
                return this.has(name) ? this.map[name] : null
            };
            Headers.prototype.has = function(name) {
                return this.map.hasOwnProperty(normalizeName(name))
            };
            Headers.prototype.set = function(name, value) {
                this.map[normalizeName(name)] = normalizeValue(value)
            };
            Headers.prototype.forEach = function(callback, thisArg) {
                for (var name in this.map) {
                    if (this.map.hasOwnProperty(name)) {
                        callback.call(thisArg, this.map[name], name, this)
                    }
                }
            };
            Headers.prototype.keys = function() {
                var items = [];
                this.forEach(function(value, name) {
                    items.push(name)
                });
                return iteratorFor(items)
            };
            Headers.prototype.values = function() {
                var items = [];
                this.forEach(function(value) {
                    items.push(value)
                });
                return iteratorFor(items)
            };
            Headers.prototype.entries = function() {
                var items = [];
                this.forEach(function(value, name) {
                    items.push([name, value])
                });
                return iteratorFor(items)
            };
            if (support.iterable) {
                Headers.prototype[Symbol.iterator] = Headers.prototype.entries
            }

            function consumed(body) {
                if (body.bodyUsed) {
                    return Promise.reject(new TypeError("Already read"))
                }
                body.bodyUsed = true
            }

            function fileReaderReady(reader) {
                return new Promise(function(resolve, reject) {
                    reader.onload = function() {
                        resolve(reader.result)
                    };
                    reader.onerror = function() {
                        reject(reader.error)
                    }
                })
            }

            function readBlobAsArrayBuffer(blob) {
                var reader = new FileReader;
                var promise = fileReaderReady(reader);
                reader.readAsArrayBuffer(blob);
                return promise
            }

            function readBlobAsText(blob) {
                var reader = new FileReader;
                var promise = fileReaderReady(reader);
                reader.readAsText(blob);
                return promise
            }

            function readArrayBufferAsText(buf) {
                var view = new Uint8Array(buf);
                var chars = new Array(view.length);
                for (var i = 0; i < view.length; i++) {
                    chars[i] = String.fromCharCode(view[i])
                }
                return chars.join("")
            }

            function bufferClone(buf) {
                if (buf.slice) {
                    return buf.slice(0)
                } else {
                    var view = new Uint8Array(buf.byteLength);
                    view.set(new Uint8Array(buf));
                    return view.buffer
                }
            }

            function Body() {
                this.bodyUsed = false;
                this._initBody = function(body) {
                    this._bodyInit = body;
                    if (!body) {
                        this._bodyText = ""
                    } else if (typeof body === "string") {
                        this._bodyText = body
                    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                        this._bodyBlob = body
                    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                        this._bodyFormData = body
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                        this._bodyText = body.toString()
                    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                        this._bodyArrayBuffer = bufferClone(body.buffer);
                        this._bodyInit = new Blob([this._bodyArrayBuffer])
                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                        this._bodyArrayBuffer = bufferClone(body)
                    } else {
                        throw new Error("unsupported BodyInit type")
                    }
                    if (!this.headers.get("content-type")) {
                        if (typeof body === "string") {
                            this.headers.set("content-type", "text/plain;charset=UTF-8")
                        } else if (this._bodyBlob && this._bodyBlob.type) {
                            this.headers.set("content-type", this._bodyBlob.type)
                        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                            this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8")
                        }
                    }
                };
                if (support.blob) {
                    this.blob = function() {
                        var rejected = consumed(this);
                        if (rejected) {
                            return rejected
                        }
                        if (this._bodyBlob) {
                            return Promise.resolve(this._bodyBlob)
                        } else if (this._bodyArrayBuffer) {
                            return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                        } else if (this._bodyFormData) {
                            throw new Error("could not read FormData body as blob")
                        } else {
                            return Promise.resolve(new Blob([this._bodyText]))
                        }
                    };
                    this.arrayBuffer = function() {
                        if (this._bodyArrayBuffer) {
                            return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                        } else {
                            return this.blob().then(readBlobAsArrayBuffer)
                        }
                    }
                }
                this.text = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                        return rejected
                    }
                    if (this._bodyBlob) {
                        return readBlobAsText(this._bodyBlob)
                    } else if (this._bodyArrayBuffer) {
                        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
                    } else if (this._bodyFormData) {
                        throw new Error("could not read FormData body as text")
                    } else {
                        return Promise.resolve(this._bodyText)
                    }
                };
                if (support.formData) {
                    this.formData = function() {
                        return this.text().then(decode)
                    }
                }
                this.json = function() {
                    return this.text().then(JSON.parse)
                };
                return this
            }
            var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

            function normalizeMethod(method) {
                var upcased = method.toUpperCase();
                return methods.indexOf(upcased) > -1 ? upcased : method
            }

            function Request(input, options) {
                options = options || {};
                var body = options.body;
                if (input instanceof Request) {
                    if (input.bodyUsed) {
                        throw new TypeError("Already read")
                    }
                    this.url = input.url;
                    this.credentials = input.credentials;
                    if (!options.headers) {
                        this.headers = new Headers(input.headers)
                    }
                    this.method = input.method;
                    this.mode = input.mode;
                    if (!body && input._bodyInit != null) {
                        body = input._bodyInit;
                        input.bodyUsed = true
                    }
                } else {
                    this.url = String(input)
                }
                this.credentials = options.credentials || this.credentials || "omit";
                if (options.headers || !this.headers) {
                    this.headers = new Headers(options.headers)
                }
                this.method = normalizeMethod(options.method || this.method || "GET");
                this.mode = options.mode || this.mode || null;
                this.referrer = null;
                if ((this.method === "GET" || this.method === "HEAD") && body) {
                    throw new TypeError("Body not allowed for GET or HEAD requests")
                }
                this._initBody(body)
            }
            Request.prototype.clone = function() {
                return new Request(this, {
                    body: this._bodyInit
                })
            };

            function decode(body) {
                var form = new FormData;
                body.trim().split("&").forEach(function(bytes) {
                    if (bytes) {
                        var split = bytes.split("=");
                        var name = split.shift().replace(/\+/g, " ");
                        var value = split.join("=").replace(/\+/g, " ");
                        form.append(decodeURIComponent(name), decodeURIComponent(value))
                    }
                });
                return form
            }

            function parseHeaders(rawHeaders) {
                var headers = new Headers;
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
                preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
                    var parts = line.split(":");
                    var key = parts.shift().trim();
                    if (key) {
                        var value = parts.join(":").trim();
                        headers.append(key, value)
                    }
                });
                return headers
            }
            Body.call(Request.prototype);

            function Response(bodyInit, options) {
                if (!options) {
                    options = {}
                }
                this.type = "default";
                this.status = options.status === undefined ? 200 : options.status;
                this.ok = this.status >= 200 && this.status < 300;
                this.statusText = "statusText" in options ? options.statusText : "OK";
                this.headers = new Headers(options.headers);
                this.url = options.url || "";
                this._initBody(bodyInit)
            }
            Body.call(Response.prototype);
            Response.prototype.clone = function() {
                return new Response(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new Headers(this.headers),
                    url: this.url
                })
            };
            Response.error = function() {
                var response = new Response(null, {
                    status: 0,
                    statusText: ""
                });
                response.type = "error";
                return response
            };
            var redirectStatuses = [301, 302, 303, 307, 308];
            Response.redirect = function(url, status) {
                if (redirectStatuses.indexOf(status) === -1) {
                    throw new RangeError("Invalid status code")
                }
                return new Response(null, {
                    status: status,
                    headers: {
                        location: url
                    }
                })
            };
            self.Headers = Headers;
            self.Request = Request;
            self.Response = Response;
            self.fetch = function(input, init) {
                return new Promise(function(resolve, reject) {
                    var request = new Request(input, init);
                    var xhr = new XMLHttpRequest;
                    xhr.onload = function() {
                        var options = {
                            status: xhr.status,
                            statusText: xhr.statusText,
                            headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                        };
                        options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                        var body = "response" in xhr ? xhr.response : xhr.responseText;
                        resolve(new Response(body, options))
                    };
                    xhr.onerror = function() {
                        reject(new TypeError("Network request failed"))
                    };
                    xhr.ontimeout = function() {
                        reject(new TypeError("Network request failed"))
                    };
                    xhr.open(request.method, request.url, true);
                    if (request.credentials === "include") {
                        xhr.withCredentials = true
                    } else if (request.credentials === "omit") {
                        xhr.withCredentials = false
                    }
                    if ("responseType" in xhr && support.blob) {
                        xhr.responseType = "blob"
                    }
                    request.headers.forEach(function(value, name) {
                        xhr.setRequestHeader(name, value)
                    });
                    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit)
                })
            };
            self.fetch.polyfill = true
        })(typeof self !== "undefined" ? self : this)
    }, {}],
    331: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var Analytics = exports.Analytics = {
            throttleSpeed: 300,
            events: {},
            createEvent: function createEvent(action, category, label) {
                var _this = this;
                var interaction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                var event = new CustomEvent(action, {
                    detail: {
                        event_category: category,
                        event_label: label
                    }
                });
                if (interaction) {
                    event.detail.non_interaction = true
                }
                if (!this.events[action]) {
                    this.events[action] = true;
                    setTimeout(function() {
                        _this.events[action] = false
                    }, this.throttleSpeed);
                    window.dispatchEvent(event);
                    // gtag("event", action, event.detail)
                }
            }
        }
    }, {}],
    332: [function(require, module, exports) {
        "use strict";
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        require("babel-polyfill");
        var _gsap = require("gsap");
        var _analytics = require("./analytics");
        var _timeline = require("./timeline");
        var _globe = require("./globe");
        var _cities = require("./cities");
        var _pages = require("./pages");
        var _nav = require("./nav");
        var _audioController = require("./audioController");
        var _audioController2 = _interopRequireDefault(_audioController);
        var _tooltip = require("./tooltip");
        var _settings = require("./settings");
        require("whatwg-fetch");

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }
        var App = function() {
            function App() {
                var _this = this;
                _classCallCheck(this, App);
                this.isMobile = "ontouchstart" in document.documentElement;
                this.isMobile = /\bCrOS\b/.test(navigator.userAgent) ? false : this.isMobile;
                this.isEmbed = window.location.pathname === "/embed";
                this.globe = new _globe.Globe(this.isMobile);
                _settings.Settings.globe = this.globe;
                this.playIntro = true;
                this.introComplete = false;
                this.date = false;
                this.deepLinkCity = false;
                this.timeline = new _timeline.Timeline(this.isMobile);
                this.tooltip = new _tooltip.Tooltip(document.querySelector("#tooltip"));
                if (this.isMobile) {
                    document.body.classList.add("is-mobile")
                }
                if (this.isEmbed) {
                    document.body.classList.add("is-embed")
                }
                document.addEventListener("touchend", function(e) {
                    if (e.changedTouches.length && document.querySelector("#city-overlay").scrollTop < 70) {
                        _this.globe.setMouse(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                    }
                });
                this.cities = new _cities.Cities({
                    isTouch: this.isMobile,
                    isEmbed: this.isEmbed
                });
                this.buildUI();
                this.pages.on("open-city", function(slug) {
                    _this.deepLinkCity = decodeURIComponent(slug)
                });
                this.pages.on("close-overlay", function() {
                    _this.cities.animateOutOverlay()
                });
                this.timeline.on("date-update", function(dateObj, lastDateObj) {
                    if (_this.date !== dateObj.date) {
                        _this.date = dateObj.date;
                        _this.globe.setDate(dateObj.date);
                        if (!!lastDateObj === true) {
                            _this.cities.setDate(dateObj.date, dateObj.date === lastDateObj.date)
                        } else {
                            _this.cities.setDate(dateObj.date)
                        }
                    }
                });
                if (!this.isMobile && !this.isEmbed) {
                    this.timeline.once("intro-complete", function() {
                        _this.addDragListeners();
                        if (_this.deepLinkCity) {
                            _gsap.TweenLite.delayedCall(1, function() {
                                _this.globe.gotoCity(_this.deepLinkCity)
                            })
                        }
                    })
                } else {
                    this.addDragListeners();
                    if (this.deepLinkCity) {
                        this.globe.gotoCity(this.deepLinkCity)
                    }
                }
                if (window.location.pathname !== "/") {
                    this.playIntro = false
                }
                Promise.all([_audioController2.default.init(this.isMobile || this.isEmbed), this.globe.load(this.playIntro)]).then(function() {
                    _gsap.TweenLite.delayedCall(.5, function() {
                        _this.introComplete = true;
                        _this.pages.introComplete = true;
                        _analytics.Analytics.createEvent("pageload", "Home", "/home", true);
                        _this.cities.on("close-overlay", function() {
                            _this.globe.zoomOut()
                        });
                        _this.cities.on("look-at-city", function(city) {
                            _this.lookAtCity(city)
                        });
                        _this.globe.on("day-loaded", function(data) {
                            _this.cities.setCityData(data)
                        });
                        _this.timeline.getData().then(function() {
                            if (!_this.isMobile && !_this.isEmbed) {
                                _this.globe.setDate(_this.timeline.points[0].date);
                                _gsap.TweenLite.delayedCall(1, function() {
                                    _this.globe.setDate(_this.timeline.points[60].date)
                                });
                                _gsap.TweenLite.delayedCall(2, function() {
                                    _this.globe.setDate(_this.timeline.points[90].date)
                                });
                                _gsap.TweenLite.delayedCall(3, function() {
                                    _this.globe.setDate(_this.timeline.points[100].date)
                                });
                                _gsap.TweenLite.delayedCall(4, function() {
                                    _this.globe.setDate(_this.timeline.points[_this.timeline.points.length - 1].date)
                                });
                                _gsap.TweenLite.delayedCall(.2, function() {
                                    _this.cities.animateIn()
                                })
                            } else {
                                _this.globe.setDate(_this.timeline.points[_this.timeline.points.length - 1].date);
                                _gsap.TweenLite.delayedCall(.2, function() {
                                    _this.cities.animateIn()
                                })
                            }
                        })
                    });
                    if (!_this.playIntro) {
                        _audioController2.default.startBackground()
                    }
                });
                this.globe.on("look-at-city", function(city) {
                    _this.lookAtCity(city);
                    _this.tooltip.clear()
                });
                this.globe.on("zoom-out", function() {
                    _this.cities.closeOverlay()
                });
                this.globe.on("hover-city", function(city) {
                    if (city) {
                        _this.tooltip.setTitle(city.city)
                    } else {
                        _this.tooltip.clear()
                    }
                });
                this.globe.on("hover-off", function() {
                    _this.tooltip.clear()
                });
                document.addEventListener("mousemove", function(event) {
                    _this.tooltip.tick(event.clientX, event.clientY)
                });
                window.onresize = function() {
                    setTimeout(function() {
                        if (_this.globe) {
                            _this.globe.resize()
                        }
                        if (_this.timeline && _this.introComplete && !_this.isEmbed) {
                            _this.timeline.resize()
                        }
                        if (_this.cities && _this.introComplete && !_this.isEmbed) {
                            _this.cities.resize()
                        }
                        if (_this.pages && !_this.isEmbed) {
                            _this.pages.resize()
                        }
                    }, 100)
                };
                window.addEventListener("orientationchange", function() {
                    var event = document.createEvent("HTMLEvents");
                    event.initEvent("resize", true, false);
                    window.dispatchEvent(event);
                    if (window.innerWidth <= 991) {
                        setTimeout(function() {
                            if (_this.pages && !_this.isEmbed) {
                                _this.pages.reorient()
                            }
                            if (_this.cities) {
                                _this.cities.reorient()
                            }
                            if (_this.nav) {
                                _this.nav.reorient()
                            }
                        }, 100)
                    }
                });
                requestAnimationFrame(function(time) {
                    _this.animate(time)
                })
            }
            _createClass(App, [{
                key: "addDragListeners",
                value: function addDragListeners() {
                    var _this2 = this;
                    var upEvent = this.isMobile ? "touchend" : "mouseup";
                    var moveEvent = this.isMobile ? "touchmove" : "mousemove";
                    document.addEventListener(upEvent, function(e) {
                        _this2.timeline.mouseup(e);
                        _this2.globe.mouseup(e)
                    });
                    document.addEventListener(moveEvent, function(e) {
                        if (!_this2.globe.dragState.isDragging) {
                            _this2.timeline.mousemove(e)
                        }
                        _this2.globe.mousemove(e)
                    })
                }
            }, {
                key: "lookAtCity",
                value: function lookAtCity(city) {
                    this.cities.openOverlay(city);
                    this.globe.zoomInOn(city)
                }
            }, {
                key: "animate",
                value: function animate(time) {
                    var _this3 = this;
                    requestAnimationFrame(function(time) {
                        _this3.animate(time)
                    });
                    if (this.timeline && this.introComplete) {
                        this.timeline.tick(time)
                    }
                    if (this.globe) {
                        this.globe.tick(time)
                    }
                }
            }, {
                key: "buildUI",
                value: function buildUI() {
                    if (!this.built) {
                        this.pages = new _pages.Pages;
                        this.nav = new _nav.Nav;
                        this.build = true
                    }
                }
            }]);
            return App
        }();
        new App
    }, {
        "./analytics": 331,
        "./audioController": 333,
        "./cities": 334,
        "./globe": 339,
        "./nav": 345,
        "./pages": 346,
        "./settings": 348,
        "./timeline": 349,
        "./tooltip": 350,
        "babel-polyfill": 1,
        gsap: 327,
        "whatwg-fetch": 330
    }],
    333: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _klang = require("./klang");
        var _klang2 = _interopRequireDefault(_klang);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }
        var klangConfig = "http://klangfiles.s3.amazonaws.com/uploads/projects/tDqjJ/config.js";
        var loadLocally = true;
        var audioController = {
            init: function init(isMobile) {
                var _this = this;
                return new Promise(function(resolve, reject) {
                    if (isMobile) {
                        resolve()
                    } else {
                        _klang2.default.init(loadLocally ? "assets/audio/config.js" : klangConfig, function(success) {
                            if (success) {
                                resolve()
                            } else {
                                reject()
                            }
                        }, function(progress) {
                            _this.trigger("loading", progress)
                        })
                    }
                })
            },
            enableWebAudio: function enableWebAudio() {
                if (_klang2.default.context) {
                    _klang2.default.context.resume()
                }
                _klang2.default.initIOS()
            },
            startBackground: function startBackground() {
                _klang2.default.trigger("background_start")
            },
            stopBackground: function stopBackground() {
                _klang2.default.trigger("background_stop")
            },
            zoomIn: function zoomIn() {
                _klang2.default.trigger("zoom_in")
            },
            zoomOut: function zoomOut() {
                _klang2.default.trigger("zoom_out")
            },
            playOneShot: function playOneShot() {
                _klang2.default.trigger("oneshot_over")
            },
            updateTimelineValue: function updateTimelineValue(value) {
                _klang2.default.trigger("update_timeline_value", Math.max(0, Math.min(1, value)))
            },
            trigger: function trigger() {
                _klang2.default.trigger.apply(_klang2.default, arguments)
            },
            onClick: function onClick() {
                _klang2.default.trigger("tap")
            },
            onOver: function onOver() {
                _klang2.default.trigger("over")
            },
            overlayIn: function overlayIn() {
                _klang2.default.trigger("overlay_in")
            },
            overlayOut: function overlayOut() {
                _klang2.default.trigger("overlay_out")
            },
            isMobile: function isMobile() {
                return _klang2.default.isMobile
            },
            // soundOn: function soundOn() {
            //     _klang2.default.trigger("sound_on")
            // },
            // soundOff: function soundOff() {
            //     _klang2.default.trigger("sound_off")
            // }
        };
        var _assign = Object.assign || function assign(target) {
            var to = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                if (nextSource != null) {
                    for (var nextKey in nextSource) {
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey]
                        }
                    }
                }
            }
            return to
        };
        _assign(audioController, _klang2.default.core.EventEmitter.prototype);
        exports.default = audioController
    }, {
        "./klang": 343
    }],
    334: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Cities = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _events = require("events");
        var _gsap = require("gsap");
        var _dateService = require("./date-service");
        var _analytics = require("./analytics");
        var _audioController = require("./audioController");
        var _audioController2 = _interopRequireDefault(_audioController);
        var _helpers = require("./helpers");
        var _settings = require("./settings");
        var _cityResults = require("./city-results");

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var Cities = exports.Cities = function(_EventEmitter) {
            _inherits(Cities, _EventEmitter);

            function Cities(args) {
                _classCallCheck(this, Cities);
                var _this = _possibleConstructorReturn(this, (Cities.__proto__ || Object.getPrototypeOf(Cities)).call(this));
                _this.isMobile = args.isTouch;
                _this.isEmbed = args.isEmbed;
                _this.todaysDate = _helpers.HELPERS.getTodaysDate();
                _this.currentDate = _this.todaysDate;
                _this.currentMonth;
                _this.cityResults = new _cityResults.CityResults(_this.isMobile);
                _this.$home = document.querySelector("#home");
                _this.$globe = document.querySelector("#globe");
                _this.$nav = document.querySelector("#home-nav");
                _this.$mobileNav = document.querySelector("#mobile-menu-btn");
                _this.$timeline = document.querySelector("#timeline");
                _this.$timelineCanvas = document.querySelector("#timelineCanvas");
                _this.$timelineMobile = document.querySelector("#timeline-mobile");
                _this.$mobileCitiesBtn = document.querySelector("#cities-btn");
                // _this.$fallbackMsg = document.querySelector("#overlay-results-no-results");
                _this.$sliderTitle = document.querySelector("#cities-slider");
                _this.$sliderBar = document.querySelector("#slider");
                _this.$citiesWrapper = document.querySelector("#cities-wrapper");
                _this.$topCities = document.querySelector("#top-cities");
                _this.$nearCities = document.querySelector("#near-cities");
                _this.$slider = document.querySelector("#slider");
                _this.$topList = document.querySelector("#cities-list-top");
                _this.$nearList = document.querySelector("#cities-list-near");
                _this.slider();
                _this.$topCity = [];
                _this.$topCity[0] = document.querySelector("[data-city-1]");
                _this.$topCity[1] = document.querySelector("[data-city-2]");
                _this.$topCity[2] = document.querySelector("[data-city-3]");
                _this.$topCity[3] = document.querySelector("[data-city-4]");
                _this.$topCity[4] = document.querySelector("[data-city-5]");
                _this.$nearCity = [];
                _this.$nearCity[0] = document.querySelector("[data-near-city-1]");
                _this.$nearCity[1] = document.querySelector("[data-near-city-2]");
                _this.$nearCity[2] = document.querySelector("[data-near-city-3]");
                _this.$nearCity[3] = document.querySelector("[data-near-city-4]");
                _this.$nearCity[4] = document.querySelector("[data-near-city-5]");
                _this.nearCities;
                _this.$nearLoader = document.querySelector("#near-cities-loader");
                _this.userLocation;
                _this.$cityOverlay = document.querySelector("#city-overlay");
                _this.$cityBackground = document.querySelector("#city-overlay-background");
                _this.$cityOverlayClose = document.querySelector("#city-overlay-close");
                _this.$cityName = document.querySelector("#city-name");
                _this.$overlayCity = document.querySelector("#overlay-city");
                _this.$searchResultsDate = Array.from(document.querySelectorAll(".search-results-date"));
                _this.$overlayCountry = document.querySelector("#overlay-country");
                _this.$citySearchTitle = document.querySelector("#overlay-results-title");
                _this.$overlayResults = document.getElementById("overlay-results");
                _this.$buttonAll = document.querySelector("[data-button-all]");
                _this.$buttonFollow = document.querySelector("[data-button-follow]");
                _this.$buttonFollowCity = document.querySelector("[data-button-follow-city]");
                _this.$prevArrow = document.querySelector("#arrow-prev");
                _this.$nextArrow = document.querySelector("#arrow-next");
                _this.$cityLegal = document.querySelector("[data-city-legal]");
                _this.$cityFooter = document.querySelector(".overlay-footerlinks");
                _this.cityOverlayData;
                _this.activeCityIndex;
                _this.staggeredData = null;
                _this.$mobileCloseBtn = document.querySelector("#cities-close-btn");
                _this.mobileInit = false;
                _this.resize();
                _this.cityOverlay();
                _this.overlayChange();
                _this.mobilePage();
                _this.cityOverlayOpen = false;
                _this.currentDate;
                _this.currentAnimation;
                return _this
            }
            _createClass(Cities, [{
                key: "setDate",
                value: function setDate(date, forceToday) {
                    if (!!forceToday === true) {
                        this.currentDate = this.todaysDate
                    } else {
                        this.currentDate = date
                    }
                    if (this.cityOverlayOpen) {
                        // this.setOverlayData(this.cityOverlayOpen)
                    }
                }
            }, {
                key: "setCityData",
                value: function setCityData(data) {
                    var _this2 = this;
                    this.cityOverlayData = data;
                    if (this.currentDate) {
                        this.staggeredData = _dateService.DateService.getStaggeredDistanceDate(this.currentDate, this.cityOverlayData);
                        if (this.cityOverlayOpen) {
                            this.activeCityIndex = this.staggeredData.findIndex(function(item) {
                                return item.city === _this2.cityOverlayOpen.city && item.country === _this2.cityOverlayOpen.country && item.region === _this2.cityOverlayOpen.region
                            })
                        }
                    }
                    this.topCities = this.cityOverlayData.slice();
                    this.topCities.sort(function(a, b) {
                        return parseFloat(a.value) - parseFloat(b.value)
                    });
                    this.topCities.reverse();
                    var length = this.topCities.length <= 5 ? this.topCities.length : 5;
                    for (var i = 0; i < length; i++) {
                        var key = this.topCities[i].city + this.topCities[i].region + this.topCities[i].country;
                        this.$topCity[i].getElementsByTagName("span")[0].innerHTML = this.topCities[i].city;
                        this.$topCity[i].setAttribute("data-city", key)
                    }
                    if (this.nearCities && this.userLocation) {
                        var newNearCities = _dateService.DateService.getNearestCities({
                            lat: this.userLocation.lat,
                            lng: this.userLocation.lng
                        }, this.currentDate);
                        this.nearCities = newNearCities ? newNearCities : this.nearCities;
                        if (this.nearCities) {
                            for (var _i = 0; _i < this.nearCities.length; _i++) {
                                var _key = this.nearCities[_i].city + this.nearCities[_i].region + this.nearCities[_i].country;
                                this.$nearCity[_i].getElementsByTagName("span")[0].innerHTML = this.nearCities[_i].city;
                                this.$nearCity[_i].setAttribute("data-city", _key)
                            }
                        }
                    }
                }
            }, {
                key: "animateIn",
                value: function animateIn() {
                    var _this3 = this;
                    _gsap.TweenLite.to(this.$home, 0, {
                        opacity: 1,
                        ease: _gsap.Linear.easeNone,
                        delay: 0
                    });
                    this.animationInterrupt("home");
                    _gsap.TweenLite.to(this.$nav, .25, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.easeNone,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$mobileNav, .25, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.easeNone,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$timeline, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Linear.easeNone,
                        delay: this.mobileInit ? 0 : 3.5
                    });
                    _gsap.TweenLite.to(this.$timelineCanvas, 0, {
                        scale: 1,
                        ease: _gsap.Linear.easeNone,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$timelineCanvas, .25, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.easeNone,
                        delay: .25
                    });
                    _gsap.TweenLite.to(this.$timelineMobile, .25, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.easeNone,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$mobileCitiesBtn, .25, {
                        opacity: 1,
                        ease: _gsap.Linear.easeNone,
                        delay: 0
                    });
                    this.$mobileCitiesBtn.style.pointerEvents = "auto";
                    this.$timeline.classList.remove("no-pointers");
                    _gsap.TweenLite.to(this.$sliderTitle, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: 5.4
                    });
                    _gsap.TweenLite.to(this.$sliderBar, .2, {
                        opacity: 1,
                        ease: _gsap.Quint.EaseOut,
                        delay: 5.4
                    });
                    var delay = 5.6;
                    this.$topCity.forEach(function($city) {
                        _gsap.TweenLite.to($city, .4, {
                            opacity: 1,
                            y: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: delay
                        });
                        delay += .2
                    });
                    _gsap.TweenMax.delayedCall(2.15, function() {
                        _this3.$prevArrow.classList.remove("inactive");
                        _this3.$nextArrow.classList.remove("inactive");
                        _this3.currentAnimation = null
                    })
                }
            }, {
                key: "getNearestCities",
                value: function getNearestCities() {
                    var _this4 = this;
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(function(position) {
                            _this4.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            _this4.nearCities = _dateService.DateService.getNearestCities({
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            }, _this4.currentDate);
                            if (_this4.nearCities) {
                                for (var i = 0; i < _this4.nearCities.length; i++) {
                                    var key = _this4.nearCities[i].city + _this4.nearCities[i].region + _this4.nearCities[i].country;
                                    _this4.$nearCity[i].getElementsByTagName("span")[0].innerHTML = _this4.nearCities[i].city;
                                    _this4.$nearCity[i].setAttribute("data-city", key)
                                }
                            }
                            _analytics.Analytics.createEvent("interaction", "Location Permission", "Nearby location permission");
                            _this4.$nearLoader.classList.remove("active");
                            _this4.$nearList.style.height = "auto"
                        }, function() {}, {
                            maximumAge: 864e5
                        })
                    } else {
                        this.$nearLoader.classList.remove("active")
                    }
                }
            }, {
                key: "slider",
                value: function slider() {
                    var _this5 = this;
                    this.$topCities.addEventListener("click", function() {
                        _this5.$topCities.classList.add("active");
                        _this5.$nearCities.classList.remove("active");
                        _this5.$slider.classList.remove("right");
                        _this5.$topList.classList.add("active");
                        _this5.$nearList.classList.remove("active");
                        _this5.$nearLoader.classList.remove("active")
                    });
                    this.$nearCities.addEventListener("click", function() {
                        if (!_this5.nearCities) {
                            _this5.$nearList.style.height = _this5.$topList.offsetHeight + 12 + "px";
                            _this5.$nearLoader.classList.add("active");
                            _this5.getNearestCities()
                        }
                        _this5.$nearCities.classList.add("active");
                        _this5.$topCities.classList.remove("active");
                        _this5.$slider.classList.add("right");
                        _this5.$nearList.classList.add("active");
                        _this5.$topList.classList.remove("active");
                        _analytics.Analytics.createEvent("click", "Nearby Cities", "clickable_link, home, nearby")
                    })
                }
            }, {
                key: "animationInterrupt",
                value: function animationInterrupt(newAnimationName) {
                    if (this.currentAnimation) {
                        _gsap.TweenMax.killAll();
                        if (this.currentAnimation === "home") {
                            this.animateOutHome();
                            this.animateOutHomeMobile()
                        } else if (this.currentAnimation === "overlay") {
                            if (newAnimationName === "overlay-close") {
                                this.animateOutOverlayCities();
                                this.animateOutCityOverlayExtras()
                            }
                        }
                    }
                    this.currentAnimation = newAnimationName
                }
            }, {
                key: "animateOutHome",
                value: function animateOutHome() {
                    var delay = 0;
                    _gsap.TweenLite.to(this.$mobileCloseBtn, .25, {
                        opacity: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    this.$mobileCloseBtn.classList.add("inactive");
                    this.$topCity.forEach(function($city) {
                        _gsap.TweenLite.to($city, .25, {
                            opacity: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: delay
                        });
                        delay += .1
                    });
                    this.$nearCity.forEach(function($city) {
                        _gsap.TweenLite.to($city, .25, {
                            opacity: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: delay
                        });
                        delay += .1
                    });
                    _gsap.TweenLite.to(this.$sliderTitle, .25, {
                        opacity: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .5
                    });
                    _gsap.TweenLite.to(this.$sliderBar, .25, {
                        opacity: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .5
                    });
                    _gsap.TweenLite.to(this.$nav, .25, {
                        opacity: 0,
                        pointerEvents: "none",
                        ease: _gsap.Linear.easeNone,
                        delay: .6
                    })
                }
            }, {
                key: "animateOutHomeMobile",
                value: function animateOutHomeMobile() {
                    if (this.mobileInit) {
                        this.$mobileCitiesBtn.style.pointerEvents = "none";
                        _gsap.TweenLite.to(this.$mobileCitiesBtn, .25, {
                            opacity: 0,
                            y: 10,
                            ease: _gsap.Linear.easeNone,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$mobileCloseBtn, .25, {
                            opacity: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: 0
                        });
                        this.$mobileCloseBtn.classList.add("inactive");
                        var delay = .1;
                        this.$topCity.forEach(function($city) {
                            _gsap.TweenLite.to($city, .25, {
                                opacity: 0,
                                y: 10,
                                ease: _gsap.Quint.EaseOut,
                                delay: delay
                            });
                            delay += .1
                        });
                        this.$nearCity.forEach(function($city) {
                            _gsap.TweenLite.to($city, .25, {
                                opacity: 0,
                                y: 10,
                                ease: _gsap.Quint.EaseOut,
                                delay: delay
                            });
                            delay += .1
                        });
                        this.$globe.classList.remove("blur")
                    }
                }
            }, {
                key: "animateOutOverlayCities",
                value: function animateOutOverlayCities() {
                    _gsap.TweenLite.to(this.$cityLegal, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$cityFooter, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$buttonAll, .25, {
                        scale: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$buttonFollow, .25, {
                        scale: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    var topDelay = this.todaysDate === this.currentDate ? .4 : .1;
                    var articles = Array.from(document.querySelectorAll(".overlay-result"));
                    articles.reverse();
                    if (articles.length > 0) {
                        _gsap.TweenMax.staggerTo(articles, .25, {
                            opacity: 0,
                            y: -10,
                            ease: _gsap.Quint.EaseOut
                        }, .1)
                    }
                    _gsap.TweenLite.to(this.$citySearchTitle, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: topDelay
                    });
                    _gsap.TweenLite.to(this.$cityName, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: topDelay + .1
                    });
                    _gsap.TweenLite.to(document.querySelector("#overlay-results-no-results"), .25, {
                        opacity: 0,
                        ease: _gsap.Quint.easeOut,
                        delay: topDelay + .1
                    })
                }
            }, {
                key: "animateOutCityOverlayExtras",
                value: function animateOutCityOverlayExtras() {
                    _gsap.TweenLite.to(this.$cityOverlayClose, .25, {
                        opacity: 0,
                        y: 0,
                        ease: _gsap.Linear.noEase,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$prevArrow, .25, {
                        opacity: 0,
                        ease: _gsap.Linear.noEase,
                        delay: .1
                    });
                    _gsap.TweenLite.to(this.$nextArrow, .25, {
                        opacity: 0,
                        ease: _gsap.Linear.noEase,
                        delay: .1
                    })
                }
            }, {
                key: "animateInOverlayCities",
                value: function animateInOverlayCities() {
                    _gsap.TweenLite.to(this.$cityName, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    var bottomDelay = this.todaysDate === this.currentDate ? 1 : 0;
                    _gsap.TweenLite.to(this.$buttonAll, .4, {
                        scale: 1,
                        ease: _gsap.Quint.EaseOut,
                        delay: bottomDelay
                    });
                    _gsap.TweenLite.to(this.$buttonFollow, .4, {
                        scale: 1,
                        ease: _gsap.Quint.EaseOut,
                        delay: bottomDelay
                    });
                    _gsap.TweenLite.to(this.$cityFooter, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: bottomDelay + .1
                    })
                }
            }, {
                key: "overlayArrowEvent",
                value: function overlayArrowEvent() {
                    this.animationInterrupt("arrows");
                    this.currentMonth = null;
                    var newCityOverlay = this.staggeredData[this.activeCityIndex];
                    if (newCityOverlay) {
                        this.setOverlayData(this.staggeredData[this.activeCityIndex]);
                        this.emit("look-at-city", this.staggeredData[this.activeCityIndex])
                    }
                    this.currentAnimation = null
                }
            }, {
                key: "overlayChange",
                value: function overlayChange() {
                    var _this6 = this;
                    this.$prevArrow.addEventListener("click", function() {
                        if (_this6.staggeredData) {
                            _this6.activeCityIndex = _this6.activeCityIndex === 0 ? _this6.staggeredData.length - 1 : _this6.activeCityIndex - 1;
                            _this6.overlayArrowEvent()
                        }
                    });
                    this.$nextArrow.addEventListener("click", function() {
                        if (_this6.staggeredData) {
                            _this6.activeCityIndex = _this6.activeCityIndex >= _this6.staggeredData.length - 1 ? 0 : _this6.activeCityIndex + 1;
                            _this6.overlayArrowEvent()
                        }
                    });
                    this.$cityOverlay.addEventListener("touchmove", function(e) {
                        e.stopPropagation()
                    })
                }
            }, {
                key: "setOverlayData",
                // value: function setOverlayData(data) {
                //     this.$cityLegal.querySelector("span.location").innerText = data.city + ", " + data.country;
                //     this.$overlayCity.innerText = data.city + ",";
                //     this.$overlayCountry.innerText = data.country;
                //     var searchText = data.city + ", " + data.country + " ";
                //     searchText = encodeURI(searchText.replace(/\s/g, "+"));
                //     searchText += "UNESCO";
                //     this.$buttonFollow.setAttribute("href", "https://www.google.com/alerts?q=" + searchText);
                //     var searchUrl = "https://www.google.com/search?q=" + searchText;
                //     if (this.todaysDate === this.currentDate) {
                //         this.$overlayResults.classList.remove("hide-articles");
                //         this.$cityOverlay.classList.remove("not-today");
                //         this.$buttonAll.setAttribute("href", searchUrl)
                //     } else {
                //         var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                //         var newDateArr = this.currentDate.split("-");
                //         var newDate = new Date(newDateArr[0], newDateArr[1] - 1, 1);
                //         var endOfMonth = new Date(newDateArr[0], newDateArr[1], 1);
                //         endOfMonth.setMonth(newDate.getMonth() + 1);
                //         endOfMonth.setDate(newDate.getDate() - 1);
                //         endOfMonth.setYear(newDate.getFullYear());
                //         var endMonthStr = endOfMonth.getMonth() + 1 + "%2F" + endOfMonth.getDate() + "%2F" + endOfMonth.getFullYear();
                //         var newDateStr = newDate.getMonth() + 1 + "%2F" + newDate.getDate() + "%2F" + newDate.getFullYear();
                //         searchUrl += "&source=lnt&tbs=cdr%3A1%2Ccd_min%3A" + newDateStr + "%2Ccd_max%3A" + endMonthStr + "&tbm=";
                //         this.$buttonAll.querySelector(".all-text-date").innerText = " from " + months[newDate.getMonth()];
                //         this.$cityOverlay.classList.add("not-today");
                //         this.$buttonAll.setAttribute("href", searchUrl)
                //     }
                //     this.$buttonFollowCity.innerText = data.city;
                //     this.getCityData(data)
                // }
            }, {
                key: "cityOverlay",
                value: function cityOverlay() {
                    var _this7 = this;
                    this.$topList.addEventListener("click", function($e) {
                        var $li = $e.target.parentElement;
                        var key = $li.getAttribute("data-city");
                        if (key) {
                            var city = _this7.cityOverlayData.find(function(item) {
                                return item.key === key
                            });
                            _this7.emit("look-at-city", city);
                            _analytics.Analytics.createEvent("click", "Top Cities - " + city.key.replace(" ", ""), "clickable_link, home, top_cities_" + city.key.replace(" ", ""));
                            _audioController2.default.overlayOut()
                        }
                    });
                    this.$nearList.addEventListener("click", function($e) {
                        var $li = $e.target.parentElement;
                        var key = $li.getAttribute("data-city");
                        var city = _this7.cityOverlayData.find(function(item) {
                            return item.key === key
                        });
                        _this7.emit("look-at-city", city);
                        _analytics.Analytics.createEvent("click", "Cities near you - " + city.key.replace(" ", ""), "clickable_link, home, top_cities_" + city.key.replace(" ", ""));
                        _audioController2.default.overlayOut()
                    });
                    this.$cityOverlayClose.addEventListener("click", function() {
                        _this7.closeOverlay()
                    })
                }
            }, {
                key: "openOverlayCheck",
                value: function openOverlayCheck($e) {
                    this.animateOutHomeMobile();
                    this.openOverlay($e)
                }
            }, {
                key: "getCityData",
                value: function getCityData(city) {
                    var _this8 = this;
                    clearTimeout(this.getCityDataDebouncer);
                    this.getCityDataDebouncer = setTimeout(function() {
                        _this8.cityResults.loadCity(city, _this8.currentDate)
                    }, 200)
                }
            }, {
                key: "openOverlay",
                value: function openOverlay(city) {
                    var _this9 = this;
                    if (!city) return;
                    _gsap.TweenLite.to(this.$mobileNav, 0, {
                        pointerEvents: "none",
                        ease: _gsap.Linear.easeNone,
                        delay: 0
                    });
                    this.$cityOverlay.scrollTop = 0;
                    document.body.classList.add("in-city");
                    this.animationInterrupt("overlay");
                    this.$globe.classList.remove("blur");
                    _analytics.Analytics.createEvent("pageload", city.key.replace(" "), "/submit_success", true);
                    this.activeCityIndex = this.staggeredData.findIndex(function(item) {
                        return item.city === city.city && item.country === city.country && item.region === city.region
                    });
                    // this.setOverlayData(city);
                    this.$cityOverlay.classList.add("active");
                    this.$citiesWrapper.classList.add("inactive");
                    this.$mobileCloseBtn.classList.add("inactive");
                    this.animateOutHomeMobile();
                    this.animateOutHome();
                    if (!this.cityOverlayOpen) {
                        _gsap.TweenMax.delayedCall(.85, function() {
                            _gsap.TweenLite.to(_this9.$cityOverlayClose, .25, {
                                opacity: 1,
                                ease: _gsap.Linear.noEase,
                                delay: 0
                            });
                            _this9.animateInOverlayCities();
                            _gsap.TweenLite.to(_this9.$cityBackground, 2, {
                                opacity: 1,
                                ease: _gsap.Linear.easeIn,
                                delay: 0
                            });
                            _gsap.TweenLite.to(_this9.$prevArrow, .25, {
                                opacity: 1,
                                ease: _gsap.Linear.noEase,
                                delay: 1.5
                            });
                            _gsap.TweenLite.to(_this9.$nextArrow, .25, {
                                opacity: 1,
                                ease: _gsap.Linear.noEase,
                                delay: 1.5
                            })
                        });
                        if (this.mobileInit) {
                            _gsap.TweenLite.to(this.$timeline, .25, {
                                opacity: 0,
                                pointerEvents: "none",
                                ease: _gsap.Linear.easeNone,
                                delay: .9
                            });
                            this.$timeline.classList.add("no-pointers");
                            _gsap.TweenLite.to(this.$timelineMobile, .25, {
                                opacity: 1,
                                pointerEvents: "auto",
                                ease: _gsap.Linear.easeNone,
                                delay: 1.1
                            })
                        }
                        _gsap.TweenMax.delayedCall(2.6, function() {
                            _this9.currentAnimation = null
                        })
                    }
                    this.cityOverlayOpen = city
                }
            }, {
                key: "animateOutOverlay",
                value: function animateOutOverlay() {
                    var _this10 = this;
                    this.cityOverlayOpen = false;
                    this.cityResults.isLookingAtCity = false;
                    this.currentMonth = null;
                    this.$cityOverlay.style.pointerEvents = "none";
                    document.querySelector(".city-overlay-wrapper").style.pointerEvents = "none";
                    document.body.classList.remove("in-city");
                    this.activeCityIndex = null;
                    _gsap.TweenLite.to(this.$cityOverlayClose, .25, {
                        opacity: 0,
                        y: 0,
                        ease: _gsap.Linear.noEase,
                        delay: 0
                    });
                    _gsap.TweenLite.to(this.$cityBackground, 1, {
                        opacity: 0,
                        ease: _gsap.Linear.noEase,
                        delay: 0
                    });
                    _gsap.TweenMax.delayedCall(.1, function() {
                        _this10.animateOutOverlayCities();
                        _gsap.TweenLite.to(_this10.$prevArrow, .25, {
                            opacity: 0,
                            ease: _gsap.Linear.noEase,
                            delay: 0
                        });
                        _gsap.TweenLite.to(_this10.$nextArrow, .25, {
                            opacity: 0,
                            ease: _gsap.Linear.noEase,
                            delay: 0
                        })
                    })
                }
            }, {
                key: "closeOverlay",
                value: function closeOverlay() {
                    var _this11 = this;
                    this.animateOutOverlay();
                    window.history.pushState({}, "Title?", "/");
                    _gsap.TweenMax.delayedCall(1, function() {
                        _this11.$cityOverlay.classList.remove("active");
                        if (!_this11.mobileInit) {
                            _this11.$citiesWrapper.classList.remove("inactive")
                        }
                    });
                    _gsap.TweenLite.to(this.$nav, .25, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.easeNone,
                        delay: .8
                    });
                    _gsap.TweenLite.to(this.$mobileNav, .25, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.easeNone,
                        delay: .8
                    });
                    if (this.mobileInit) {
                        _gsap.TweenLite.to(this.$timeline, .25, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: .9
                        });
                        _gsap.TweenLite.to(this.$mobileCitiesBtn, .25, {
                            opacity: 1,
                            y: 0,
                            ease: _gsap.Linear.easeNone,
                            delay: 1
                        });
                        this.$mobileCitiesBtn.style.pointerEvents = "auto";
                        this.$mobileCloseBtn.classList.remove("inactive");
                        this.$timeline.classList.remove("no-pointers");
                        if (!this.isEmbed) {
                            _gsap.TweenLite.to(this.$timelineMobile, .25, {
                                opacity: 1,
                                pointerEvents: "auto",
                                ease: _gsap.Linear.easeNone,
                                delay: 1.1
                            })
                        }
                    } else {
                        if (this.isEmbed) {
                            _gsap.TweenLite.to(this.$timeline, .25, {
                                opacity: 1,
                                pointerEvents: "auto",
                                ease: _gsap.Linear.easeNone,
                                delay: .9
                            });
                            this.$timeline.classList.remove("no-pointers")
                        }
                        _gsap.TweenLite.to(this.$sliderTitle, .25, {
                            opacity: 1,
                            ease: _gsap.Quint.EaseOut,
                            delay: .9
                        });
                        _gsap.TweenLite.to(this.$sliderBar, .25, {
                            opacity: 1,
                            ease: _gsap.Quint.EaseOut,
                            delay: .9
                        });
                        var delay = 1;
                        this.$topCity.forEach(function($city) {
                            _gsap.TweenLite.to($city, .25, {
                                opacity: 1,
                                y: 0,
                                ease: _gsap.Quint.EaseOut,
                                delay: delay
                            });
                            delay += .1
                        });
                        this.$nearCity.forEach(function($city) {
                            _gsap.TweenLite.to($city, .25, {
                                opacity: 1,
                                y: 0,
                                ease: _gsap.Quint.EaseOut,
                                delay: delay
                            });
                            delay += .1
                        })
                    }
                    _gsap.TweenMax.delayedCall(this.mobileInit ? 1.8 : 1.4, function() {
                        _this11.currentAnimation = null
                    });
                    if (this.isEmbed) {
                        this.$globe.classList.remove("blur")
                    }
                    this.emit("close-overlay")
                }
            }, {
                key: "mobilePage",
                value: function mobilePage() {
                    var _this12 = this;
                    // this.$mobileCitiesBtn.addEventListener("click", function() {
                    //     _this12.animationInterrupt("mobile-overlay");
                    //     _settings.Settings.globe.interactionEnabled = false;
                    //     if (!_this12.mobileInit) {
                    //         _this12.$topCity.forEach(function($city) {
                    //             _gsap.TweenLite.to($city, 0, {
                    //                 opacity: 0,
                    //                 y: 10
                    //             })
                    //         });
                    //         _this12.$nearCity.forEach(function($city) {
                    //             _gsap.TweenLite.to($city, 0, {
                    //                 opacity: 0,
                    //                 y: 10
                    //             })
                    //         });
                    //         _gsap.TweenLite.to(_this12.$citiesWrapper, 0, {
                    //             opacity: 0,
                    //             y: "-50%",
                    //             x: "-50%",
                    //             ease: _gsap.Quint.EaseOut,
                    //             delay: 0
                    //         });
                    //         _this12.mobileInit = true
                    //     }
                    //     _this12.$citiesWrapper.classList.add("active");
                    //     _this12.$citiesWrapper.classList.remove("inactive");
                    //     _this12.$mobileCloseBtn.classList.add("active");
                    //     _this12.$mobileCloseBtn.classList.remove("inactive");
                    //     _this12.$globe.classList.add("blur");
                    //     _gsap.TweenLite.to(_this12.$mobileCitiesBtn, .25, {
                    //         opacity: 0,
                    //         y: 10,
                    //         ease: _gsap.Linear.easeNone,
                    //         delay: 0
                    //     });
                    //     _gsap.TweenLite.to(_this12.$timeline, .25, {
                    //         opacity: 0,
                    //         pointerEvents: "none",
                    //         ease: _gsap.Linear.easeNone,
                    //         delay: .1
                    //     });
                    //     _gsap.TweenLite.to(_this12.$timelineMobile, .25, {
                    //         opacity: 0,
                    //         pointerEvents: "none",
                    //         ease: _gsap.Linear.easeNone,
                    //         delay: .1
                    //     });
                    //     _gsap.TweenLite.to(_this12.$nav, .25, {
                    //         opacity: 0,
                    //         pointerEvents: "none",
                    //         ease: _gsap.Linear.easeNone,
                    //         delay: .2
                    //     });
                    //     _gsap.TweenLite.to(_this12.$mobileNav, 0, {
                    //         pointerEvents: "none",
                    //         ease: _gsap.Linear.easeNone,
                    //         delay: 0
                    //     });
                    //     _gsap.TweenLite.to(_this12.$mobileNav, .25, {
                    //         opacity: 0,
                    //         ease: _gsap.Linear.easeNone,
                    //         delay: .2
                    //     });
                    //     _this12.$timeline.classList.add("no-pointers");
                    //     _gsap.TweenLite.to(_this12.$citiesWrapper, 0, {
                    //         y: "-50%",
                    //         x: "-50%",
                    //         ease: _gsap.Quint.EaseOut,
                    //         delay: 0
                    //     });
                    //     _gsap.TweenLite.to(_this12.$citiesWrapper, .4, {
                    //         opacity: 1,
                    //         ease: _gsap.Quint.EaseOut,
                    //         delay: .4
                    //     });
                    //     _gsap.TweenLite.to(_this12.$mobileCloseBtn, .25, {
                    //         opacity: 1,
                    //         ease: _gsap.Quint.EaseOut,
                    //         delay: .5
                    //     });
                    //     _gsap.TweenLite.to(_this12.$sliderTitle, 0, {
                    //         opacity: 1,
                    //         y: 0,
                    //         ease: _gsap.Quint.EaseOut,
                    //         delay: .6
                    //     });
                    //     _gsap.TweenLite.to(_this12.$sliderBar, 0, {
                    //         opacity: 1,
                    //         y: 0,
                    //         ease: _gsap.Quint.EaseOut,
                    //         delay: .6
                    //     });
                    //     var delay = .8;
                    //     _this12.$topCity.forEach(function($city) {
                    //         _gsap.TweenLite.to($city, .4, {
                    //             opacity: 1,
                    //             y: 0,
                    //             ease: _gsap.Quint.EaseOut,
                    //             delay: delay
                    //         });
                    //         delay += .2
                    //     });
                    //     delay = .8;
                    //     _this12.$nearCity.forEach(function($city) {
                    //         _gsap.TweenLite.to($city, .4, {
                    //             opacity: 1,
                    //             y: 0,
                    //             ease: _gsap.Quint.EaseOut,
                    //             delay: delay
                    //         });
                    //         delay += .2
                    //     });
                    //     _gsap.TweenMax.delayedCall(2.1, function() {
                    //         _this12.currentAnimation = null
                    //     })
                    // });
                    this.$mobileCloseBtn.addEventListener("click", function() {
                        _this12.animationInterrupt("mobile-overlay-close");
                        _settings.Settings.globe.interactionEnabled = true;
                        _gsap.TweenLite.to(_this12.$mobileCloseBtn, .25, {
                            opacity: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: 0
                        });
                        var delay = .1;
                        _this12.$topCity.forEach(function($city) {
                            _gsap.TweenLite.to($city, .25, {
                                opacity: 0,
                                y: 10,
                                ease: _gsap.Quint.EaseOut,
                                delay: delay
                            });
                            delay += .1
                        });
                        delay = .1;
                        _this12.$nearCity.forEach(function($city) {
                            _gsap.TweenLite.to($city, .25, {
                                opacity: 0,
                                y: 10,
                                ease: _gsap.Quint.EaseOut,
                                delay: delay
                            });
                            delay += .1
                        });
                        _gsap.TweenLite.to(_this12.$citiesWrapper, .25, {
                            opacity: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: .6
                        });
                        _this12.$globe.classList.remove("blur");
                        _gsap.TweenLite.to(_this12.$mobileNav, .25, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: .9
                        });
                        _gsap.TweenLite.to(_this12.$nav, .25, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: 1
                        });
                        _gsap.TweenLite.to(_this12.$timeline, .25, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: 1.1
                        });
                        _gsap.TweenLite.to(_this12.$timelineMobile, .25, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: 1.1
                        });
                        _gsap.TweenLite.to(_this12.$mobileCitiesBtn, .25, {
                            opacity: 1,
                            y: 0,
                            ease: _gsap.Linear.easeNone,
                            delay: 1.2
                        });
                        _this12.$mobileCitiesBtn.style.pointerEvents = "auto";
                        _this12.$timeline.classList.remove("no-pointers");
                        _audioController2.default.overlayOut();
                        _gsap.TweenMax.delayedCall(1.5, function() {
                            _this12.$mobileCloseBtn.classList.remove("active");
                            _this12.$citiesWrapper.classList.remove("active");
                            _this12.currentAnimation = null
                        })
                    })
                }
            }, {
                key: "reorient",
                value: function reorient() {
                    var _this13 = this;
                    _gsap.TweenLite.set([this.$cityLegal], {
                        display: "none"
                    });
                    setTimeout(function() {
                        _gsap.TweenLite.set([_this13.$cityLegal], {
                            display: "block"
                        })
                    }, 100)
                }
            }, {
                key: "resize",
                value: function resize() {
                    if (this.mobileInit && window.innerWidth > 991) {
                        this.mobileInit = false;
                        _gsap.TweenLite.to(this.$mobileCloseBtn, 0, {
                            opacity: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$sliderTitle, 0, {
                            opacity: 1,
                            ease: _gsap.Quint.EaseOut,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$sliderBar, 0, {
                            opacity: 1,
                            ease: _gsap.Quint.EaseOut,
                            delay: 0
                        });
                        this.$topCity.forEach(function($city) {
                            _gsap.TweenLite.to($city, 0, {
                                opacity: 1,
                                y: 0
                            })
                        });
                        _gsap.TweenLite.to(this.$citiesWrapper, 0, {
                            opacity: 1,
                            y: "-50%",
                            x: "0%",
                            ease: _gsap.Quint.EaseOut,
                            delay: 0
                        });
                        this.$globe.classList.remove("blur");
                        _gsap.TweenLite.to(this.$mobileNav, 0, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$nav, 0, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$timeline, 0, {
                            opacity: 1,
                            pointerEvents: "auto",
                            ease: _gsap.Linear.easeNone,
                            delay: 0
                        });
                        this.$timeline.classList.remove("no-pointers");
                        if (this.isEmbed || this.isMobile) {
                            _gsap.TweenLite.to(this.$timelineMobile, 0, {
                                opacity: 1,
                                pointerEvents: "auto",
                                ease: _gsap.Linear.easeNone,
                                delay: 0
                            })
                        }
                        _gsap.TweenLite.to(this.$mobileCitiesBtn, 0, {
                            opacity: 1,
                            y: 0,
                            ease: _gsap.Linear.easeNone,
                            delay: 0
                        });
                        this.$citiesWrapper.classList.remove("active");
                        this.$mobileCloseBtn.classList.remove("active");
                        if (this.activeCityIndex || this.activeCityIndex === 0) {
                            this.$topCity.forEach(function($city) {
                                _gsap.TweenLite.to($city, 0, {
                                    opacity: 0,
                                    y: 10
                                })
                            });
                            _gsap.TweenLite.to(this.$sliderTitle, 0, {
                                opacity: 0,
                                y: 10,
                                ease: _gsap.Quint.EaseOut,
                                delay: 0
                            });
                            _gsap.TweenLite.to(this.$sliderBar, 0, {
                                opacity: 0,
                                y: 10,
                                ease: _gsap.Quint.EaseOut,
                                delay: 0
                            });
                            _gsap.TweenLite.to(this.$nav, 0, {
                                opacity: 0,
                                pointerEvents: "none",
                                ease: _gsap.Linear.easeNone,
                                delay: 0
                            })
                        }
                    } else if (!this.mobileInit && window.innerWidth <= 991) {
                        if (this.activeCityIndex || this.activeCityIndex === 0) {
                            _gsap.TweenLite.to(this.$mobileNav, 0, {
                                opacity: 0,
                                pointerEvents: "none",
                                ease: _gsap.Linear.easeNone,
                                delay: 0
                            });
                            _gsap.TweenLite.to(this.$timeline, 0, {
                                opacity: 0,
                                pointerEvents: "none",
                                ease: _gsap.Linear.easeNone,
                                delay: 0
                            });
                            _gsap.TweenLite.to(this.$timelineMobile, 0, {
                                opacity: 0,
                                pointerEvents: "none",
                                ease: _gsap.Linear.easeNone,
                                delay: 0
                            });
                            _gsap.TweenLite.to(this.$mobileCitiesBtn, 0, {
                                opacity: 0,
                                y: 0,
                                ease: _gsap.Linear.easeNone,
                                delay: 0
                            });
                            this.$timeline.classList.add("no-pointers")
                        } else {
                            _gsap.TweenLite.to(this.$timeline, 0, {
                                y: 0,
                                ease: _gsap.Linear.easeNone
                            });
                            this.$mobileCitiesBtn.style.pointerEvents = "auto"
                        }
                        this.mobileInit = true
                    }
                }
            }]);
            return Cities
        }(_events.EventEmitter)
    }, {
        "./analytics": 331,
        "./audioController": 333,
        "./city-results": 335,
        "./date-service": 337,
        "./helpers": 341,
        "./settings": 348,
        events: 326,
        gsap: 327
    }],
    335: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.CityResults = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _events = require("events");
        var _gsap = require("gsap");
        var _helpers = require("./helpers");
        var _cityService = require("./city-service");

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var CityResults = exports.CityResults = function(_EventEmitter) {
            _inherits(CityResults, _EventEmitter);

            function CityResults(isMobile) {
                _classCallCheck(this, CityResults);
                var _this = _possibleConstructorReturn(this, (CityResults.__proto__ || Object.getPrototypeOf(CityResults)).call(this));
                _this.isMobile = isMobile;
                _this.months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                _this.$citySearchTitle = document.querySelector("#overlay-results-title");
                // _this.$fallbackMsg = document.querySelector("#overlay-results-no-results");
                _this.$articleResults = document.querySelector("#overlay-results");
                _this.$buttonGroup = document.querySelector(".overlay-buttons");
                _this.$container = document.querySelector(".city-overlay-wrapper");
                _this.$parent = document.querySelector("#city-overlay");
                _this.$dateMentions = Array.from(document.querySelectorAll(".search-results-date"));
                _this.$legalLine = document.querySelector(".overlay-legal");
                _this.isLookingAtCity = false;
                return _this
            }
            _createClass(CityResults, [{
                key: "showResult",
                value: function showResult(articles) {
                    var _this2 = this;
                    clearTimeout(this.offsetTimer);
                    if (this.isMobile) this.$parent.style.pointerEvents = "auto";
                    this.$container.style.pointerEvents = "auto";
                    this.updateDisplayDate();
                    var delay = !this.isLookingAtCity ? 1.3 : 0;
                    this.isLookingAtCity = true;
                    if (articles.length > 0) {
                        var html = "";
                        articles.forEach(function(item) {
                            html += '<a class="overlay-result article" target="_blank" href="' + item.url + '">\n                 <span>' + item.title + "</span></a>"
                        });
                        this.$articleResults.innerHTML = html;
                        _gsap.TweenLite.to(this.$citySearchTitle, .25, {
                            opacity: 1,
                            delay: delay,
                            overwrite: "all"
                        });
                        _gsap.TweenLite.to(this.$legalLine, .25, {
                            opacity: 1,
                            delay: delay + .6,
                            overwrite: "all"
                        });
                        _gsap.TweenLite.to(this.$buttonGroup, .25, {
                            opacity: 1,
                            overwrite: "all"
                        });
                        var $articles = document.querySelectorAll(".overlay-result");
                        _gsap.TweenMax.staggerFromTo($articles, .4, {
                            opacity: 0,
                            y: 10
                        }, {
                            opacity: 1,
                            y: 0,
                            ease: _gsap.Quint.easeOut,
                            delay: delay,
                            overwrite: "all"
                        }, .1);
                        // this.$fallbackMsg.style.display = "none";
                        this.$buttonGroup.style.position = "relative";
                        this.$buttonGroup.style.top = 0;
                        this.$buttonGroup.style.left = 0
                    } else {
                        this.$buttonGroup.style.left = "";
                        // _gsap.TweenLite.to(this.$fallbackMsg, .25, {
                        //     opacity: 1,
                        //     delay: delay,
                        //     overwrite: "all"
                        // });
                        _gsap.TweenLite.to(this.$citySearchTitle, .25, {
                            opacity: 0,
                            delay: delay,
                            overwrite: "all"
                        });
                        _gsap.TweenLite.to(this.$legalLine, .25, {
                            opacity: 0,
                            delay: delay,
                            overwrite: "all"
                        });
                        this.offsetTimer = setTimeout(function() {
                            _this2.$buttonGroup.style.position = "absolute";
                            _this2.$buttonGroup.style.top = _this2.$citySearchTitle.offsetTop + "px";
                            _gsap.TweenLite.to(_this2.$buttonGroup, .25, {
                                opacity: 1,
                                delay: delay,
                                overwrite: "all"
                            })
                        }, 100);
                        // this.$fallbackMsg.style.display = "block";
                        var _$articles = document.querySelectorAll(".overlay-result");
                        _gsap.TweenMax.staggerTo(_$articles, .2, {
                            opacity: 0,
                            y: -10,
                            ease: _gsap.Quint.easeOut,
                            delay: delay,
                            overwrite: "all"
                        }, .1)
                    }
                }
            }, {
                key: "updateDisplayDate",
                value: function updateDisplayDate() {
                    var _this3 = this;
                    this.$dateMentions.forEach(function(item) {
                        var currentDate = _helpers.HELPERS.parseDate(_this3.dateWeAreLookingAt);
                        var month = _this3.months[currentDate.getMonth()];
                        var date = _helpers.HELPERS.getTodaysDate() === _this3.dateWeAreLookingAt ? "today" : month + ", " + currentDate.getFullYear();
                        item.innerHTML = " " + date
                    })
                }
            }, {
                key: "loadCity",
                value: function loadCity(city, date) {
                    var _this4 = this;
                    this.dateWeAreLookingAt = date;
                    this.cityWeAreLookingAt = city;
                    (function(promisedDate, promisedCity) {
                        var articles = [];
                        _cityService.CityService.getCity(city, date).then(function(response) {
                            if (promisedDate !== _this4.dateWeAreLookingAt && promisedCity !== _this4.cityWeAreLookingAt) {
                                return
                            }
                            if (response && response[0]) {
                                var data = response[0];
                                if (Object.keys(data).length > 0) {
                                    var key = Object.keys(data)[0];
                                    articles = data[key]
                                }
                            }
                            _this4.showResult(articles)
                        })
                    })(date, city)
                }
            }]);
            return CityResults
        }(_events.EventEmitter)
    }, {
        "./city-service": 336,
        "./helpers": 341,
        events: 326,
        gsap: 327
    }],
    336: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.CityService = undefined;
        var _settings = require("./settings");
        var _helpers = require("./helpers");
        var cities = [];
        var cityToggle = false;
        var CityService = exports.CityService = {
            getCity: function getCity(city, date) {
                return new Promise(function(resolve, reject) {
                    var cityStr = city.city + city.region + city.country;
                    if (!cityStr) {
                        reject()
                    } else if (cities[cityStr + date]) {
                        resolve(cities[cityStr + date])
                    } else {
                        cityToggle = !cityToggle;
                        var path = _settings.Settings.USE_DUMMY_DATA ? "/assets/city-" + (cityToggle ? "1" : "2") + ".json" : "/city/" + cityStr;
                        if (date !== _helpers.HELPERS.getTodaysDate()) {
                            path += "?date=" + date
                        }
                        return fetch(_settings.Settings.API_PATH + path, {
                            credentials: "include"
                        }).then(function(response) {
                            return response.text()
                        }).then(function(text) {
                            try {
                                if (text.startsWith(")]}',")) {
                                    text = text.replace(")]}',", "");
                                    var data = JSON.parse(text);
                                    cities[cityStr + date] = data;
                                    resolve(data)
                                }
                            } catch (err) {
                                reject()
                            }
                        })
                    }
                })
            }
        }
    }, {
        "./helpers": 341,
        "./settings": 348
    }],
    337: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.DateService = undefined;
        var _helpers = require("./helpers");
        var _settings = require("./settings");
        var dates = [];
        var nearCities = [];
        var trendToggle = false;
        var staggeredDistanceDates = [];
        var DateService = exports.DateService = {
            getDate: function getDate(date) {
                return new Promise(function(resolve, reject) {
                    if (!date) {
                        reject()
                    } else if (dates[date]) {
                        resolve(dates[date])
                    } else {
                        trendToggle = !trendToggle;
                        var path = _settings.Settings.USE_DUMMY_DATA ? "assets/trends-" + (trendToggle ? "1" : "2") + ".json" : "/trend-data/" + date;
                        return fetch(_settings.Settings.API_PATH + path, {
                            credentials: "include"
                        }).then(function(response) {
                            return response.text()
                        }).then(function(text) {
                            try {
                                if (text.startsWith(")]}',")) {
                                    text = text.replace(")]}',", "");
                                    var data = JSON.parse(text);
                                    dates[date] = DateService.sortTrendsByDistance(data);
                                    resolve(dates[date])
                                }
                            } catch (err) {
                                reject()
                            }
                        })
                    }
                })
            },
            getStaggeredDistanceDate: function getStaggeredDistanceDate(date, cities) {
                if (staggeredDistanceDates[date]) {
                    return staggeredDistanceDates[date]
                } else {
                    var citiesArr = cities.slice();
                    var newArr = [];
                    newArr.push(citiesArr.shift());
                    while (citiesArr.length) {
                        var city = newArr[newArr.length - 1];
                        var farCityIndexes = [];
                        for (var i = 0; i < citiesArr.length; i++) {
                            var distance = _helpers.HELPERS.distanceBetweenTwoCoordinations({
                                lat: city.lat,
                                lng: city.lon
                            }, {
                                lat: citiesArr[i].lat,
                                lng: citiesArr[i].lon
                            });
                            if (distance > 3e6 && distance < 1e7) {
                                farCityIndexes.push(i)
                            }
                        }
                        var newCityIndex = farCityIndexes.length ? farCityIndexes[Math.floor(Math.random() * farCityIndexes.length)] : Math.floor(Math.random() * citiesArr.length);
                        newArr.push(citiesArr.splice(newCityIndex, 1)[0])
                    }
                    staggeredDistanceDates[date] = newArr;
                    return staggeredDistanceDates[date]
                }
            },
            sortTrendsByDistance: function sortTrendsByDistance(trends) {
                trends.forEach(function(trend) {
                    trend.key = trend.city + trend.region + trend.country
                });
                var trendsWithOutNeighbors = trends.slice();
                var firstItem = trendsWithOutNeighbors.shift();
                var processed = [];
                var getClosestTrend = function getClosestTrend(trend) {
                    var minDist = Infinity;
                    var minDistIndex = undefined;
                    trendsWithOutNeighbors.forEach(function(item, index) {
                        item.distance = _helpers.HELPERS.distanceBetweenTwoCoordinations({
                            lat: item.lat,
                            lng: item.lon
                        }, {
                            lat: trend.lat,
                            lng: trend.lon
                        });
                        if (item.distance < minDist) {
                            minDist = item.distance;
                            minDistIndex = index
                        }
                    });
                    if (minDistIndex !== undefined) {
                        return trendsWithOutNeighbors.splice(minDistIndex, 1)[0]
                    } else {
                        return false
                    }
                };
                var runLoop = function runLoop(firstTrend) {
                    var trend = getClosestTrend(firstTrend);
                    if (trend) {
                        processed.push(trend);
                        runLoop(trend)
                    }
                };
                runLoop(firstItem);
                firstItem.distance = processed.length ? processed[0].distance : 1;
                processed.unshift(firstItem);
                return processed
            },
            getNearestCities: function getNearestCities(position, date) {
                var slug = position.lat + "-" + position.lng + "-" + date;
                if (nearCities[slug]) {
                    return nearCities[slug]
                }
                var pointsForDate = dates[date];
                if (!pointsForDate) {
                    return null
                }
                var distances = [];
                pointsForDate.forEach(function(cityPoint) {
                    distances.push(_helpers.HELPERS.distanceBetweenTwoCoordinations(position, {
                        lat: cityPoint.lat,
                        lng: cityPoint.lon
                    }))
                });
                var nearest = [];
                var _loop = function _loop(i) {
                    var min = Math.min.apply(Math, distances);
                    var index = distances.findIndex(function(item) {
                        return item === min
                    });
                    distances[index] = Infinity;
                    nearest.push(pointsForDate[index])
                };
                for (var i = 0; i < 5; i++) {
                    _loop(i)
                }
                nearCities[slug] = nearest;
                return nearest
            }
        }
    }, {
        "./helpers": 341,
        "./settings": 348
    }],
    338: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.EarthGlow = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _three = require("three");
        var THREE = _interopRequireWildcard(_three);
        var _events = require("events");
        var _gsap = require("gsap");

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]
                    }
                }
                newObj.default = obj;
                return newObj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var VERTEX = "\nvarying vec2 v_uv;\n\nvoid main() {\n  v_uv = uv;\n  vec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n  mvPosition.xy += position.xy;\n  gl_Position = projectionMatrix * mvPosition;\n}\n";
        var FRAG = "\nuniform float opacity;\nuniform float r;\nvarying vec2 v_uv;\nvarying vec3 colorP;\n\nvoid main() {\n  float r = 0.2;\n  vec2 uv = v_uv * 1.2;\n  vec2 diff = vec2(0.5) - v_uv;\n  float angle = atan(diff.y, diff.x);\n  float s = distance(v_uv, vec2(0.5)) / 0.41667 - 1.0;\n  float inner = smoothstep(-0.01, 0.0, s);\n  float outer = pow(clamp((r + .005 - s) / r, 0., 1.), 1.);\n  s = mix(inner, outer, step(0.0, s));\n\n  gl_FragColor = vec4(0.2 * 0.7, 0.18 * 0.7, 0.19 * 0.7, s * opacity * cos(angle * 0.8 + 0.24));\n  // gl_FragColor = vec4(vec3(diff), 0.5);\n}\n";
        var SIZE = 1.2;
        var EarthGlow = exports.EarthGlow = function(_EventEmitter) {
            _inherits(EarthGlow, _EventEmitter);

            function EarthGlow() {
                _classCallCheck(this, EarthGlow);
                var _this = _possibleConstructorReturn(this, (EarthGlow.__proto__ || Object.getPrototypeOf(EarthGlow)).call(this));
                var texture = (new THREE.TextureLoader).load("assets/images/marker.png");
                texture.flipY = false;
                _this.uniforms = {
                    opacity: {
                        value: 0,
                        type: "f"
                    }
                };
                var material = new THREE.ShaderMaterial({
                    uniforms: _this.uniforms,
                    vertexShader: VERTEX,
                    fragmentShader: FRAG,
                    blending: THREE.NormalBlending,
                    depthTest: false,
                    transparent: true
                });
                var geometry = new THREE.PlaneGeometry(SIZE, SIZE, 1);
                var plane = new THREE.Mesh(geometry, material);
                _this.mesh = plane;
                return _this
            }
            _createClass(EarthGlow, [{
                key: "show",
                value: function show(small) {
                    _gsap.TweenLite.to(this.uniforms.opacity, .25, {
                        value: 1,
                        ease: _gsap.Quad.easeOut
                    });
                    _gsap.TweenLite.to(this.uniforms.r, .25, {
                        value: small ? .75 : 1,
                        ease: _gsap.Quad.easeOut
                    })
                }
            }, {
                key: "hide",
                value: function hide() {
                    _gsap.TweenLite.to(this.uniforms.opacity, .2, {
                        value: 0,
                        ease: _gsap.Quad.easeInOut
                    });
                    _gsap.TweenLite.to(this.uniforms.r, .2, {
                        value: 0,
                        ease: _gsap.Quad.easeInOut
                    })
                }
            }]);
            return EarthGlow
        }(_events.EventEmitter)
    }, {
        events: 326,
        gsap: 327,
        three: 329
    }],
    339: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Globe = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _three = require("three");
        var THREE = _interopRequireWildcard(_three);
        var _gsap = require("gsap");
        var _helpers = require("./helpers");
        var _markers = require("./markers");
        var _particle_system = require("./particle_system");
        var _glows = require("./glows");
        var _earthglow = require("./earthglow");
        var _events = require("events");
        var _dateService = require("./date-service");
        var _analytics = require("./analytics");
        var _settings = require("./settings");
        var _audioController = require("./audioController");
        var _audioController2 = _interopRequireDefault(_audioController);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]
                    }
                }
                newObj.default = obj;
                return newObj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        window.setFromSpherical = function(obj, r, p, t) {
            obj.setFromSpherical(new THREE.Spherical(r, THREE.Math.degToRad(p), THREE.Math.degToRad(t)))
        };
        var Globe = exports.Globe = function(_EventEmitter) {
            _inherits(Globe, _EventEmitter);

            function Globe(isMobile) {
                _classCallCheck(this, Globe);
                var _this = _possibleConstructorReturn(this, (Globe.__proto__ || Object.getPrototypeOf(Globe)).call(this));
                _this.viewportHeight = _this.getViewportHeight();
                _this.isMobile = isMobile;
                _this.ROTATION_SPEED = 2.5;
                _this.WEATHER_ROTATION_SPEED = 1;
                _this.RADIUS = .5;
                _this.SEGMENTS = 64;
                _this.TILT_AMOUNT = 0 * Math.PI / 180;
                _this.setDefaultRotation();
                _this.DRAG_SPEED = 20;
                _this.WEATHER_OPACITY = .2;
                _this.touchPointsDiff = -1;
                _this.PINCH_ZOOM_SPEED = .2;
                _this.CAMERA_FAR = _this.isMobile ? 6.5 : 4.5;
                _this.CAMERA_INTRO = _this.CAMERA_FAR - .4;
                _this.CAMERA_ZOOM_IN = 1.45;
                _this.ORIGIN = new THREE.Vector3;
                _this.DRAG_THRESHOLD = _this.isMobile ? 2 : 0;
                _this.renderer = new THREE.WebGLRenderer({
                    alpha: false
                });
                _this.renderer.setClearColor(0, 1);
                var ratio = _helpers.HELPERS.DPR();
                _this.renderer.setPixelRatio(ratio);
                _this.renderer.setSize(window.innerWidth, _this.viewportHeight);
                _this.$overlayWrapper = document.querySelector(".city-overlay-wrapper");
                _this.$topCities = Array.from(document.querySelectorAll(".cities-wrapper .city span"));
                _this.$home = document.querySelector("#home");
                _this.globe = document.querySelector("#globe");
                _this.globe.appendChild(_this.renderer.domElement);
                _this.scene = new THREE.Scene;
                _this.camera = new THREE.PerspectiveCamera(15, window.innerWidth / _this.viewportHeight, .01, 100);
                _this.camera.position.z = _this.CAMERA_INTRO;
                _this.cameraSpherical = new THREE.Spherical;
                _this.dragCamera = false;
                _this.dragCameraSpherical = new THREE.Spherical;
                _this.cameraGoal = new THREE.Vector3;
                window.camera = _this.camera;
                window.THREE = THREE;
                window.globe = _this;
                window.scene = _this.scene;
                _this.lightGroup = new THREE.Object3D;
                _this.scene.add(_this.lightGroup);
                _this.light1 = new THREE.DirectionalLight(16775912, 0);
                _this.light1.position.setFromSpherical(new THREE.Spherical(1, THREE.Math.degToRad(100), THREE.Math.degToRad(10)));
                _this.lightGroup.add(_this.light1);
                window.light1 = _this.light1;
                _this.light2 = new THREE.DirectionalLight(16775912, 0);
                _this.light2.position.set(-13, 10, -20);
                _this.lightGroup.add(_this.light2);
                _this.light2GoalPosition = (new THREE.Vector3).setFromSpherical(new THREE.Spherical(1, THREE.Math.degToRad(75), THREE.Math.degToRad(-147.5)));
                window.light2 = _this.light2;
                _this.topGlobGroup = new THREE.Object3D;
                _this.globeGroup = new THREE.Object3D;
                _this.globeGroup.rotation.y = -35 * Math.PI / 180;
                _this.topGlobGroup.add(_this.globeGroup);
                _this.topGlobGroup.rotation.z = _this.TILT_AMOUNT;
                _this.scene.add(_this.topGlobGroup);
                _this.earthglow = new _earthglow.EarthGlow;
                _this.topGlobGroup.add(_this.earthglow.mesh);
                _this.markers = false;
                _this.pointer = new THREE.Vector2(-1, 1);
                _this.overMarkerId = false;
                _this.dragState = {
                    maybe: false,
                    isDragging: false,
                    start: {
                        x: 0,
                        y: 0
                    },
                    prev: {
                        x: 0,
                        y: 0
                    }
                };
                _this.time = 0;
                _this.isZoomedOut = true;
                // _this.$soundOn = document.querySelector("#icon-sound");
                // _this.$soundOff = document.querySelector("#icon-sound-off");
                return _this
            }
            _createClass(Globe, [{
                key: "setDefaultRotation",
                value: function setDefaultRotation() {
                    this.maxXRotate = 15 * Math.PI / 180 + .5 * Math.PI;
                    this.minXRotate = -15 * Math.PI / 180 + .5 * Math.PI
                }
            }, {
                key: "setZoomedInRotation",
                value: function setZoomedInRotation() {
                    this.maxXRotate = 60 * Math.PI / 180 + .5 * Math.PI;
                    this.minXRotate = -60 * Math.PI / 180 + .5 * Math.PI
                }
            }, {
                key: "colorTest",
                value: function colorTest() {
                    this.globeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(this.RADIUS + .025, 12, 12), new THREE.ShaderMaterial({
                        vertexShader: "\n        varying vec3 color;\n\n        void main() {\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n          color = vec3(1.0, 0.2, 0.8);\n\n          // World Position\n          // vec4 wPos = modelMatrix * vec4(position, 1.0 );\n          // float xmix = min(1., max(0., (wPos.x / 0.25) * 0.5 + 0.5));\n          // float ymix = min(1., max(0., (wPos.y / 0.25) * 0.5 + 0.5));\n          // color =\n          //   vec3(.906, .278, .294) * (1. - ymix) * 0.5 +\n          //   vec3(.306, .259, .545) * xmix +\n          //   vec3(.835, .803, .392) * (1. - xmix);\n\n          // Camera Position\n          float xmix = min(1., max(0., (mvPosition.x / 0.25) * 0.5 + 0.5));\n          float ymix = min(1., max(0., (mvPosition.y / 0.25) * 0.5 + 0.5));\n          color =\n            vec3(1., .486, 0.451) * (1. - ymix) +\n            vec3(.62, .6, 1.) * ymix +\n            vec3(1., .957, .502) * xmix +\n            vec3(.6, 1., .6) * (1. - xmix);\n\n          gl_Position = projectionMatrix * mvPosition;\n        }",
                        fragmentShader: "\n        varying vec3 color;\n\n        void main() {\n          gl_FragColor = vec4(color, 1.0);\n        }",
                        blending: THREE.NormalBlending
                    })))
                }
            }, {
                key: "loadWeather",
                value: function loadWeather() {
                    var weatherDistance = .001;
                    var textureLoader = new THREE.TextureLoader;
                    this.weatherImg = textureLoader.load("assets/images/weather.jpg");
                    this.weatherImg.mapping = THREE.UVMapping;
                    this.weatherMesh = new THREE.Mesh(new THREE.SphereGeometry(this.RADIUS + weatherDistance, this.SEGMENTS, this.SEGMENTS), new THREE.MeshLambertMaterial({
                        map: this.weatherImg,
                        transparent: true,
                        opacity: this.WEATHER_OPACITY,
                        blending: THREE.AdditiveBlending
                    }));
                    this.globeGroup.add(this.weatherMesh)
                }
            }, {
                key: "loadEarthImages",
                value: function loadEarthImages(onLoaded) {
                    var textureLoader = new THREE.TextureLoader;
                    var done = 0;
                    var image_path = "assets/images/earth_updated.jpg";
                    if (this.renderer.capabilities.maxTextureSize <= 4096) {
                        image_path = "assets/images/earth_updated.jpg"
                    }
                    this.earth_img = textureLoader.load(image_path, function() {
                        done++;
                        if (done === 1) onLoaded()
                    });
                    this.earth_img.mapping = THREE.UVMapping
                }
            }, {
                key: "loadStars",
                value: function loadStars() {
                    var starDistance = .001;
                    var textureLoader = new THREE.TextureLoader;
                    this.starImg = textureLoader.load("assets/images/background-blended2.jpg");
                    this.starImg.mapping = THREE.UVMapping;
                    this.starImg.wrapS = THREE.RepeatWrapping;
                    this.starImg.wrapT = THREE.RepeatWrapping;
                    this.starImg.repeat.set(7, 7);
                    this.starMesh = new THREE.Mesh(new THREE.SphereGeometry(this.RADIUS + starDistance + 4, 8, 7), new THREE.MeshLambertMaterial({
                        map: this.starImg
                    }));
                    this.starMesh.material.side = THREE.BackSide;
                    this.scene.add(this.starMesh)
                }
            }, {
                key: "playIntro",
                value: function playIntro() {
                    var _this2 = this;
                    var introLine1 = document.querySelector("#intro-line-1");
                    var introLine2 = document.querySelector("#intro-line-2");
                    var introLine3 = document.querySelector("#intro-line-3");
                    if (this.shouldPlayIntro) {
                        _analytics.Analytics.createEvent("pageload", "Intro", "/intro");
                        _gsap.TweenLite.delayedCall(1, function() {
                            introLine1.classList.add("visible")
                        });
                        _gsap.TweenLite.delayedCall(3, function() {
                            introLine2.classList.add("visible")
                        });
                        _gsap.TweenLite.delayedCall(5, function() {
                            introLine3.classList.add("visible")
                        });
                        _gsap.TweenLite.delayedCall(8, function() {
                            introLine1.classList.add("fade");
                            introLine2.classList.add("fade");
                            introLine3.classList.add("fade");
                            _gsap.TweenLite.to(_this2.earthglow.uniforms.opacity, 4, {
                                value: 1,
                                ease: _gsap.Quint.EaseOut,
                                delay: .7
                            });
                            _gsap.TweenLite.to(_this2.light2, 1, {
                                intensity: 3,
                                ease: _gsap.Quint.EaseOut,
                                delay: .7
                            });
                            _gsap.TweenLite.to(_this2.light1, 2, {
                                intensity: .8,
                                ease: _gsap.Quint.EaseOut,
                                delay: 2
                            });
                            _gsap.TweenLite.to(_this2.camera.position, 6, {
                                z: _this2.CAMERA_FAR,
                                ease: _gsap.Quint.EaseOut,
                                delay: .5
                            });
                            _analytics.Analytics.createEvent("pageload", "Landing Page", "/landing_page")
                        });
                        _gsap.TweenLite.delayedCall(9, this.showEntrance.bind(this))
                    } else {
                        this.camera.position.z = this.CAMERA_FAR;
                        this.camera.lookAt(this.ORIGIN);
                        this.light2.intensity = .2;
                        this.light1.intensity = .5;
                        this.earthglow.uniforms.opacity.value = 1;
                        this.showEntrance();
                        _analytics.Analytics.createEvent("click", "Home", "/home", true)
                    }
                }
            }, {
                key: "showEntrance",
                value: function showEntrance() {
                    var _this3 = this;
                    var $introBtn = document.querySelector("#intro-btn");
                    var $introMainSite = document.querySelector(".intro-main--site");
                    var $intro = document.querySelector("#intro");
                    $introMainSite.querySelector(".intro-header").classList.add("visible");
                    _gsap.TweenLite.delayedCall(.8, function() {
                        $introMainSite.querySelector(".intro-subheader").classList.add("visible")
                    });
                    _gsap.TweenLite.delayedCall(1.6, function() {
                        $introBtn.classList.add("scale")
                    });
                    $introBtn.addEventListener("click", function() {
                        _audioController2.default.enableWebAudio();
                        _audioController2.default.startBackground();
                        $introMainSite.querySelector(".intro-header").classList.add("fade");
                        $introMainSite.querySelector(".intro-subheader").classList.add("fade");
                        $introMainSite.querySelector(".intro-btn").classList.add("scale-in");
                        _gsap.TweenLite.delayedCall(.5, function() {
                            _this3.emit("intro-complete")
                        });
                        _gsap.TweenLite.to(_this3.light1, 2, {
                            intensity: 1,
                            ease: _gsap.Quint.EaseOut
                        });
                        _gsap.TweenLite.to(_this3.light2.position, 3, {
                            x: _this3.light2GoalPosition.x,
                            y: _this3.light2GoalPosition.y,
                            z: _this3.light2GoalPosition.z,
                            ease: _gsap.Quint.EaseOut
                        });
                        _gsap.TweenLite.to(_this3.light2, 3, {
                            intensity: 5,
                            ease: _gsap.Quint.EaseOut
                        });
                        _analytics.Analytics.createEvent("click", "clickable_link, landing_page, explore", "Explore Button");
                        _gsap.TweenLite.delayedCall(2, function() {
                            $intro.style.display = "none";
                            _this3.addEvents()
                        })
                    });
                    var $introEmbed = document.querySelector(".intro-main--embed");
                    document.querySelector("#intro-btn-embed").addEventListener("click", function() {
                        $introEmbed.querySelector(".intro-subheader").classList.add("fade");
                        $introEmbed.querySelector(".intro-icon").classList.add("fade");
                        $introEmbed.querySelector(".intro-btn").classList.add("scale-in");
                        _this3.emit("intro-complete");
                        _gsap.TweenLite.to(_this3.light1, 2, {
                            intensity: 1,
                            ease: _gsap.Quint.EaseOut
                        });
                        _gsap.TweenLite.to(_this3.light2.position, 3, {
                            x: _this3.light2GoalPosition.x,
                            y: _this3.light2GoalPosition.y,
                            z: _this3.light2GoalPosition.z,
                            ease: _gsap.Quint.EaseOut
                        });
                        _gsap.TweenLite.to(_this3.light2, 3, {
                            intensity: 5,
                            ease: _gsap.Quint.EaseOut
                        });
                        _analytics.Analytics.createEvent("click", "clickable_link, landing_page, explore", "Explore Button");
                        _gsap.TweenLite.delayedCall(2, function() {
                            document.querySelector("#intro").style.display = "none";
                            _this3.addEvents()
                        })
                    })
                }
            }, {
                key: "load",
                value: function load() {
                    var _this4 = this;
                    var shouldPlayIntro = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                    this.shouldPlayIntro = shouldPlayIntro;
                    this.playIntro();
                    return new Promise(function(resolve) {
                        _this4.loadWeather();
                        _this4.loadStars();
                        _this4.loadEarthImages(function() {
                            var earthMaterial = new THREE.MeshPhongMaterial({
                                map: _this4.earth_img,
                                specular: new THREE.Color(0, 0, 0),
                                shininess: .25
                            });
                            window.earthMaterial = earthMaterial;
                            _this4.globeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(_this4.RADIUS, _this4.SEGMENTS, _this4.SEGMENTS), earthMaterial));
                            _this4.particles = new _particle_system.ParticleSystem;
                            _this4.globeGroup.add(_this4.particles.mesh);
                            _this4.glows = new _glows.Glows(300, _this4.globeGroup);
                            _this4.autoRotating = true;
                            _this4.interactionEnabled = true;
                            _this4.on("intro-complete", function() {
                                _this4.$home.style.opacity = "1";
                                resolve()
                            })
                        })
                    })
                }
            }, {
                key: "overMarker",
                value: function overMarker(markerId) {
                    if (markerId !== this.overMarkerId) {
                        this.leaveAllMarkers();
                        this.overMarkerId = markerId;
                        if (!this.isMobile) {
                            this.onMarkerEnter(markerId)
                        }
                    }
                }
            }, {
                key: "leaveAllMarkers",
                value: function leaveAllMarkers() {
                    if (this.overMarkerId) {
                        this.onMarkerLeave(this.overMarkerId);
                        this.overMarkerId = false;
                        this.emit("hover-off")
                    }
                }
            }, {
                key: "onMarkerEnter",
                value: function onMarkerEnter(markerId) {
                    var point = this.markers.getPointById(markerId);
                    if (point) this.emit("hover-city", point);
                    document.body.style.cursor = "pointer";
                    if (point && !this.currentLookedAtCity) this.particles.increaseRate(markerId, point.pos, point.howmany);
                    this.markers.select(markerId);
                    _audioController2.default.playOneShot()
                }
            }, {
                key: "onMarkerLeave",
                value: function onMarkerLeave(markerId) {
                    document.body.style.cursor = "";
                    this.emit("hover-off");
                    this.markers.deselect(markerId);
                    this.particles.decreaseRate(markerId)
                }
            }, {
                key: "mouseOverTopCities",
                value: function mouseOverTopCities() {
                    var topCities = this.$topCities;
                    for (var i = 0; i < topCities.length; i++) {
                        var overlayCoords = topCities[i].getBoundingClientRect();
                        if (!(this.clientX < overlayCoords.left || this.clientX > overlayCoords.left + overlayCoords.width || this.clientY < overlayCoords.top || this.clientY > overlayCoords.top + overlayCoords.height)) return true
                    }
                    return false
                }
            }, {
                key: "mouseOverCityOverlay",
                value: function mouseOverCityOverlay() {
                    var overlayCoords = this.$overlayWrapper.getBoundingClientRect();
                    return !(this.clientX < overlayCoords.left || this.clientX > overlayCoords.left + overlayCoords.width || this.clientY < overlayCoords.top || this.clientY > overlayCoords.top + overlayCoords.height)
                }
            }, {
                key: "tick",
                value: function tick(time) {
                    this.time = time;
                    if (this.dragCamera) {
                        var startRotation = this.camera.quaternion.clone();
                        var thetaDiff = this.dragCameraSpherical.theta - this.cameraSpherical.theta;
                        var phiDiff = this.dragCameraSpherical.phi - this.cameraSpherical.phi;
                        this.cameraSpherical.theta = this.cameraSpherical.theta + thetaDiff * .08;
                        this.cameraSpherical.phi = this.cameraSpherical.phi + phiDiff * .08;
                        this.camera.position.setFromSpherical(this.cameraSpherical);
                        this.camera.lookAt(this.ORIGIN);
                        var endRotation = this.camera.quaternion.clone();
                        var deltaRotation = endRotation.multiply(startRotation.inverse());
                        var rotateGlobeBy = new THREE.Quaternion;
                        rotateGlobeBy.slerp(deltaRotation, .9);
                        this.starMesh.applyQuaternion(rotateGlobeBy)
                    }
                    this.lightGroup.rotation.copy(this.camera.rotation);
                    if (this.isMobile && !!this.lookingAt || !!this.lookingAt && this.mouseOverCityOverlay() || !!this.markers === false || this.dragState.isDragging || !this.isMobile && this.mouseOverTopCities()) {
                        this.leaveAllMarkers()
                    } else {
                        var overId = this.markers.raycast(this.pointer, this.camera);
                        if (overId) {
                            this.overMarker(overId)
                        } else {
                            this.leaveAllMarkers()
                        }
                    }
                    if (this.autoRotating) {
                        this.globeGroup.rotation.y += this.ROTATION_SPEED * Math.PI / 18e3;
                        this.starMesh.rotation.y += .05 * this.ROTATION_SPEED * Math.PI / 18e3
                    }
                    if (this.weatherMesh && this.autoRotating) {
                        this.weatherMesh.rotation.y += this.WEATHER_ROTATION_SPEED * Math.PI / 18e3
                    }
                    if (this.markers) this.markers.tick(time);
                    if (this.particles) this.particles.tick(time);
                    this.renderer.render(this.scene, this.camera)
                }
            }, {
                key: "addMarkers",
                value: function addMarkers(points) {
                    var _this5 = this;
                    this.points = points;
                    var clusters = _helpers.HELPERS.cluster(points, 4e5);
                    this.clusters = clusters.map(function(c) {
                        if (c.length === 1) {
                            return c[0]
                        } else {
                            var point = c.reduce(function(a, o) {
                                a.lat += o.lat;
                                a.lon += o.lon;
                                a._howmany += o.howmany;
                                return a
                            }, {
                                lat: 0,
                                lon: 0,
                                _howmany: 0
                            });
                            point.lat /= c.length;
                            point.lon /= c.length;
                            point.pos = _helpers.HELPERS.xyzFromLatLng(point.lat, point.lon, _this5.RADIUS);
                            point.city = c[0].city + " combined " + c.length;
                            point.region = c[0].region;
                            point.country = c[0].country;
                            point.distance = 0;
                            point.howmany = Math.min(150, 3 * point._howmany / c.length);
                            point.combined = true;
                            return point
                        }
                    });
                    this.points;
                    this.clearSpawners(this.isMobile);
                    if (!this.markers) {
                        this.markers = new _markers.Markers(this.isMobile);
                        this.globeGroup.add(this.markers.mesh);
                        this.globeGroup.add(this.markers.hoverglow.mesh)
                    }
                    this.markers.updatePoints(this.points);
                    if (!!this.currentLookedAtCity === true) {
                        this.markers.highlight(_helpers.HELPERS.pointId(this.currentLookedAtCity));
                        var point = this.points.find(function(o) {
                            return o.key === _this5.currentLookedAtCity.key
                        });
                        if (point) {
                            this.particles.addSpawner(_helpers.HELPERS.pointId(this.currentLookedAtCity), this.currentLookedAtCity.pos, point ? point.howmany * 10 : 5, 1, new THREE.Vector2(1 + 2.5 * Math.random(), 1.5 + 2 * Math.random()))
                        }
                    } else {
                        this.addSpawners()
                    }
                }
            }, {
                key: "addSpawners",
                value: function addSpawners() {
                    var _this6 = this;
                    if (this.particles) {
                        this.clusters.forEach(function(p) {
                            var area = void 0;
                            if (p.combined) {
                                area = new THREE.Vector2(2.5, 2.5)
                            }
                            _this6.particles.addSpawner(_helpers.HELPERS.pointId(p), p.pos, p.howmany, p.distance, area)
                        });
                        this.glows.update(this.clusters)
                    }
                }
            }, {
                key: "clearSpawners",
                value: function clearSpawners() {
                    var quick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    if (this.particles) {
                        this.particles.clearSpawners(quick);
                        this.glows.clear()
                    }
                }
            }, {
                key: "setDate",
                value: function setDate(date) {
                    var _this7 = this;
                    if (!this.loadingDate) {
                        this.loadingDate = true;
                        this.nextDate = null;
                        _dateService.DateService.getDate(date).then(function(response) {
                            _this7.loadingDate = false;
                            if (response) {
                                var dist = [];
                                var markerData = response.map(function(point) {
                                    dist.push(point.distance);
                                    var min = 20;
                                    var max = 3e3;
                                    var value = point.value;
                                    value = value < min ? min : value;
                                    value = value > max ? max : value;
                                    var howmany = Math.round(_helpers.HELPERS.mapRange(value, min, max, 10, 30));
                                    var pos = _helpers.HELPERS.xyzFromLatLng(point.lat, point.lon, _this7.RADIUS);
                                    if (_this7.nextDate) {
                                        _this7.setDate(_this7.nextDate)
                                    }
                                    return {
                                        pos: pos,
                                        howmany: howmany,
                                        lat: point.lat,
                                        lon: point.lon,
                                        key: point.key,
                                        value: point.value,
                                        city: point.city,
                                        region: point.region,
                                        country: point.country,
                                        distance: 0
                                    }
                                });
                                _this7.addMarkers(markerData);
                                _this7.emit("day-loaded", markerData)
                            }
                        })
                    } else {
                        this.nextDate = date
                    }
                }
            }, {
                key: "lookAtCamera",
                value: function lookAtCamera(lookAt) {
                    var cityPos = this.globeGroup.localToWorld(lookAt.clone());
                    var cameraPos = cityPos.clone();
                    cameraPos.normalize().multiplyScalar(this.CAMERA_ZOOM_IN);
                    var cameraClone = this.camera.clone();
                    cameraClone.position.copy(cameraPos);
                    cameraClone.lookAt(cityPos);
                    var fov = THREE.Math.degToRad(cameraClone.fov);
                    var dist = cameraClone.position.distanceTo(cityPos);
                    var height = 2 * Math.tan(fov / 2) * dist;
                    var width = height * cameraClone.aspect;
                    var x = 0,
                        y = 0;
                    if (window.innerWidth < 992) {
                        y = -height * .25
                    } else if (window.innerWidth < 1300) {
                        x = width * .3
                    } else {
                        x = width * .25
                    }
                    var vx = new THREE.Vector3(1, 0, 0);
                    vx.applyQuaternion(cameraClone.quaternion);
                    cityPos.add(vx.multiplyScalar(x));
                    var vy = new THREE.Vector3(0, 1, 0);
                    vy.applyQuaternion(cameraClone.quaternion);
                    cityPos.add(vy.multiplyScalar(y));
                    cameraClone.position.copy(cityPos).normalize().multiplyScalar(this.CAMERA_ZOOM_IN);
                    cameraClone.lookAt(cityPos);
                    return cameraClone
                }
            }, {
                key: "zoomInOn",
                value: function zoomInOn(city) {
                    var _this8 = this;
                    this.dragCamera = false;
                    this.currentLookedAtCity = city;
                    this.lookingAt = new THREE.Vector3(city.pos.x, city.pos.y, city.pos.z);
                    this.markers.decreaseHitArea();
                    this.autoRotating = false;
                    this.dragDisabled = true;
                    if (this.isZoomedOut) {
                        _audioController2.default.zoomIn()
                    }
                    this.isZoomedOut = false;
                    _gsap.TweenLite.killTweensOf(this.cameraSpherical);
                    this.cameraSpherical.setFromVector3(this.camera.position).makeSafe();
                    var goalCamera = this.lookAtCamera(this.lookingAt);
                    var goalSpherical = new THREE.Spherical;
                    goalSpherical.setFromVector3(goalCamera.position).makeSafe();
                    var thetaDiff = goalSpherical.theta - this.cameraSpherical.theta;
                    if (thetaDiff > Math.PI) {
                        goalSpherical.theta -= Math.PI * 2
                    } else if (thetaDiff < -Math.PI) {
                        goalSpherical.theta += Math.PI * 2
                    }
                    _gsap.TweenLite.to(this.cameraSpherical, 2.5, {
                        radius: goalSpherical.radius,
                        phi: goalSpherical.phi,
                        theta: goalSpherical.theta,
                        ease: _gsap.Quint.easeOut,
                        onUpdate: function onUpdate() {
                            _this8.camera.position.setFromSpherical(_this8.cameraSpherical);
                            _this8.camera.lookAt(_this8.ORIGIN)
                        }
                    });
                    _gsap.TweenLite.to(this.weatherMesh.material, 1, {
                        opacity: 0
                    });
                    this.clearSpawners();
                    this.markers.highlight(_helpers.HELPERS.pointId(city));
                    this.particles.addSpawner(_helpers.HELPERS.pointId(city), city.pos, city.howmany * 10, 1, new THREE.Vector2(1 + 3 * Math.random(), 1.5 + 2.5 * Math.random()))
                }
            }, {
                key: "zoomOut",
                value: function zoomOut() {
                    var _this9 = this;
                    this.setDefaultRotation();
                    this.currentLookedAtCity = false;
                    this.lookingAt = false;
                    this.markers.setDefaultHitArea();
                    this.autoRotating = true;
                    this.interactionEnabled = true;
                    this.dragDisabled = false;
                    if (!this.isZoomedOut) {
                        _audioController2.default.zoomOut()
                    }
                    this.isZoomedOut = true;
                    _gsap.TweenLite.killTweensOf(this.cameraSpherical);
                    this.cameraSpherical.setFromVector3(this.camera.position).makeSafe();
                    var p = new THREE.Vector3;
                    p.copy(this.camera.position);
                    p.y = 0;
                    p.normalize().multiplyScalar(this.CAMERA_FAR);
                    var goalSpherical = new THREE.Spherical;
                    goalSpherical.setFromVector3(p);
                    goalSpherical.makeSafe();
                    _gsap.TweenLite.to(this.cameraSpherical, 2.5, {
                        radius: goalSpherical.radius,
                        phi: goalSpherical.phi,
                        theta: goalSpherical.theta,
                        ease: _gsap.Quint.easeOut,
                        onUpdate: function onUpdate() {
                            _this9.camera.position.setFromSpherical(_this9.cameraSpherical);
                            _this9.camera.lookAt(_this9.ORIGIN)
                        }
                    });
                    _gsap.TweenLite.to(this.weatherMesh.material, 2.5, {
                        opacity: this.WEATHER_OPACITY
                    });
                    this.clearSpawners();
                    this.addSpawners();
                    this.markers.unhighlight()
                }
            }, {
                key: "onDragStart",
                value: function onDragStart() {
                    this.leaveAllMarkers();
                    document.body.classList.add("is-dragging");
                    this.autoRotating = false;
                    this.cameraSpherical.setFromVector3(this.camera.position).makeSafe();
                    this.dragCameraSpherical.setFromVector3(this.camera.position).makeSafe()
                }
            }, {
                key: "onDrag",
                value: function onDrag(dx, dy) {
                    this.dragCamera = true;
                    if (dx) {
                        this.dragCameraSpherical.theta -= dx * this.DRAG_SPEED * Math.PI / 18e3
                    }
                    if (dy) {
                        this.dragCameraSpherical.phi -= dy * this.DRAG_SPEED * Math.PI / 18e3;
                        this.dragCameraSpherical.phi = Math.min(Math.max(this.dragCameraSpherical.phi, this.minXRotate), this.maxXRotate)
                    }
                    this.dragCameraSpherical.makeSafe()
                }
            }, {
                key: "onDragStop",
                value: function onDragStop() {
                    document.body.classList.remove("is-dragging");
                    this.autoRotating = true
                }
            }, {
                key: "stopDrag",
                value: function stopDrag() {
                    this.dragState.maybe = false;
                    if (this.dragState.isDragging) {
                        this.dragState.isDragging = false;
                        this.onDragStop()
                    }
                }
            }, {
                key: "mouseup",
                value: function mouseup(e) {
                    var wasDragging = this.dragState.isDragging;
                    this.stopDrag(e);
                    if (!this.interactionEnabled || wasDragging || this.pinching) return;
                    if (this.markers && this.overMarkerId !== false && !wasDragging) {
                        this.gotoCity(this.overMarkerId);
                        var point = this.markers.getPointById(this.overMarkerId);
                        if (point && this.currentLookedAtCity !== point) {
                            if (_settings.Settings.isEmbedMode) return;
                            this.currentLookedAtCity = point;
                            _analytics.Analytics.createEvent("click", "Globe Click - " + point.key.replace(" ", ""), "clickable_link, home, globe_" + point.key.replace(" ", ""));
                            this.emit("look-at-city", point);
                            _audioController2.default.onClick()
                        }
                    }
                    return
                }
            }, {
                key: "gotoCity",
                value: function gotoCity(id) {
                    if (_settings.Settings.isEmbedMode) {
                        window.open("/location#" + id, "_blank");
                        return
                    }
                    var point = this.markers.getPointById(id);
                    if (point && this.currentLookedAtCity !== point) {
                        this.currentLookedAtCity = point;
                        _analytics.Analytics.createEvent("click", "Globe Click - " + point.key.replace(" ", ""), "clickable_link, home, globe_" + point.key.replace(" ", ""));
                        this.emit("look-at-city", point);
                        _audioController2.default.onClick()
                    }
                }
            }, {
                key: "mousemove",
                value: function mousemove(e) {
                    if (!this.interactionEnabled) {
                        return
                    }
                    e.preventDefault();
                    if (this.isMobile) {
                        if (e.targetTouches.length === 2) {
                            var curDiff = Math.abs(e.targetTouches[0].clientX - e.targetTouches[1].clientX);
                            if (curDiff > this.touchPointsDiff) {
                                this.cameraSpherical.setFromVector3(this.camera.position).makeSafe();
                                if (this.cameraSpherical.radius - this.PINCH_ZOOM_SPEED > this.CAMERA_ZOOM_IN) {
                                    this.setZoomedInRotation();
                                    this.cameraSpherical.radius -= this.PINCH_ZOOM_SPEED;
                                    this.camera.position.setFromSpherical(this.cameraSpherical)
                                } else {
                                    this.setDefaultRotation()
                                }
                            }
                            if (curDiff < this.touchPointsDiff) {
                                this.cameraSpherical.setFromVector3(this.camera.position).makeSafe();
                                if (this.cameraSpherical.radius + this.PINCH_ZOOM_SPEED < this.CAMERA_FAR) {
                                    this.setZoomedInRotation();
                                    this.cameraSpherical.radius += this.PINCH_ZOOM_SPEED;
                                    this.camera.position.setFromSpherical(this.cameraSpherical)
                                } else {
                                    this.setDefaultRotation()
                                }
                            }
                            this.touchPointsDiff = curDiff;
                            this.pinching = true;
                            return
                        }
                    }
                    this.pinching = false;
                    var x = Math.floor(this.isMobile ? e.touches[0].clientX : e.clientX);
                    var y = Math.floor(this.isMobile ? e.touches[0].clientY : e.clientY);
                    this.clientX = x;
                    this.clientY = y;
                    this.pointer.x = x / window.innerWidth * 2 - 1;
                    this.pointer.y = -(y / this.viewportHeight) * 2 + 1;
                    if (!this.dragDisabled) {
                        var dx = Math.abs(x - this.dragState.start.x);
                        var dy = Math.abs(y - this.dragState.start.y);
                        if (this.dragState.maybe && (dx > this.DRAG_THRESHOLD || dy > this.DRAG_THRESHOLD)) {
                            this.dragState.maybe = false;
                            this.dragState.isDragging = true;
                            this.dragState.prev.x = this.dragState.start.x;
                            this.dragState.prev.y = this.dragState.start.y;
                            this.onDragStart()
                        }
                        if (this.dragState.isDragging) {
                            this.onDrag(x - this.dragState.prev.x, y - this.dragState.prev.y);
                            this.dragState.prev.x = x;
                            this.dragState.prev.y = y;
                            _analytics.Analytics.createEvent("interaction", "Moves Globe")
                        }
                    }
                }
            }, {
                key: "addEvents",
                value: function addEvents() {
                    var _this10 = this;
                    // this.$soundOn.addEventListener("click", function() {
                    //     _audioController2.default.soundOff();
                    //     _this10.$soundOn.classList.remove("active");
                    //     _this10.$soundOff.classList.add("active");
                    //     _analytics.Analytics.createEvent("click", "Sound Toggle", "clickable_link, nav, sound_toggle")
                    // });
                    // this.$soundOff.addEventListener("click", function() {
                    //     _audioController2.default.soundOn();
                    //     _this10.$soundOff.classList.remove("active");
                    //     _this10.$soundOn.classList.add("active");
                    //     _analytics.Analytics.createEvent("click", "Sound Toggle", "clickable_link, nav, sound_toggle")
                    // });
                    var downEvent = this.isMobile ? "touchstart" : "mousedown";
                    this.globe.addEventListener(downEvent, function(e) {
                        if (!_this10.interactionEnabled) {
                            return
                        }
                        e.preventDefault();
                        _this10.dragCamera = false;
                        var x = Math.floor(_this10.isMobile ? e.touches[0].clientX : e.clientX);
                        var y = Math.floor(_this10.isMobile ? e.touches[0].clientY : e.clientY);
                        if (!_this10.dragState.isDragging && _this10.isMobile) {
                            _this10.pointer.x = x / window.innerWidth * 2 - 1;
                            _this10.pointer.y = -(y / _this10.viewportHeight) * 2 + 1
                        }
                        _this10.dragState.maybe = true;
                        _this10.dragState.start.x = x;
                        _this10.dragState.start.y = y
                    })
                }
            }, {
                key: "getViewportHeight",
                value: function getViewportHeight() {
                    return window.innerWidth <= 991 ? document.getElementById("globe").clientHeight : window.innerHeight
                }
            }, {
                key: "resize",
                value: function resize() {
                    this.viewportHeight = this.getViewportHeight();
                    this.camera.aspect = window.innerWidth / this.viewportHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, this.viewportHeight);
                    if (this.lookingAt) {
                        var goalCamera = this.lookAtCamera(this.lookingAt);
                        this.camera.position.copy(goalCamera.position);
                        this.camera.rotation.copy(goalCamera.rotation)
                    }
                }
            }, {
                key: "setMouse",
                value: function setMouse(x, y) {
                    if (this.markers && !this.isZoomedOut) {
                        this.pointer.x = x / window.innerWidth * 2 - 1;
                        this.pointer.y = -(y / this.viewportHeight) * 2 + 1;
                        var id = this.markers.raycast(this.pointer, this.camera);
                        if (id) {
                            this.gotoCity(id)
                        }
                    }
                }
            }]);
            return Globe
        }(_events.EventEmitter)
    }, {
        "./analytics": 331,
        "./audioController": 333,
        "./date-service": 337,
        "./earthglow": 338,
        "./glows": 340,
        "./helpers": 341,
        "./markers": 344,
        "./particle_system": 347,
        "./settings": 348,
        events: 326,
        gsap: 327,
        three: 329
    }],
    340: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Glows = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _three = require("three");
        var THREE = _interopRequireWildcard(_three);
        var _events = require("events");
        var _gsap = require("gsap");
        var _helpers = require("./helpers");

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]
                    }
                }
                newObj.default = obj;
                return newObj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var FADE_DUR = 1.8;
        var SIZE = .21;
        var UNIFORMS = {
            texture: {
                value: (new THREE.TextureLoader).load("assets/images/glow3.jpg")
            },
            opacity: {
                value: 0,
                type: "f"
            }
        };
        var VERTEX = "\nuniform float opacity;\n\nvarying vec3 color;\nvarying vec2 v_uv;\n\n" + _helpers.COLOR_SHADER + "\n\nvoid main() {\n  v_uv = uv;\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); // 3D\n  // vec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0); // Billboard\n  // mvPosition.xy += position.xy;\n  color = positionBasedColor(modelMatrix * vec4( position, 1.0 ));\n  gl_Position = projectionMatrix * (mvPosition + vec4(0, 0, 100, 0) * step(opacity, 0.01));\n}";
        var FRAG = "\nuniform sampler2D texture;\nuniform float opacity;\n\nvarying vec3 color;\nvarying vec2 v_uv;\n\nvoid main() {\n  vec4 tex = texture2D(texture, v_uv);\n  gl_FragColor = vec4(color, tex.r * opacity);\n}";
        var MATERIAL = new THREE.ShaderMaterial({
            uniforms: UNIFORMS,
            vertexShader: VERTEX,
            fragmentShader: FRAG,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });
        var Glows = exports.Glows = function(_EventEmitter) {
            _inherits(Glows, _EventEmitter);

            function Glows() {
                var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 300;
                var group = arguments[1];
                _classCallCheck(this, Glows);
                var _this = _possibleConstructorReturn(this, (Glows.__proto__ || Object.getPrototypeOf(Glows)).call(this));
                _this.group = group;
                _this.size = size;
                _this.meshes = [];
                for (var i = 0; i < _this.size; i++) {
                    _this.meshes[i] = _this.makeGlowMesh();
                    _this.group.add(_this.meshes[i]);
                    _this.meshes[i].position.z = 100
                }
                return _this
            }
            _createClass(Glows, [{
                key: "makeGlowMesh",
                value: function makeGlowMesh() {
                    var geometry = new THREE.PlaneGeometry(SIZE, SIZE, 1);
                    return new THREE.Mesh(geometry, MATERIAL)
                }
            }, {
                key: "update",
                value: function update(clusters) {
                    var _this2 = this;
                    _gsap.TweenLite.killTweensOf(UNIFORMS.opacity);
                    if (UNIFORMS.opacity.value > 0) {
                        _gsap.TweenLite.to(UNIFORMS.opacity, .5, {
                            value: 0,
                            ease: _gsap.Quad.easeInOut,
                            onComplete: function onComplete() {
                                return _this2.updatePositionsAndFadeIn(clusters)
                            }
                        })
                    } else {
                        this.updatePositionsAndFadeIn(clusters)
                    }
                }
            }, {
                key: "updatePositionsAndFadeIn",
                value: function updatePositionsAndFadeIn(clusters) {
                    for (var i = 0; i < this.size; i++) {
                        if (clusters[i]) {
                            var pos = new THREE.Vector3(clusters[i].pos.x, clusters[i].pos.y, clusters[i].pos.z);
                            pos.normalize().multiplyScalar(.5);
                            this.meshes[i].position.copy(new THREE.Vector3);
                            this.meshes[i].lookAt(pos);
                            this.meshes[i].position.copy(pos)
                        } else {
                            this.meshes[i].position.z = 100
                        }
                    }
                    _gsap.TweenLite.to(UNIFORMS.opacity, FADE_DUR, {
                        value: 1,
                        ease: _gsap.Quad.easeInOut
                    })
                }
            }, {
                key: "clear",
                value: function clear() {
                    _gsap.TweenLite.to(UNIFORMS.opacity, FADE_DUR, {
                        value: 0,
                        ease: _gsap.Quad.easeInOut
                    })
                }
            }]);
            return Glows
        }(_events.EventEmitter)
    }, {
        "./helpers": 341,
        events: 326,
        gsap: 327,
        three: 329
    }],
    341: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var HELPERS = exports.HELPERS = {
            mapRange: function mapRange(value, low1, high1, low2, high2) {
                return low2 + (high2 - low2) * (value - low1) / (high1 - low1)
            },
            xyzFromLatLng: function xyzFromLatLng(lat, lng, radius) {
                var phi = (90 - lat) * Math.PI / 180;
                var theta = (360 - lng) * Math.PI / 180;
                return {
                    x: radius * Math.sin(phi) * Math.cos(theta),
                    y: radius * Math.cos(phi),
                    z: radius * Math.sin(phi) * Math.sin(theta)
                }
            },
            distanceBetweenTwoCoordinations: function distanceBetweenTwoCoordinations(point1, point2) {
                var R = 6371e3;
                return 20
            },
            throttle: function throttle(fn) {
                var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
                var timer = null;
                var throttledFn = function throttledFn() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key]
                    }
                    if (!timer) {
                        timer = setTimeout(function() {
                            fn.apply(undefined, args);
                            timer = null
                        }, time)
                    }
                };
                throttledFn.cancel = function() {
                    clearTimeout(timer);
                    timer = null
                };
                return throttledFn
            },
            pointId: function pointId(p) {
                return p.city + p.region + p.country
            },
            cluster: function cluster(points, distance) {
                points = points.slice(0);
                var clusters = [];
                for (var i = points.length - 1; i > -1; i--) {
                    var p = points.splice(i, 1)[0];
                    var cluster = [p];
                    for (var j = i - 1; j > -1; j--) {
                        var p1 = points[j];
                        var isClose = true;
                        for (var k = 0; k < cluster.length; k++) {
                            if (HELPERS.distanceBetweenTwoCoordinations({
                                    lat: cluster[k].lat,
                                    lng: cluster[k].lon
                                }, {
                                    lat: p1.lat,
                                    lng: p1.lon
                                }) > distance) {
                                isClose = false;
                                break
                            }
                        }
                        if (isClose) {
                            cluster.push(points.splice(j, 1)[0]);
                            i--
                        }
                    }
                    clusters.push(cluster)
                }
                return clusters
            },
            parseDate: function parseDate(input) {
                var parts = input.split("-");
                return new Date(parts[0], parts[1] - 1, parts[2])
            },
            DPR: function DPR() {
                return window.devicePixelRatio < 1.5 ? window.devicePixelRatio : 1.5
            },
            distance: function distance(x1, y1, z1, x2, y2, z2) {
                var dx = x2 - x1;
                var dy = y2 - y1;
                var dz = z2 - z1;
                return Math.sqrt(dx * dx + dy * dy + dz * dz)
            },
            getTodaysDate: function getTodaysDate() {
                var d = new Date;
                var month = "" + (d.getMonth() + 1);
                var day = "" + d.getDate();
                var year = d.getFullYear();
                if (month.length < 2) month = "0" + month;
                if (day.length < 2) day = "0" + day;
                return [year, month, day].join("-")
            }
        };
        var toRadians = function toRadians(value) {
            return value * Math.PI / 180
        };
        var COLOR_SHADER = exports.COLOR_SHADER = "\nvec3 positionBasedColor(vec4 position) {\n  float xmix = min(1., max(0., (position.x / 0.25) * 0.5 + 0.5));\n  float ymix = min(1., max(0., (position.y / 0.25) * 0.5 + 0.5));\n  vec3 color =\n    vec3(.906, .278, .294) * (1. - ymix) * 0.5 +\n    vec3(.306, .259, .545) * xmix +\n    vec3(.835, .803, .392) * (1. - xmix);\n  return color;\n}\n"
    }, {}],
    342: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.HoverGlow = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _three = require("three");
        var THREE = _interopRequireWildcard(_three);
        var _events = require("events");
        var _gsap = require("gsap");
        var _helpers = require("./helpers");

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]
                    }
                }
                newObj.default = obj;
                return newObj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var VERTEX = "\nvarying vec2 v_uv;\nvarying vec3 colorP;\n\n" + _helpers.COLOR_SHADER + "\n\nvoid main() {\n  v_uv = uv;\n  vec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n  mvPosition.xy += position.xy;\n\n  colorP = positionBasedColor(modelMatrix * vec4(0.0, 0.0, 0.0, 1.0));\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n";
        var FRAG = "\nuniform float opacity;\nuniform float r;\nuniform vec2 disc; // disc.x is the radius of hover disc, disc.y is visibilty of the hover disc\nvarying vec2 v_uv;\nvarying vec3 colorP;\n\nvoid main() {\n  // Distance to center\n  float dToC = distance(v_uv, vec2(0.5));\n  // Scale position to the current radius setting\n  float _r = max(1. - dToC / r, 0.0) ; // 0 -> 1 in the center;\n  // Increase fall off\n  float c = pow(_r, 2.5);\n\n  vec3 glow = colorP * c * opacity;\n\n  // Draw disc\n  vec3 discC = vec3(1, 1, 1) * step(0.1, disc.y) * step(dToC, disc.x);\n\n  gl_FragColor = vec4(glow + discC, 1.);\n}\n";
        var SIZE = .21;
        var HoverGlow = exports.HoverGlow = function(_EventEmitter) {
            _inherits(HoverGlow, _EventEmitter);

            function HoverGlow() {
                _classCallCheck(this, HoverGlow);
                var _this = _possibleConstructorReturn(this, (HoverGlow.__proto__ || Object.getPrototypeOf(HoverGlow)).call(this));
                var texture = (new THREE.TextureLoader).load("assets/images/marker.png");
                texture.flipY = false;
                _this.uniforms = {
                    opacity: {
                        value: 0,
                        type: "f"
                    },
                    r: {
                        value: .001,
                        type: "f"
                    },
                    disc: {
                        value: new THREE.Vector2(0, 0),
                        type: "v2"
                    }
                };
                var material = new THREE.ShaderMaterial({
                    uniforms: _this.uniforms,
                    vertexShader: VERTEX,
                    fragmentShader: FRAG,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                });
                var geometry = new THREE.PlaneGeometry(SIZE, SIZE, 1);
                var plane = new THREE.Mesh(geometry, material);
                _this.mesh = plane;
                return _this
            }
            _createClass(HoverGlow, [{
                key: "moveTo",
                value: function moveTo(x, y, z) {
                    this.mesh.position.x = x;
                    this.mesh.position.y = y;
                    this.mesh.position.z = z
                }
            }, {
                key: "show",
                value: function show(small) {
                    _gsap.TweenLite.to(this.uniforms.opacity, .25, {
                        value: .8,
                        ease: _gsap.Quad.easeOut
                    });
                    _gsap.TweenLite.to(this.uniforms.r, .25, {
                        value: .5 * (small ? .35 : 1),
                        ease: _gsap.Quad.easeOut
                    });
                    this.uniforms.disc.value.x = .029;
                    this.uniforms.disc.value.y = small ? 0 : 1
                }
            }, {
                key: "hide",
                value: function hide() {
                    _gsap.TweenLite.to(this.uniforms.opacity, .2, {
                        value: 0,
                        ease: _gsap.Quad.easeInOut
                    });
                    _gsap.TweenLite.to(this.uniforms.r, .2, {
                        value: .001,
                        ease: _gsap.Quad.easeInOut
                    });
                    this.uniforms.disc.value.y = 0
                }
            }]);
            return HoverGlow
        }(_events.EventEmitter)
    }, {
        "./helpers": 341,
        events: 326,
        gsap: 327,
        three: 329
    }],
    343: [function(require, module, exports) {
        (function(root) {
            "use strict";
            var Klang;
            window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;

            function Main(func) {
                Klang = func()
            }

            function Module(func) {
                func(Klang)
            }
            Main(function() {
                var Klang = {};
                Klang.version = Klang.versionNumber = 3;
                Klang.context = null;
                Klang.engineVersion = "N/A";
                Klang.progressCallback = null;
                Klang.readyCallback = null;
                Klang.browser = null;
                Klang.os = null;
                Klang.isMobile = null;
                Klang.isIOS = null;
                Klang.fallback = null;
                Klang.loggingEnabled = false;
                Klang.useMonoBuffers = false;
                Klang.Panner = null;
                Klang.safari = false;
                Klang.Model = {};
                return Klang
            });
            Module(function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext
            });
            Module(function(Klang) {
                return Klang.Model.Data = function(data, name) {
                    this.data = data.data;
                    this._name = name
                }
            });
            Module(function(Klang) {
                return Klang.core = {}
            });
            Module(function(Klang) {
                (function(detector) {
                    var supportedAudioFileSuffixes;

                    function detectAudioFileSuffixes() {
                        var a = window.document.createElement("audio");
                        if (!a.canPlayType) {
                            return false
                        }
                        var supportedFileTypes = [];
                        if (a.canPlayType('audio/ogg; codecs="vorbis"').replace(/no/, "")) {
                            supportedFileTypes.push(".ogg")
                        }
                        if (a.canPlayType("audio/aac").replace(/no/, "")) {
                            supportedFileTypes.push(".m4a")
                        }
                        if (a.canPlayType("audio/mpeg;").replace(/no/, "")) {
                            supportedFileTypes.push(".mp3")
                        }
                        return supportedFileTypes
                    }

                    function canPlayAudioSuffix(suffix) {
                        supportedAudioFileSuffixes = supportedAudioFileSuffixes || detectAudioFileSuffixes();
                        for (var i = 0; i < supportedAudioFileSuffixes.length; i++) {
                            if (supportedAudioFileSuffixes[i] === suffix) {
                                return true
                            }
                        }
                        return false
                    }
                    detector.canPlayAudioSuffix = canPlayAudioSuffix;

                    function detectBrowser() {
                        var ua = navigator.userAgent;
                        var temp;
                        var match = ua.match(/(edge(?=\/))\/?\s*(\d+)/i) || [];
                        if (match.length == 0) {
                            match = ua.match(/(edge|opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []
                        }
                        if (/trident/i.test(match[1])) {
                            temp = /\brv[ :]+(\d+)/g.exec(ua) || [];
                            return {
                                name: "IE",
                                version: temp[1] || "unknown"
                            }
                        }
                        if (match[1] === "Chrome") {
                            temp = ua.match(/\bOPR\/(\d+)/);
                            if (temp !== null) {
                                return {
                                    name: "Opera",
                                    version: temp[1]
                                }
                            }
                        }
                        match = match[2] ? [match[1], match[2]] : [navigator.appName, navigator.appVersion, "-?"];
                        if ((temp = ua.match(/version\/(\d+)/i)) !== null) {
                            match.splice(1, 1, temp[1])
                        }
                        return {
                            name: match[0],
                            version: parseInt(match[1])
                        }
                    }
                    detector.browser = detectBrowser()
                })(Klang.detector || (Klang.detector = {}));
                var detector = Klang.detector;
                return Klang.core.detector = detector
            });
            Module(function(Klang) {
                (function(network) {
                    function isCrossDomain(url) {
                        var target = document.createElement("a");
                        target.href = url;
                        var host = document.createElement("a");
                        host.href = location.href;
                        var crossdomain = target.hostname != "" && (target.port != host.port || target.protocol != host.protocol || target.hostname != host.hostname);
                        return crossdomain
                    }
                    network.isCrossDomain = isCrossDomain;

                    function request(options, onDone, onProgress, onError) {
                        var request;
                        options.type = options.type || "GET";
                        if (Klang.detector.browser["name"] == "MSIE" && Klang.detector.browser["version"] < 10) {
                            request = new window["XDomainRequest"];
                            request.onload = function() {
                                setTimeout(function() {
                                    onDone && onDone(request.responseText)
                                }, 10)
                            };
                            request.onprogress = onProgress || function() {};
                            request.onerror = onError || function() {};
                            request.open(options.type, options.url, true)
                        } else if (window["XMLHttpRequest"]) {
                            request = new XMLHttpRequest;
                            request.open(options.type, options.url, true);
                            request.onreadystatechange = function() {
                                try {
                                    if (request.readyState == 4 && request.status == 200) {
                                        if (onDone) {
                                            var response = request.responseText;
                                            onDone(response)
                                        }
                                    } else if (request.status != 0 && request.status != 200) {
                                        if (onError) {
                                            onError({
                                                status: request.status
                                            })
                                        }
                                    }
                                } catch (e) {
                                    throw e;
                                    if (onError) {
                                        onError({
                                            status: "aborted"
                                        })
                                    }
                                }
                            }
                        } else {
                            throw "Error - browser does not support XDomain/XMLHttp Requests"
                        }
                        if (request) {
                            request.send(null)
                        }
                    }
                    network.request = request
                })(Klang.network || (Klang.network = {}));
                var network = Klang.network;
                return Klang.core.network = network
            });
            Module(function(Klang) {
                function FileHandler() {
                    this.memUsage = 0;
                    this._decoding = false;
                    this._files = {};
                    this._bufferQue = [];
                    this._groups = {};
                    this._lastSentPercent = -1;
                    this.deferDecoding = false;
                    this.stremingFileIds = []
                }
                FileHandler.inst = null;
                Object.defineProperty(FileHandler, "instance", {
                    get: function() {
                        if (FileHandler.inst == null) {
                            FileHandler.inst = new FileHandler
                        }
                        return FileHandler.inst
                    },
                    enumerable: true,
                    configurable: true
                });
                FileHandler.prototype.sendProgressCallback = function(group) {
                    var loadGroup = this._groups[group];
                    if (loadGroup.progressCallback && !loadGroup.loadInterrupted) {
                        var percent = 0;
                        if (loadGroup.progress.readyAudioFiles >= loadGroup.progress.totalAudioFiles) {
                            percent = Math.floor((loadGroup.progress.loadedBytes + loadGroup.progress.bufferedFiles) / (loadGroup.progress.totalBytes + loadGroup.progress.totalFiles) * (100 - (loadGroup.progress.totalFiles - loadGroup.progress.convertedFiles)))
                        }
                        if (this._lastSentPercent !== percent) {
                            loadGroup.progressCallback(percent)
                        }
                        this._lastSentPercent = percent
                    }
                };
                FileHandler.prototype.updateProgress = function(request, e) {
                    var group = request["load_group"];
                    if (!request["sizeReceived"]) {
                        request["sizeReceived"] = true;
                        var totalBytes = 1;
                        if (e.lengthComputable) {
                            totalBytes = e.total;
                            request["loadedBytes"] = 0
                        }
                        request["totalBytes"] = totalBytes;
                        this._groups[group].progress.totalBytes += totalBytes;
                        this._groups[group].progress.readyAudioFiles++
                    }
                    if (request["loadedBytes"] !== undefined) {
                        var deltaBytes = e.loaded - request["loadedBytes"];
                        request["loadedBytes"] = e.loaded;
                        this._groups[group].progress.loadedBytes += deltaBytes;
                        this.sendProgressCallback(group)
                    }
                };
                FileHandler.prototype.decodeBufferQue = function() {
                    var _this = this;
                    if (this._bufferQue.length) {
                        var queItem = this._bufferQue.pop();
                        var data = queItem.data;
                        var info = queItem.info;
                        var callback = queItem.callback;
                        this._decoding = true;
                        Klang.context.decodeAudioData(data, function(buf) {
                            var group = _this._groups[info.load_group];
                            _this._decoding = false;
                            if (Klang.useMonoBuffers) {
                                var bufferLength = buf.length;
                                var monoBuffer = Klang.context.createBuffer(1, bufferLength, Klang.context.sampleRate);
                                var leftChannelData = buf.getChannelData(0);
                                var monoChannelData = monoBuffer.getChannelData(0);
                                if (typeof monoChannelData.set === "function") {
                                    monoChannelData.set(leftChannelData)
                                } else {
                                    for (var ix = 0; ix < bufferLength; ix++) {
                                        monoChannelData[ix] = leftChannelData[ix]
                                    }
                                    buf = monoBuffer
                                }
                            }
                            if (Klang.downSample && Klang.downSample !== Klang.context.sampleRate) {
                                buf = Klang.Util.downSample(buf, Klang.downSample)
                            }
                            _this.memUsage += buf.length * buf.numberOfChannels * Float32Array.BYTES_PER_ELEMENT;
                            var memUsageBytes = _this.memUsage;
                            var memUsageMb = memUsageBytes / 1e6;
                            _this.addFile(info, buf);
                            group.progress.convertedFiles++;
                            queItem.data = null;
                            if (_this._bufferQue.length) {
                                _this.decodeBufferQue()
                            } else if (callback) {
                                callback()
                            }
                        }, function(ex) {
                            Klang.log("Klang warning: unable to load file '" + (this._baseURL || "") + info.url + "'")
                        })
                    }
                };
                FileHandler.prototype.decode = FileHandler.prototype.decodeBufferQue;
                FileHandler.prototype.loadAudioBuffer = function(info, callback) {
                    var _this = this;
                    var request = new XMLHttpRequest;
                    var format = ".mp3";
                    if (Klang.detector.browser["name"] === "Firefox" || Klang.detector.browser["name"] === "Chrome") {
                        format = ".ogg"
                    }
                    var url = (info.external ? "" : this._baseURL) + info.url + format;
                    request.open("GET", url, true);
                    request.responseType = "arraybuffer";
                    request["sizeReceived"] = false;
                    request["load_group"] = info.load_group;
                    request.onprogress = function(e) {
                        _this.updateProgress(request, e)
                    };
                    request.onload = function(e) {
                        var group = _this._groups[info.load_group];
                        var queueItem = {
                            data: request.response,
                            load_group: group,
                            info: info,
                            callback: callback
                        };
                        _this._bufferQue.push(queueItem);
                        if (request["loadedBytes"]) {
                            var deltaBytes = request["totalBytes"] - request["loadedBytes"];
                            group.progress.loadedBytes += deltaBytes
                        } else {
                            group.progress.loadedBytes += 1
                        }
                        _this.updateProgress(request, e);
                        if (!_this.deferDecoding) {
                            _this.decodeBufferQue()
                        } else {
                            queueItem.callback && queueItem.callback();
                            queueItem.load_group.progress.bufferedFiles++;
                            if (queueItem.load_group.progress.bufferedFiles === queueItem.load_group.progress.totalFiles) {
                                queueItem.load_group.filesLoadedCallback(true, queueItem.load_group._loadedFiles)
                            }
                        }
                        try {
                            request.response = null
                        } catch (e) {}
                        request = null
                    };
                    request.onreadystatechange = function() {
                        if (request.readyState == 4 && request.status == 200) {} else if (request.status != 200) {
                            _this._groups[info.load_group].loadInterrupted = true;
                            if (_this._groups[info.load_group].loadFailedCallback) {
                                _this._groups[info.load_group].loadFailedCallback()
                            }
                        }
                    };
                    request.send();
                    this._groups[info.load_group].progress.totalAudioFiles++
                };
                FileHandler.prototype.loadMidiFile = function(info, callback) {
                    var _this = this;
                    loadRemote(this._baseURL + info.url, function(request, e) {
                        _this.updateProgress(request, e)
                    }, function(data) {
                        _this.addFile(info, readMidiFile(data));
                        if (callback) {
                            callback()
                        }
                    })
                };
                FileHandler.prototype.loadMidiString = function(info) {
                    var _this = this;
                    var request = new XMLHttpRequest;
                    request.open("GET", this._baseURL + info.url);
                    request.onprogress = function(e) {
                        _this.updateProgress(request, e)
                    };
                    request.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            _this.addFile(info, readMidiString(request.response))
                        }
                    };
                    request.send()
                };
                FileHandler.prototype.loadFiles = function(group, filesLoadedCallback, progressCallback, loadFailedCallback) {
                    if (typeof group == "string") {
                        group = [group]
                    }
                    var groupsToLoad = group.length;
                    var _filesLoadedCallback = function() {
                        groupsToLoad--;
                        if (groupsToLoad === 0) {
                            filesLoadedCallback && filesLoadedCallback.apply(this, arguments)
                        }
                    };
                    var loadProgression = {};
                    var _progressCallback = function(prog) {
                        if (progressCallback) {
                            loadProgression[this.name] = prog;
                            var cnt = 0;
                            var totProg = 0;
                            for (var key in loadProgression) {
                                if (loadProgression.hasOwnProperty(key)) {
                                    cnt++;
                                    totProg += loadProgression[key]
                                }
                            }
                            totProg /= cnt;
                            progressCallback(totProg)
                        }
                    };
                    var _loadFailedCallback = function() {
                        _filesLoadedCallback()
                    };
                    for (var ix = 0, len = group.length; ix < len; ix++) {
                        loadProgression[group[ix]] = 0;
                        this._groups[group[ix]] = {};
                        this._groups[group[ix]]._loadedFiles = [];
                        this._groups[group[ix]].filesLoadedCallback = _filesLoadedCallback;
                        this._groups[group[ix]].progressCallback = _progressCallback.bind(this._groups[group[ix]]);
                        this._groups[group[ix]].loadFailedCallback = _loadFailedCallback;
                        this._groups[group[ix]].loadInterrupted = false;
                        this._groups[group[ix]].name = group[ix];
                        this._groups[group[ix]].progress = {
                            totalBytes: 0,
                            loadedBytes: 0,
                            totalFiles: 0,
                            totalAudioFiles: 0,
                            readyAudioFiles: 0,
                            bufferedFiles: 0,
                            convertedFiles: 0
                        }
                    }
                    this.checkStreaming();
                    for (var ix = 0, len = this._fileInfo.length; ix < len; ix++) {
                        var info = this._fileInfo[ix];
                        var groupIx = group.indexOf(info.load_group);
                        if (groupIx != -1 && !this._files[info.id] && !info.only_audio_tag) {
                            switch (info.file_type) {
                                case "audio":
                                    if (this.stremingFileIds.indexOf(info.id) === -1) {
                                        this.loadAudioBuffer(info)
                                    } else {
                                        continue
                                    }
                                    break;
                                case "midi":
                                    this.loadMidiFile(info);
                                    break;
                                case "midistring":
                                    this.loadMidiString(info);
                                    break
                            }
                            this._groups[group[groupIx]].progress.totalFiles++
                        }
                    }
                    for (var ix = 0, len = group.length; ix < len; ix++) {
                        if (this._groups[group[ix]].progress.totalFiles == 0) {
                            if (this._groups[group[ix]].filesLoadedCallback && !this._groups[group[ix]]._loadInterrupted) {
                                this._groups[group[ix]].filesLoadedCallback(true, this._groups[group[ix]]._loadedFiles)
                            }
                        }
                    }
                };
                FileHandler.prototype.checkStreaming = function() {
                    var objects = Klang.core.Core.instance._objectTable;
                    for (var key in objects) {
                        var object = objects[key];
                        if (object instanceof Klang.Model.StreamingAudioSource) {
                            var fileId = object._fileId;
                            this.stremingFileIds.push(fileId)
                        }
                    }
                };
                FileHandler.prototype.prepareFile = function(fileInfo) {
                    this._fileInfo.push(fileInfo)
                };
                FileHandler.prototype.prepareFiles = function(fileInfo) {
                    var i, len;
                    for (i = 0, len = fileInfo.length; i < len; i++) {
                        this.prepareFile(fileInfo[i])
                    }
                };
                FileHandler.prototype.addFile = function(info, file) {
                    this._files[info.id] = file;
                    this._groups[info.load_group].progress.bufferedFiles++;
                    this._groups[info.load_group]._loadedFiles = this._groups[info.load_group]._loadedFiles || [];
                    this._groups[info.load_group]._loadedFiles.push(info);
                    this.sendProgressCallback(info.load_group);
                    if (this._groups[info.load_group].progress.bufferedFiles == this._groups[info.load_group].progress.totalFiles && !this._groups[info.load_group].loadInterrupted) {
                        if (this._groups[info.load_group].filesLoadedCallback) {
                            this._groups[info.load_group].filesLoadedCallback(true, this._groups[info.load_group]._loadedFiles || [])
                        }
                    }
                };
                FileHandler.prototype.freeSoundFiles = function(group) {
                    if (typeof group == "string") {
                        group = [group]
                    }
                    for (var ix = 0, len = this._fileInfo.length; ix < len; ix++) {
                        var info = this._fileInfo[ix];
                        if (group.indexOf(info.load_group) != -1) {
                            this._files[info.id] = null
                        }
                    }
                };
                FileHandler.prototype.freeSoundFile = function(id) {
                    if (this._files[id]) {
                        this._files[id] = null
                    }
                };
                FileHandler.prototype.getLoadGroups = function() {
                    var i;
                    var fileInfoArr = this._fileInfo || [];
                    var groupTable = {};
                    var listOfGroups = [];
                    for (i = 0; i < fileInfoArr.length; i++) {
                        var fileInfo = fileInfoArr[i];
                        groupTable[fileInfo.load_group] = fileInfo.load_group
                    }
                    for (i in groupTable) {
                        listOfGroups.push(i)
                    }
                    return listOfGroups
                };
                FileHandler.prototype.getFile = function(id) {
                    return this._files[id] || null
                };
                FileHandler.prototype.getFilesForLoadgroup = function(loadGroup) {
                    var ret = [];
                    for (var ix = 0, len = this._fileInfo.length; ix < len; ix++) {
                        if (this._fileInfo[ix].load_group == loadGroup) {
                            ret.push(this._fileInfo[ix])
                        }
                    }
                    return ret
                };
                FileHandler.prototype.getFileInfo = function(fileId) {
                    for (var ix = 0, len = this._fileInfo.length; ix < len; ix++) {
                        if (this._fileInfo[ix].id == fileId) {
                            return this._fileInfo[ix]
                        }
                    }
                    return undefined
                };
                FileHandler.prototype.preloadFiles = function(loadgroups) {};
                Object.defineProperty(FileHandler.prototype, "progress", {
                    get: function() {
                        return this._groups
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileHandler.prototype, "baseURL", {
                    set: function(url) {
                        this._baseURL = url
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileHandler.prototype, "fileInfo", {
                    set: function(fileInfo) {
                        this._fileInfo = fileInfo
                    },
                    enumerable: true,
                    configurable: true
                });
                return Klang.core.FileHandler = FileHandler
            });
            Module(function(Klang) {
                function Scheduler() {
                    this._updateTime = 100;
                    this._lookAHead = this._updateTime * 2;
                    this._callbacks = []
                }
                Scheduler.prototype.scheduleClose = function(callback) {
                    var timeOffset = callback.targetTime - Klang.context.currentTime;
                    setTimeout(function() {
                        callback.func.apply(callback.ctx)
                    }, timeOffset * 1e3)
                };
                Scheduler.prototype.runScheduler = function() {
                    if (this._callbacks.length > 0) {
                        var currentTime = Klang.context.currentTime;
                        for (var ix = 0; ix < this._callbacks.length; ix++) {
                            var callback = this._callbacks[ix];
                            if (currentTime + this._lookAHead >= callback.targetTime) {
                                this.scheduleClose(callback);
                                this._callbacks.splice(ix, 1);
                                ix--
                            }
                        }
                        this._lastTime = currentTime;
                        var _this = this;
                        this._scheduler = setTimeout(function() {
                            _this.runScheduler()
                        }, _this._updateTime)
                    } else {
                        this.stop()
                    }
                };
                Scheduler.prototype.start = function() {
                    this._started = true;
                    this._lastTime = Klang.context.currentTime;
                    clearTimeout(this._scheduler);
                    this.runScheduler()
                };
                Scheduler.prototype.stop = function() {
                    this._started = false;
                    clearTimeout(this._scheduler);
                    this._scheduler = null
                };
                Scheduler.prototype.delay = function(targetTime, func, ctx) {
                    return this.at(Klang.context.currentTime + targetTime, func, ctx)
                };
                Scheduler.prototype.at = function(targetTime, func, ctx) {
                    if (targetTime < Klang.context.currentTime) {
                        return this
                    }
                    this._callbacks.push({
                        ctx: ctx || this,
                        func: func,
                        targetTime: targetTime
                    });
                    if (!this._started) {
                        this.start()
                    }
                    return this
                };
                Scheduler.prototype.cancel = function(func) {
                    for (var i = 0; i < this._callbacks.length; i++) {
                        if (this._callbacks[i]["func"] && this._callbacks[i]["func"] === func) {
                            this._callbacks.splice(i, 1);
                            break
                        }
                    }
                    return this
                };
                return Klang.core.Scheduler = Scheduler
            });
            Module(function(Klang) {
                function TimeHandler() {
                    this._callbacks = []
                }
                TimeHandler.inst = null;
                Object.defineProperty(TimeHandler, "instance", {
                    get: function() {
                        if (TimeHandler.inst == null) {
                            TimeHandler.inst = new TimeHandler
                        }
                        return TimeHandler.inst
                    },
                    enumerable: true,
                    configurable: true
                });
                TimeHandler.prototype.startScheduler = function() {
                    if (this._callbacks.length > 0) {
                        var currentTime = Klang.context.currentTime;
                        var deltaTime = currentTime - this._lastTime;
                        for (var ix = 0; ix < this._callbacks.length; ix++) {
                            var callback = this._callbacks[ix];
                            callback.timePassed += deltaTime;
                            if (callback.timePassed >= callback.targetTime) {
                                callback.obj[callback.func]();
                                this._callbacks.splice(ix, 1);
                                ix--
                            }
                        }
                        this._lastTime = currentTime;
                        var _this = this;
                        this._scheduler = setTimeout(function() {
                            _this.startScheduler()
                        }, Klang.core.Core.settings.timehandler_lookahead)
                    } else {
                        this.stop()
                    }
                };
                TimeHandler.prototype.start = function() {
                    this._started = true;
                    this._lastTime = Klang.context.currentTime;
                    clearTimeout(this._scheduler);
                    this.startScheduler()
                };
                TimeHandler.prototype.stop = function() {
                    this._started = false;
                    clearTimeout(this._scheduler);
                    this._scheduler = null
                };
                TimeHandler.prototype.registerMethodCallback = function(obj, func, targetTime) {
                    this._callbacks.push({
                        obj: obj,
                        func: func,
                        timePassed: 0,
                        targetTime: targetTime
                    });
                    if (!this._started) {
                        this.start()
                    }
                    return this
                };
                TimeHandler.prototype.removeMethodCallback = function(obj, func) {
                    for (var ix = 0, len = this._callbacks.length; ix < len; ix++) {
                        var callback = this._callbacks[ix];
                        if (callback.obj == obj && callback.func == func) {
                            this._callbacks.splice(ix, 1);
                            return
                        }
                    }
                    return this
                };
                return Klang.core.TimeHandler = TimeHandler
            });
            Module(function(Klang) {
                var Util;
                (function(Util) {
                    function setParam(param, value, when) {
                        param.setValueAtTime(value, when || Klang.context.currentTime)
                    }
                    Util.setParam = setParam;

                    function adjustParam(param, value, when) {
                        param.setValueAtTime(param.value + value, when || Klang.context.currentTime)
                    }
                    Util.adjustParam = adjustParam;

                    function curveParamLin(param, value, duration, when, startValue) {
                        when = when || Klang.context.currentTime;
                        var startAt = param.value;
                        if (startValue !== undefined && Klang.detector.browser["name"] == "Firefox") {
                            startAt = startValue
                        }
                        param.setValueAtTime(startAt, when);
                        param.linearRampToValueAtTime(value, Klang.context.currentTime + duration)
                    }
                    Util.curveParamLin = curveParamLin;

                    function curveParamExp(param, value, duration, when, startValue) {
                        when = when || Klang.context.currentTime;
                        var startAt = param.value;
                        if (startValue !== undefined && Klang.detector.browser["name"] == "Firefox") {
                            startAt = startValue
                        }
                        param.setValueAtTime(startAt == 0 ? Util.EXP_MIN_VALUE : startAt, when);
                        param.exponentialRampToValueAtTime(value, Klang.context.currentTime + duration)
                    }
                    Util.curveParamExp = curveParamExp;

                    function curveParam(param, curve, duration, when) {
                        when = when || Klang.context.currentTime;
                        param.setValueCurveAtTime(Util.CUSTOM_CURVES[curve], when, duration)
                    }
                    Util.curveParam = curveParam;
                    Util.CUSTOM_CURVES = {};

                    function createCurves(data) {
                        for (var name in data) {
                            var cdata = data[name];
                            if (cdata instanceof Array) {
                                var curve = new Float32Array(cdata.length);
                                for (var ix = 0, len = cdata.length; ix < len; ix++) {
                                    curve[ix] = cdata[ix]
                                }
                            } else {
                                if (!cdata.curve_type) {
                                    Klang.warn("Modulation: Curve type not specified")
                                }
                                if (!cdata.resolution) {
                                    cdata.resolution = 1024
                                }
                                if (!cdata.amplitude) {
                                    cdata.amplitude = 1
                                }
                                if (!cdata.amplitude_offset) {
                                    cdata.amplitude_offset = 0
                                }
                                if (!cdata.phase_offset) {
                                    cdata.phase_offset = 0
                                }
                                if (!cdata.length) {
                                    cdata.length = 1
                                }
                                var curve = new Float32Array(cdata.resolution);
                                if (cdata.curve_type == "sine") {
                                    var phase_offset = cdata.phase_offset * Math.PI * 2;
                                    var length = cdata.length * Math.PI * 2;
                                    for (var ix = 0, len = curve.length; ix < len; ix++) {
                                        curve[ix] = cdata.amplitude_offset + Math.sin(phase_offset + ix / len * length) * cdata.amplitude
                                    }
                                } else if (cdata.curve_type == "saw") {
                                    for (var ix = 0, len = curve.length; ix < len; ix++) {
                                        curve[ix] = cdata.amplitude_offset + (len - ix) / len * cdata.amplitude
                                    }
                                } else if (cdata.curve_type == "inverse-saw") {
                                    for (var ix = 0, len = curve.length; ix < len; ix++) {
                                        curve[ix] = cdata.amplitude_offset + ix / len * cdata.amplitude
                                    }
                                } else {
                                    Klang.warn("Modulation: Unrecognized curve type")
                                }
                                Util.CUSTOM_CURVES[name] = curve
                            }
                        }
                    }
                    Util.createCurves = createCurves;
                    if (navigator.userAgent.indexOf("MSIE") != -1) {
                        var ie = true;
                        var ua = navigator.userAgent;
                        var re = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
                        var ieVersion;
                        if (re.exec(ua) != null) {
                            ieVersion = parseInt(RegExp.$1)
                        }
                        if (ieVersion < 9) {
                            Object.defineProperty = Object["oldDefineProperty"];
                            delete Object["oldDefineProperty"]
                        }
                    }
                    Util.ROOT12 = 1.059463094359295;
                    Util.NYQUIST_FREQUENCY = 22050;
                    Util.PITCH_SHIFT_FFT = 2048;
                    Util.EXP_MIN_VALUE = 1e-4;
                    Util.OSC_START_DELAY = .005;
                    Util.LOG_TIME_COLOR = "#999999";
                    Util.LOG_EVENT_COLOR = "#54CBDD";
                    Util.LOG_UNIMPLEMENTED_EVENT_COLOR = "#E075A9";
                    Util.LOG_LOAD_COLOR = "#333333";
                    Util.LOG_WARN_COLOR = "DarkOrange";
                    Util.LOG_ERROR_COLOR = "Red";

                    function applyMixins(derivedCtor, baseCtors) {
                        baseCtors.forEach(function(baseCtor) {
                            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name) {
                                derivedCtor.prototype[name] = baseCtor.prototype[name]
                            })
                        })
                    }
                    Util.lastEvent = undefined;
                    Util.clamp = function(value, min, max) {
                        return Math.max(min, Math.min(max, value))
                    };
                    Util.clamp01 = function(value) {
                        return Util.clamp(value, 0, 1)
                    };
                    Util.vars = {};

                    function random(max, min) {
                        min !== undefined ? min : 1;
                        return Math.floor(min + (1 + max - min) * Math.random())
                    }
                    Util.random = random;

                    function randomFloat(max, min) {
                        min !== undefined ? min : 1;
                        return min + (max - min) * Math.random()
                    }
                    Util.randomFloat = randomFloat;

                    function loadScriptFile(url, success, fail) {
                        var script = document.createElement("script");
                        script.async = true;
                        script.onload = function() {
                            success && success();
                            script.onload = null
                        };
                        script.onerror = function(e) {
                            fail && fail(e);
                            script.onerror = null
                        };
                        script.src = url;
                        document.getElementsByTagName("head")[0].appendChild(script)
                    }
                    Util.loadScriptFile = loadScriptFile;

                    function ease(current, delta, ease) {
                        if (typeof ease === "undefined") {
                            ease = 3
                        }
                        return current - (current - delta) / ease
                    }
                    Util.ease = ease;

                    function now() {
                        return Klang.engineVersion == "webaudio" ? Klang.context.currentTime : 0
                    }
                    Util.now = now;

                    function downSample(buffer, sampleRate) {
                        var ratio = sampleRate / Klang.context.sampleRate;
                        var stepLen = Math.floor(1 / ratio);
                        var newLen = Math.floor(buffer.length * ratio);
                        var newSampleRate = Math.floor(Klang.context.sampleRate * ratio);
                        var downSampleBuff = Klang.context.createBuffer(buffer.numberOfChannels, newLen, newSampleRate);
                        for (var c = 0; c < buffer.numberOfChannels; c++) {
                            var buffDataIn = buffer.getChannelData(c);
                            var buffDataOut = downSampleBuff.getChannelData(c);
                            var j = 0;
                            for (var i = 0; i < buffDataIn.length; i += stepLen) {
                                var acc = 0;
                                for (var j = 0; j < stepLen; j++) {
                                    acc += buffDataIn[i + j]
                                }
                                buffDataOut[i / stepLen] = acc / stepLen
                            }
                        }
                        return downSampleBuff
                    }
                    Util.downSample = downSample;

                    function semitonesToPlaybackRate(semitones) {
                        var semitoneRatio = Math.pow(2, 1 / 12);
                        var playbackRate = Math.pow(semitoneRatio, semitones);
                        return playbackRate
                    }
                    Util.semitonesToPlaybackRate = semitonesToPlaybackRate;

                    function midiNoteToFrequency(note) {
                        return 440 * Math.pow(2, (note - 69) / 12)
                    }
                    Util.midiNoteToFrequency = midiNoteToFrequency;

                    function frequencyToMidiNote(freq) {
                        return 69 + 12 * Math.log(freq / 440) / Math.log(2)
                    }
                    Util.frequencyToMidiNote = frequencyToMidiNote;

                    function safeFilterType(filterType) {
                        if (filterType === undefined) {
                            return "lowpass"
                        }
                        return filterType
                    }
                    Util.safeFilterType = safeFilterType;

                    function checkMobile() {
                        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
                    }
                    Util.checkMobile = checkMobile;

                    function checkIOS() {
                        return /(iPad|iPhone|iPod)/g.test(navigator.userAgent)
                    }
                    Util.checkIOS = checkIOS;

                    function setBlurFadeOut(state) {
                        Klang.core.Core.instance.blurFadeOut = state
                    }
                    Util.setBlurFadeOut = setBlurFadeOut;

                    function getParameterByName(name) {
                        name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                        var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
                            results = regex.exec(location.search);
                        return results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "))
                    }
                    Util.getParameterByName = getParameterByName;

                    function transition(from, to, bpm, sync, fadeOutTime, fadeInTime, useOffset, fadeOutImmediately) {
                        var i = 0;
                        var bpm = bpm || 120;
                        var fadeOutTime = fadeOutTime || 2;
                        var toStop = [];
                        if (!to) {
                            return Util.now()
                        }
                        if (from && !Array.isArray(from)) {
                            from = [from]
                        }
                        if (from) {
                            var playingLoop;
                            for (i = 0; i < from.length; i++) {
                                if (from[i].playing || from[i].scheduledToPlay()) {
                                    if (playingLoop && playingLoop.scheduledToPlay() && from[i].playing) {
                                        playingLoop = from[i]
                                    } else {
                                        playingLoop = playingLoop || from[i]
                                    }
                                    if (!from[i]._stopping && from[i] !== to) {
                                        toStop.push(from[i])
                                    }
                                }
                            }
                            from = playingLoop
                        }
                        if (from === to && !from._stopping) {
                            return Util.now()
                        }
                        if (!from) {
                            to.play(Util.now(), 0, false);
                            return Util.now()
                        }
                        var bps = 60 / bpm;
                        var spb = bpm / 60;
                        var p1 = from ? from.position : 0;
                        p1 = p1 || 0;
                        var beat1 = p1 * spb;
                        var sync = sync || 4;
                        var toNextBar = sync - beat1 % sync;
                        if (toNextBar < .5) {
                            toNextBar += sync
                        }
                        while (fadeOutImmediately && toNextBar < fadeOutTime * spb) {
                            toNextBar += sync
                        }
                        var toNextBarSec = toNextBar * bps;
                        if (!from.playing) {
                            toNextBarSec = 0
                        }
                        var scheduleTime = Util.now() + toNextBarSec;
                        var offset = 0;
                        if (useOffset) {
                            offset = from.position + toNextBarSec
                        }
                        if (fadeInTime) {
                            to.fadeInAndPlay(fadeInTime, scheduleTime, offset)
                        } else {
                            to.play(scheduleTime, offset, false)
                        }
                        var fadeOutStartTime = fadeOutImmediately ? scheduleTime - fadeOutTime : scheduleTime;
                        if (fadeOutImmediately && fadeOutStartTime < Klang.context.currentTime) {
                            fadeOutTime = scheduleTime - Klang.context.currentTime
                        }
                        for (i = 0; i < toStop.length; i++) {
                            toStop[i].fadeOutAndStop(fadeOutTime, fadeOutStartTime)
                        }
                        return scheduleTime
                    }
                    Util.transition = transition;

                    function getTimeToBeat(from, bpm, sync, offset) {
                        var bpm = bpm || 120;
                        var from = from;
                        var offset = offset || 0;
                        if (Array.isArray(from)) {
                            var playingLoop;
                            for (var i = 0; i < from.length; i++) {
                                if (from[i].playing) {
                                    playingLoop = from[i];
                                    break
                                }
                            }
                            from = playingLoop
                        }
                        if (!from) {
                            return
                        }
                        var bps = 60 / bpm;
                        var spb = bpm / 60;
                        var p1 = from.position;
                        p1 = p1 || 0;
                        if (from._loopStart > 0) {
                            if (p1 < from._loopStart) {
                                p1 = 0
                            } else {
                                p1 -= from._loopStart
                            }
                        }
                        var beat1 = p1 * spb;
                        var sync = sync || 4;
                        var toNextBar = sync - beat1 % sync;
                        toNextBar += offset;
                        var toNextBarSec = toNextBar * bps;
                        if (!from.playing) {
                            toNextBarSec = 0
                        }
                        return toNextBarSec
                    }
                    Util.getTimeToBeat = getTimeToBeat;

                    function stopPlayingExcept() {
                        var exceptions = [];
                        for (var _i = 0; _i < arguments.length - 0; _i++) {
                            exceptions[_i] = arguments[_i + 0]
                        }
                        var sequencerArgs = [{
                            beat: 0,
                            fadeOut: 2
                        }];
                        for (var ix = exceptions.length - 1; ix >= 0; ix--) {
                            var instance = Klang.core.Core.instance.findInstance(exceptions[ix]);
                            if (instance.type == "Pattern") {
                                sequencerArgs.push(exceptions[ix])
                            }
                        }
                        var objects = Klang.core.Core.instance._objectTable;
                        for (var o in Klang.core.Core.instance._objectTable) {
                            var obj = objects[o];
                            if (obj._type == "AudioSource" && exceptions.indexOf(o) == -1) {
                                if (obj.loop && obj.playing) {
                                    obj.fadeOutAndStop(1)
                                }
                            } else if (obj._type == "Sequencer") {
                                obj.stopAll.apply(obj, sequencerArgs)
                            } else if (obj._type == "AdvancedProcess") {
                                if (obj.started && exceptions.indexOf(o) == -1) {
                                    obj.stop()
                                }
                            }
                        }
                    }
                    Util.stopPlayingExcept = stopPlayingExcept;

                    function shuffle(array) {
                        var counter = array.length,
                            temp, index;
                        while (counter--) {
                            index = Math.random() * counter | 0;
                            temp = array[counter];
                            array[counter] = array[index];
                            array[index] = temp
                        }
                        return array
                    }
                    Util.shuffle = shuffle;

                    function cloneObject(obj) {
                        if (obj === null || typeof obj !== "object") {
                            return obj
                        }
                        var temp = obj.constructor();
                        for (var key in obj) {
                            temp[key] = cloneObject(obj[key])
                        }
                        return temp
                    }
                    Util.cloneObject = cloneObject;

                    function logFreq(value) {
                        if (value == 0) {
                            return 0
                        }
                        var min = 20;
                        var max = 2e4;
                        if (min == 0) {
                            min = .01
                        }
                        var position = value;
                        var minp = min;
                        var maxp = max;
                        var minv = Math.log(minp);
                        var maxv = Math.log(maxp);
                        var scale = (maxv - minv) / (maxp - minp);
                        return Math.exp(minv + scale * (position - minp))
                    }
                    Util.logFreq = logFreq;

                    function generateIdString(len) {
                        var seed = "";
                        while (seed.length < len) {
                            seed += "0"
                        }
                        return (seed + (Math.random() * Math.pow(36, len) << 0).toString(36)).slice(-len)
                    }
                    Util.generateIdString = generateIdString;
                    Util.MidiHandler = {
                        midiAccess: null,
                        midiIn: null,
                        midiOut: null,
                        inputs: [],
                        outputs: [],
                        init: function(done) {
                            this.MIDIUtils.initUtils();
                            var _this = this;
                            window["navigator"].requestMIDIAccess().then(function(e) {
                                _this.onMIDIStarted(e);
                                done && done()
                            }, this.onMIDISystemError)
                        },
                        onMIDISystemError: function(msg) {
                            console.log("Error encountered:", msg)
                        },
                        onMIDIStarted: function(midi) {
                            Util.MidiHandler.midiAccess = midi;
                            var inputs = midi.inputs;
                            inputs.forEach(function(port) {
                                Util.MidiHandler.inputs.push(port)
                            });
                            var outputs = midi.outputs;
                            outputs.forEach(function(port) {
                                Util.MidiHandler.outputs.push(port)
                            });
                            if (Util.MidiHandler.inputs.length) {
                                Util.MidiHandler.midiIn = Util.MidiHandler.inputs[0];
                                Util.MidiHandler.midiIn.onmidimessage = Util.MidiHandler.midiMessageReceived;
                                Util.MidiHandler.midiOut = Util.MidiHandler.outputs[0]
                            } else {
                                console.error("No midi inputs found");
                                return
                            }
                        },
                        midiMessageReceived: function(ev) {
                            var a = ev.data[0];
                            var cmd = ev.data[0] >> 4;
                            var channel = ev.data[0] & 15;
                            var noteNumber = ev.data[1];
                            var velocity = ev.data[2];
                            Util.MidiHandler.handleMidiData(a, cmd, channel, noteNumber, velocity)
                        },
                        handleMidiData: function(a, cmd, channel, noteNumber, velocity) {},
                        changeMidi: function(index) {
                            this.midiOut = this.outputs[index];
                            this.midiIn = this.inputs[index]
                        },
                        MIDIUtils: {
                            noteMap: {},
                            noteNumberMap: [],
                            notes: ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"],
                            initUtils: function(argument) {
                                for (var i = 0; i < 127; i++) {
                                    var index = i,
                                        key = this.notes[index % 12],
                                        octave = (index / 12 | 0) - 1;
                                    if (key.length === 1) {
                                        key = key + "-"
                                    }
                                    key += octave;
                                    this.noteMap[key] = i;
                                    this.noteNumberMap[i] = key
                                }
                            },
                            getBaseLog: function(value, base) {
                                return Math.log(value) / Math.log(base)
                            },
                            noteNameToNoteNumber: function(name) {
                                return this.noteMap[name]
                            },
                            noteNumberToFrequency: function(note) {
                                return 440 * Math.pow(2, (note - 69) / 12)
                            },
                            noteNumberToName: function(note) {
                                return this.noteNumberMap[note]
                            },
                            frequencyToNoteNumber: function(f) {
                                return Math.round(12 * this.getBaseLog(f / 440, 2) + 69)
                            }
                        },
                        play: function(note, noteLength, velocity) {
                            if (typeof velocity === "undefined") {
                                velocity = 100
                            }
                            this.midiOut.send([144, note, velocity]);
                            console.log("On");
                            this.midiOut.send([128, note, 0], window.performance.now() + noteLength)
                        },
                        panic: function() {
                            for (var i = 1; i < 128; ++i) {
                                this.midiOut.send([128, i, 0])
                            }
                        }
                    }
                })(Util || (Util = {}));
                Util.__extends = function(d, b) {
                    function __() {
                        this.constructor = d
                    }
                    __.prototype = b.prototype;
                    d.prototype = new __
                };
                return Klang.Util = Util
            });
            Module(function(Klang) {
                function EventEmitter() {}
                EventEmitter.prototype.on = function(name, callback, context) {
                    this._events = this._events || {};
                    var events = this._events[name] || (this._events[name] = []);
                    events.push({
                        callback: callback,
                        ctxArg: context,
                        context: context || this
                    });
                    return this
                };
                EventEmitter.prototype.off = function(name, callback, context) {
                    var i, len, listener, retain;
                    if (!this._events || !this._events[name]) {
                        return this
                    }
                    if (!name && !callback && !context) {
                        this._events = {}
                    }
                    var eventListeners = this._events[name];
                    if (eventListeners) {
                        retain = [];
                        if (callback && context) {
                            for (i = 0, len = eventListeners.length; i < len; i++) {
                                listener = eventListeners[i];
                                if (callback !== listener.callback && context !== listener.ctxArg) {
                                    retain.push(eventListeners[i])
                                }
                            }
                        } else if (callback) {
                            for (i = 0, len = eventListeners.length; i < len; i++) {
                                listener = eventListeners[i];
                                if (callback !== listener.callback) {
                                    retain.push(eventListeners[i])
                                }
                            }
                        } else if (context) {
                            for (i = 0, len = eventListeners.length; i < len; i++) {
                                listener = eventListeners[i];
                                if (context !== listener.ctxArg) {
                                    retain.push(eventListeners[i])
                                }
                            }
                        }
                        this._events[name] = retain
                    }
                    if (!this._events[name].length) {
                        delete this._events[name]
                    }
                    return this
                };
                EventEmitter.prototype.trigger = function(name) {
                    var args = [];
                    for (var _i = 0; _i < arguments.length - 1; _i++) {
                        args[_i] = arguments[_i + 1]
                    }
                    if (!this._events || !this._events[name]) {
                        return this
                    }
                    var i, binding, listeners;
                    listeners = this._events[name];
                    args = [].splice.call(arguments, 1);
                    for (i = listeners.length - 1; i >= 0; i--) {
                        binding = listeners[i];
                        binding.callback.apply(binding.context, args)
                    }
                    return this
                };
                Klang.core.internalEventBus = new EventEmitter;
                return Klang.core.EventEmitter = EventEmitter
            });
            Module(function(Klang) {
                function Core() {
                    this._initComplete = false;
                    this._blurFadeOut = false;
                    this._masterBusId = null;
                    this._preLoadInitStack = [];
                    this._postLoadInitStack = [];
                    this._connectStack = [];
                    this._superMasterOutput = Klang.context ? Klang.context.createGain() : null;
                    this.scheduler = new Klang.core.Scheduler;
                    if (Klang.Util.getParameterByName("klang_log")) {
                        Klang.loggingEnabled = true
                    }
                }
                Core.debugSettings = {};
                Core.inst = null;
                Core.isInited = function isInited() {
                    if (Core.inst == null) {
                        return false
                    }
                    return Core.inst._initComplete
                };
                Object.defineProperty(Core.prototype, "initComplete", {
                    get: function() {
                        return this._initComplete
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Core, "instance", {
                    get: function() {
                        if (Core.inst == null) {
                            Core.inst = new Core
                        }
                        return Core.inst
                    },
                    enumerable: true,
                    configurable: true
                });
                Core.prototype.setCallbacks = function(callbacks) {
                    this._callbacks = callbacks
                };
                Object.defineProperty(Core, "callbacks", {
                    get: function() {
                        return Core.instance._callbacks
                    },
                    enumerable: true,
                    configurable: true
                });
                Core.deinit = function deinit() {
                    Core.inst = null
                };
                Core.prototype.stopAll = function() {
                    if (window["KlangVisual"]) {
                        KlangVisual.stop()
                    }
                    for (var p in this._objectTable) {
                        if (this._objectTable[p].stop) {
                            try {
                                this._objectTable[p].stop()
                            } catch (ex) {}
                        }
                    }
                };
                Core.prototype.getPlaying = function() {
                    var playing = [];
                    for (var p in this._objectTable) {
                        var obj = this._objectTable[p];
                        if (obj instanceof Klang.Model.AudioSource && obj.playing) {
                            playing.push(obj)
                        } else if (obj instanceof Klang.Model.AudioGroup && obj.playing) {
                            if (obj.latestPlayed) {
                                playing.push(obj.latestPlayed)
                            }
                        }
                    }
                    return playing
                };
                Core.prototype.loadJSON = function(options, readyCallback, progressCallback, url) {
                    this._readyCallback = readyCallback;
                    this._progressCallback = progressCallback || function() {};
                    if (typeof options === "object") {
                        Klang.log("Loading config (editor)");
                        var data = this.createConfigNode(options);
                        Core.settings = data.settings;
                        Core.instance.initContent(data, null, url);
                        if (window["KlangVisual"]) {
                            KlangVisual.init(options)
                        }
                    } else if (typeof options === "string") {
                        Klang.log("Loading config (client)");
                        var request = new XMLHttpRequest;
                        request.open("GET", options, true);
                        var _this = this;
                        request.onreadystatechange = function() {
                            if (request.readyState == 4 && request.status == 200) {
                                var configText = request.responseText;
                                var data = _this.parseConfigJSON(configText);
                                Core.settings = data.settings;
                                Core.instance.initContent(data, null, options);
                                if (window["KlangVisual"]) {
                                    KlangVisual.init(JSON.parse(configText))
                                }
                            } else if (request.status == 404) {
                                throw "Klang exception: config file not found: '" + options + "'"
                            } else if (request.status != 200) {
                                throw "Klang exception: unable to load config file: '" + options + "'"
                            }
                        };
                        request.send(null)
                    } else {
                        throw "Klang exception: unrecognized options: '" + options + "'"
                    }
                };
                Core.prototype.parseConfigJSON = function(jsonString) {
                    if (typeof jsonString === "string") {
                        return JSON.parse(jsonString, function(key, value) {
                            if (value && typeof value === "object" && typeof value.type === "string") {
                                if (!Klang.Model[value.type]) {
                                    Klang.warn("Core: Type not found: " + value.type);
                                    return null
                                }
                                return new Klang.Model[value.type](value, key)
                            }
                            return value
                        })
                    } else {
                        for (var key in Object.keys(jsonString)) {
                            var value = jsonString[key];
                            if (!Klang.Model[value.type]) {
                                Klang.warn("Core: Type not found: " + value.type);
                                return null
                            }
                            return new Klang.Model[value.type](value, key)
                        }
                    }
                };
                Core.prototype.createConfigNode = function(node) {
                    if (typeof node === "object") {
                        for (var key in node) {
                            var prop = node[key];
                            if (typeof prop === "object" && typeof prop.type === "string") {
                                if (!Klang.Model[prop.type]) {
                                    Klang.warn("Core: Type not found: " + prop.type)
                                }
                                if (prop.type == "channel") continue;
                                node[key] = this.createConfigNode(prop);
                                node[key] = new Klang.Model[prop.type](prop, key)
                            } else {
                                node[key] = this.createConfigNode(prop)
                            }
                        }
                    }
                    return node
                };
                Core.prototype.createObject = function(name, data, options) {
                    if (!options) {
                        options = {}
                    }
                    if (!Klang.Model[data.type]) {
                        Klang.warn("Core: Type not found: " + data.type);
                        return
                    }
                    if (!options.excludeFromTable && this._objectTable[name]) {
                        Klang.warn("Core: Duplicate object: " + name)
                    }
                    var obj = new Klang.Model[data.type](data, name);
                    if (!options.excludeFromTable) {
                        this._objectTable[name] = obj
                    }
                    if (!options.noInit && obj.init) {
                        obj.init()
                    }
                    if (!options.noConnect && obj.destinationName && obj.connect) {
                        if (obj.destinationName == "$OUT") {
                            obj.connect(this._superMasterOutput)
                        } else {
                            var destination = this.findInstance(obj.destinationName);
                            if (!destination) {
                                Klang.warn("Core: Destination not found: " + obj.destinationName)
                            }
                            if (destination._type != "Bus") {
                                Klang.warn("Core: Destination is not a bus: " + obj.destinationName)
                            }
                            obj.connect(destination.input)
                        }
                    }
                    return obj
                };
                Core.prototype.updateObject = function(object, data) {
                    var obj = typeof object == "string" ? this._objectTable[object] : object;
                    if (obj._type == "SimpleProcess" && data.type == "AdvancedProcess") {
                        var advancedProcess = newAdvancedProcess(data, object);
                        advancedProcess.init();
                        this._objectTable[object] = advancedProcess
                    } else if (obj._type == "AdvancedProcess" && data.type == "SimpleProcess") {
                        var simpleProcess = newSimpleProcess(data, object);
                        simpleProcess.init();
                        this._objectTable[object] = simpleProcess
                    } else if (obj.setData) {
                        obj.setData(data)
                    }
                };
                Core.prototype.createEvent = function(name, target) {
                    if (this._eventTable[name]) {
                        Klang.warn("Core: Duplicate event: " + name)
                    }
                    this._eventTable[name] = target
                };
                Core.prototype.visChange = function(fadeTime) {
                    if (this.isHidden()) {
                        if (this._blurFadeOut) {
                            Klang.Util.curveParamLin(this._superMasterOutput.gain, 0, fadeTime)
                        }
                    } else {
                        Klang.Util.curveParamLin(this._superMasterOutput.gain, 1, fadeTime)
                    }
                };
                Core.prototype.initContent = function(data, files, url) {
                    var relativePath = data.settings.relative_path;
                    var baseURL;
                    var filePath = data.settings.file_path || "";
                    if (relativePath) {
                        if (url.lastIndexOf("/") != -1) {
                            baseURL = url.substring(0, url.lastIndexOf("/"));
                            if (baseURL.charAt(baseURL.length - 1) !== "/") {
                                baseURL += "/"
                            }
                            baseURL += filePath
                        } else {
                            baseURL = filePath
                        }
                    } else {
                        baseURL = filePath
                    }
                    Klang.log("Initializing core");
                    var startTimeStamp = Klang.context.currentTime;
                    if (data.settings.blur_fade_time != -1) {
                        this._blurFadeOut = true;
                        var fadeTime = data.settings.blur_fade_time || .5;
                        if (fadeTime < 0 && fadeTime != -1) {
                            Klang.warn("Core: Invalid blur_fade_time value. Must be -1 or >= 0.")
                        }
                        var _this = this;
                        var visProp = this.getHiddenProp();
                        if (visProp) {
                            var evtname = "visibilitychange";
                            document.addEventListener(evtname, function() {
                                _this.visChange(fadeTime)
                            })
                        }
                    }
                    this.maxSimultaneousSounds = data.settings.max_simultaneous_sounds;
                    Klang.core.FileHandler.instance.fileInfo = (files !== undefined && files !== null ? files : data.files) || [];
                    this._eventTable = data.events || {};
                    this._objectTable = {};
                    for (var p in data.audio) {
                        this._objectTable[p] = data.audio[p]
                    }
                    for (var p in data.busses) {
                        this._objectTable[p] = data.busses[p]
                    }
                    for (var p in data.sequencers) {
                        this._objectTable[p] = data.sequencers[p]
                    }
                    for (var p in data.processes) {
                        this._objectTable[p] = data.processes[p]
                    }
                    for (var p in data.synths) {
                        this._objectTable[p] = data.synths[p]
                    }
                    for (var p in data.lfos) {
                        this._objectTable[p] = data.lfos[p]
                    }
                    for (var p in data.automations) {
                        this._objectTable[p] = data.automations[p]
                    }
                    for (var p in data.data) {
                        this._objectTable[p] = data.data[p]
                    }
                    this.setVars(data.vars);
                    this._masterBusId = data.masterBus;
                    this._exportedSymbols = data.exportedSymbols || {};
                    this._logIgnore = data.debug.log_ignore || data.log_ignore || {};
                    Klang.Util.createCurves(data.curves);
                    this._loadStartTimestamp = (new Date).getTime();
                    if (data.debug) {
                        Klang.debugData.ignoredEvents = data.debug.ignored_events || Klang.debugData.ignoredEvents;
                        Klang.debugData.logToConsole = data.debug.log_to_console || Klang.debugData.logToConsole
                    }
                    Klang.log("Pre load initialization started");
                    for (var ix = 0, len = this._preLoadInitStack.length; ix < len; ix++) {
                        var element = this._preLoadInitStack[ix];
                        if (element.init) {
                            element.init()
                        }
                    }
                    Klang.log("Pre load initialization finished");
                    Klang.log("Connecting nodes");
                    this._superMasterOutput.connect(Klang.context.destination);
                    for (var ix = 0, len = this._connectStack.length; ix < len; ix++) {
                        var element = this._connectStack[ix];
                        switch (element.destinationName) {
                            case "$OUT":
                                element.connect(this._superMasterOutput);
                                break;
                            case "$PARENT":
                                break;
                            default:
                                {
                                    var destination = this.findInstance(element.destinationName);
                                    if (!destination) {
                                        Klang.warn("Core: Destination not found: " + element.destinationName)
                                    }
                                    if (destination._type != "Bus") {
                                        Klang.warn("Core: Destination is not a bus: " + element.destinationName)
                                    }
                                    element.connect(destination.input);
                                    break
                                }
                        }
                    }
                    Klang.log("Nodes connected");
                    this._preLoadInitStack = null;
                    this._connectStack = null;
                    this._timeHandler = new Klang.core.TimeHandler;
                    this._initComplete = true;
                    Klang.log("Core initialized");
                    Klang.core.FileHandler.instance.baseURL = baseURL;
                    if (!Klang.initOptions || Klang.initOptions && !Klang.initOptions.noAutoLoad) {
                        Klang.core.FileHandler.instance.loadFiles("auto", Core.soundsLoaded, this._progressCallback)
                    } else {
                        setTimeout(Core.soundsLoaded, 4)
                    }
                };
                Core.prototype.isHidden = function() {
                    var prop = this.getHiddenProp();
                    if (!prop) {
                        return false
                    }
                    return document[prop]
                };
                Core.prototype.getHiddenProp = function() {
                    var prefixes = ["webkit", "moz", "ms", "o"];
                    if ("hidden" in document) {
                        return "hidden"
                    }
                    for (var i = 0; i < prefixes.length; i++) {
                        if (prefixes[i] + "Hidden" in document) {
                            return prefixes[i] + "Hidden"
                        }
                    }
                    return null
                };
                Core.prototype.setVars = function(vars) {
                    if (vars) {
                        for (var key in vars) {
                            if (typeof vars[key] == "string" && vars[key].indexOf("me.") > -1) {
                                vars[key] = this.findInstance(vars[key].split("me.")[1])
                            } else if (typeof vars[key] == "object") {
                                var obj = vars[key];
                                for (var prop in obj) {
                                    if (obj.hasOwnProperty(prop)) {
                                        if (typeof obj[prop] == "string" && obj[prop].indexOf("me.") > -1) {
                                            obj[prop] = this.findInstance(obj[prop].split("me.")[1])
                                        }
                                    }
                                }
                            }
                        }
                        Klang.Util.vars = vars
                    }
                };
                Core.prototype.loadSoundFiles = function(name, callback, progressCallback, loadFailedCallback) {
                    var start = (new Date).getTime();
                    if (progressCallback) {
                        this._progressCallback = progressCallback
                    }
                    var _this = this;
                    Klang.core.FileHandler.instance.loadFiles(name, function(success, loadedFiles) {
                        for (var i = 0; i < loadedFiles.length; i++) {
                            var fileId = loadedFiles[i].id;
                            for (var j in _this._objectTable) {
                                if (_this._objectTable.hasOwnProperty(j)) {
                                    var obj = _this._objectTable[j];
                                    if (obj._type === "AudioSource" && obj._fileId === fileId) {
                                        obj.init()
                                    }
                                }
                            }
                        }
                        var end = (new Date).getTime();
                        var time = end - start;
                        Klang.log("Execution time for loadgroup: " + time);
                        callback && callback(true)
                    }, this._progressCallback, loadFailedCallback)
                };
                Core.prototype.freeSoundFiles = function(name) {
                    var loadGroups = Klang.core.FileHandler.instance.getLoadGroups();
                    if (typeof name === "string") {
                        name = [name]
                    }
                    for (var i = 0; i < name.length; i++) {
                        var isLoadGroup = false;
                        if (loadGroups.includes(name[i])) {
                            Klang.core.FileHandler.instance.freeSoundFiles(name[i]);
                            isLoadGroup = true;
                            Klang.log("freeing loadgroup!", name[i])
                        }
                        for (var p in this._objectTable) {
                            var obj = this._objectTable[p];
                            if (obj._type == "AudioSource") {
                                var fileInfo = Klang.core.FileHandler.instance.getFileInfo(obj._fileId);
                                if (isLoadGroup) {
                                    if (fileInfo && fileInfo.load_group == name[i]) {
                                        obj.freeBuffer()
                                    }
                                } else if (obj.editorName === name[i]) {
                                    Klang.core.FileHandler.instance.freeSoundFile(obj._fileId);
                                    obj.freeBuffer();
                                    Klang.log("freeing buffer!", name[i])
                                }
                            }
                        }
                    }
                };
                Core.soundsLoaded = function soundsLoaded() {
                    Klang.log("Post load initialization started");
                    var _this = Core.instance;
                    for (var i = 0, len = _this._postLoadInitStack.length; i < len; i++) {
                        _this._postLoadInitStack[i].init()
                    }
                    Klang.log("Post load initialization finished");
                    _this._postLoadInitStack = null;
                    if (_this._readyCallback) {
                        _this._readyCallback(true)
                    }
                };
                Core.prototype.pushToPreLoadInitStack = function(instance) {
                    if (this._preLoadInitStack) {
                        this._preLoadInitStack.push(instance);
                        return true
                    }
                    return false
                };
                Core.prototype.pushToPostLoadInitStack = function(instance) {
                    if (this._postLoadInitStack) {
                        this._postLoadInitStack.push(instance);
                        return true
                    }
                    return false
                };
                Core.prototype.pushToConnectStack = function(instance) {
                    if (this._connectStack) {
                        this._connectStack.push(instance);
                        return true
                    }
                    return false
                };
                Core.prototype.findInstance = function(name) {
                    var instance = this._objectTable[name];
                    if (!instance) {
                        Klang.warn("Core: Unknown reference: '" + name + "'")
                    }
                    return instance
                };
                Core.prototype.triggerEvent = function(id) {
                    var eventArgs = [];
                    for (var _i = 0; _i < arguments.length - 1; _i++) {
                        eventArgs[_i] = arguments[_i + 1]
                    }
                    Klang.Util.lastEvent = id;
                    if (Klang.debugData.ignoredEvents[id]) {
                        return
                    }
                    if (!this._eventTable) {
                        Klang.logc("Klang Core: eventTable is undefined");
                        return
                    }
                    if (!this._eventTable[id]) {
                        if (Klang.debugData.logToConsole && !this._logIgnore[id]) {
                            Klang.logc("Klang Core: Incoming sound event: '" + id + "'" + ", " + eventArgs, Klang.Util.LOG_UNIMPLEMENTED_EVENT_COLOR)
                        }
                    } else {
                        if (Klang.debugData.logToConsole && !this._logIgnore[id]) {
                            Klang.logc("Klang Core: Incoming sound event: '" + id + "'" + ", " + eventArgs, Klang.Util.LOG_EVENT_COLOR)
                        }
                    }
                    var process = this._eventTable[id];
                    if (typeof process == "string") {
                        if (!this._objectTable[process]) {
                            Klang.warn("Core: Unknown process: '" + process + "'")
                        }
                        if (this._objectTable[process]._type != "SimpleProcess" && this._objectTable[process]._type != "AdvancedProcess") {
                            Klang.warn("Core: Object is not a process: '" + process + "'")
                        }
                        this._objectTable[process].start(eventArgs[0])
                    } else if (process instanceof Array) {
                        for (var ix = 0, len = process.length; ix < len; ix++) {
                            if (!this._objectTable[process[ix]]) {
                                Klang.warn("Core: Unknown process: '" + process[ix] + "'")
                            }
                            if (this._objectTable[process[ix]]._type != "SimpleProcess" && this._objectTable[process[ix]]._type != "AdvancedProcess") {
                                Klang.warn("Core: Object is not a process: '" + process + "'")
                            }
                            this._objectTable[process[ix]].start(eventArgs[0])
                        }
                    }
                };
                Core.prototype.getSymbolId = function(symbol) {
                    return this._exportedSymbols[symbol]
                };
                Core.prototype.initIOS = function() {
                    var src = Klang.context.createBufferSource();
                    src.start(0);
                    Klang.core.internalEventBus.trigger("INIT_IOS")
                };
                Object.defineProperty(Core.prototype, "timeHandler", {
                    get: function() {
                        return this._timeHandler
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Core.prototype, "output", {
                    get: function() {
                        return this._superMasterOutput
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Core.prototype, "blurFadeOut", {
                    get: function() {
                        return this._blurFadeOut
                    },
                    set: function(state) {
                        this._blurFadeOut = state
                    },
                    enumerable: true,
                    configurable: true
                });
                return Klang.core.Core = Core
            });
            Module(function(Klang) {
                Klang.READY_STATE_NOT_INITIATED = 0;
                Klang.READY_STATE_INITIATED = 1;
                Klang.READY_STATE_LOADED = 2;
                Klang.klangInited = false;
                Klang.readyState = Klang.READY_STATE_NOT_INITIATED;
                var _eventQue;

                function pushToEventQue(name) {
                    _eventQue = _eventQue || {};
                    _eventQue[name] = arguments
                }
                Klang.pushToEventQue = pushToEventQue;

                function triggerEvent(name) {
                    var args = [];
                    for (var _i = 0; _i < arguments.length - 1; _i++) {
                        args[_i] = arguments[_i + 1]
                    }
                    if (!Klang.core.Core.isInited) {
                        return
                    }
                    if (Klang.engineVersion === "webaudio") {
                        if (!Klang.context) {
                            return
                        }
                        Klang.core.Core.instance.triggerEvent(name, args)
                    } else if (Klang.engineVersion === "audiotag") {
                        if (Klang.audioTagHandler) {
                            Klang.audioTagHandler.triggerEvent(name, args)
                        }
                    }
                }
                Klang.triggerEvent = Klang.trigger = triggerEvent;

                function getDestinationForEvent(eventName) {
                    var process = Klang.core.Core.instance.findInstance(Klang.getEvents()[eventName]);
                    if (process) {
                        return process.destination()
                    }
                    return null
                }
                Klang.getDestinationForEvent = getDestinationForEvent;

                function processEventQue() {
                    if (_eventQue) {
                        for (var i in _eventQue) {
                            if (_eventQue.hasOwnProperty(i)) {
                                Klang.triggerEvent.apply(Klang, _eventQue[i])
                            }
                        }
                        _eventQue = null
                    }
                }

                function init(json, readyCallback, progressCallback, loadFailedCallback, options) {
                    var start = (new Date).getTime();
                    Klang.initOptions = options = options || {};
                    Klang.isMobile = Klang.Util.checkMobile();
                    Klang.isIOS = Klang.Util.checkIOS();
                    if (options.useMonoBuffers) {
                        Klang.useMonoBuffers = options.useMonoBuffers
                    }
                    if (typeof json == "object" && json.settings && json.settings.force_logging) {
                        Klang.loggingEnabled = true
                    }
                    if (Klang.klangInited) {
                        Klang.warn("Klang already initialized");
                        return
                    }
                    Klang.klangInited = true;
                    Klang.readyState = Klang.READY_STATE_NOT_INITIATED;
                    var doWebaudio = options.forceMode === "webaudio" || !options.forceMode && window.AudioContext !== undefined;
                    var doAudioTag = options.forceMode === "audiotag" || !options.forceMode && !window.AudioContext;
                    if (doWebaudio) {
                        if (!Klang.context) {
                            Klang.context = Klang.engines.webAudio.Util.createAudioContext()
                        }
                    } else {
                        Klang.engineVersion = "audiotag";
                        if (typeof json === "string" && json.indexOf(".json") === -1 && json.indexOf(".js") > 1) {
                            var oldKLANG_CONFIG = window["KLANGCONFIG"];
                            Klang.Util.loadScriptFile(json, function() {
                                var config = window["KLANG_CONFIG"];
                                window["KLANG_CONFIG"] = oldKLANG_CONFIG;
                                Klang.audioTagHandler = new Klang.AudioTagHandler(config, function(success) {
                                    Klang.readyState = Klang.READY_STATE_LOADED;
                                    readyCallback && readyCallback(success);
                                    processEventQue()
                                }, progressCallback, json)
                            }, function() {})
                        } else {
                            Klang.audioTagHandler = new Klang.AudioTagHandler(json, function(success) {
                                Klang.readyState = Klang.READY_STATE_LOADED;
                                readyCallback && readyCallback(success);
                                var end = (new Date).getTime();
                                var time = end - start;
                                Klang.log("Execution time: " + time);
                                processEventQue()
                            }, progressCallback, json)
                        }
                        return true
                    }
                    Klang.engineVersion = "webaudio";
                    if (Klang.core.Core.isInited()) {
                        Klang.warn("Klang already initialized")
                    }
                    if (typeof json === "string" && json.indexOf(".json") === -1 && json.indexOf(".js") > 1) {
                        var oldKLANG_CONFIG = window["KLANG_CONFIG"];
                        Klang.Util.loadScriptFile(json, function() {
                            var config = window["KLANG_CONFIG"];
                            window["KLANG_CONFIG"] = oldKLANG_CONFIG;
                            Klang.core.Core.instance.loadJSON(config, function(success) {
                                Klang.readyState = Klang.READY_STATE_LOADED;
                                readyCallback && readyCallback(success);
                                processEventQue()
                            }, progressCallback, json)
                        }, function() {})
                    } else {
                        Klang.core.Core.instance.loadJSON(json, function(success) {
                            Klang.readyState = Klang.READY_STATE_LOADED;
                            readyCallback && readyCallback(success);
                            processEventQue();
                            var end = (new Date).getTime();
                            var time = end - start;
                            Klang.log("Execution time: " + time)
                        }, progressCallback, json)
                    }
                    return true
                }
                Klang.init = init;

                function initIOS(gui) {
                    if (Klang.engineVersion == "webaudio") {
                        Klang.core.Core.instance.initIOS()
                    } else if (Klang.engineVersion == "audiotag" && Klang.isMobile) {
                        Klang.audioTagHandler.initIOS()
                    }
                }
                Klang.initIOS = function(debugButton) {
                    initIOS()
                };

                function getLoadGroups() {
                    var listOfGroups = [];
                    var fileHandler;
                    if (Klang.engineVersion === "webaudio") {
                        fileHandler = Klang.core.FileHandler.instance
                    } else if (Klang.engineVersion === "audiotag") {
                        fileHandler = Klang.audioTagHandler
                    } else {
                        return []
                    }
                    listOfGroups = fileHandler.getLoadGroups();
                    var autoIndex = listOfGroups.indexOf("auto");
                    if (autoIndex !== -1) {
                        listOfGroups.splice(autoIndex, 1)
                    }
                    return listOfGroups
                }
                Klang.getLoadGroups = getLoadGroups;
                Klang.getCoreInstance = function() {
                    return Klang.core.Core.instance
                };
                Klang.getFileHandlerInstance = function() {
                    return Klang.core.FileHandler.instance
                };

                function getUtil() {
                    return Klang.Util
                }
                Klang.getUtil = getUtil;

                function getModel() {
                    return Klang.Model
                }
                Klang.getModel = getModel;

                function schedule(time, fn) {
                    if (Klang.engineVersion !== "webaudio") {
                        Klang.err("Schedule only availible in WebAudio version");
                        return this
                    }
                    if (typeof time === "number" && typeof fn === "function") {
                        Klang.core.Core.instance.scheduler.at(time, fn)
                    } else {
                        Klang.err(".schedule requires arg0 - time in seconds and arg1 - a callback function")
                    }
                    return this
                }
                Klang.schedule = schedule;

                function createObject(name, options) {
                    if (!Model[name]) {
                        throw new Error("No such object")
                    }
                    return new Model[name](options)
                }
                Klang.createObject = createObject;

                function setDebugFlag(flagName, value) {
                    Klang.core.Core.debugSettings[flagName] = value
                }
                Klang.setDebugFlag = setDebugFlag;

                function load(name, readyCallback, progressCallback, loadFailedCallback) {
                    Klang.logc("Klang: Loading: '" + name + "'", Klang.Util.LOG_LOAD_COLOR);
                    if (Klang.engineVersion == "webaudio") {
                        Klang.core.Core.instance.loadSoundFiles(name, readyCallback, progressCallback, loadFailedCallback)
                    } else if (Klang.engineVersion == "audiotag") {
                        Klang.audioTagHandler.loadSoundFiles(name, readyCallback, progressCallback, loadFailedCallback)
                    } else {
                        if (progressCallback) {
                            progressCallback(1)
                        }
                        if (readyCallback) {
                            readyCallback(false)
                        }
                    }
                }
                Klang.load = load;

                function free(name) {
                    Klang.logc("Klang: Freeing: '" + name + "'", Klang.Util.LOG_LOAD_COLOR);
                    if (Klang.engineVersion == "webaudio") {
                        Klang.core.Core.instance.freeSoundFiles(name)
                    } else if (Klang.engineVersion == "audiotag") {}
                }
                Klang.free = free;

                function getLoadProgress() {
                    return FileHandler.instance.progress
                }
                Klang.getLoadProgress = getLoadProgress;

                function stopAll() {
                    if (Klang.engineVersion == "webaudio") {
                        if (Klang.core.Core.isInited()) {
                            Klang.core.Core.instance.stopAll()
                        }
                    } else if (Klang.engineVersion == "audiotag") {
                        Klang.audioTagHandler.stopAll()
                    }
                }
                Klang.stopAll = stopAll;

                function $(symbol, args) {
                    if (Klang.engineVersion == "webaudio") {
                        if (Klang.core.Core.isInited()) {
                            if (symbol.indexOf(".") === 0) {
                                var type = symbol.substring(1);
                                var ret = [];
                                var entities = Klang.getCoreInstance()._objectTable;
                                for (var i in entities) {
                                    if (entities.hasOwnProperty(i)) {
                                        var entity = entities[i];
                                        if (entity._type === type) {
                                            ret.push(entity)
                                        }
                                    }
                                }
                                return ret
                            } else {
                                var id = Klang.core.Core.instance.getSymbolId(symbol);
                                return Klang.core.Core.instance.findInstance(id)
                            }
                        }
                    } else if (Klang.engineVersion == "audiotag") {
                        if (symbol.indexOf(".") === 0) {
                            var ret = [];
                            var type = symbol.substring(1);
                            for (var k in Klang.audioTagHandler._audio) {
                                var obj = Klang.audioTagHandler._audio[k];
                                if (obj.constructor.name.indexOf(type) !== -1) {
                                    ret.push(obj)
                                }
                            }
                            return ret
                        } else {
                            for (var k in Klang.audioTagHandler._audio) {
                                var obj = Klang.audioTagHandler._audio[k];
                                if (obj._data.editorName === symbol) {
                                    return obj
                                }
                            }
                        }
                    }
                    return null
                }
                Klang.$ = $
            });
            Module(function(Klang) {
                function log() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length - 0; _i++) {
                        args[_i] = arguments[_i + 0]
                    }
                    if (Klang.loggingEnabled) {
                        if (Klang.browser == "Chrome") {
                            console.log("%c[" + getTimeString() + "] " + args.join(), "color:" + Klang.Util.LOG_TIME_COLOR)
                        } else {
                            console.log.apply(console, args)
                        }
                    }
                }
                Klang.log = log;

                function logc(message, color) {
                    if (Klang.loggingEnabled) {
                        if (Klang.browser == "Chrome") {
                            if (!color) {
                                color = "gray"
                            }
                            console.log("%c[" + getTimeString() + "] " + message, "color:" + color)
                        } else {
                            console.log(message)
                        }
                    }
                }
                Klang.logc = logc;

                function warn() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length - 0; _i++) {
                        args[_i] = arguments[_i + 0]
                    }
                    if (Klang.loggingEnabled) {
                        if (Klang.browser == "Chrome") {
                            console.warn("%c[" + Klang.getTimeString() + "] " + args.join(), "color:" + Klang.Util.LOG_WARN_COLOR)
                        } else {
                            console.warn.apply(console, args)
                        }
                    }
                }
                Klang.warn = warn;

                function err() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length - 0; _i++) {
                        args[_i] = arguments[_i + 0]
                    }
                    if (Klang.loggingEnabled) {
                        if (Klang.browser == "Chrome") {
                            console.warn("%c[" + Klang.getTimeString() + "] " + args.join(), "color:" + Klang.Util.LOG_ERROR_COLOR)
                        } else {
                            console.warn.apply(console, args)
                        }
                    }
                }
                Klang.err = err;

                function zeropad(num, digits) {
                    var str = num.toString();
                    while (str.length < digits) {
                        str = "0" + str
                    }
                    return str
                }
                Klang.zeropad = zeropad;

                function getTimeStamp(time) {
                    return zeropad(time.getUTCMinutes(), 2) + ":" + zeropad(time.getUTCSeconds(), 2) + "." + zeropad(time.getUTCMilliseconds(), 3)
                }
                Klang.getTimeStamp = getTimeStamp;

                function getTimeString(t) {
                    if (t === undefined) {
                        t = Klang.context.currentTime
                    }
                    var ms = Math.round(t * 1e3);
                    var s = Math.floor(ms / 1e3 % 60);
                    var m = Math.floor(ms / (1e3 * 60) % 60);
                    var h = Math.floor(ms / (1e3 * 60 * 60) % 24);
                    return zeropad(h, 2) + ":" + zeropad(m, 2) + ":" + zeropad(s, 2) + "." + zeropad(ms % 1e3, 3)
                }
                Klang.getTimeString = getTimeString;

                function getEvents() {
                    if (Klang.engineVersion === "flash") {
                        return null
                    } else if (Klang.engineVersion == "audiotag") {
                        return Klang["audioTagHandler"]._events
                    }
                    return Klang.core.Core.instance._eventTable
                }
                Klang.getEvents = getEvents;
                Klang.debugData = {
                    ignoredEvents: {},
                    logToConsole: true
                };
                Klang.visualWindow;

                function setCallbacks(callbacks) {
                    Klang.core.Core.instance.setCallbacks(callbacks)
                }
                Klang.setCallbacks = setCallbacks;

                function schedulePredefinedEvents(events) {
                    var nextEventIx = 0;
                    var eventInterval = setInterval(function() {
                        var now = Klang.context.currentTime;
                        var e = events[nextEventIx];
                        while (e.time < now) {
                            triggerEvent(e.name, e.args);
                            nextEventIx++;
                            if (nextEventIx == events.length) {
                                clearInterval(eventInterval);
                                break
                            } else {
                                e = events[nextEventIx]
                            }
                        }
                    }, 10)
                }
                Klang.schedulePredefinedEvents = schedulePredefinedEvents;

                function deinit(url, readyCallback) {
                    Klang.klangInited = false;
                    if (Klang.engineVersion == "webaudio") {
                        if (Klang.core.Core.isInited()) {
                            Klang.core.Core.instance.stopAll();
                            Klang.core.Core.deinit()
                        }
                    } else if (Klang.engineVersion == "audiotag") {
                        Klang.audioTagHandler.stopAll()
                    }
                    Klang.engineVersion = "n/a"
                }
                Klang.deinit = deinit
            });
            Module(function(Klang) {
                function SyncCountdown(targetStep, process, args) {
                    this._currentStep = 0;
                    this._targetStep = targetStep;
                    this._process = process;
                    this._args = args
                }
                SyncCountdown.prototype.advance = function(step) {
                    this._currentStep += step
                };
                SyncCountdown.prototype.performAction = function() {
                    if (typeof this._process == "string") {
                        new Function("Core", "Model", "Util", "args", this._process)(Klang.core.Core, Klang.Model, Klang.Util, this._args)
                    } else {
                        this._process.start(this._args)
                    }
                };
                Object.defineProperty(SyncCountdown.prototype, "finished", {
                    get: function() {
                        return this._currentStep >= this._targetStep
                    },
                    enumerable: true,
                    configurable: true
                });
                return Klang.core.SyncCountdown = SyncCountdown
            });
            Module(function(Klang) {
                function SyncHandler() {
                    this._timers = []
                }
                SyncHandler.prototype.addSyncCountdown = function(countdown) {
                    this._timers.push(countdown)
                };
                SyncHandler.prototype.update = function(step) {
                    for (var ix = 0; ix < this._timers.length; ix++) {
                        var countdown = this._timers[ix];
                        countdown.advance(step);
                        if (countdown.finished) {
                            countdown.performAction();
                            this._timers.splice(ix, 1);
                            ix--
                        }
                    }
                };
                return Klang.core.SyncHandler = SyncHandler
            });
            Module(function() {});
            Module(function(Klang) {
                function Audio(data, name) {
                    this.data = data;
                    this._name = name;
                    this._type = data.type;
                    this._output = Klang.context.createGain();
                    this._volume = data.volume !== undefined ? data.volume : 1;
                    this._output.gain.setValueAtTime(this._volume, Klang.context.currentTime);
                    if (data.destination_name) {
                        this.destinationName = data.destination_name;
                        if (!Klang.core.Core.instance.initComplete) {
                            Klang.core.Core.instance.pushToConnectStack(this)
                        }
                    }
                }
                Audio.prototype.connect = function(destination) {
                    Klang.warn("Audio: Invocation of abstract method: Audio.connect in", this);
                    return this
                };
                Audio.prototype.disconnect = function() {
                    Klang.warn("Audio: Invocation of abstract method: Audio.disconnect in", this);
                    return this
                };
                Audio.prototype.play = function(when, offset) {
                    Klang.warn("Audio: Invocation of abstract method: Audio.play in", this);
                    return this
                };
                Audio.prototype.stop = function(when) {
                    Klang.warn("Audio: Invocation of abstract method: Audio.stop in", this);
                    return this
                };
                Audio.prototype.pause = function() {
                    Klang.warn("Audio: Invocation of abstract method: Audio.pause in", this);
                    return this
                };
                Audio.prototype.unpause = function() {
                    Klang.warn("Audio: Invocation of abstract method: Audio.unpause in", this);
                    return this
                };
                Audio.prototype.curvePlaybackRate = function(value, duration) {
                    Klang.warn("Audio: Invocation of abstract method: Audio.curvePlaybackRate in", this);
                    return this
                };
                Audio.prototype.fadeInAndPlay = function(duration, when) {
                    console.warn("Audio: Invocation of abstract method: Audio.fadeInAndPlay in", this);
                    return this
                };
                Audio.prototype.fadeOutAndStop = function(duration, when) {
                    console.warn("Audio: Invocation of abstract method: Audio.fadeOutAndStop in", this);
                    return this
                };
                Audio.prototype.deschedule = function() {
                    console.warn("Audio: Invocation of abstract method: Audio.deschedule in", this);
                    return this
                };
                Object.defineProperty(Audio.prototype, "playbackRate", {
                    set: function(value) {
                        Klang.warn("Audio: Invocation of abstract property: Audio.playbackRate in", this);
                        return this
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Audio.prototype, "playing", {
                    get: function() {
                        Klang.warn("Audio: Invocation of abstract property: Audio.playing in", this);
                        return false
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Audio.prototype, "duration", {
                    get: function() {
                        Klang.warn("Audio: Invocation of abstract property: Audio.duration in", this);
                        return 0
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Audio.prototype, "output", {
                    get: function() {
                        return this._output
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Audio.prototype, "playbackState", {
                    get: function() {
                        Klang.warn("Audio: Invocation of abstract property: Audio.playbackState in", this);
                        return 0
                    },
                    enumerable: true,
                    configurable: true
                });
                Audio.prototype.setData = function(data) {
                    this._volume = data.volume === undefined ? 1 : data.volume;
                    this._output.gain.value = this._volume;
                    if (this.destinationName != data.destination_name) {
                        this.destinationName = data.destination_name;
                        this.disconnect();
                        this.connect(Klang.core.Core.instance.findInstance(this.destinationName).input)
                    }
                };
                Audio.prototype.clone = function() {
                    var clone = new this["constructor"](this.data, this._name);
                    if (this.data.panner) {
                        this.data.panner = new Klang.Model.Panner(this.data.panner.data)
                    }
                    clone.connect(Klang.core.Core.instance.findInstance(this.destinationName).input);
                    return clone
                };
                return Klang.Model.Audio = Audio
            });
            Module(function(Klang) {
                Klang.engines = Klang.engines || {};
                Klang.engines.webAudio = {}
            });
            Module(function(Klang) {
                Klang.audioUtils = Klang.engines.webAudio.audioUtils = {
                    crossfade: function(buf, loopStart, loopEnd, length, type) {
                        if (typeof type === "undefined") {
                            type = "equalpower"
                        }
                        var funA;
                        var funB;
                        if (type == "linear") {
                            funA = function(x) {
                                return 1 - x
                            };
                            funB = function(x) {
                                return x
                            }
                        } else if (type == "equalpower") {
                            funA = function(x) {
                                return Math.pow(1 - x, .5)
                            };
                            funB = function(x) {
                                return Math.pow(x, .5)
                            }
                        } else {
                            return
                        }
                        loopEnd = Math.min(loopEnd, buf.length);
                        length = Math.min(length, loopStart);
                        for (var c = 0; c < buf.numberOfChannels; c++) {
                            var data = buf.getChannelData(c);
                            var a = loopEnd - 1;
                            var b = loopStart - 1;
                            for (var i = length - 1; i >= 0; i--) {
                                var ratio = (i + 1) / (length + 1);
                                data[a] = data[a] * funA(ratio) + data[b] * funB(ratio);
                                a--;
                                b--
                            }
                            var le = loopEnd;
                            var ls = loopStart;
                            while (le < buf.length) {
                                data[le++] = data[ls++]
                            }
                        }
                    }
                }
            });
            Module(function(Klang) {
                var AudioSource = function(_super) {
                    Klang.Util.__extends(AudioSource, _super);

                    function AudioSource(data, name) {
                        if (data.streaming && Klang.Model.StreamingAudioSource) {
                            return new Klang.Model.StreamingAudioSource(data, name)
                        }
                        _super.call(this, data, name);
                        this._sources = [];
                        this._startTime = 0;
                        this._loopStartTime = 0;
                        this._scheduleAhead = .2;
                        this._stopping = false;
                        this._fading = false;
                        this._paused = false;
                        this._pauseTime = -1;
                        this._pauseStartTime = -1;
                        this.editorName = data.editorName;
                        this._fileId = data.file_id;
                        this._playbackRate = data.playback_rate || 1;
                        this._endTime = 0;
                        this._loop = data.loop !== undefined ? data.loop : false;
                        this._loopStart = data.loop_start;
                        this._loopEnd = data.loop_end;
                        this._offset = data.offset || 0;
                        this._duration = data.duration || 0;
                        this._reverse = data.reverse;
                        this._retrig = data.retrig !== undefined ? data.retrig : true;
                        this._volumeStartRange = data.volume_start_range;
                        this._volumeEndRange = data.volume_end_range;
                        this._pitchStartRange = data.pitch_start_range;
                        this._pitchEndRange = data.pitch_end_range;
                        this._maxSources = data.max_sources || -1;
                        this.priority;
                        if (data.panner) {
                            this._panner = data.panner
                        }
                        if (!Klang.core.Core.instance.pushToPostLoadInitStack(this)) {
                            this.init()
                        }
                    }
                    AudioSource.prototype.init = function() {
                        if (this._fileId) {
                            if (typeof this._fileId == "string") {
                                this._buffer = Klang.core.FileHandler.instance.getFile(this._fileId)
                            } else if (this._fileId.sampleRate) {
                                this._buffer = this._fileId
                            }
                        }
                        if (!this._buffer) {
                            return
                        }
                        if (!this._duration) {
                            this._duration = this._buffer.duration
                        }
                        if (Klang.detector.browser["name"] == "Edge" && this._loop) {
                            this._loopStart = (this._loopStart || 0) + .07;
                            this._loopEnd = (this._loopEnd || this.duration) + .07;
                            this.data.xfade = this.data.xfade || .1
                        }
                        if (this._reverse) {
                            var reverseBuffer = Klang.context.createBuffer(this._buffer.numberOfChannels, this._buffer.length, Klang.context.sampleRate);
                            for (var c = 0; c < this._buffer.numberOfChannels; c++) {
                                var channelBuffer = this._buffer.getChannelData(c);
                                var reverseChannelBuffer = reverseBuffer.getChannelData(c);
                                for (var len = channelBuffer.length, ix = len - 1; ix >= 0; ix--) {
                                    reverseChannelBuffer[len - ix] = channelBuffer[ix]
                                }
                            }
                            this._buffer = reverseBuffer
                        }
                        if (this.data.xfade) {
                            var newBuffer = Klang.context.createBuffer(this._buffer.numberOfChannels, this._buffer.length, Klang.context.sampleRate);
                            for (var c = 0; c < this._buffer.numberOfChannels; c++) {
                                var channelBuffer = this._buffer.getChannelData(c);
                                var newChannelBuffer = newBuffer.getChannelData(c);
                                for (var len = channelBuffer.length, ix = len - 1; ix >= 0; ix--) {
                                    newChannelBuffer[ix] = channelBuffer[ix]
                                }
                            }
                            this._buffer = newBuffer;
                            var sampleRate = Klang.context.sampleRate;
                            var fadeLength = this.data.xfade === true ? 11025 : this.data.xfade * sampleRate;
                            var loopStart = this._loopStart === undefined ? fadeLength : Math.round(this._loopStart * sampleRate);
                            var loopEnd = this._loopEnd === undefined ? this._buffer.length : Math.round(this._loopEnd * sampleRate);
                            Klang.engines.webAudio.audioUtils.crossfade(this._buffer, loopStart, loopEnd, fadeLength)
                        }
                    };
                    AudioSource.prototype.setLoopRegion = function(loopStart, loopEnd) {
                        this._loopStart = loopStart || this._loopStart;
                        this._loopEnd = loopEnd || this._loopEnd;
                        for (var ix = 0, len = this._sources.length; ix < len; ix++) {
                            var source = this._sources[ix];
                            source.loopStart = this._loopStart;
                            source.loopEnd = this._loopEnd
                        }
                        return this
                    };
                    AudioSource.prototype.connect = function(destination, forceConnect) {
                        if (!this._destination || forceConnect) {
                            this._destination = destination;
                            if (this._panner) {
                                this._output.connect(this._panner.input);
                                this._panner.output.connect(destination)
                            } else {
                                this._output.connect(destination)
                            }
                        }
                        return this
                    };
                    AudioSource.prototype.disconnect = function() {
                        this._output.disconnect();
                        this._destination = null;
                        if (this._panner) {
                            this._panner.output.disconnect()
                        }
                        return this
                    };
                    AudioSource.prototype.play = function(when, offset, duration, resume) {
                        when = when || 0;
                        offset = offset || 0;
                        resume = !!resume;
                        this.removeUnusedSources();
                        if (this.priority !== undefined && Klang.getCoreInstance().maxSimultaneousSounds) {
                            var canPlay = this.checkPriority();
                            if (!canPlay) {
                                Klang.warn("AudioSource: Skipped", this.editorName, "due to priority. Priority:", this.priority, "Max sources:", Klang.getCoreInstance().maxSimultaneousSounds);
                                return
                            }
                        }
                        if (this._maxSources > -1 && this._sources.length > this._maxSources) {
                            Klang.warn("AudioSource: Max sources reached", this.editorName);
                            return
                        }
                        if (!duration) {
                            if (this._loop) {
                                duration = 9999999999
                            } else {
                                duration = this._duration
                            }
                        }
                        if (!this._buffer) {
                            this.init();
                            if (!this._buffer) {
                                Klang.warn("AudioSource: Buffer not found!", this.editorName);
                                return
                            }
                        }
                        when = when || 0;
                        if (when !== 0 && when + .01 <= Klang.context.currentTime) {
                            Klang.warn("AudioSource: Returned, playTime < currentTime", this.editorName);
                            return this
                        }
                        if (when === 0) {
                            when = Klang.context.currentTime
                        }
                        this.output.gain.cancelScheduledValues(when);
                        if (this._volumeStartRange !== undefined) {
                            this.output.gain.setValueAtTime(this._volume * (Math.random() * (this._volumeEndRange - this._volumeStartRange) + this._volumeStartRange), when)
                        } else {
                            this.output.gain.setValueAtTime(this._volume, when)
                        }
                        if (!this.paused) {
                            this._pauseStartTime = when
                        }
                        if (!resume) {
                            this._pauseTime = 0
                        }
                        this._startTime = when;
                        this._loopStartTime = when + this.duration;
                        this._paused = false;
                        if (this._stopping && !this._retrig) {
                            this.output.gain.cancelScheduledValues(when);
                            this.output.gain.setValueAtTime(this.output.gain.value, when);
                            this.output.gain.linearRampToValueAtTime(this._volume, when + .25);
                            clearTimeout(this._stoppingId);
                            this._stopping = false;
                            return
                        } else if (!this._fading) {}
                        this._fading = false;
                        if (!this._retrig && !this.loop) {
                            if (when < this._endTime) {
                                return
                            }
                        } else if (this.loop && !this._retrig) {
                            if (this._endTime == -1 || when < this._endTime) {
                                return
                            }
                        } else if (this.loop && this._retrig && this.playing && !this._stopping) {
                            return
                        } else if (this._stopping) {
                            this._stopping = false
                        } else if (Math.round(this._endTime * 1e3) / 1e3 == Math.round((when + this._buffer.duration) * 1e3) / 1e3) {
                            Klang.warn("AudioSource: Returned, Doubletrig", this._name);
                            return this
                        }
                        this._endTime = this.loop ? -1 : when + this._buffer.duration;
                        var source = this.createBufferSource();
                        source.buffer = this._buffer;
                        if (this._loop) {
                            source.loop = true;
                            source.loopStart = this._loopStart ? this._loopStart : 0;
                            source.loopEnd = this._loopEnd ? this._loopEnd : this._buffer.duration
                        }
                        if (!this._destination) {
                            Klang.warn("AudioSource: no destination node")
                        }
                        if (typeof this._destination != "object") {
                            Klang.warn("AudioSource: destination is not an object", this.editorName)
                        }
                        source.connect(this._output);
                        if (offset > this._duration) {
                            offset = offset % this._duration
                        }
                        this._startOffset = this._offset + offset;
                        if (this._pitchStartRange !== undefined) {
                            var _randomplaybackrateValue = this._playbackRate * (Math.random() * (this._pitchEndRange - this._pitchStartRange) + this._pitchStartRange);
                            source.playbackRate.setValueAtTime(_randomplaybackrateValue, Klang.context.currentTime)
                        }
                        source["startTime"] = when;
                        if (this._loop) {
                            source.start(when, this._startOffset)
                        } else {
                            source.start(when, this._startOffset, duration || source.buffer.duration)
                        }
                        if (Klang.core.Core.callbacks && Klang.core.Core.callbacks.scheduleAudioSource) {
                            Klang.core.Core.callbacks.scheduleAudioSource({
                                audio: this,
                                startTime: when
                            })
                        }
                        return this
                    };
                    AudioSource.prototype.getNumberOfSamples = function() {
                        return this._buffer.length
                    };
                    AudioSource.prototype.stop = function(when) {
                        if (typeof when === "undefined") {
                            when = 0
                        }
                        if (this._stopping) {
                            this._stopping = false;
                            clearTimeout(this._stoppingId)
                        }
                        var numSources = this._sources.length;
                        if (numSources > 0) {
                            when = when || Klang.Util.now();
                            if (this._loop) {
                                this._loopPlaying = false
                            }
                            this._endTime = when;
                            if (this._retrig) {
                                this._sources[this._sources.length - 1].stop(when);
                                this._sources.splice(this._sources.length - 1, 1)
                            } else {
                                for (var ix = 0; ix < numSources; ix++) {
                                    var source = this._sources[ix];
                                    source.stop(when);
                                    this._endTime = Klang.Util.now()
                                }
                                this._sources = []
                            }
                        } else {
                            this._loopPlaying = false
                        }
                        this._startTime = -1;
                        return this
                    };
                    AudioSource.prototype.deschedule = function() {
                        for (var ix = 0; ix < this._sources.length; ix++) {
                            var source = this._sources[ix];
                            if (source["startTime"] > Klang.context.currentTime) {
                                source.stop(0);
                                this._sources[ix].disconnect();
                                source.disconnect();
                                this._sources.splice(ix, 1);
                                ix--
                            }
                        }
                        return this
                    };
                    AudioSource.prototype.pause = function() {
                        if (this._endTime > Klang.Util.now()) {
                            this._paused = true;
                            var pauseDelta = Klang.Util.now() - this._startTime;
                            this._pauseTime += pauseDelta;
                            this.stop()
                        }
                        return this
                    };
                    AudioSource.prototype.unpause = function() {
                        if (this.paused) {
                            var realOffset = this._offset;
                            this._offset += this._pauseTime;
                            this.play(0, 0, null, true);
                            this._offset = realOffset;
                            this._paused = false
                        }
                        return this
                    };
                    AudioSource.prototype.createBufferSource = function() {
                        var source = Klang.context.createBufferSource();
                        source.playbackRate.setValueAtTime(this._playbackRate, Klang.context.currentTime);
                        this._sources.push(source);
                        return source
                    };
                    AudioSource.prototype.fadeInAndPlay = function(fadeDuration, when, offset, duration) {
                        if (typeof offset === "undefined") {
                            offset = 0
                        }
                        if (typeof duration === "undefined") {
                            duration = this._duration
                        }
                        var now = Klang.context.currentTime;
                        if (!when) {
                            when = now
                        }
                        if (this.loop && (!this._retrig && (this._endTime == -1 || when < this._endTime)) && !this._stopping) {
                            return
                        } else if (this.loop && this._retrig && this.playing && !this._stopping) {
                            return
                        }
                        this.output.gain.cancelScheduledValues(when);
                        if (this._stopping) {
                            clearTimeout(this._stoppingId);
                            this.output.gain.setValueAtTime(this.output.gain.value, when)
                        } else {
                            this._fading = true;
                            this.play(when == now ? 0 : when, offset, duration);
                            this.output.gain.setValueAtTime(0, when)
                        }
                        this._stopping = false;
                        this.output.gain.linearRampToValueAtTime(this._volume, when + fadeDuration);
                        return this
                    };
                    AudioSource.prototype.fadeOutAndStop = function(duration, when) {
                        if (!this.playing && !this.scheduledToPlay()) {
                            return
                        }
                        if (when === undefined) {
                            when = Klang.context.currentTime
                        }
                        if (when <= this._startTime) {
                            return this.stop()
                        }
                        if (this._stopping) {
                            clearTimeout(this._stoppingId)
                        }
                        this.output.gain.cancelScheduledValues(when);
                        this.output.gain.setValueAtTime(this.output.gain.value || this._volume, when);
                        this.output.gain.linearRampToValueAtTime(0, when + duration);
                        var _this = this;
                        this._stoppingId = setTimeout(function() {
                            if (!_this._stopping) {
                                return
                            }
                            _this._stopping = false;
                            if (_this.loop) {
                                _this._loopPlaying = false
                            }
                            _this.stop(when + duration)
                        }, (duration + (when - Klang.Util.now()) - _this._scheduleAhead) / .001);
                        this._stopping = true;
                        return this
                    };
                    AudioSource.prototype.checkPriority = function() {
                        var core = Klang.getCoreInstance();
                        var playing = core.getPlaying();
                        var canPlay = true;
                        var maxSounds = core.maxSimultaneousSounds;
                        if (playing.length > core.maxSimultaneousSounds) {
                            playing.sort(function(a, b) {
                                return parseFloat(a.priority) - parseFloat(b.priority)
                            });
                            if (playing.length) {
                                if (playing[0].priority < this.priority) {
                                    playing[0].fadeOutAndStop(.1);
                                    Klang.warn("AudioSource: Stopped", playing[0].editorName, "due to priority. Priority:", playing[0].priority, "Max sources:", Klang.getCoreInstance().maxSimultaneousSounds)
                                } else {
                                    canPlay = false
                                }
                            }
                        }
                        return canPlay
                    };
                    AudioSource.prototype.removeUnusedSources = function() {
                        for (var ix = 0; ix < this._sources.length; ix++) {
                            var source = this._sources[ix];
                            if (!source.buffer || !this.loop && source["startTime"] + source.buffer.duration < Klang.context.currentTime) {
                                this._sources[ix].disconnect();
                                this._sources.splice(ix, 1);
                                ix--
                            }
                        }
                    };
                    AudioSource.prototype.curvePlaybackRate = function(value, duration, when) {
                        var startTime = when ? when : Klang.Util.now();
                        var node = this.playbackRateNode;
                        if (node) {
                            node.cancelScheduledValues(startTime);
                            node.setValueAtTime(node.value == 0 ? Klang.Util.EXP_MIN_VALUE : node.value, startTime);
                            node.exponentialRampToValueAtTime(value, startTime + duration)
                        }
                        this._playbackRate = value;
                        return this
                    };
                    Object.defineProperty(AudioSource.prototype, "lastSource", {
                        get: function() {
                            var numSources = this._sources.length;
                            if (numSources == 0) {
                                return null
                            }
                            return this._sources[numSources - 1]
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "loop", {
                        get: function() {
                            return this._loop
                        },
                        set: function(value) {
                            this._loop = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "offset", {
                        get: function() {
                            return this._offset
                        },
                        set: function(value) {
                            if (typeof value === "string" && value.indexOf("%") !== -1) {
                                value = this._duration * parseFloat(value)
                            }
                            this._offset = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "position", {
                        get: function() {
                            if (!this.playing || !this._duration) {
                                return 0
                            }
                            var duration = this._duration;
                            if (this._loopStart || this._loopEnd) {
                                duration = (this._loopEnd || duration) - (this._loopStart || 0)
                            }
                            var timePlayed = Klang.Util.now() - this._startTime;
                            var loopTimePlayed = Klang.Util.now() + this._startOffset - this._loopStartTime;
                            if (this._startOffset + timePlayed > this._duration) {
                                return (this._loopStart || 0) + loopTimePlayed % duration
                            } else {
                                return this._startOffset + timePlayed
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "duration", {
                        get: function() {
                            return this._duration
                        },
                        set: function(value) {
                            this._duration = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "paused", {
                        get: function() {
                            return this._paused
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "playbackRate", {
                        get: function() {
                            return this._playbackRate
                        },
                        set: function(value) {
                            var node = this.playbackRateNode;
                            if (node) {
                                node.cancelScheduledValues(Klang.Util.now())
                            }
                            this._playbackRate = value;
                            for (var ix = 0, len = this._sources.length; ix < len; ix++) {
                                this._sources[ix].playbackRate.value = this._playbackRate
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "nextPlaybackRate", {
                        set: function(value) {
                            this._playbackRate = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "playbackRateNode", {
                        get: function() {
                            var source = this.lastSource;
                            return source && source.playbackRate
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "buffer", {
                        get: function() {
                            if (!this._buffer) {
                                this._buffer = Klang.core.FileHandler.instance.getFile(this._fileId)
                            }
                            return this._buffer
                        },
                        set: function(buffer) {
                            this._buffer = buffer
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "playing", {
                        get: function() {
                            return (this._endTime == -1 || this._endTime > Klang.Util.now()) && this._startTime <= Klang.Util.now()
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "playbackState", {
                        get: function() {
                            var source = this.lastSource;
                            if (source) {
                                return source.playbackState
                            }
                            return 0
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "output", {
                        get: function() {
                            if (this._panner) {
                                return this._panner.output
                            } else {
                                return this._output
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AudioSource.prototype, "panner", {
                        get: function() {
                            return this._panner
                        },
                        enumerable: true,
                        configurable: true
                    });
                    AudioSource.prototype.scheduledToPlay = function() {
                        return this._startTime > Klang.Util.now()
                    };
                    AudioSource.prototype.freeBuffer = function() {
                        this._buffer = null;
                        for (var ix = 0, len = this._sources.length; ix < len; ix++) {
                            try {
                                this._sources[ix].stop(0)
                            } catch (ex) {}
                            this._sources[ix].disconnect();
                            this._sources[ix] = null
                        }
                        this._sources = []
                    };
                    AudioSource.prototype.setData = function(data) {
                        _super.prototype.setData.call(this, data);
                        var reinit = false;
                        this._volumeStartRange = data.volume_start_range;
                        this._volumeEndRange = data.volume_end_range;
                        this._pitchEndRange = data.pitch_end_range;
                        this._pitchStartRange = data.pitch_start_range;
                        if (data.file_id !== undefined && this._fileId != data.file_id) {
                            this._fileId = data.file_id;
                            reinit = true
                        }
                        this._playbackRate = data.playback_rate === undefined ? 1 : data.playback_rate;
                        if (this.playbackRateNode) {
                            this.playbackRateNode.value = this._playbackRate
                        }
                        this._loop = data.loop === undefined ? false : data.loop;
                        if (this.lastSource) {
                            this.lastSource.loop = this._loop
                        }
                        if (!this._loop) {
                            this._loopPlaying = false
                        }
                        this._loopStart = data.loop_start === undefined ? 0 : data.loop_start;
                        if (this.lastSource) {
                            this.lastSource.loopStart = this._loopStart
                        }
                        this._loopEnd = data.loop_end === undefined ? 0 : data.loop_end;
                        if (this.lastSource) {
                            this.lastSource.loopEnd = this._loopEnd
                        }
                        var offset = data.offset === undefined ? 0 : data.offset;
                        if (this._offset != offset) {
                            this._offset = offset;
                            reinit = true
                        }
                        var duration = data.duration === undefined ? 0 : data.duration;
                        if (this._duration != duration) {
                            this._duration = duration;
                            reinit = true
                        }
                        this._retrig = data.retrig === undefined ? true : data.retrig;
                        if (data.reverse === undefined) {
                            data.reverse = false
                        }
                        if (this._reverse != data.reverse) {
                            this._reverse = data.reverse;
                            reinit = true
                        }
                        if (data.xfade === undefined) {
                            data.xfade = false
                        }
                        if (this.data.xfade != data.xfade) {
                            reinit = true
                        }
                        this.data = data;
                        if (reinit) {
                            this.init()
                        }
                        if (data.panner) {
                            if (!this._panner) {
                                var d = this._destination;
                                this.disconnect();
                                this._panner = newPanner(data.panner);
                                this.connect(d)
                            } else {
                                this._panner.setData(data.panner)
                            }
                        } else if (!data.panner) {
                            if (this._panner) {
                                var d = this._destination;
                                this.disconnect();
                                this._panner = null;
                                this.connect(d)
                            }
                        }
                    };
                    return AudioSource
                }(Klang.Model.Audio);
                return Klang.Model.AudioSource = AudioSource
            });
            Module(function(Klang) {
                var GroupType = {
                    CONCURRENT: 0,
                    STEP: 1,
                    RANDOM: 2,
                    SHUFFLE: 3,
                    BACKWARDS: 4
                };
                var QueueType = {
                    NONE: 0,
                    ONE: 1,
                    INFINITE: 2
                };

                function AudioGroup(data, name) {
                    this._adder = 0;
                    this._currentId = 0;
                    this._paused = false;
                    this.data = data;
                    this.editorName = data.editorName;
                    this._name = name;
                    this._type = data.type;
                    this._groupType = data.group_type !== undefined ? data.group_type : GroupType.STEP;
                    this._retrig = data.retrig !== undefined ? data.retrig : true;
                    this._queue = data.queue !== undefined ? data.queue : QueueType.NONE;
                    this._content = data.content || [];
                    Klang.core.Core.instance.pushToPreLoadInitStack(this)
                }
                AudioGroup.prototype.init = function() {
                    var newContent = [];
                    for (var ix = 0, len = this._content.length; ix < len; ix++) {
                        newContent.push(Klang.core.Core.instance.findInstance(this._content[ix]))
                    }
                    this._content = newContent
                };
                AudioGroup.prototype.play = function(when, audioSource, forcePlay) {
                    if (!this._content.length) {
                        return
                    }
                    var latestPlaying = this.latestPlayed ? this.latestPlayed.playing : false;
                    if (!forcePlay && !this._retrig && latestPlaying) {
                        if (this._queue != QueueType.NONE) {
                            if (this._queue == QueueType.ONE && this._latestStartTime > Klang.context.currentTime) {
                                this.latestPlayed.stop();
                                this.play(this._latestStartTime, audioSource, true)
                            } else {
                                this.play(this._latestStartTime + this.latestPlayed.duration, audioSource, true)
                            }
                        }
                        return this
                    }
                    this._paused = false;
                    if (audioSource !== undefined) {
                        var asId;
                        if (typeof audioSource == "number") {
                            asId = audioSource
                        } else if (typeof audioSource == "string") {
                            asId = this.getIdFromString(audioSource)
                        } else if (audioSource._name) {
                            asId = this.getIdFromString(audioSource._name)
                        }
                        this._content[asId].play(when);
                        this._latestPlayed = this._content[asId]
                    } else {
                        if (this._groupType == GroupType.CONCURRENT) {
                            for (var ix = 0, len = this._content.length; ix < len; ix++) {
                                this._content[ix].play(when)
                            }
                        } else {
                            this._currentId = this.getIdToPlay();
                            this._content[this._currentId].play(when)
                        }
                        if (this._groupType === GroupType.CONCURRENT) {
                            this._latestPlayed = this._content[0]
                        } else {
                            this._latestPlayed = this._content[this._currentId]
                        }
                    }
                    this._latestStartTime = when || Klang.context.currentTime;
                    return this
                };
                AudioGroup.prototype.getIdToPlay = function() {
                    var _id;
                    if (this._groupType == GroupType.STEP) {
                        if (this._adder < 0) {
                            _id = this._content.length - 1 + this._adder % this._content.length
                        } else {
                            _id = this._adder % this._content.length
                        }
                        this._adder++
                    } else if (this._groupType == GroupType.RANDOM) {
                        var random = Math.floor(Math.random() * (this._content.length - 1));
                        if (this._content.length > 1 && random == this._adder) {
                            random = (random + 1) % this._content.length
                        }
                        _id = this._adder = random
                    } else if (this._groupType == GroupType.SHUFFLE) {
                        if (this._adder % this._content.length == 0) {
                            Klang.Util.shuffle(this._content)
                        }
                        _id = this._adder % this._content.length;
                        this._adder++
                    } else if (this._groupType == GroupType.BACKWARDS) {
                        if (this._adder < 0) {
                            _id = this._content.length - 1 + this._adder % this._content.length
                        } else {
                            _id = this._adder % this._content.length
                        }
                        this._adder--
                    }
                    return _id
                };
                AudioGroup.prototype.stop = function(when) {
                    this._content[this._currentId].stop(when);
                    return this
                };
                AudioGroup.prototype.stopAll = function(when) {
                    for (var ix = 0, len = this._content.length; ix < len; ix++) {
                        this._content[ix].stop(when)
                    }
                    return this
                };
                AudioGroup.prototype.pause = function() {
                    this._paused = true;
                    if (this._latestPlayed) {
                        this._latestPlayed.pause()
                    }
                    return this
                };
                AudioGroup.prototype.unpause = function() {
                    this._paused = false;
                    if (this._latestPlayed) {
                        this._latestPlayed.unpause()
                    }
                    return this
                };
                AudioGroup.prototype.fadeInAndPlay = function(duration, when) {
                    var latestPlaying = this.latestPlayed ? this.latestPlayed.playing : false;
                    if (!this._retrig && latestPlaying) {
                        return
                    }
                    this._currentId = this.getIdToPlay();
                    this._latestPlayed = this._content[this._currentId];
                    this._content[this._currentId].fadeInAndPlay(duration, when);
                    return this
                };
                AudioGroup.prototype.fadeOutAndStop = function(duration, when) {
                    if (when === undefined) {
                        when = Klang.context.currentTime
                    }
                    if (this._latestPlayed) {
                        this._latestPlayed.fadeOutAndStop(duration, when)
                    }
                    return this
                };
                AudioGroup.prototype.curvePlaybackRate = function(value, duration, when) {
                    var startTime = when ? when : Klang.Util.now();
                    for (var ix = 0, len = this._content.length; ix < len; ix++) {
                        this._content[ix].curvePlaybackRate(value, duration, when)
                    }
                    return this
                };
                AudioGroup.prototype.deschedule = function() {
                    for (var ix = 0, len = this._content.length; ix < len; ix++) {
                        this._content[ix].deschedule()
                    }
                    return this
                };
                AudioGroup.prototype.getIdFromString = function(str) {
                    for (var ix = 0, len = this._content.length; ix < len; ix++) {
                        if (this._content[ix]._name == str) {
                            return ix
                        }
                    }
                };
                Object.defineProperty(AudioGroup.prototype, "playbackRate", {
                    set: function(value) {
                        for (var ix = 0, len = this._content.length; ix < len; ix++) {
                            this._content[ix].playbackRate = value
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AudioGroup.prototype, "groupType", {
                    get: function() {
                        return this._groupType
                    },
                    set: function(value) {
                        this._groupType = value
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AudioGroup.prototype, "content", {
                    get: function() {
                        return this._content
                    },
                    set: function(value) {
                        this._content = value;
                        this.init()
                    },
                    enumerable: true,
                    configurable: true
                });
                AudioGroup.prototype.addContent = function(audio) {
                    this._content.push(audio)
                };
                AudioGroup.prototype.removeContent = function(name) {
                    for (var i = 0; i < this._content.length; i++) {
                        if (this._content[i]._name === name) {
                            this._content.splice(i, 1)
                        }
                    }
                };
                Object.defineProperty(AudioGroup.prototype, "playing", {
                    get: function() {
                        return this._latestPlayed ? this._latestPlayed.playing : false
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AudioGroup.prototype, "duration", {
                    get: function() {
                        return this._latestPlayed ? this._latestPlayed.duration : this._content[0].duration
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AudioGroup.prototype, "playbackState", {
                    get: function() {
                        return this._content[this._currentId].playbackState
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AudioGroup.prototype, "latestPlayed", {
                    get: function() {
                        return this._latestPlayed
                    },
                    enumerable: true,
                    configurable: true
                });
                AudioGroup.prototype.setData = function(data) {
                    this._groupType = data.group_type === undefined ? GroupType.STEP : data.group_type;
                    this._retrig = data.retrig === undefined ? true : data.retrig;
                    this._queue = data.queue === undefined ? QueueType.NONE : data.queue;
                    if (data.content) {
                        this._content = data.content;
                        this.init()
                    }
                };
                return Klang.Model.AudioGroup = AudioGroup
            });
            Module(function(Klang) {
                function Automation(data) {
                    this._startValue = data.start_value || 0;
                    this._points = data.points || []
                }
                Automation.prototype.automate = function(param, when) {
                    when = when || Klang.context.currentTime;
                    param.cancelScheduledValues(when);
                    param.setValueAtTime(this._startValue, when);
                    var lastEndTime = 0;
                    for (var ix = 0, len = this._points.length; ix < len; ix++) {
                        var p = this._points[ix];
                        switch (p.curve) {
                            case "lin":
                                param.linearRampToValueAtTime(p.value, when + p.time);
                                break;
                            case "exp":
                                param.exponentialRampToValueAtTime(p.value, when + p.time);
                                break;
                            default:
                                if (Klang.Util.CUSTOM_CURVES[p.curve]) {
                                    Klang.warn("Automation: Invalid curve type: " + p.curve);
                                    break
                                }
                                param.setValueCurveAtTime(Klang.Util.CUSTOM_CURVES[p.curve], when + lastEndTime, p.time - lastEndTime);
                                break
                        }
                        lastEndTime = p.time
                    }
                };
                return Klang.Model.Automation = Automation
            });
            Module(function(Klang) {
                function Bus(data, name) {
                    this._name = name;
                    this._type = data.type;
                    this._input = Klang.context.createGain();
                    this._output = Klang.context.createGain();
                    this._effects = data.effects || [];
                    this._data = data;
                    for (var i = 0, len = this._effects.length; i < len; i++) {
                        if (data.effects[i].active === false) {
                            this._effects[i].setActive(false)
                        }
                    }
                    var inputVol = data.input_vol !== undefined ? data.input_vol : 1;
                    var outputVol = data.output_vol !== undefined ? data.output_vol : 1;
                    this._input.gain.setValueAtTime(inputVol, Klang.context.currentTime);
                    this._output.gain.setValueAtTime(outputVol, Klang.context.currentTime);
                    if (data.destination_name) {
                        this.destinationName = data.destination_name;
                        Klang.core.Core.instance.pushToConnectStack(this)
                    }
                    Klang.core.Core.instance.pushToPreLoadInitStack(this)
                }
                Bus.prototype.init = function() {
                    var lastNode = this._input;
                    for (var i = 0, len = this._effects.length; i < len; i++) {
                        lastNode.disconnect();
                        lastNode.connect(this._effects[i].input);
                        lastNode = this._effects[i]
                    }
                    lastNode.connect(this._output)
                };
                Bus.prototype.connect = function(destination) {
                    this._output.connect(destination);
                    this._destination = destination;
                    return this
                };
                Bus.prototype.disconnect = function() {
                    this._output.disconnect();
                    return this
                };
                Bus.prototype.refreshAudioNodes = function() {
                    for (var i = 0; i < this.effects.length; i++) {
                        this.effects[i].disconnect();
                        if (this.effects[i].refreshAudioNodes) {
                            this.effects[i].refreshAudioNodes()
                        }
                    }
                    var outVol = this._output.gain.value;
                    this._output.gain.cancelScheduledValues(Klang.context.currentTime);
                    this._output.disconnect();
                    this._output = Klang.context.createGain();
                    this._output.gain.setValueAtTime(outVol, Klang.context.currentTime);
                    this.init();
                    if (this._destination) {
                        this._output.connect(this._destination)
                    }
                };
                Bus.prototype.insertEffect = function(effectData, index) {
                    var effect = Klang.core.Core.instance.createObject(undefined, effectData, {
                        excludeFromTable: true
                    });
                    if (index === undefined) {
                        this._effects.push(effect)
                    } else {
                        this._effects.splice(index, 0, effect)
                    }
                    this.init();
                    return this
                };
                Bus.prototype.moveEffect = function(fromIndex, toIndex) {
                    for (var i = 0, len = this._effects.length; i < len; i++) {
                        this._effects[i].disconnect()
                    }
                    var effect = this._effects[fromIndex];
                    this._effects.splice(fromIndex, 1);
                    this._effects.splice(toIndex, 0, effect);
                    this.init();
                    return this
                };
                Object.defineProperty(Bus.prototype, "input", {
                    get: function() {
                        return this._input
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bus.prototype, "output", {
                    get: function() {
                        return this._output
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bus.prototype, "effects", {
                    get: function() {
                        return this._effects
                    },
                    enumerable: true,
                    configurable: true
                });
                Bus.prototype.setData = function(data) {
                    this._input.gain.value = data.input_vol === undefined ? 1 : data.input_vol;
                    this._output.gain.value = data.output_vol === undefined ? 1 : data.output_vol;
                    if (data.effects.length < this.effects.length) {
                        this.input.disconnect();
                        var found = false;
                        for (var ix = 0; ix < this._effects.length; ix++) {
                            this._effects[ix].disconnect();
                            if (!found) {
                                if (data.effects[ix] === undefined) {
                                    this._effects.splice(ix, 1);
                                    found = true
                                } else if (this._effects[ix]._type != data.effects[ix].type) {
                                    this._effects.splice(ix, 1);
                                    ix--;
                                    found = true
                                }
                            }
                        }
                        this.init()
                    } else if (data.effects.length > this.effects.length) {
                        this.insertEffect(data.effects[data.effects.length - 1])
                    } else {
                        for (var ix = 0, len = this._effects.length; ix < len; ix++) {
                            this._effects[ix].setData(data.effects[ix])
                        }
                    }
                    if (this.destinationName != data.destination_name) {
                        this.destinationName = data.destination_name;
                        this.disconnect();
                        if (this.destinationName == "$OUT") {
                            this.connect(Klang.core.Core.instance._superMasterOutput)
                        } else {
                            this.connect(Klang.core.Core.instance.findInstance(this.destinationName).input)
                        }
                    }
                };
                return Klang.Model.Bus = Bus
            });
            Module(function(Klang) {
                Klang.audioUtil = Klang.engines.webAudio.Util = {}
            });
            Module(function(Klang) {
                var scales = {
                    diatonic: [0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, 0],
                    dorian: [0, 1, 0, 0, -1, 0, 1, 0, 1, 0, 0, -1],
                    phrygian: [0, 0, -1, 0, -1, 0, 1, 0, 0, -1, 0, -1],
                    lydian: [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],
                    mixolydian: [0, 1, 0, 1, 0, 0, -1, 0, -1, 0, 0, -1],
                    aeolian: [0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0, -1],
                    locrian: [0, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1],
                    harmonicMinor: [0, 1, 0, 0, -1, 0, 1, 0, 0, -1, 1, 0],
                    melodicMinor: [0, 1, 0, 0, -1, 0, 1, 0, -1, 0, 1, 0],
                    majorPentatonic: [0, 1, 0, 1, 0, -1, 1, 0, 1, 0, -1, 1],
                    minorPentatonic: [0, -1, 1, 0, -1, 0, 1, 0, -1, 1, 0, -1],
                    doubleHarmonic: [0, 0, -1, 1, 0, 0, 1, 0, 0, -1, 1, 0],
                    halfDim: [0, 1, 0, 0, -1, 0, 0, -1, 0, -1, 0, -1],
                    chromatic: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    custom: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                };
                var getTransposeFromScale = function(midiNoteNumber, scale, root) {
                    var scaleStep = midiNoteNumber % 12 - root;
                    if (scaleStep < 0) {
                        scaleStep += 12
                    }
                    var transpose = this.scales[scale][scaleStep];
                    return transpose
                };
                var getNoteInScale = function(midiNoteNumber, scale, root) {
                    var transpose;
                    if (scale) {
                        var orgNote = midiNoteNumber;
                        var scaleStep = orgNote % 12 - root;
                        if (scaleStep < 0) {
                            scaleStep += 12
                        }
                        transpose = this.scales[scale][scaleStep]
                    }
                    return midiNoteNumber + transpose
                };
                Klang.engines.webAudio.Util.getNoteInScale = getNoteInScale;
                Klang.engines.webAudio.Util.getTransposeFromScale = getTransposeFromScale;
                Klang.engines.webAudio.Util.scales = scales
            });
            Module(function(Klang) {
                (function(PatternState) {
                    PatternState._map = [];
                    PatternState._map[0] = "PrePlaying";
                    PatternState.PrePlaying = 0;
                    PatternState._map[1] = "Playing";
                    PatternState.Playing = 1;
                    PatternState._map[2] = "PreStopping";
                    PatternState.PreStopping = 2;
                    PatternState._map[3] = "PostStop";
                    PatternState.PostStop = 3;
                    PatternState._map[4] = "Stopped";
                    PatternState.Stopped = 4
                })(Klang.Model.PatternState || (Klang.Model.PatternState = {}));
                var PatternState = Klang.Model.PatternState;

                function getPatternStateString(state) {
                    switch (state) {
                        case PatternState.PrePlaying:
                            return "PrePlaying";
                        case PatternState.Playing:
                            return "Playing";
                        case PatternState.PreStopping:
                            return "PreStopping";
                        case PatternState.PostStop:
                            return "PostStop";
                        case PatternState.Stopped:
                            return "Stopped"
                    }
                }
                Klang.Model.getPatternStateString = getPatternStateString;
                var Pattern = function(_super) {
                    Klang.Util.__extends(Pattern, _super);

                    function Pattern(data, name) {
                        _super.call(this, data, name);
                        this._startStep = 0;
                        this._totalStep = 0;
                        this._currentStep = 0;
                        this._syncStep = 0;
                        this._stepCount = 0;
                        this._fadeTime = 0;
                        this._length = 2;
                        this._loop = true;
                        this._tail = false;
                        this._forceFade = false;
                        this._activeUpbeat = -1;
                        this._startOffset = 0;
                        this._state = PatternState.Stopped;
                        this._beatSubscription = data.beat_subscription || .25;
                        this._length = data.length || 0;
                        this._startStep = data.start_step || 0;
                        this._loop = data.loop !== undefined ? data.loop : true;
                        this._tail = data.tail !== undefined ? data.tail : false;
                        this._clips = [];
                        this._upbeats = [];
                        this._sequencerName = data.sequencer;
                        this._initData = {
                            dummyClips: data.content,
                            dummyUpbeats: data.upbeats
                        };
                        Klang.core.Core.instance.pushToPreLoadInitStack(this)
                    }
                    Pattern.prototype.init = function() {
                        if (this._initData.dummyClips) {
                            for (var ix = 0, len = this._initData.dummyClips.length; ix < len; ix++) {
                                var dummy = this._initData.dummyClips[ix];
                                if (dummy.audio) {
                                    this._clips.push({
                                        audio: Klang.core.Core.instance.findInstance(dummy.audio),
                                        process: null,
                                        args: null,
                                        step: dummy.step
                                    });
                                    this._clips[this._clips.length - 1].audio._parentType = this._type
                                } else {
                                    this._clips.push({
                                        audio: null,
                                        process: Klang.core.Core.instance.findInstance(dummy.process),
                                        args: dummy.args,
                                        step: dummy.step
                                    })
                                }
                            }
                        }
                        if (this._initData.dummyUpbeats) {
                            for (var ix = 0, ilen = this._initData.dummyUpbeats.length; ix < ilen; ix++) {
                                var dummyUpbeat = this._initData.dummyUpbeats[ix];
                                var upbeatClips = [];
                                for (var jx = 0, jlen = dummyUpbeat.content.length; jx < jlen; jx++) {
                                    var dummyClip = dummyUpbeat.content[jx];
                                    if (dummyClip.audio) {
                                        upbeatClips.push({
                                            audio: Klang.core.Core.instance.findInstance(dummyClip.audio),
                                            process: null,
                                            args: null,
                                            step: dummyClip.step
                                        });
                                        this._clips[this._clips.length - 1].audio._parentType = this._type
                                    } else {
                                        upbeatClips.push({
                                            audio: null,
                                            process: Klang.core.Core.instance.findInstance(dummyClip.process),
                                            args: dummyClip.args,
                                            step: dummyClip.step
                                        })
                                    }
                                }
                                dummyUpbeat.clips = upbeatClips;
                                this._upbeats.push({
                                    length: dummyUpbeat.length,
                                    clips: upbeatClips
                                })
                            }
                            this._upbeats.sort(function(a, b) {
                                return b.length - a.length
                            })
                        }
                        this._sequencer = Klang.core.Core.instance.findInstance(this._sequencerName);
                        this._sequencer.registerPattern(this);
                        this._initData = null
                    };
                    Pattern.prototype.connect = function(destination) {
                        for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                            var a = this._clips[ix].audio;
                            if (a && (!a.destinationName || Klang.core.Core.instance.findInstance(a.destinationName).destinationName == "$OUT")) {
                                a.disconnect();
                                a.connect(this._output)
                            }
                        }
                        this._output.connect(destination);
                        return this
                    };
                    Pattern.prototype.disconnect = function() {
                        this._output.disconnect();
                        return this
                    };
                    Pattern.prototype.changeState = function(state) {
                        if (state == this._state) {
                            return
                        }
                        if (Klang.core.Core.callbacks && Klang.core.Core.callbacks.changePatternState) {
                            Klang.core.Core.callbacks.changePatternState({
                                pattern: this,
                                lastState: this._state,
                                newState: state,
                                step: this._sequencer.currentStep
                            })
                        }
                        this._state = state
                    };
                    Pattern.prototype.prePlaySchedule = function(steps, syncStep, restart, fadeIn, duration, offset) {
                        restart = restart || false;
                        var t = Klang.context.currentTime;
                        if (this._state == PatternState.PreStopping || this._state == PatternState.PostStop) {
                            this._output.gain.cancelScheduledValues(t);
                            this._output.gain.setValueAtTime(this._output.gain.value, t);
                            this._output.gain.linearRampToValueAtTime(this._volume, t + .5);
                            this.changeState(PatternState.Playing);
                            clearTimeout(this._stoppingId);
                            return this
                        } else if (this._output.gain.value != this._volume || PatternState.Stopped) {
                            var v;
                            if (this._state === PatternState.Stopped && fadeIn) {
                                v = 0
                            } else {
                                v = this._output.gain.value
                            }
                            this._output.gain.cancelScheduledValues(t);
                            this._output.gain.setValueAtTime(v, t);
                            this._output.gain.linearRampToValueAtTime(this._volume, t + duration)
                        } else if (fadeIn) {
                            var playTime = this._sequencer.getBeatTime(steps);
                            this._output.gain.cancelScheduledValues(playTime);
                            this._output.gain.setValueAtTime(0, playTime);
                            this._output.gain.linearRampToValueAtTime(this._volume, playTime + duration)
                        }
                        if (this._state == PatternState.Playing || this._state == PatternState.PrePlaying) {
                            if (restart) {
                                this._syncStep = syncStep;
                                this.stop(steps, true, 0)
                            } else {
                                return this
                            }
                        }
                        if (offset !== undefined) {
                            this._startOffset = offset
                        }
                        this._syncStep = syncStep % this._length + this._startStep;
                        if (steps > 0 || restart) {
                            this._stepCount = steps;
                            this._currentStep = this._startStep;
                            this._totalStep = 0;
                            this._activeUpbeat = -1;
                            for (var ix = 0, len = this._upbeats.length; ix < len; ix++) {
                                var upbeat = this._upbeats[ix];
                                if (upbeat.length <= steps) {
                                    if (this._activeUpbeat == -1 || this._upbeats[this._activeUpbeat].length < upbeat.length) {
                                        this._activeUpbeat = ix
                                    }
                                }
                            }
                            this.changeState(PatternState.PrePlaying)
                        } else {
                            this.changeState(PatternState.Playing)
                        }
                        return this
                    };
                    Pattern.prototype.play = function(when) {
                        if (this._state == PatternState.Playing || this._state == PatternState.PrePlaying) {
                            return this
                        } else if (this._state == PatternState.PreStopping || this._state == PatternState.PostStop) {
                            clearTimeout(this._stoppingId)
                        }
                        this._currentStep = this._sequencer.currentStep % this._length + this._startStep;
                        this.changeState(PatternState.Playing);
                        if (!this._sequencer.started) {
                            this._sequencer.start()
                        }
                        return this
                    };
                    Pattern.prototype.stop = function(when, beat, fadeTime, wait) {
                        if (this._state == PatternState.Stopped) {
                            return this
                        } else if (this._state === PatternState.PrePlaying) {
                            this.changeState(PatternState.Stopped);
                            return
                        }
                        if (when === undefined) {
                            this.changeState(PatternState.Stopped);
                            this._currentStep = 0;
                            return this
                        }
                        if (beat === undefined) {
                            beat = true
                        }
                        if (beat) {
                            this._stepCount = this._sequencer.getStepsToNext(this._sequencer.beatLength * when) || 0;
                            this._fadeTime = fadeTime;
                            this.changeState(PatternState.PreStopping);
                            if (wait > 0) {
                                this._stepCount += wait
                            }
                        } else {
                            if (fadeTime) {
                                var fadeBeats = fadeTime / this._sequencer.getNoteTime(1);
                                this._stepCount = Math.ceil(fadeBeats);
                                this.changeState(PatternState.Stopped);
                                var t = Klang.context.currentTime;
                                for (var i = 0; i < this._clips.length; i++) {
                                    if (this._clips[i].audio) {
                                        this._clips[i].audio.fadeOutAndStop(fadeTime, when)
                                    }
                                }
                            } else {
                                this.changeState(PatternState.Stopped);
                                this._currentStep = 0;
                                for (var i = 0; i < this._clips.length; i++) {
                                    if (this._clips[i].audio) {
                                        this._clips[i].audio.stop(when + this._sequencer.getNoteTime(this._sequencer.resolution))
                                    }
                                }
                            }
                        }
                        return this
                    };
                    Pattern.prototype.pause = function() {
                        for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                            if (this._clips[ix].audio) {
                                this._clips[ix].audio.pause()
                            }
                        }
                        return this
                    };
                    Pattern.prototype.unpause = function() {
                        for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                            if (this._clips[ix].audio) {
                                this._clips[ix].audio.unpause()
                            }
                        }
                        return this
                    };
                    Pattern.prototype.playStep = function(currentStep, scheduleTime) {
                        if (this._currentStep >= this._length + this._startStep) {
                            if (this._loop) {
                                this._currentStep = this._startStep
                            } else if (!this._loop) {
                                this.changeState(PatternState.Stopped)
                            }
                        }
                        for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                            if (this._clips[ix].step == this._currentStep) {
                                var clip = this._clips[ix];
                                if (clip.audio) {
                                    clip.audio.play(scheduleTime, this._startOffset)
                                } else {
                                    clip.process.start(clip.args)
                                }
                            }
                        }
                        this._totalStep += this._beatSubscription;
                        this._currentStep += this._beatSubscription
                    };
                    Pattern.prototype.update = function(currentStep, scheduleTime) {
                        if (this._state != PatternState.Stopped && currentStep % this._beatSubscription == 0) {
                            switch (this._state) {
                                case PatternState.PrePlaying:
                                    {
                                        if (this._activeUpbeat != -1) {
                                            var upbeat = this._upbeats[this._activeUpbeat];
                                            for (var ix = 0, len = upbeat.clips.length; ix < len; ix++) {
                                                var clip = upbeat.clips[ix];
                                                if (clip.step == upbeat.length - this._stepCount) {
                                                    if (clip.audio) {
                                                        clip.audio.play(scheduleTime)
                                                    } else {
                                                        clip.process.start(clip.args)
                                                    }
                                                }
                                            }
                                        }
                                        this._stepCount -= this._beatSubscription;
                                        if (this._stepCount <= 0) {
                                            this._currentStep = this._startStep + this._syncStep % this._length;
                                            this._syncStep = 0;
                                            this.changeState(PatternState.Playing)
                                        }
                                        break
                                    }
                                case PatternState.Playing:
                                    {
                                        this.playStep(currentStep, scheduleTime);
                                        break
                                    }
                                case PatternState.PreStopping:
                                    {
                                        this._stepCount -= this._beatSubscription;
                                        if (this._stepCount <= 0) {
                                            if (!this._tail || this._forceFade) {
                                                this.stop(scheduleTime, false, this._fadeTime)
                                            } else {
                                                this.changeState(PatternState.Stopped);
                                                this._currentStep = 0
                                            }
                                        } else {
                                            this.playStep(currentStep, scheduleTime)
                                        }
                                        break
                                    }
                                case PatternState.PostStop:
                                    {
                                        this.playStep(currentStep, scheduleTime);this._stepCount -= this._beatSubscription;
                                        if (this._stepCount <= 0) {
                                            this._forceFade = false;
                                            this.changeState(PatternState.Stopped);
                                            this._currentStep = 0
                                        }
                                        break
                                    }
                            }
                        }
                        return this
                    };
                    Pattern.prototype.deschedule = function(steps) {
                        if (steps === undefined) {
                            steps = this._length
                        }
                        if (this._state != PatternState.Stopped) {
                            steps = steps % this._length;
                            for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                                var clip = this._clips[ix];
                                if (clip.audio) {
                                    clip.audio.deschedule()
                                }
                            }
                            clearTimeout(this._stoppingId);
                            this._output.gain.cancelScheduledValues(Klang.Util.now());
                            this._currentStep = this._currentStep - steps;
                            if (this._currentStep < this._startStep) {
                                var stepDelta = this._startStep - this._currentStep;
                                this._currentStep = this._startStep + this._length - stepDelta
                            }
                        }
                        return this
                    };
                    Pattern.prototype.fadeInAndPlay = function(duration, when) {
                        return this
                    };
                    Pattern.prototype.fadeOutAndStop = function(duration, when) {
                        when = when || Klang.Util.now();
                        this.stop(when, false, duration);
                        return this
                    };
                    Pattern.prototype.curvePlaybackRate = function(value, duration) {
                        for (var i = 0, l = this._clips.length; i < l; i++) {
                            this._clips[i].audio.curvePlaybackRate(value, duration)
                        }
                        return this
                    };
                    Pattern.prototype.getNextBar = function(x) {
                        var nextBar = Math.ceil(this._currentStep / x);
                        if (this._currentStep > this._length - x) {
                            nextBar = 0
                        }
                        return nextBar
                    };
                    Object.defineProperty(Pattern.prototype, "forceFade", {
                        set: function(value) {
                            this._forceFade = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "playbackRate", {
                        set: function(value) {
                            for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                                this._clips[ix].audio.playbackRate = value
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "length", {
                        get: function() {
                            return this._length
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "loop", {
                        get: function() {
                            return this._loop
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "state", {
                        get: function() {
                            return this._state
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "playing", {
                        get: function() {
                            var _playing = false;
                            if (this._state === 1 || this._state === 1) {
                                _playing = true
                            }
                            return _playing
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "duration", {
                        get: function() {
                            return this._length * this._sequencer.getNoteTime(1)
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "playbackState", {
                        get: function() {
                            return 0
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Pattern.prototype, "currentStep", {
                        get: function() {
                            return this._currentStep
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Pattern.prototype.setData = function(data) {
                        _super.prototype.setData.call(this, data);
                        var reinit = false;
                        this._beatSubscription = data.beat_subscription !== undefined ? data.beat_subscription : .25;
                        this._length = data.length !== undefined ? data.length : 0;
                        this._startStep = data.start_step !== undefined ? data.start_step : 0;
                        this._loop = data.loop === undefined ? true : data.loop;
                        this._tail = data.tail === undefined ? false : data.tail;
                        if (data.sequencer !== undefined && this._sequencerName != data.sequencer) {
                            this._sequencerName = data.sequencer;
                            reinit = true
                        }
                        this._initData = {
                            dummyClips: null,
                            dummyUpbeats: null
                        };
                        if (data.content) {
                            this._initData.dummyClips = data.content;
                            this._clips = [];
                            reinit = true
                        }
                        if (data.upbeats) {
                            this._initData.dummyUpbeats = data.upbeats;
                            this._upbeats = [];
                            reinit = true
                        }
                        if (reinit) {
                            this._sequencer.unregisterPattern(this);
                            this.init()
                        }
                    };
                    return Pattern
                }(Klang.Model.Audio);
                return Klang.Model.Pattern = Pattern
            });
            Module(function(Klang) {
                var PatternState = Klang.Model.PatternState;
                var audioUtil = Klang.engines.webAudio.Util;
                var MidiPattern = function(_super) {
                    Klang.Util.__extends(MidiPattern, _super);

                    function MidiPattern(data, name) {
                        _super.call(this, data, name);
                        this._startStep = 0;
                        this._totalStep = 0;
                        this._currentStep = 0;
                        this._syncStep = 0;
                        this._stepCount = 0;
                        this._fadeTime = 0;
                        this._transpose = 0;
                        this._updatedClips = [];
                        this._state = PatternState.Stopped;
                        this._beatSubscription = data.beat_subscription || .25;
                        this._midiFileId = data.file_id;
                        this._midiTrackIx = data.midi_track || 0;
                        this._sequencerName = data.sequencer;
                        this._synthName = data.synth;
                        this._loop = data.loop !== undefined ? data.loop : true;
                        this._length = data.length || 0;
                        this._nextClip = 0;
                        this._startStep = data.start_step || 0;
                        this._root = data.root || 0;
                        this._transpose = this._orgTranspose = data.transpose || 0;
                        this._scale = this._orgScale = data.scale;
                        this._rootNote = data.root_note || 36;
                        this._activeUpbeat = -1;
                        this._dataClips = data.clips || undefined;
                        if (data.upbeats) {
                            this._upbeats = [];
                            this._upbeatLoopOffset = 0;
                            for (var ix = 0, len = data.upbeats.length; ix < len; ix++) {
                                this._upbeats.push({
                                    length: data.upbeats[ix].length,
                                    step: data.upbeats[ix].step,
                                    targetStep: data.upbeats[ix].target_step,
                                    playInLoop: data.upbeats[ix].play_in_loop
                                })
                            }
                        }
                        Klang.core.Core.instance.pushToPostLoadInitStack(this)
                    }
                    MidiPattern.prototype.init = function() {
                        this._sequencer = Klang.core.Core.instance.findInstance(this._sequencerName);
                        this._sequencer.registerPattern(this);
                        if (this._synthName === "progression") {
                            this._synth = "progression";
                            this._progression = true;
                            this._currentChord = []
                        } else {
                            this._synth = Klang.core.Core.instance.findInstance(this._synthName)
                        }
                        this._midiFile = Klang.core.FileHandler.instance.getFile(this._midiFileId);
                        if (this._midiFile) {
                            this.setupFile()
                        } else if (this._dataClips) {
                            this._clips = this._dataClips
                        } else {
                            this._clips = []
                        }
                    };
                    MidiPattern.prototype.setupFile = function() {
                        this._midiTrack = this._midiFile.tracks[this._midiTrackIx];
                        if (this._midiTrack === undefined) {
                            Klang.warn("MidiPattern: midi track out of bounds: " + this._midiTrackIx)
                        }
                        this.recalculateBPM(this._sequencer.bpm);
                        var ticksPerBeat = this._midiFile.header.ticksPerBeat;
                        var step = 0;
                        var ticks = 0;
                        this._clips = [];
                        for (var ix = 0, len = this._midiTrack.length; ix < len; ix++) {
                            var ev = this._midiTrack[ix];
                            ticks += ev.deltaTime;
                            var of = ticks / ticksPerBeat % this._sequencer.resolution;
                            var st = ticks / ticksPerBeat - of;
                            this._clips.push({
                                event: ev,
                                step: st,
                                offset: ticks % (ticksPerBeat * this._sequencer.resolution)
                            })
                        }
                        return this
                    };
                    MidiPattern.prototype.connect = function(destination) {
                        this._output.connect(destination);
                        return this
                    };
                    MidiPattern.prototype.disconnect = function() {
                        this._output.disconnect();
                        return this
                    };
                    MidiPattern.prototype.changeState = function(state) {
                        if (state == this._state) {
                            return
                        }
                        if (Klang.core.Core.callbacks && Klang.core.Core.callbacks.changePatternState) {
                            Klang.core.Core.callbacks.changePatternState({
                                pattern: this,
                                lastState: this._state,
                                newState: state,
                                step: this._sequencer.currentStep
                            })
                        }
                        this._state = state
                    };
                    MidiPattern.prototype.prePlaySchedule = function(steps, syncStep, restart) {
                        if (!this._midiFile) {
                            this._midiFile = Klang.core.FileHandler.instance.getFile(this._midiFileId);
                            if (!this._midiFile) {
                                Klang.log("MidiPattern: midifile not found: " + this._name + ". Playing without midifile.")
                            } else {
                                this.setupFile()
                            }
                        }
                        restart = restart || false;
                        if (this._state == PatternState.Playing) {
                            if (restart) {
                                this._syncStep = syncStep;
                                this.stop(steps, true)
                            } else {
                                return this
                            }
                        }
                        var startTime = this._sequencer._scheduleTime + steps * this._sequencer.getNoteTime(.25);
                        this.trigger("start", startTime);
                        this._syncStep = syncStep % this._length;
                        this._currentStep = this._startStep;
                        this.findNextClip(this._currentStep);
                        if (steps > 0) {
                            this._stepCount = steps;
                            this._currentStep += this._syncStep;
                            this._syncStep = 0;
                            this._totalStep = 0;
                            this.changeState(PatternState.PrePlaying);
                            if (this._upbeats) {
                                this._activeUpbeat = -1;
                                for (var ix = 0, len = this._upbeats.length; ix < len; ix++) {
                                    var upbeat = this._upbeats[ix];
                                    if (upbeat.length <= steps) {
                                        if (this._activeUpbeat == -1 || this._upbeats[this._activeUpbeat].length < upbeat.length) {
                                            this._activeUpbeat = ix
                                        }
                                    }
                                }
                                if (this._activeUpbeat != -1 && this._upbeats[this._activeUpbeat].playInLoop) {
                                    this._upbeatLoopOffset = this._upbeats[this._activeUpbeat].length
                                }
                            }
                            this.findNextClip(this._activeUpbeat == -1 ? this._currentStep : this._upbeats[this._activeUpbeat].step)
                        } else {
                            this.changeState(PatternState.Playing)
                        }
                        this._patternStartTime = Klang.Util.now();
                        return this
                    };
                    MidiPattern.prototype.play = function(when) {
                        if (!this._midiFile) {
                            this._midiFile = Klang.core.FileHandler.instance.getFile(this._midiFileId);
                            if (!this._midiFile) {
                                Klang.log("MidiPattern: midifile not found: " + this._name + ". Playing without midifile.")
                            } else {
                                this.setupFile()
                            }
                        }
                        if (this._state == PatternState.Playing) {
                            return this
                        }
                        if (when && when != 0) {
                            var targetVol = this._output.gain.value;
                            this._output.gain.setValueAtTime(0, 0);
                            this._output.gain.setValueAtTime(targetVol, when)
                        }
                        this._currentStep = this._sequencer.currentStep % this._length + this._startStep;
                        this.changeState(PatternState.Playing);
                        this.findNextClip(this._currentStep);
                        if (!this._sequencer.started) {
                            this._sequencer.start()
                        }
                        return this
                    };
                    MidiPattern.prototype.restart = function() {
                        this._currentStep = this._startStep;
                        this._nextClip = 0;
                        return this
                    };
                    MidiPattern.prototype.stop = function(when, beat) {
                        this.trigger("stop", when);
                        if (this._synth.deschedule && this._sequencer._scheduleAheadTime > .5) {
                            this._synth.deschedule()
                        }
                        if (when === undefined || this._state == PatternState.Stopped) {
                            this.changeState(PatternState.Stopped);
                            return this
                        }
                        if (beat === undefined) {
                            beat = true
                        }
                        if (beat) {
                            this._stepCount = this._sequencer.getStepsToNext(this._sequencer.beatLength * when);
                            this.changeState(PatternState.PreStopping)
                        } else {
                            this.changeState(PatternState.Stopped);
                            if (this._synth !== "progression" && this._synth._loopedSamples) {
                                this._synth.stop(when)
                            }
                        }
                        return this
                    };
                    MidiPattern.prototype.pause = function() {
                        return this
                    };
                    MidiPattern.prototype.unpause = function() {
                        return this
                    };
                    MidiPattern.prototype.sendMidiEvents = function(step, scheduleTime, bypassNoteOn) {
                        if (!this._clips.length) {
                            return
                        }
                        var startClip = this._nextClip;
                        while (this._clips[this._nextClip].step == step) {
                            var nextClip = this._clips[this._nextClip];
                            if (!this._progression) {
                                var transpose = 0;
                                if (nextClip.event.noteNumber) {
                                    if (this._scale) {
                                        transpose = audioUtil.getTransposeFromScale(nextClip.event.noteNumber, this._scale, this._root)
                                    }
                                    if (this._transpose != 0) {
                                        transpose += this._transpose
                                    }
                                }
                                if (!(bypassNoteOn && nextClip.event.subtype === "noteOn")) {
                                    var offset = this._midiFile ? nextClip.offset * this._secPerTick : nextClip.offset;
                                    this._synth.handleMidiEvent(nextClip.event, scheduleTime + offset, transpose);
                                    if (nextClip.duration != "undefined") {
                                        var newEvent = Klang.Util.cloneObject(nextClip.event);
                                        newEvent.subtype = "noteOff";
                                        var noteOffTime = nextClip.duration * (this._sequencer.getNoteTime(.25) * 4);
                                        this._synth.handleMidiEvent(newEvent, scheduleTime + noteOffTime + offset, transpose)
                                    }
                                }
                            } else {
                                if (nextClip.event.subtype === "noteOn") {
                                    this._currentChord.push(nextClip.event.noteNumber)
                                } else if (nextClip.event.subtype === "noteOff") {
                                    var id = this._currentChord.indexOf(nextClip.event.noteNumber);
                                    if (id > -1) {
                                        this._currentChord.splice(id, 1)
                                    }
                                }
                            }
                            this._nextClip++;
                            if (this._nextClip == this._clips.length) {
                                this._nextClip = 0
                            }
                            if (this._nextClip === startClip) {
                                Klang.log("MidiPattern", this._name, "got stuck, check if you're playing the correct midi track.");
                                break
                            }
                        }
                        if (this._progression && this._currentChord.length) {
                            this._currentChord.sort(function(a, b) {
                                return a - b
                            });
                            var chordRootMidiNote = this._currentChord[0];
                            var root = chordRootMidiNote % 12;
                            var transpose = 0;
                            if (root != this._root) {
                                transpose = chordRootMidiNote - this._rootNote
                            }
                            var scale = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                            var chordNormalized = [];
                            for (var j = 0; j < this._currentChord.length; j++) {
                                var n = this._currentChord[j] % 12 - root;
                                if (n < 0) {
                                    n += 12
                                }
                                chordNormalized.push(n)
                            }
                            chordNormalized.sort(function(a, b) {
                                return a - b
                            });
                            for (var i = 0; i < scale.length; i++) {
                                var closest = this.getClosestValues(chordNormalized, i);
                                if (closest !== undefined) {
                                    scale[i] = closest - i
                                }
                            }
                            this._sequencer.customScale = scale;
                            this._sequencer.transpose = transpose;
                            this._rootNote = chordRootMidiNote
                        }
                    };
                    MidiPattern.prototype.getClosestValues = function(a, x) {
                        var lo = -1,
                            hi = a.length;
                        while (hi - lo > 1) {
                            var mid = Math.round((lo + hi) / 2);
                            if (a[mid] <= x) {
                                lo = mid
                            } else {
                                hi = mid
                            }
                        }
                        var closest;
                        if (a[lo] == x) {
                            closest = hi = lo
                        }
                        if (Math.abs(x - hi) > Math.abs(x - lo)) {
                            closest = lo
                        } else if (Math.abs(x - hi) < Math.abs(x - lo)) {
                            closest = hi
                        } else {
                            closest = lo
                        }
                        return a[closest]
                    };
                    MidiPattern.prototype.findNextClip = function(step) {
                        for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                            if (this._clips[ix].step >= step) {
                                this._nextClip = ix;
                                return ix;
                                break
                            }
                        }
                    };
                    MidiPattern.prototype.playStep = function(currentStep, scheduleTime) {
                        var playThisStep = true;
                        if (this._currentStep >= this._length + this._startStep) {
                            this.sendMidiEvents(this._length, scheduleTime, true);
                            this._currentStep = this._startStep;
                            this.findNextClip(this._currentStep);
                            if (!this._loop) {
                                this.changeState(PatternState.Stopped);
                                playThisStep = false
                            }
                            if (this._updatedClips.length) {
                                var newArray = this._clips.concat(this._updatedClips);
                                newArray.sort(function(a, b) {
                                    return a.step - b.step
                                });
                                this._clips = newArray;
                                this._updatedClips = []
                            }
                        }
                        if (playThisStep) {
                            this.sendMidiEvents(this._currentStep, scheduleTime, false)
                        }
                        this._totalStep += this._beatSubscription;
                        this._currentStep += this._beatSubscription
                    };
                    MidiPattern.prototype.update = function(currentStep, scheduleTime) {
                        if (this._state != PatternState.Stopped && currentStep % this._beatSubscription == 0) {
                            if (this._upbeats && this._activeUpbeat != -1 && this._upbeats[this._activeUpbeat].playInLoop && this._state == PatternState.Playing) {
                                if (this._currentStep >= this._length + this._startStep - this._upbeatLoopOffset) {
                                    if (this._upbeatLoopOffset > 0) {
                                        this._stepCount = this._upbeatLoopOffset;
                                        this.changeState(PatternState.PrePlaying)
                                    }
                                    this.sendMidiEvents(this._currentStep, scheduleTime, true);
                                    this._currentStep = this._startStep;
                                    this.findNextClip(this._upbeats[this._activeUpbeat].step)
                                }
                            }
                            switch (this._state) {
                                case PatternState.PrePlaying:
                                    {
                                        if (this._activeUpbeat != -1) {
                                            var upbeat = this._upbeats[this._activeUpbeat];
                                            var currentUpbeatStep = upbeat.length - this._stepCount;
                                            if (currentUpbeatStep >= 0) {
                                                this.sendMidiEvents(upbeat.step + currentUpbeatStep, scheduleTime, false)
                                            }
                                        }
                                        this._stepCount -= this._beatSubscription;
                                        if (this._stepCount <= 0) {
                                            if (this._activeUpbeat != -1 && upbeat.targetStep) {
                                                this._currentStep = upbeat.targetStep
                                            }
                                            this.findNextClip(this._currentStep);
                                            this.changeState(PatternState.Playing)
                                        }
                                        break
                                    }
                                case PatternState.Playing:
                                    {
                                        this.playStep(currentStep, scheduleTime);
                                        break
                                    }
                                case PatternState.PreStopping:
                                    {
                                        this._stepCount -= this._beatSubscription;
                                        if (this._stepCount <= 0) {
                                            this.stop(scheduleTime, false)
                                        } else {
                                            this.playStep(currentStep, scheduleTime)
                                        }
                                        break
                                    }
                                case PatternState.PostStop:
                                    {
                                        break
                                    }
                            }
                        }
                        return this
                    };
                    MidiPattern.prototype.recalculateBPM = function(bpm) {
                        var ticksPerBeat = this._midiFile.header.ticksPerBeat;
                        var microsecPerQuarterNote = 6e7 / bpm;
                        var secPerQuarterNote = microsecPerQuarterNote / 1e6;
                        this._secPerTick = secPerQuarterNote / ticksPerBeat
                    };
                    MidiPattern.prototype.getNextBar = function(x) {
                        var nextBar = Math.ceil(this._currentStep / x);
                        if (this._currentStep > this._length - x) {
                            nextBar = 0
                        }
                        return nextBar
                    };
                    MidiPattern.prototype.fadeInAndPlay = function(duration, when) {
                        this.play(when);
                        this.output.gain.value = 0;
                        Klang.Util.curveParamLin(this.output.gain, 1, duration, when);
                        return this
                    };
                    MidiPattern.prototype.fadeOutAndStop = function(duration, when) {
                        if (when === undefined) {
                            when = Klang.context.currentTime
                        }
                        this.output.gain.cancelScheduledValues(when);
                        Klang.Util.curveParamLin(this.output.gain, 0, duration, when);
                        Klang.Util.setParam(this.output.gain, this._volume, when + duration);
                        this.stop(when + duration);
                        return this
                    };
                    MidiPattern.prototype.deschedule = function(steps) {
                        if (steps === undefined) {
                            steps = this._length
                        }
                        if (this._synth.deschedule) {
                            this._synth.deschedule()
                        }
                        if (this._state != PatternState.Stopped) {
                            steps = steps % this._length;
                            this._currentStep = this._currentStep - steps;
                            if (this._currentStep < this._startStep) {
                                var stepDelta = this._startStep - this._currentStep;
                                this._currentStep = this._startStep + this._length - stepDelta
                            }
                            for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                                if (this._clips[ix].step >= this._currentStep) {
                                    this._nextClip = ix;
                                    break
                                }
                            }
                        }
                        return this
                    };
                    MidiPattern.prototype.resetTranspose = function() {
                        this._transpose = this._orgTranspose
                    };
                    Object.defineProperty(MidiPattern.prototype, "length", {
                        get: function() {
                            return this._length
                        },
                        set: function(length) {
                            this._length = length
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "startStep", {
                        set: function(step) {
                            this._startStep = step;
                            this._currentStep = this._sequencer.currentStep % this._length + this._startStep;
                            for (var ix = 0, len = this._clips.length; ix < len; ix++) {
                                if (this._clips[ix].step >= this._currentStep) {
                                    this._nextClip = ix;
                                    break
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "scale", {
                        set: function(scale) {
                            if (!this._progression) {
                                if (scale === "reset") {
                                    this._scale = this._orgScale
                                } else {
                                    this._scale = scale
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "customScale", {
                        set: function(obj) {
                            if (!this._progression) {
                                Klang.audioUtil.scales["custom"] = obj;
                                this._scale = "custom"
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "transpose", {
                        get: function() {
                            return this._transpose
                        },
                        set: function(transpose) {
                            this._transpose = transpose
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "loop", {
                        get: function() {
                            return this._loop
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "state", {
                        get: function() {
                            return this._state
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "playing", {
                        get: function() {
                            var _playing = false;
                            if (this._state === 1 || this._state === 1) {
                                _playing = true
                            }
                            return _playing
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MidiPattern.prototype, "duration", {
                        get: function() {
                            return this._length * this._sequencer.getNoteTime(1)
                        },
                        enumerable: true,
                        configurable: true
                    });
                    MidiPattern.prototype.getNoteInScale = function(midiNumber) {
                        return Klang.audioUtil.getNoteInScale(midiNumber, this._scale, this._root)
                    };
                    MidiPattern.prototype.getPositionInPattern = function() {
                        var patternLength = this.length;
                        var lengthSeconds = this._sequencer.getNoteTime(patternLength);
                        var positionSeconds = (Klang.Util.now() - this._patternStartTime) % lengthSeconds;
                        var sixteenNote = this._sequencer.getNoteTime(.25);
                        var positionStepsRaw = positionSeconds / sixteenNote;
                        var positionSteps = Math.floor(positionStepsRaw);
                        var delta = positionStepsRaw - positionSteps;
                        var offset = sixteenNote * delta;
                        var step = positionSteps / 4 - .25;
                        return {
                            step: step,
                            offset: offset
                        }
                    };
                    MidiPattern.prototype.addNote = function(noteNumber, velocity, step, duration, offset) {
                        this.addSingleEvent("noteOn", noteNumber, velocity, step, offset);
                        var noteOffStep = step + duration;
                        if (noteOffStep > this.length) {
                            noteOffStep = noteOffStep - this.length
                        }
                        this.addSingleEvent("noteOff", noteNumber, velocity, noteOffStep, offset)
                    };
                    MidiPattern.prototype.addSingleEvent = function(type, noteNumber, velocity, step, offset) {
                        this._updatedClips.push({
                            event: {
                                type: "channel",
                                subtype: type,
                                noteNumber: noteNumber,
                                velocity: velocity
                            },
                            step: step,
                            offset: offset || 0
                        });
                        this._updatedClips.sort(function(a, b) {
                            return a.step - b.step
                        })
                    };
                    MidiPattern.prototype.setData = function(data) {
                        _super.prototype.setData.call(this, data);
                        var reinit = false;
                        this._beatSubscription = data.beat_subscription === undefined ? .25 : data.beat_subscription;
                        if (this._midiFile != data.file_id) {
                            this._midiFile = data.file_id
                        }
                        if (this._midiTrackIx != data.midi_track) {
                            this._midiTrackIx = data.midi_track
                        }
                        if (data.sequener !== undefined && this._sequencerName != data.sequencer) {
                            this._sequencerName = data.sequencer;
                            reinit = true
                        }
                        if (data.synth !== undefined && this._synthName != data.synth) {
                            this._synthName = data.synth;
                            reinit = true
                        }
                        if (data.clips) {
                            this._clips = data.clips
                        }
                        this._loop = data.loop === undefined ? false : data.loop;
                        this._length = data.length === undefined ? 0 : data.length;
                        this._root = data.root === undefined ? 0 : data.root;
                        this._orgTranspose = data.transpose === undefined ? 0 : data.transpose;
                        this._transpose = this._orgTranspose;
                        this._orgScale = data.scale === undefined ? 0 : data.scale;
                        this._scale = this._orgScale;
                        this._rootNote = data.root_note === undefined ? 36 : data.root_note;
                        this._activeUpbeat = -1;
                        if (data.upbeats) {
                            this._upbeats = [];
                            this._upbeatLoopOffset = 0;
                            for (var ix = 0, len = data.upbeats.length; ix < len; ix++) {
                                this._upbeats.push({
                                    length: data.upbeats[ix].length,
                                    step: data.upbeats[ix].step,
                                    targetStep: data.upbeats[ix].target_step,
                                    playInLoop: data.upbeats[ix].play_in_loop
                                })
                            }
                            reinit = true
                        }
                        if (reinit) {
                            this._sequencer.unregisterPattern(this);
                            this.init()
                        }
                    };
                    return MidiPattern
                }(Klang.Model.Audio);
                return Klang.Model.MidiPattern = MidiPattern
            });
            Module(function(Klang) {
                function Effect(data) {
                    this.active = true;
                    this._type = data.type;
                    this._output && this.disconnect();
                    this._input = Klang.context.createGain();
                    this._output = Klang.context.createGain();
                    if (data.active === false) {
                        this.active = false
                    }
                }
                Effect.prototype.connect = function(destination) {
                    this._output.connect(destination);
                    return this
                };
                Effect.prototype.disconnect = function() {
                    this._output.disconnect();
                    return this
                };
                Effect.prototype.setActive = function(state) {
                    Klang.warn("Effect: Invocation of abstract method: Effect.setActive in", this);
                    return this
                };
                Object.defineProperty(Effect.prototype, "input", {
                    get: function() {
                        return this._input
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Effect.prototype, "output", {
                    get: function() {
                        return this._output
                    },
                    enumerable: true,
                    configurable: true
                });
                return Klang.Model.Effect = Effect
            });
            Module(function(Klang) {
                var EffectSend = function(_super) {
                    Klang.Util.__extends(EffectSend, _super);

                    function EffectSend(data) {
                        _super.call(this, data);
                        this._wet = Klang.context.createGain();
                        this._wet.gain.setValueAtTime(data.wet, Klang.context.currentTime);
                        this._input.connect(this._wet);
                        this._input.connect(this._output);
                        this.destinationName = data.destination_name;
                        Klang.core.Core.instance.pushToPreLoadInitStack(this)
                    }
                    EffectSend.prototype.init = function() {
                        var destination = Klang.core.Core.instance.findInstance(this.destinationName);
                        if (destination) {
                            this._wet.connect(destination.input)
                        }
                    };
                    EffectSend.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._wet);
                            this._input.connect(this._output)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Object.defineProperty(EffectSend.prototype, "wet", {
                        get: function() {
                            return this._wet.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    EffectSend.prototype.setData = function(data) {
                        if (data.wet !== undefined) {
                            this.wet.value = data.wet
                        }
                        if (data.destination_name != this.destinationName) {
                            this.destinationName = data.destination_name;
                            this._wet.disconnect();
                            this.init()
                        }
                    };
                    return EffectSend
                }(Klang.Model.Effect);
                return Klang.Model.EffectSend = EffectSend
            });
            Module(function(Klang) {
                var Equalizer = function(_super) {
                    Klang.Util.__extends(Equalizer, _super);

                    function Equalizer(data) {
                        _super.call(this, data);
                        this._filters = [];
                        if (Klang.detector.browser["name"] == "Firefox") {
                            this._input.connect(this._output);
                            return
                        }
                        if (data.bands.length == 0) {
                            Klang.warn("Equalizer: No bands specified");
                            this._input.connect(this.output)
                        } else {
                            for (var ix = 0, len = data.bands.length; ix < len; ix++) {
                                var band = data.bands[ix];
                                var filter = Klang.context.createBiquadFilter();
                                if (band.filter_type) {
                                    filter.type = Klang.Util.safeFilterType(band.filter_type)
                                }
                                if (band.frequency) {
                                    filter.frequency.value = band.frequency
                                }
                                if (band.gain) {
                                    filter.gain.value = band.gain
                                }
                                if (band.Q) {
                                    filter.Q.value = band.Q
                                }
                                if (ix == 0) {
                                    this._input.connect(filter)
                                } else {
                                    this._filters[ix - 1].connect(filter)
                                }
                                this._filters.push(filter)
                            }
                            this._filters[this._filters.length - 1].connect(this._output)
                        }
                    }
                    Equalizer.prototype.addFilter = function(type, frequency, q, gain) {
                        var filter = Klang.context.createBiquadFilter();
                        filter.type = type;
                        filter.frequency.value = frequency;
                        filter.gain.value = gain;
                        filter.Q.value = q;
                        if (this._filters.length == 0) {
                            this._input.disconnect();
                            this._input.connect(filter)
                        } else {
                            this._filters[this._filters.length - 1].disconnect();
                            this._filters[this._filters.length - 1].connect(filter)
                        }
                        filter.connect(this.output);
                        this._filters.push(filter)
                    };
                    Equalizer.prototype.removeFilter = function(index) {
                        this._filters[index].disconnect();
                        if (index == 0 && this._filters.length > 1) {
                            this._input.disconnect();
                            this._input.connect(this._filters[1])
                        } else if (index == 0) {
                            this._input.disconnect();
                            this._input.connect(this._output)
                        } else if (index == this._filters.length - 1) {
                            this._filters[index - 1].disconnect();
                            this._filters[index - 1].connect(this._output)
                        } else {
                            this._filters[index - 1].disconnect();
                            this._filters[index - 1].connect(this._filters[index + 1])
                        }
                        this._filters.splice(index, 1)
                    };
                    Equalizer.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            if (this._filters.length == 0) {
                                this._input.connect(this._output)
                            } else {
                                this._input.connect(this._filters[0])
                            }
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Object.defineProperty(Equalizer.prototype, "filters", {
                        get: function() {
                            return this._filters
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Equalizer.prototype.setData = function(data) {
                        for (var ix = 0, len = this._filters.length; ix < len; ix++) {
                            var filterData = data.bands[ix];
                            var filter = this._filters[ix];
                            if (filter && filterData) {
                                filter.frequency.value = filterData.frequency;
                                filter.Q.value = filterData.Q;
                                filter.gain.value = filterData.gain;
                                var newType = Klang.Util.safeFilterType(filterData.filter_type);
                                if (filter.type != newType) {
                                    filter.type = newType
                                }
                            }
                        }
                    };
                    return Equalizer
                }(Klang.Model.Effect);
                return Klang.Model.Equalizer = Equalizer
            });
            Module(function(Klang) {
                var BiquadFilter = function(_super) {
                    Klang.Util.__extends(BiquadFilter, _super);

                    function BiquadFilter(data) {
                        _super.call(this, data);
                        this.init(data)
                    }
                    BiquadFilter.prototype.init = function(data) {
                        this._data = data;
                        this._filter = Klang.context.createBiquadFilter();
                        this._filter.type = Klang.Util.safeFilterType(data.filter_type);
                        this._input.connect(this._filter);
                        this._filter.connect(this._output);
                        var _filterStartFreq = data.frequency !== undefined ? data.frequency : 1e3;
                        this._filter.frequency.setValueAtTime(_filterStartFreq, Klang.context.currentTime);
                        var _filterStartQ = data.Q !== undefined ? data.Q : 1;
                        this._filter.Q.setValueAtTime(_filterStartQ, Klang.context.currentTime);
                        var _filterStartGain = data.gain !== undefined ? data.gain : 0;
                        this._filter.gain.setValueAtTime(_filterStartGain, Klang.context.currentTime)
                    };
                    BiquadFilter.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._filter)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Object.defineProperty(BiquadFilter.prototype, "frequency", {
                        get: function() {
                            return this._filter.frequency
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(BiquadFilter.prototype, "Q", {
                        get: function() {
                            return this._filter.Q
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(BiquadFilter.prototype, "gain", {
                        get: function() {
                            return this._filter.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    BiquadFilter.prototype.refreshAudioNodes = function() {
                        var fValue = this._filter.frequency.value;
                        var qValue = this._filter.Q.value;
                        var gValue = this._filter.gain.value;
                        this._filter.frequency.cancelScheduledValues(Klang.context.currentTime);
                        this._filter.Q.cancelScheduledValues(Klang.context.currentTime);
                        this._filter.gain.cancelScheduledValues(Klang.context.currentTime);
                        this._filter.disconnect();
                        this.init(this._data);
                        this._filter.frequency.value = fValue;
                        this._filter.Q.value = qValue;
                        this._filter.gain.value = gValue
                    };
                    BiquadFilter.prototype.setData = function(data) {
                        if (data.filter_type === undefined) {
                            data.filter_type = "lowpass"
                        }
                        if (this._filter.type != data.filter_type) {
                            this._filter.type = Klang.Util.safeFilterType(data.filter_type)
                        }
                        this._filter.frequency.value = data.frequency === undefined ? 1e3 : data.frequency;
                        this._filter.Q.value = data.Q === undefined ? 1 : data.Q;
                        this._filter.gain.value = data.gain === undefined ? 0 : data.gain
                    };
                    return BiquadFilter
                }(Klang.Model.Effect);
                return Klang.Model.BiquadFilter = BiquadFilter
            });
            Module(function(Klang) {
                var Bitcrusher = function(_super) {
                    Klang.Util.__extends(Bitcrusher, _super);

                    function Bitcrusher(data) {
                        _super.call(this, data);
                        this._pro = Klang.context.createScriptProcessor(data.buffer_size || 4096, 2, 2);
                        var _this = this;
                        this._pro.onaudioprocess = function(e) {
                            var inp = e.inputBuffer,
                                out = e.outputBuffer,
                                iL = inp.getChannelData(0),
                                iR = inp.getChannelData(1),
                                oL = out.getChannelData(0),
                                oR = out.getChannelData(1),
                                step = Math.pow(.5, _this._bits),
                                len = inp.length,
                                sample = 0,
                                lastL = 0,
                                lastR = 0,
                                i = 0;
                            for (; i < len; ++i) {
                                if ((sample += _this._reduction) >= 1) {
                                    sample--;
                                    lastL = step * Math.floor(iL[i] / step);
                                    lastR = step * Math.floor(iR[i] / step)
                                }
                                oL[i] = lastL;
                                oR[i] = lastR
                            }
                        };
                        this._bits = data.bits || 4;
                        this._reduction = data.reduction || .2;
                        this._input.connect(this._pro);
                        this._pro.connect(this._output)
                    }
                    Bitcrusher.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._pro);
                            this._input.connect(this._output)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Object.defineProperty(Bitcrusher.prototype, "bits", {
                        get: function() {
                            return this._bits
                        },
                        set: function(value) {
                            this._bits = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Bitcrusher.prototype, "reduction", {
                        get: function() {
                            return this._reduction
                        },
                        set: function(value) {
                            this._reduction = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Bitcrusher.prototype.setData = function(data) {
                        this._bits = data.bits !== undefined ? data.bits : 4;
                        this._reduction = data.reduction !== undefined ? data.reduction : .2
                    };
                    return Bitcrusher
                }(Klang.Model.Effect);
                return Klang.Model.Bitcrusher = Bitcrusher
            });
            Module(function(Klang) {
                var Compressor = function(_super) {
                    Klang.Util.__extends(Compressor, _super);

                    function Compressor(data) {
                        _super.call(this, data);
                        this._bypass = data.bypass;
                        if (Klang.isMobile) {
                            this._input.connect(this._output);
                            return
                        }
                        this._dynamicsCompressor = Klang.context.createDynamicsCompressor();
                        this._makeUpGain = Klang.context.createGain();
                        this._input.connect(this._dynamicsCompressor);
                        this._dynamicsCompressor.connect(this._makeUpGain);
                        this._makeUpGain.connect(this._output);
                        if (this._bypass) {
                            this._input.connect(this._output);
                            this._makeUpGain.gain.value = 0
                        }
                        this._dynamicsCompressor.threshold.value = data.threshold || this._dynamicsCompressor.threshold.value;
                        this._dynamicsCompressor.knee.value = data.knee || this._dynamicsCompressor.knee.value;
                        this._dynamicsCompressor.ratio.value = data.ratio || this._dynamicsCompressor.ratio.value;
                        this._dynamicsCompressor.attack.value = data.attack || this._dynamicsCompressor.attack.value;
                        this._dynamicsCompressor.release.value = data.release || this._dynamicsCompressor.release.value;
                        this._makeUpGain.gain.value = data.make_up_gain || this._makeUpGain.gain.value
                    }
                    Compressor.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._dynamicsCompressor);
                            if (this._bypass) {
                                this._input.connect(this._output)
                            }
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Object.defineProperty(Compressor.prototype, "threshold", {
                        get: function() {
                            return this._dynamicsCompressor.threshold
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Compressor.prototype, "knee", {
                        get: function() {
                            return this._dynamicsCompressor.knee
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Compressor.prototype, "ratio", {
                        get: function() {
                            return this._dynamicsCompressor.ratio
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Compressor.prototype, "attack", {
                        get: function() {
                            return this._dynamicsCompressor.attack
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Compressor.prototype, "release", {
                        get: function() {
                            return this._dynamicsCompressor.release
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Compressor.prototype, "reduction", {
                        get: function() {
                            return this._dynamicsCompressor.reduction
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Compressor.prototype, "makeUpGain", {
                        get: function() {
                            return this._makeUpGain.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Compressor.prototype.setData = function(data) {
                        if (data.threshold !== undefined) {
                            this.threshold.value = data.threshold
                        }
                        if (data.knee !== undefined) {
                            this.knee.value = data.knee
                        }
                        if (data.ratio !== undefined) {
                            this.ratio.value = data.ratio
                        }
                        if (data.attack !== undefined) {
                            this.attack.value = data.attack
                        }
                        if (data.release !== undefined) {
                            this.release.value = data.release
                        }
                        if (data.make_up_gain !== undefined) {
                            this.makeUpGain.value = data.make_up_gain
                        }
                    };
                    return Compressor
                }(Klang.Model.Effect);
                return Klang.Model.Compressor = Compressor
            });
            Module(function(Klang) {
                var Convolver = function(_super) {
                    Klang.Util.__extends(Convolver, _super);

                    function Convolver(data) {
                        _super.call(this, data);
                        this._soundName = data.sound;
                        this._convolver = Klang.context.createConvolver();
                        this._wetGain = Klang.context.createGain();
                        this._dryGain = Klang.context.createGain();
                        this._wetGain.gain.value = 1;
                        this._dryGain.gain.value = 0;
                        this._wetGain.connect(this._convolver);
                        this._dryGain.connect(this._output);
                        this._input.connect(this._wetGain);
                        this._input.connect(this._dryGain);
                        this._convolver.connect(this._output);
                        Klang.core.Core.instance.pushToPostLoadInitStack(this)
                    }
                    Convolver.prototype.dryWet = function(mix) {
                        mix = Math.max(0, Math.min(1, mix));
                        this._wetGain.gain.value = mix;
                        this._dryGain.gain.value = 1 - mix
                    };
                    Convolver.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._convolver)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Convolver.prototype.init = function() {
                        var soundInstance = Klang.core.Core.instance.findInstance(this._soundName);
                        this._convolver.buffer = soundInstance.buffer
                    };
                    Convolver.prototype.setData = function(data) {
                        if (data.sound && data.sound != this._soundName) {
                            this._soundName = data.sound;
                            this.init()
                        }
                    };
                    return Convolver
                }(Klang.Model.Effect);
                return Klang.Model.Convolver = Convolver
            });
            Module(function(Klang) {
                var DelayBase = function(_super) {
                    Klang.Util.__extends(DelayBase, _super);

                    function DelayBase(data) {
                        _super.call(this, data);
                        this._sync = data.sync
                    }
                    DelayBase.prototype.init = function() {
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            this.updateSync(seq.bpm);
                            seq.registerBPMSync(this)
                        }
                    };
                    DelayBase.prototype.setSync = function(sequencer, rate) {
                        if (sequencer) {
                            this._sync = sequencer;
                            this._syncResolution = rate || 1;
                            this.init()
                        } else {
                            this._sync = null;
                            this._syncResolution = null
                        }
                        return this
                    };
                    DelayBase.prototype.setSyncRate = function(rate) {
                        if (this._sync) {
                            this._syncResolution = rate;
                            this.updateSync(Klang.core.Core.instance.findInstance(this._sync).bpm)
                        }
                        return this
                    };
                    DelayBase.prototype.updateSync = function(bpm) {
                        Klang.warn("DelayBase: Invocation of abstract method: DelayBase.updateSync in", this);
                        return this
                    };
                    Object.defineProperty(DelayBase.prototype, "sync", {
                        get: function() {
                            return this._sync
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DelayBase.prototype, "syncResolution", {
                        get: function() {
                            return this._syncResolution
                        },
                        set: function(value) {
                            this._syncResolution = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return DelayBase
                }(Klang.Model.Effect);
                return Klang.Model.DelayBase = DelayBase
            });
            Module(function(Klang) {
                var Delay = function(_super) {
                    Klang.Util.__extends(Delay, _super);

                    function Delay(data) {
                        _super.call(this, data);
                        this._feedback = Klang.context.createGain();
                        this._delay = Klang.context.createDelay();
                        if (data.filter) {
                            this._filter = Klang.context.createBiquadFilter();
                            this._input.connect(this._filter);
                            this._filter.connect(this._delay);
                            this._filter.type = Klang.Util.safeFilterType(data.filter.filter_type);
                            this._filter.frequency.value = data.filter.frequency || 1e3;
                            this._filter.Q.value = data.filter.Q || 4;
                            this._filter.gain.value = data.filter.gain || 1
                        } else {
                            this._input.connect(this._delay)
                        }
                        this._delay.connect(this._feedback);
                        this._delay.connect(this._output);
                        this._feedback.connect(this._delay);
                        if (this.sync) {
                            Klang.core.Core.instance.pushToPreLoadInitStack(this);
                            this.syncResolution = data.delay_time || 1
                        } else {
                            this._delay.delayTime.value = data.delay_time || .125
                        }
                        this._feedback.gain.value = data.feedback || .3;
                        this._output.gain.value = data.output_vol || data.wet || 1
                    }
                    Delay.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._delay)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Delay.prototype.updateSync = function(bpm) {
                        this._delay.delayTime.value = 60 / bpm * this.syncResolution;
                        return this
                    };
                    Object.defineProperty(Delay.prototype, "delayTime", {
                        get: function() {
                            return this._delay.delayTime
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Delay.prototype, "feedback", {
                        get: function() {
                            return this._feedback.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Delay.prototype, "filter", {
                        get: function() {
                            return this._filter
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Delay.prototype.setData = function(data) {
                        if (data.feedback) {
                            this._feedback.gain.value = data.feedback
                        }
                        if (data.sync) {
                            this.setSync(data.sync, data.delay_time)
                        } else {
                            if (data.delay_time) {
                                this._delay.delayTime.value = data.delay_time
                            }
                        }
                        if (data.filter) {
                            if (!this._filter) {
                                this.input.disconnect();
                                this._filter = Klang.context.createBiquadFilter();
                                this.input.connect(this._filter);
                                this._filter.connect(this._delay)
                            }
                            if (data.filter.filter_type !== undefined) {
                                this._filter.type = Klang.Util.safeFilterType(data.filter.filter_type)
                            }
                            if (data.filter.frequency !== undefined) {
                                this._filter.frequency.value = data.filter.frequency
                            }
                            if (data.filter.Q !== undefined) {
                                this._filter.Q.value = data.filter.Q
                            }
                            if (data.filter.gain !== undefined) {
                                this._filter.gain.value = data.filter.gain
                            }
                        } else {
                            if (this._filter) {
                                this.input.disconnect();
                                this._filter.disconnect();
                                this.input.connect(this._delay);
                                this._filter = null
                            }
                        }
                    };
                    return Delay
                }(Klang.Model.DelayBase);
                return Klang.Model.Delay = Delay
            });
            Module(function(Klang) {
                var StereoDelay = function(_super) {
                    Klang.Util.__extends(StereoDelay, _super);

                    function StereoDelay(data) {
                        _super.call(this, data);
                        if (this.sync) {
                            data.left.sync = this.sync;
                            data.right.sync = this.sync
                        }
                        this._splitter = Klang.context.createChannelSplitter(2);
                        this._merger = Klang.context.createChannelMerger(2);
                        this._leftDelay = new Delay(data.left || {});
                        this._rightDelay = new Delay(data.right || {});
                        this._input.connect(this._splitter);
                        this._splitter.connect(this._leftDelay.input, 0, 0);
                        this._splitter.connect(this._rightDelay.input, 0, 0);
                        this._splitter.connect(this._rightDelay.input, 1, 0);
                        this._leftDelay.output.connect(this._merger, 0, 0);
                        this._rightDelay.output.connect(this._merger, 0, 1);
                        this._merger.connect(this._output)
                    }
                    StereoDelay.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._splitter)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    StereoDelay.prototype.updateSync = function(bpm) {
                        this._leftDelay.updateSync(bpm);
                        this._rightDelay.updateSync(bpm);
                        return this
                    };
                    Object.defineProperty(StereoDelay.prototype, "leftDelay", {
                        get: function() {
                            return this._leftDelay
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StereoDelay.prototype, "rightDelay", {
                        get: function() {
                            return this._rightDelay
                        },
                        enumerable: true,
                        configurable: true
                    });
                    StereoDelay.prototype.setData = function(data) {
                        this._leftDelay.setData(data.left);
                        this._rightDelay.setData(data.right)
                    };
                    return StereoDelay
                }(Klang.Model.DelayBase);
                return Klang.Model.StereoDelay = StereoDelay
            });
            Module(function(Klang) {
                var PingPongDelay = function(_super) {
                    Klang.Util.__extends(PingPongDelay, _super);

                    function PingPongDelay(data) {
                        _super.call(this, data);
                        this._splitter = Klang.context.createChannelSplitter(2);
                        this._merger = Klang.context.createChannelMerger(2);
                        this._mono = Klang.context.createGain();
                        this._leftDelay = Klang.context.createDelay();
                        this._rightDelay = Klang.context.createDelay();
                        this._feedback = Klang.context.createGain();
                        if (data.filter) {
                            this._filter = Klang.context.createBiquadFilter();
                            this._mono.connect(this._filter);
                            this._filter.connect(this._leftDelay);
                            this._feedback.connect(this._filter);
                            this._filter.type = Klang.Util.safeFilterType(data.filter.filter_type);
                            this._filter.frequency.value = data.filter.frequency || 1e3;
                            this._filter.Q.value = data.filter.Q || 4;
                            this._filter.gain.value = data.filter.gain || 1
                        } else {
                            this._mono.connect(this._leftDelay);
                            this._feedback.connect(this._leftDelay)
                        }
                        this._input.connect(this._splitter);
                        this._splitter.connect(this._mono, 0, 0);
                        this._splitter.connect(this._mono, 1, 0);
                        this._leftDelay.connect(this._rightDelay);
                        this._rightDelay.connect(this._feedback);
                        this._leftDelay.connect(this._merger, 0, 0);
                        this._rightDelay.connect(this._merger, 0, 1);
                        this._merger.connect(this._output);
                        if (this.sync) {
                            Klang.core.Core.instance.pushToPreLoadInitStack(this);
                            this.syncResolution = data.delay_time || 1
                        } else {
                            var _delayStartTime = data.delay_time || .125;
                            this._leftDelay.delayTime.setValueAtTime(_delayStartTime, Klang.context.currentTime);
                            this._rightDelay.delayTime.setValueAtTime(_delayStartTime, Klang.context.currentTime)
                        }
                        var _startFeedback = data.feedback || .3;
                        this._feedback.gain.setValueAtTime(_startFeedback, Klang.context.currentTime);
                        var _startOutput = data.output_vol || data.wet || 1;
                        this._output.gain.setValueAtTime(_startOutput, Klang.context.currentTime)
                    }
                    PingPongDelay.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._splitter)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    PingPongDelay.prototype.updateSync = function(bpm) {
                        this._leftDelay.delayTime.value = 60 / bpm * this.syncResolution;
                        this._rightDelay.delayTime.value = this._leftDelay.delayTime.value;
                        return this
                    };
                    Object.defineProperty(PingPongDelay.prototype, "delay_time", {
                        set: function(val) {
                            this._leftDelay.delayTime.value = val;
                            this._rightDelay.delayTime.value = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(PingPongDelay.prototype, "feedback", {
                        get: function() {
                            return this._feedback.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(PingPongDelay.prototype, "filter", {
                        get: function() {
                            return this._filter
                        },
                        enumerable: true,
                        configurable: true
                    });
                    PingPongDelay.prototype.setData = function(data) {
                        if (data.feedback) {
                            this._feedback.gain.value = data.feedback
                        }
                        if (data.sync) {
                            this.setSync(data.sync, data.delay_time)
                        } else {
                            if (data.delay_time) {
                                this._leftDelay.delayTime.value = data.delay_time;
                                this._rightDelay.delayTime.value = data.delay_time
                            }
                        }
                        if (data.filter) {
                            if (!this._filter) {
                                this._mono.disconnect();
                                this._feedback.disconnect();
                                this._filter = Klang.context.createBiquadFilter();
                                this._mono.connect(this._filter);
                                this._filter.connect(this._leftDelay);
                                this._feedback.connect(this._filter)
                            }
                            if (data.filter.filter_type !== undefined) {
                                this._filter.type = Klang.Util.safeFilterType(data.filter.filter_type)
                            }
                            if (data.filter.frequency !== undefined) {
                                this._filter.frequency.value = data.filter.frequency
                            }
                            if (data.filter.Q !== undefined) {
                                this._filter.Q.value = data.filter.Q
                            }
                            if (data.filter.gain !== undefined) {
                                this._filter.gain.value = data.filter.gain
                            }
                        } else {
                            if (this._filter) {
                                this._mono.disconnect();
                                this._feedback.disconnect();
                                this._filter.disconnect();
                                this._mono.connect(this._leftDelay);
                                this._feedback.connect(this._leftDelay);
                                this._filter = null
                            }
                        }
                    };
                    return PingPongDelay
                }(Klang.Model.DelayBase);
                return Klang.Model.PingPongDelay = PingPongDelay
            });
            Module(function(Klang) {
                var Limiter = function(_super) {
                    Klang.Util.__extends(Limiter, _super);

                    function Limiter(data) {
                        _super.call(this, data);
                        this._compressor = Klang.context.createDynamicsCompressor();
                        this._preGain = Klang.context.createGain();
                        this._postGain = Klang.context.createGain();
                        this._input.connect(this._preGain);
                        this._preGain.connect(this._compressor);
                        this._compressor.connect(this._postGain);
                        this._postGain.connect(this._output);
                        this._compressor.threshold.value = data.threshold || 0;
                        this._compressor.knee.value = 0;
                        this._compressor.ratio.value = 100;
                        this._compressor.attack.value = 0;
                        this._compressor.release.value = 0;
                        this._preGain.gain.value = data.pre_gain === undefined ? 1 : data.pre_gain;
                        this._postGain.gain.value = data.post_gain === undefined ? 1 : data.post_gain
                    }
                    Limiter.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._preGain)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Object.defineProperty(Limiter.prototype, "threshold", {
                        get: function() {
                            return this._compressor.threshold
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Limiter.prototype, "preGain", {
                        get: function() {
                            return this._preGain.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Limiter.prototype, "postGain", {
                        get: function() {
                            return this._postGain.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Limiter.prototype, "reduction", {
                        get: function() {
                            return this._compressor.reduction
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Limiter.prototype.setData = function(data) {
                        if (data.threshold !== undefined) {
                            this._compressor.threshold.value = data.threshold
                        }
                        if (data.pre_gain !== undefined) {
                            this._preGain.gain.value = data.pre_gain
                        }
                        if (data.post_gain !== undefined) {
                            this._postGain.gain.value = data.post_gain
                        }
                    };
                    return Limiter
                }(Klang.Model.Effect);
                return Klang.Model.Limiter = Limiter
            });
            Module(function(Klang) {
                var Panner = function(_super) {
                    Klang.Util.__extends(Panner, _super);

                    function Panner(data) {
                        _super.call(this, data);
                        this.data = data;
                        this._name = data.name;
                        this._panner = Klang.context.createPanner();
                        this._input.connect(this._panner);
                        this._panner.connect(this._output);
                        if (data.panning_model !== undefined) {
                            this._panner.panningModel = data.panning_model
                        }
                        if (data.distance_model !== undefined) {
                            this._panner.distanceModel = data.distance_model
                        }
                        if (data.ref_distance !== undefined) {
                            this._panner.refDistance = data.ref_distance
                        }
                        if (data.max_distance !== undefined) {
                            this._panner.maxDistance = data.max_distance
                        }
                        if (data.rolloff_factor !== undefined) {
                            this._panner.rolloffFactor = data.rolloff_factor
                        }
                        if (data.cone_inner_angle !== undefined) {
                            this._panner.coneInnerAngle = data.cone_inner_angle
                        }
                        if (data.cone_outer_angle !== undefined) {
                            this._panner.coneOuterAngle = data.cone_outer_angle
                        }
                        if (data.cone_outer_gain !== undefined) {
                            this._panner.coneOuterGain = data.cone_outer_gain
                        }
                        if (data.position !== undefined) {
                            this._panner.setPosition(data.position[0], data.position[1], data.position[2])
                        }
                        if (data.orientation !== undefined) {
                            this._panner.setOrientation(data.position[0], data.position[1], data.position[2])
                        }
                        Panner.panners[this._name] = this
                    }
                    Panner.panners = {};
                    Panner._scale = 1;
                    Panner.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._panner)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Panner.prototype.setPosition = function(x, y, z) {
                        this._panner.setPosition(x * Panner.scale, y * Panner.scale, z * Panner.scale)
                    };
                    Panner.prototype.setOrientation = function(x, y, z) {
                        this._panner.setOrientation(x, y, z)
                    };
                    Panner.prototype.setVelocity = function(x, y, z) {
                        Klang.warn("setVelocity is removed from Klang and the WebAudio API")
                    };
                    Panner.prototype.setData = function(data) {
                        this._panner.setPosition(data.position[0], data.position[1], data.position[2]);
                        this._panner.setOrientation(data.position[0], data.position[1], data.position[2]);
                        if (data.panning_model !== undefined) {
                            this._panner.panningModel = data.panning_model
                        }
                        if (data.distance_model !== undefined) {
                            this._panner.distanceModel = data.distance_model
                        }
                        if (data.ref_distance !== undefined) {
                            this._panner.refDistance = data.ref_distance
                        }
                        if (data.max_distance !== undefined) {
                            this._panner.maxDistance = data.max_distance
                        }
                        if (data.rolloff_factor !== undefined) {
                            this._panner.rolloffFactor = data.rolloff_factor
                        }
                        if (data.cone_inner_angle !== undefined) {
                            this._panner.coneInnerAngle = data.cone_inner_angle
                        }
                        if (data.cone_outer_angle !== undefined) {
                            this._panner.coneOuterAngle = data.cone_outer_angle
                        }
                        if (data.cone_outer_gain !== undefined) {
                            this._panner.coneOuterGain = data.cone_outer_gain
                        }
                    };
                    Object.defineProperty(Panner, "listener", {
                        get: function() {
                            return Klang.context.listener
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Panner.setListenerPosition = function setListenerPosition(x, y, z) {
                        Klang.context.listener.setPosition(x * Panner.scale, y * Panner.scale, z * Panner.scale)
                    };
                    Panner.setListenerOrientation = function setListenerOrientation(x, y, z, xUp, yUp, zUp) {
                        Klang.context.listener.setOrientation(x, y, z, xUp, yUp, zUp)
                    };
                    Panner.setListenerVelocity = function setListenerVelocity(x, y, z) {
                        Klang.warn("setListenerVelocity is removed from Klang and the WebAudio API")
                    };
                    Panner.setDopplerFactor = function setDopplerFactor(factor) {
                        Klang.warn("setDopplerFactor is removed from Klang and the WebAudio API")
                    };
                    Panner.setSpeedOfSound = function setSpeedOfSound(speed) {
                        Klang.context.listener.speed = speed
                    };
                    Panner.setListenerData = function setListenerData(data) {
                        if (!data) {
                            return
                        }
                        Panner.scale = data.scale;
                        Panner.setListenerPosition(data.position[0], data.position[1], data.position[2]);
                        Panner.setListenerOrientation(data.orientation[0], data.orientation[1], data.orientation[2], data.orientation_up[0], data.orientation_up[1], data.orientation_up[2]);
                        Panner.setSpeedOfSound(data.speed_of_sound)
                    };
                    Panner.get = function get(name) {
                        return Panner.panners[name]
                    };
                    Object.defineProperty(Panner, "scale", {
                        get: function() {
                            return Panner._scale
                        },
                        set: function(scale) {
                            Panner._scale = scale
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return Panner
                }(Klang.Model.Effect);
                return Klang.Model.Panner = Panner
            });
            Module(function(Klang) {
                var Sidechain = function(_super) {
                    Klang.Util.__extends(Sidechain, _super);

                    function Sidechain(data) {
                        _super.call(this, data);
                        this._source = data.source;
                        this._gain = Klang.context.createGain();
                        this._processor = Klang.context.createScriptProcessor(data.buffer_size || 0);
                        var _this = this;
                        var reductionIsAudioParameter = typeof this._source.reduction !== "number";
                        this._processor.onaudioprocess = function() {
                            var reduction = reductionIsAudioParameter ? _this._source.reduction.value : _this._source.reduction;
                            _this._gain.gain.value = reduction === 0 ? 1 : Math.pow(10, reduction / 20)
                        };
                        this._input.connect(this._gain);
                        this._input.connect(this._processor);
                        this._processor.connect(Klang.context.destination);
                        this._gain.connect(this._output);
                        Klang.core.Core.instance.pushToPreLoadInitStack(this)
                    }
                    Sidechain.prototype.init = function() {
                        if (!this._source || !this._source.bus || this._source.index === undefined) {
                            Klang.warn("Sidechain: No source specified")
                        }
                        var bus = Klang.core.Core.instance.findInstance(this._source.bus);
                        this._source = bus._effects[this._source.index]
                    };
                    Sidechain.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._gain);
                            this._input.connect(this._processor)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    return Sidechain
                }(Klang.Model.Effect);
                return Klang.Model.Sidechain = Sidechain
            });
            Module(function(Klang) {
                var StereoPannerPolyfill = function(_super) {
                    Klang.Util.__extends(StereoPannerPolyfill, _super);

                    function StereoPannerPolyfill(data) {
                        _super.call(this, data);
                        this._splitter = Klang.context.createChannelSplitter(2);
                        this._merger = Klang.context.createChannelMerger(2);
                        this._left = Klang.context.createGain();
                        this._right = Klang.context.createGain();
                        this._input.connect(this._splitter);
                        this._splitter.connect(this._left, 0, 0);
                        this._splitter.connect(this._right, 1, 0);
                        this._left.connect(this._merger, 0, 0);
                        this._right.connect(this._merger, 0, 1);
                        this._merger.connect(this._output);
                        this.pan = data.pan
                    }
                    StereoPannerPolyfill.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._splitter)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    StereoPannerPolyfill.prototype.getGainValue = function(value) {
                        return (value + 1) / 2
                    };
                    StereoPannerPolyfill.prototype.setPanTo = function(value, when) {
                        var gainValue = this.getGainValue(value);
                        this._left.gain.setValueAtTime(1 - gainValue, when || 0);
                        this._right.gain.setValueAtTime(gainValue, when || 0);
                        return this
                    };
                    StereoPannerPolyfill.prototype.linPanTo = function(value, duration, when) {
                        when = when || Klang.context.currentTime;
                        var gainValue = this.getGainValue(value);
                        this._left.gain.setValueAtTime(this._left.gain.value, when);
                        this._left.gain.linearRampToValueAtTime(1 - gainValue, when + duration);
                        this._right.gain.setValueAtTime(this._right.gain.value, when);
                        this._right.gain.linearRampToValueAtTime(gainValue, when + duration);
                        return this
                    };
                    StereoPannerPolyfill.prototype.expPanTo = function(value, duration, when) {
                        when = when || Klang.context.currentTime;
                        var gainValue = this.getGainValue(value);
                        this._left.gain.setValueAtTime(this._left.gain.value == 0 ? Klang.Util.EXP_MIN_VALUE : this._left.gain.value, when);
                        this._left.gain.exponentialRampToValueAtTime(1 - gainValue, when + duration);
                        this._right.gain.setValueAtTime(this._right.gain.value == 0 ? Klang.Util.EXP_MIN_VALUE : this._right.gain.value, when);
                        this._right.gain.exponentialRampToValueAtTime(gainValue, when + duration);
                        return this
                    };
                    Object.defineProperty(StereoPannerPolyfill.prototype, "pan", {
                        get: function() {
                            return this._right.gain.value
                        },
                        set: function(value) {
                            var gainValue = this.getGainValue(value);
                            this._left.gain.value = 1 - gainValue;
                            this._right.gain.value = gainValue
                        },
                        enumerable: true,
                        configurable: true
                    });
                    StereoPannerPolyfill.prototype.setData = function(data) {
                        if (data.pan !== undefined) {
                            this.pan = data.pan
                        }
                    };
                    return StereoPannerPolyfill
                }(Klang.Model.Effect);
                var StereoPanner = function(_super) {
                    if (window.AudioContext) {
                        if (typeof window.AudioContext.prototype.createStereoPanner === "undefined") {
                            return StereoPannerPolyfill
                        }
                    }
                    Klang.Util.__extends(StereoPanner, _super);

                    function StereoPanner(data) {
                        _super.call(this, data);
                        this._panner = Klang.context.createStereoPanner();
                        this._panner.pan.setValueAtTime(data.pan, Klang.context.currentTime);
                        this._input.connect(this._panner);
                        this._panner.connect(this._output)
                    }
                    StereoPanner.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._splitter)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    StereoPanner.prototype.getGainValue = function(value) {
                        return value
                    };
                    StereoPanner.prototype.setPanTo = function(value, when) {
                        when = Math.max(when || 0, Klang.context.currentTime);
                        this._panner.pan.cancelScheduledValues(when);
                        this._panner.pan.setValueAtTime(value, when);
                        return this
                    };
                    StereoPanner.prototype.linPanTo = function(value, duration, when) {
                        when = Math.max(when || 0, Klang.context.currentTime);
                        this._panner.pan.cancelScheduledValues(when);
                        this._panner.pan.setValueAtTime(this._panner.pan.value, when);
                        this._panner.pan.linearRampToValueAtTime(value, when + duration);
                        return this
                    };
                    StereoPanner.prototype.expPanTo = function(value, duration, when) {
                        when = when || Klang.context.currentTime;
                        value = Klang.Util.clamp(value, -.99, .99);
                        this._panner.pan.setValueAtTime(this._panner.pan.value == 0 ? Klang.Util.EXP_MIN_VALUE : this._panner.pan.value, when);
                        this._panner.pan.exponentialRampToValueAtTime(value, when + duration);
                        return this
                    };
                    StereoPanner.prototype.refreshAudioNodes = function() {
                        var panValue = this._panner.pan.value;
                        this._panner.pan.cancelScheduledValues(Klang.context.currentTime);
                        this._panner.disconnect();
                        this._panner = Klang.context.createStereoPanner();
                        this._panner.pan.value = panValue;
                        this._input.connect(this._panner);
                        this._panner.connect(this._output)
                    };
                    Object.defineProperty(StereoPanner.prototype, "pan", {
                        get: function() {
                            return this._panner.pan.value
                        },
                        set: function(value) {
                            this._panner.pan.value = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    StereoPanner.prototype.setData = function(data) {
                        if (data.pan !== undefined) {
                            this.pan = data.pan
                        }
                    };
                    return StereoPanner
                }(Klang.Model.Effect);
                return Klang.Model.StereoPanner = StereoPanner
            });
            Module(function(Klang) {
                var Tremolo = function(_super) {
                    Klang.Util.__extends(Tremolo, _super);

                    function Tremolo(data, startTime) {
                        _super.call(this, data);
                        if (data.sync) {
                            this._sync = data.sync;
                            this._rate = data.rate || .25
                        }
                        this._oscillator = Klang.context.createOscillator();
                        this._amplitude = Klang.context.createGain();
                        this._input.connect(this._output);
                        this._oscillator.connect(this._amplitude);
                        this._amplitude.connect(this._output.gain);
                        this._oscillator.frequency.value = data.frequency || 10;
                        this._oscillator.type = data.wave || 0;
                        this._amplitude.gain.value = data.amplitude || 1;
                        this._oscillator.start(startTime);
                        Klang.core.Core.instance.pushToPreLoadInitStack(this)
                    }
                    Tremolo.prototype.init = function() {
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            this.updateSync(seq.bpm);
                            seq.registerBPMSync(this)
                        }
                    };
                    Tremolo.prototype.setActive = function(state) {
                        if (state) {
                            this._amplitude.connect(this._output.gain)
                        } else {
                            this._amplitude.disconnect()
                        }
                        return this
                    };
                    Tremolo.prototype.updateSync = function(bpm) {
                        this._oscillator.frequency.value = bpm / 60 / this._rate;
                        return this
                    };
                    Object.defineProperty(Tremolo.prototype, "frequency", {
                        get: function() {
                            return this._oscillator.frequency
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Tremolo.prototype, "amplitude", {
                        get: function() {
                            return this._amplitude.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Tremolo.prototype.setData = function(data) {
                        if (data.amplitude !== undefined) {
                            this.amplitude.value = data.amplitude
                        }
                        if (data.wave !== undefined) {
                            this._oscillator.type = data.wave
                        }
                        if (data.sync) {
                            this._sync = data.sync;
                            this._rate = data.rate || .25;
                            this.init()
                        } else {
                            if (data.frequency !== undefined) {
                                this.frequency.value = data.frequency
                            }
                        }
                    };
                    return Tremolo
                }(Klang.Model.Effect);
                return Klang.Model.Tremolo = Tremolo
            });
            Module(function(Klang) {
                var Distortion = function(_super) {
                    Klang.Util.__extends(Distortion, _super);

                    function Distortion(data) {
                        _super.call(this, data);
                        this._samples = 8192;
                        this._distortionType = data.distortion_type || 0;
                        this._amount = data.amount || .7;
                        this._samples = 8192;
                        this._waveshaper = Klang.context.createWaveShaper();
                        this._inputDrive = Klang.context.createGain();
                        this._outputDrive = Klang.context.createGain();
                        this._input.connect(this._inputDrive);
                        this._inputDrive.connect(this._waveshaper);
                        this._waveshaper.connect(this._outputDrive);
                        this._outputDrive.connect(this._output);
                        this._ws_table = new Float32Array(this._samples);
                        this.createWSCurve(this._distortionType, this._amount);
                        this._inputDrive.gain.value = data.drive || .5;
                        this._outputDrive.gain.value = data.outputGain || .5
                    }
                    Distortion.prototype.createWSCurve = function(type, amount) {
                        switch (type) {
                            case 0:
                                var amount = Math.min(amount, .9999);
                                var k = 2 * amount / (1 - amount),
                                    i, x;
                                for (i = 0; i < this._samples; i++) {
                                    x = i * 2 / this._samples - 1;
                                    this._ws_table[i] = (1 + k) * x / (1 + k * Math.abs(x))
                                }
                                break;
                            case 1:
                                var i, x, y;
                                for (i = 0; i < this._samples; i++) {
                                    x = i * 2 / this._samples - 1;
                                    y = (.5 * Math.pow(x + 1.4, 2) - 1) * y >= 0 ? 5.8 : 1.2;
                                    this._ws_table[i] = this.tanh(y)
                                }
                                break;
                            case 2:
                                var i, x, y, a = 1 - amount;
                                for (i = 0; i < this._samples; i++) {
                                    x = i * 2 / this._samples - 1;
                                    y = x < 0 ? -Math.pow(Math.abs(x), a + .04) : Math.pow(x, a);
                                    this._ws_table[i] = this.tanh(y * 2)
                                }
                                break;
                            case 3:
                                var i, x, y, abx, a = 1 - amount > .99 ? .99 : 1 - amount;
                                for (i = 0; i < this._samples; i++) {
                                    x = i * 2 / this._samples - 1;
                                    abx = Math.abs(x);
                                    if (abx < a) {
                                        y = abx
                                    } else if (abx > a) {
                                        y = a + (abx - a) / (1 + Math.pow((abx - a) / (1 - a), 2))
                                    } else if (abx > 1) {
                                        y = abx
                                    }
                                    this._ws_table[i] = this.sign(x) * y * (1 / ((a + 1) / 2))
                                }
                                break;
                            case 4:
                                var i, x;
                                for (i = 0; i < this._samples; i++) {
                                    x = i * 2 / this._samples - 1;
                                    if (x < -.08905) {
                                        this._ws_table[i] = -3 / 4 * (1 - Math.pow(1 - (Math.abs(x) - .032857), 12) + 1 / 3 * (Math.abs(x) - .032847)) + .01
                                    } else if (x >= -.08905 && x < .320018) {
                                        this._ws_table[i] = -6.153 * (x * x) + 3.9375 * x
                                    } else {
                                        this._ws_table[i] = .630035
                                    }
                                }
                                break;
                            case 5:
                                var a = 2 + Math.round(amount * 14),
                                    bits = Math.round(Math.pow(2, a - 1)),
                                    i, x;
                                for (i = 0; i < this._samples; i++) {
                                    x = i * 2 / this._samples - 1;
                                    this._ws_table[i] = Math.round(x * bits) / bits
                                }
                                break
                        }
                        this._waveshaper.curve = this._ws_table
                    };
                    Distortion.prototype.tanh = function(n) {
                        return (Math.exp(n) - Math.exp(-n)) / (Math.exp(n) + Math.exp(-n))
                    };
                    Distortion.prototype.sign = function(x) {
                        if (x === 0) {
                            return 1
                        } else {
                            return Math.abs(x) / x
                        }
                    };
                    Distortion.prototype.setActive = function(state) {
                        this._input.disconnect();
                        if (state) {
                            this._input.connect(this._inputDrive)
                        } else {
                            this._input.connect(this._output)
                        }
                        return this
                    };
                    Object.defineProperty(Distortion.prototype, "amount", {
                        get: function() {
                            return this._amount
                        },
                        set: function(val) {
                            this._amount = val;
                            this.createWSCurve(this._distortionType, this._amount)
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Distortion.prototype, "distortionType", {
                        get: function() {
                            return this._distortionType
                        },
                        set: function(val) {
                            this._distortionType = val;
                            this.createWSCurve(this._distortionType, this._amount)
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Distortion.prototype, "drive", {
                        get: function() {
                            return this._inputDrive.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Distortion.prototype, "outputGain", {
                        get: function() {
                            return this._outputDrive.gain
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Distortion.prototype.setData = function(data) {
                        if (data.amount !== undefined) {
                            this.amount = data.amount
                        }
                        if (data.distortion_type !== undefined) {
                            this.distortionType = data.distortion_type
                        }
                        if (data.drive !== undefined) {
                            this._inputDrive.gain.value = data.drive
                        }
                        if (data.outputGain !== undefined) {
                            this._outputDrive.gain.value = data.outputGain
                        }
                    };
                    return Distortion
                }(Klang.Model.Effect);
                return Klang.Model.Distortion = Distortion
            });
            Module(function(Klang) {
                function Synth(data, name) {
                    this._arpCounter = 0;
                    this._arpNoteLength = .5;
                    this._arpPattern = [];
                    this._arpPatternStep = 0;
                    this._name = name;
                    this._type = data.type;
                    this._output = Klang.context.createGain();
                    this._output.gain.value = data.volume || 1;
                    if (data.destination_name) {
                        this.destinationName = data.destination_name;
                        if (!Klang.core.Core.instance.initComplete) {
                            Klang.core.Core.instance.pushToConnectStack(this)
                        }
                    }
                    if (data.arp) {
                        this._arpMode = data.arp.arp_mode || "off";
                        this._octaves = data.arp.octaves || 1;
                        this._sync = data.arp.sync;
                        this._arpPattern = data.arp.arp_pattern || []
                    } else {
                        this._arpMode = "off"
                    }
                    this._activeVoices = [];
                    this._arpVoices = [];
                    this._beatSubscription = data.beat_subscription || .25;
                    this.data = data
                }
                Synth.prototype.connect = function(destination) {
                    this._output.connect(destination);
                    return this
                };
                Synth.prototype.disconnect = function() {
                    this._output.disconnect();
                    return this
                };
                Synth.prototype.handleMidiEvent = function(event, when, transpose, bypassArp) {
                    Klang.warn("Synth: Invocation of abstract method: Synth.handleMidiEvent in", this);
                    return this
                };
                Synth.prototype.stop = function() {
                    Klang.warn("Synth: Invocation of abstract method: Synth.stop in", this)
                };
                Synth.prototype.handleArpModes = function(midiEvent) {
                    this._arpVoices = [];
                    if (this._octaves > 1) {
                        var octaves = [];
                        for (var j = 0; j < this._octaves - 1; j++) {
                            for (var i = 0; i < this._activeVoices.length; i++) {
                                var e = this._activeVoices[i].midiEvent;
                                var note = e.noteNumber;
                                var ev = {
                                    type: "channel",
                                    subtype: e.subtype,
                                    noteNumber: note += 12 * (j + 1),
                                    velocity: e.velocity,
                                    deltaTime: e.deltaTime
                                };
                                octaves.push({
                                    midiEvent: ev,
                                    transpose: this._activeVoices[i].transpose
                                })
                            }
                        }
                        this._arpVoices = this._activeVoices.concat(octaves)
                    } else {
                        this._arpVoices = this._activeVoices
                    }
                    if (this._arpMode === "up") {
                        this._arpVoices = this._arpVoices.sort(this.sortVoices)
                    } else if (this._arpMode === "down") {
                        this._arpVoices = this._arpVoices.sort(this.sortVoices);
                        this._arpVoices.reverse()
                    } else if (this._arpMode === "up-down") {
                        var up = this._arpVoices.slice(0);
                        up.sort(this.sortVoices);
                        var down = this._arpVoices.slice(0);
                        down.sort(this.sortVoices);
                        down.reverse();
                        this._arpVoices = up.concat(down);
                        if (this._arpVoices.length > 1) {
                            this._arpVoices.splice(this._arpVoices.length / 2, 1);
                            this._arpVoices.pop()
                        }
                    } else if (this._arpMode === "random") {
                        this._arpVoices = Klang.Util.shuffle(this._arpVoices)
                    }
                };
                Synth.prototype.sortVoices = function(a, b) {
                    if (a.midiEvent.noteNumber < b.midiEvent.noteNumber) {
                        return -1
                    }
                    if (a.midiEvent.noteNumber > b.midiEvent.noteNumber) {
                        return 1
                    }
                    return 0
                };
                Synth.prototype.arpActive = function(active) {
                    if (active) {
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            seq.registerSynth(this);
                            if (!seq._started) {
                                seq.start()
                            }
                        }
                    } else {
                        this._arpMode = "off";
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            seq.unregisterSynth(this)
                        }
                    }
                };
                Synth.prototype.update = function(currentStep, scheduleTime) {
                    if (currentStep % this._beatSubscription == 0) {
                        this._arpPatternStep = currentStep * 4 % this._arpPattern.length;
                        if (this._arpVoices.length === 0) {
                            return
                        }
                        if (this._arpPattern.length) {
                            if (!this._arpPattern[currentStep * 4 % this._arpPattern.length]) {
                                return
                            }
                        }
                        this._arpCounter++;
                        this._arpCounter = this._arpCounter % this._arpVoices.length;
                        if (this._arpCounter < this._arpVoices.length) {
                            var vel = this._fixedVelocities ? this._fixedVelocities[this._arpCounter] : this._arpVoices[this._arpCounter].midiEvent.velocity;
                            this._arpVoices[this._arpCounter].midiEvent.velocity = vel;
                            this.handleMidiEvent(this._arpVoices[this._arpCounter].midiEvent, scheduleTime, this._arpVoices[this._arpCounter].transpose, true);
                            var noteOff = {
                                type: "channel",
                                subtype: "noteOff",
                                noteNumber: this._arpVoices[this._arpCounter].midiEvent.noteNumber,
                                velocity: this._arpVoices[this._arpCounter].midiEvent.velocity,
                                deltaTime: this._arpVoices[this._arpCounter].midiEvent.deltaTime
                            };
                            this.handleMidiEvent(noteOff, scheduleTime + this._arpNoteLength, this._arpVoices[this._arpCounter].transpose, true)
                        }
                    }
                };
                Synth.prototype.deschedule = function() {
                    Klang.warn("Synth: Invocation of abstract method: Synth.deschedule in", this);
                    return this
                };
                Object.defineProperty(Synth.prototype, "arpCounter", {
                    get: function() {
                        return this._arpCounter
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Synth.prototype, "arpLength", {
                    get: function() {
                        return this._arpVoices.length
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Synth.prototype, "output", {
                    get: function() {
                        return this._output
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Synth.prototype, "arpPattern", {
                    get: function() {
                        return this._arpPattern
                    },
                    set: function(pattern) {
                        this._arpPattern = pattern
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Synth.prototype, "arpPatternStep", {
                    get: function() {
                        return this._arpPatternStep
                    },
                    enumerable: true,
                    configurable: true
                });
                Synth.prototype.setData = function(data) {
                    if (data.volume !== undefined) {
                        this.output.gain.value = data.volume
                    }
                    if (this.destinationName != data.destination_name) {
                        this.destinationName = data.destination_name;
                        this.disconnect();
                        this.connect(Klang.core.Core.instance.findInstance(this.destinationName).input)
                    }
                    if (data.arp) {
                        this._sync = data.arp.sync;
                        this._octaves = data.arp.octaves;
                        this._arpPattern = data.arp.arp_pattern;
                        if (this._arpMode == "off") {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            seq.registerSynth(this);
                            if (!seq._started) {
                                seq.start()
                            }
                        }
                        this._arpMode = data.arp.arp_mode
                    } else {
                        this._arpMode = "off";
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            seq.unregisterSynth(this)
                        }
                    }
                    this.data = data
                };
                return Klang.Model.Synth = Synth
            });
            Module(function(Klang) {
                function LFO(data, startTime) {
                    startTime = startTime || 0;
                    this._targets = data.targets;
                    this._sync = data.sync;
                    this._rate = data.rate || 1;
                    this._phaseVal = data.phase || 0;
                    this._oscillator = Klang.context.createOscillator();
                    this._oscillator.type = data.wave || "sine";
                    this._oscillator.frequency.value = this._rate;
                    this._amplitude = Klang.context.createGain();
                    this._amplitude.gain.value = data.amplitude || 1;
                    this._phase = Klang.context.createDelay();
                    this._phase.delayTime.value = this._phaseVal * (1 / this._oscillator.frequency.value);
                    this._oscillator.connect(this._phase);
                    this._phase.connect(this._amplitude);
                    this._oscillator.start(startTime);
                    Klang.core.Core.instance.pushToPreLoadInitStack(this)
                }
                LFO.prototype.init = function() {
                    if (this._sync) {
                        var seq = Klang.core.Core.instance.findInstance(this._sync);
                        this.updateSync(seq.bpm);
                        seq.registerBPMSync(this)
                    }
                    for (var ix = 0, len = this._targets.length; ix < len; ix++) {
                        var t = this._targets[ix];
                        var bus = Klang.core.Core.instance.findInstance(t.bus);
                        var effect = bus.effects[t.effect];
                        if (!effect) {
                            Klang.warn("LFO: Effect index out of bounds: " + t.effect)
                        }
                        if (!effect[t.param]) {
                            Klang.warn("LFO: Parameter not recognized: " + t.param)
                        }
                        this._amplitude.connect(effect[t.param])
                    }
                };
                LFO.prototype.updateSync = function(bpm) {
                    this._oscillator.frequency.value = bpm / 60 / this._rate;
                    this._phase.delayTime.value = this._phaseVal * (1 / this._oscillator.frequency.value);
                    return this
                };
                LFO.prototype.setData = function(data) {
                    this._oscillator.type = data.wave;
                    this._oscillator.frequency.value = data.rate;
                    this._phase.delayTime.value = data.phase * (1 / this._oscillator.frequency.value);
                    this._amplitude.gain.value = data.amplitude || 1;
                    if (data.targets) {
                        this._targets = data.targets;
                        this.init()
                    }
                    if (this._sync != data.sync) {
                        this._sync = data.sync;
                        this.init()
                    }
                };
                return Klang.Model.LFO = LFO
            });
            Module(function(Klang) {
                var generateNoiseBuffer = function(frames, alg) {
                    if (alg < 0 || alg > 3) {
                        Klang.warn("Synth: Invalid noise algorithm: " + alg)
                    }
                    var sampleFrames = frames || 65536;
                    var buffer = Klang.context.createBuffer(1, sampleFrames, Klang.context.sampleRate);
                    var bufferData = buffer.getChannelData(0);
                    if (!alg) {
                        alg = 0
                    }
                    for (var i = 0; i < sampleFrames; i++) {
                        switch (alg) {
                            case 0:
                                bufferData[i] = Math.random() * 2 - 1;
                                break;
                            case 1:
                                bufferData[i] = Math.random();
                                break;
                            case 2:
                                bufferData[i] = Math.random() - 1;
                                break;
                            case 3:
                                bufferData[i] = i / sampleFrames;
                                break;
                            default:
                                break
                        }
                    }
                    return buffer
                };
                Klang.engines.webAudio.Util.generateNoiseBuffer = generateNoiseBuffer
            });
            Module(function(Klang) {
                var audioUtil = Klang.engines.webAudio.Util;
                var SympleVoice = function() {
                    function SympleVoice(data, voiceType, filterData, startTime, noiseBuffer) {
                        this.filterStartFreq = -1;
                        this._filterEnabled = true;
                        this.voiceType = voiceType;
                        this.active = false;
                        this.activatedNote = -1;
                        this._enabled = true;
                        this._detune = data.detune || 0;
                        this._wave = data.wave || "sine";
                        this._frames = data.frames;
                        this._algorithm = data.algorithm;
                        if (noiseBuffer) {
                            this._noiseBuffer = noiseBuffer
                        }
                        this.gain = Klang.context.createGain();
                        if (!filterData) {
                            filterData = {
                                frequency: 22050,
                                Q: 1,
                                filter_type: "lowpass"
                            };
                            this.filterEnabled = false
                        }
                        this._filterData = filterData
                    }
                    SympleVoice.prototype.noteOn = function(noteNumber, velocity, when, gainEG, filterEG, pitchEG, transpose) {
                        if (!this.enabled) {
                            return
                        }
                        if (this._wave !== "noise") {
                            this.source = Klang.context.createOscillator();
                            this.source.type = this._wave;
                            this.source.detune.value = this._detune
                        } else if (this._wave == "noise") {
                            this.source = Klang.context.createBufferSource();
                            this.source.buffer = this._noiseBuffer;
                            this.source.loop = true
                        }
                        this._envelope = Klang.context.createGain();
                        if (this._filterData) {
                            this.filter = Klang.context.createBiquadFilter();
                            this.filter.type = Klang.Util.safeFilterType(this._filterData.filter_type);
                            this.filter.frequency.value = this._filterData.frequency === undefined ? Klang.Util.NYQUIST_FREQUENCY : this._filterData.frequency;
                            if (this.filter.detune) {
                                this.filter.detune.value = this._filterData.detune || 0
                            }
                            this.filter.Q.value = this._filterData.Q || this.filter.Q.value;
                            this.filter.gain.value = this._filterData.gain || this.filter.gain.value;
                            this.filterTargetFreq = this.filter.frequency.value;
                            this.source.connect(this.filter);
                            this.filter.connect(this._envelope);
                            this._envelope.connect(this.gain)
                        } else {
                            this.source.connect(this._envelope);
                            this._envelope.connect(this.gain)
                        }
                        if (this.voiceType == 1) {
                            this.filterAmplitudeGainNode.connect(this.filter.frequency)
                        }
                        if (when < Klang.Util.now()) {
                            when = Klang.Util.now()
                        }
                        this.active = true;
                        this.activatedNote = noteNumber;
                        if (this._wave !== "noise") {
                            var pitchTargetFreq = Klang.Util.midiNoteToFrequency(noteNumber + transpose);
                            if (pitchEG) {
                                var pitchStartFreq = -1;
                                if (pitchEG.contour > 0) {
                                    pitchStartFreq = pitchTargetFreq * (1 - pitchEG.contour)
                                } else if (pitchEG.contour < 0) {
                                    pitchStartFreq = (Klang.Util.NYQUIST_FREQUENCY - pitchTargetFreq) * -pitchEG.contour + pitchTargetFreq
                                }
                                this.source.frequency.cancelScheduledValues(when);
                                if (pitchStartFreq != -1) {
                                    this.source.frequency.setValueAtTime(pitchStartFreq, when);
                                    if (Klang.safari) {
                                        this.source.frequency.setTargetValueAtTime(pitchTargetFreq, when, pitchEG.decay)
                                    } else {
                                        this.source.frequency.setTargetAtTime(pitchTargetFreq, when, pitchEG.decay)
                                    }
                                } else {
                                    this.source.frequency.setValueAtTime(pitchTargetFreq, when)
                                }
                            } else {
                                this.source.frequency.setValueAtTime(pitchTargetFreq, when)
                            }
                        }
                        if (filterEG) {
                            this.filterStartFreq = -1;
                            if (filterEG.contour < 0) {
                                this.filterStartFreq = this.filterTargetFreq * (1 + filterEG.contour) + 1
                            } else if (filterEG.contour > 0) {
                                this.filterStartFreq = (Klang.Util.NYQUIST_FREQUENCY - this.filterTargetFreq) * filterEG.contour + this.filterTargetFreq
                            }
                            if (this.filterStartFreq != -1) {
                                this.filter.frequency.cancelScheduledValues(when);
                                this.filter.frequency.setValueAtTime(this.filterStartFreq, when + 1e-4);
                                this.filter.frequency.exponentialRampToValueAtTime(this.filterTargetFreq, when + filterEG.attack);
                                if (Klang.safari) {
                                    this.filter.frequency.setTargetValueAtTime(this.filterTargetFreq * filterEG.sustain, when + filterEG.attack, filterEG.decay)
                                } else {
                                    this.filter.frequency.setTargetAtTime(this.filterTargetFreq * filterEG.sustain, when + filterEG.attack + 1e-4, filterEG.decay)
                                }
                            }
                        }
                        var vol;
                        if (gainEG.volumeCurve === "linear") {
                            vol = velocity / 128
                        } else if (gainEG.volumeCurve === "exponential") {
                            vol = Math.abs(1 - Math.exp(velocity / 128))
                        } else {
                            vol = 1
                        }
                        if (gainEG) {
                            this.gain.gain.cancelScheduledValues(when);
                            this._envelope.gain.setValueAtTime(0, when);
                            this._envelope.gain.linearRampToValueAtTime(vol, when + gainEG.attack);
                            if (Klang.safari) {
                                this._envelope.gain.setTargetValueAtTime(vol * gainEG.sustain, when + gainEG.attack, gainEG.decay)
                            } else {
                                this._envelope.gain.setTargetAtTime(vol * gainEG.sustain, when + gainEG.attack + 1e-4, gainEG.decay)
                            }
                        } else {
                            this._envelope.gain.setValueAtTime(vol, when)
                        }
                        this.source["startTime"] = when;
                        Klang.safari ? this.source.noteOn(when) : this.source.start(when)
                    };
                    SympleVoice.prototype.noteOff = function(noteNumber, when, gainEG, filterEG) {
                        if (!this.enabled) {
                            return
                        }
                        if (when < Klang.Util.now()) {
                            when = Klang.Util.now()
                        }
                        this.active = false;
                        if (filterEG) {
                            if (this.filterStartFreq != -1) {
                                this.filter.frequency.cancelScheduledValues(when);
                                if (when != Klang.Util.now()) {
                                    this.filter.frequency.setTargetAtTime(this.filterTargetFreq * filterEG.sustain, when, .1)
                                } else {
                                    this.filter.frequency.setValueAtTime(this.filter.frequency.value, when)
                                }
                                if (Klang.safari) {
                                    this.filter.frequency.setTargetValueAtTime(this.filterStartFreq, when, filterEG.release)
                                } else {
                                    this.filter.frequency.setTargetAtTime(this.filterStartFreq, when, filterEG.release)
                                }
                            }
                        }
                        if (gainEG) {
                            this._envelope.gain.cancelScheduledValues(when);
                            if (when != Klang.Util.now()) {
                                this._envelope.gain.setTargetAtTime(gainEG.sustain, when, .1)
                            } else {
                                this._envelope.gain.setValueAtTime(this._envelope.gain.value, when)
                            }
                            if (Klang.safari) {
                                this._envelope.gain.setTargetValueAtTime(0, when, gainEG.release)
                            } else {
                                this._envelope.gain.setTargetAtTime(0, when, gainEG.release)
                            }
                        } else {
                            this._envelope.gain.setValueAtTime(0, when)
                        }
                        this.source["offTime"] = when;
                        Klang.safari ? this.source.noteOff(when + gainEG.release * 5) : this.source.stop(when + gainEG.release * 5)
                    };
                    SympleVoice.prototype.stop = function() {
                        this.filter.frequency.cancelScheduledValues(0);
                        this._envelope.gain.cancelScheduledValues(0);
                        this._envelope.gain.setValueAtTime(0, 0);
                        Klang.safari ? this.source.noteOff(0) : this.source.stop(0);
                        this.source.disconnect();
                        if (this.filter) {
                            this.filter.disconnect()
                        }
                        if (this._envelope) {
                            this._envelope.disconnect()
                        }
                    };
                    SympleVoice.prototype.stopSoft = function(when, gainEG, filterEG) {
                        this.active = false;
                        this._envelope.gain.cancelScheduledValues(when);
                        if (Klang.safari) {
                            this._envelope.gain.setTargetValueAtTime(0, when, gainEG.release)
                        } else {
                            this._envelope.gain.setTargetAtTime(0, when, gainEG.release)
                        }
                        var offTime = when + gainEG.release * 5;
                        Klang.safari ? this.source.noteOff(offTime) : this.source.stop(offTime);
                        var _this = this;
                        setTimeout(function() {
                            _this.source.disconnect();
                            if (_this.filter) {
                                _this.filter.disconnect()
                            }
                            if (_this._envelope) {
                                _this._envelope.disconnect()
                            }
                        }, (offTime - Klang.Util.now()) * 1e3)
                    };
                    Object.defineProperty(SympleVoice.prototype, "enabled", {
                        get: function() {
                            return this._enabled
                        },
                        set: function(state) {
                            this._enabled = state
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SympleVoice.prototype, "filterEnabled", {
                        get: function() {
                            return this._filterEnabled
                        },
                        set: function(state) {
                            this._filterEnabled = state;
                            if (!this.source) {
                                return
                            }
                            if (state) {
                                this.source.disconnect();
                                this.source.connect(this.filter);
                                this.filter.connect(this._envelope)
                            } else {
                                this.source.disconnect();
                                this.filter.disconnect();
                                this.source.connect(this._envelope)
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return SympleVoice
                }();
                var SympleOsc = function() {
                    function SympleOsc(data, poly, filterData, startTime) {
                        this._enabled = true;
                        this.nextVoice = 0;
                        this.octave = data.octave || 0;
                        this.output = Klang.context.createGain();
                        this.output.gain.value = data.volume === undefined ? 1 : data.volume;
                        this._data = data;
                        this._poly = poly;
                        this._filterData = filterData;
                        this.voices = [];
                        this._noiseBuffer = audioUtil.generateNoiseBuffer(this._data._frames, this._data._algorithm)
                    }
                    SympleOsc.prototype.noteOn = function(noteNumber, velocity, when, gainEG, filterEG, pitchEG, transpose) {
                        if (!this.enabled) {
                            return
                        }
                        if (this.voices.length == this._poly) {
                            this.voices[0].noteOff(noteNumber, when, gainEG, filterEG);
                            this.voices.splice(0, 1)
                        }
                        noteNumber += this.octave * 12;
                        var v;
                        if (this._data.wave == "noise") {
                            v = new SympleVoice(this._data, 0, this._filterData, when, this._noiseBuffer)
                        } else {
                            v = new SympleVoice(this._data, 0, this._filterData, when, null)
                        }
                        v.gain.connect(this.output);
                        v.noteOn(noteNumber, velocity, when, gainEG, filterEG, pitchEG, transpose);
                        if (this.lfoPitchGainNode && this._data.wave != "noise") {
                            this.lfoPitchGainNode.connect(v.source.frequency)
                        }
                        if (this.filterAmplitude && v.filter) {
                            this.filterAmplitude.connect(v.filter.frequency)
                        }
                        this.voices.push(v)
                    };
                    SympleOsc.prototype.noteOff = function(noteNumber, when, gainEG, filterEG) {
                        if (!this.enabled) {
                            return
                        }
                        noteNumber += this.octave * 12;
                        for (var ix = 0; ix < this.voices.length; ix++) {
                            if (this.voices[ix].active && this.voices[ix].activatedNote == noteNumber) {
                                this.voices[ix].noteOff(noteNumber, when, gainEG, filterEG);
                                this.voices.splice(ix, 1);
                                break
                            }
                        }
                    };
                    SympleOsc.prototype.stopSoft = function(when, gainEG, filterEG) {
                        for (var ix = 0; ix < this.voices.length; ix++) {
                            this.voices[ix].stopSoft(when, gainEG, filterEG)
                        }
                        this.voices = []
                    };
                    SympleOsc.prototype.stop = function() {
                        for (var ix = 0, len = this.voices.length; ix < len; ix++) {
                            this.voices[ix].stop()
                        }
                        this.voices = []
                    };
                    SympleOsc.prototype.deschedule = function() {
                        for (var ix = 0, len = this.voices.length; ix < len; ix++) {
                            if (this.voices[ix]) {
                                var source = this.voices[ix].source;
                                if (source.playbackState == 1 || source["startTime"] > Klang.context.currentTime) {
                                    this.voices[ix].stop();
                                    this.voices.splice(ix, 1);
                                    ix--
                                }
                            }
                        }
                    };
                    SympleOsc.prototype.setDetune = function(detune, when) {
                        if (this._data) {
                            this._data.detune = detune;
                            for (var ix = 0, len = this.voices.length; ix < len; ix++) {
                                this.voices[ix].source.detune.setValueAtTime(detune, when)
                            }
                        }
                    };
                    Object.defineProperty(SympleOsc.prototype, "enabled", {
                        get: function() {
                            return this._enabled
                        },
                        set: function(state) {
                            this._enabled = state
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SympleOsc.prototype, "detune", {
                        get: function() {
                            return this._detune
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return SympleOsc
                }();
                var SympleLFO = function() {
                    function SympleLFO(data, startTime) {
                        this.osc = Klang.context.createOscillator();
                        this.phaseDelay = Klang.context.createDelay();
                        this.osc.type = data.wave || "sine";
                        this.osc.frequency.value = data.rate || 1;
                        this.phase = data.phase || 0;
                        this.phaseDelay.delayTime.value = this.phase * (1 / this.osc.frequency.value);
                        this.sync = data.sync;
                        this.syncResolution = data.rate;
                        this.osc.connect(this.phaseDelay);
                        this.oscVolumeAmplitude = Klang.context.createGain();
                        this.oscVolumeAmplitude.gain.value = data.osc_volume_amount;
                        this.phaseDelay.connect(this.oscVolumeAmplitude);
                        this.pitchAmplitude = Klang.context.createGain();
                        this.pitchAmplitude.gain.value = data.pitch_amount;
                        this.phaseDelay.connect(this.pitchAmplitude);
                        this.filterAmplitude = Klang.context.createGain();
                        this.filterAmplitude.gain.value = data.filter_amount;
                        this.phaseDelay.connect(this.filterAmplitude);
                        Klang.safari ? this.osc.noteOn(startTime) : this.osc.start(startTime)
                    }
                    SympleLFO.prototype.updateSync = function(bpm) {
                        this.osc.frequency.value = bpm / 60 / this.syncResolution;
                        this.phaseDelay.delayTime.value = this.phase * (1 / this.osc.frequency.value);
                        return this
                    };
                    return SympleLFO
                }();
                var Symple = function(_super) {
                    Klang.Util.__extends(Symple, _super);

                    function Symple(data, name) {
                        _super.call(this, data, name);
                        this.bendRange = 400;
                        var startTime = Klang.context.currentTime + Klang.Util.OSC_START_DELAY;
                        this._gainEG = data.gain_eg;
                        this._filterEG = data.filter_eg;
                        this._pitchEG = data.pitch_eg;
                        var disabledOscs = 0;
                        if (!data.oscillators[0]) {
                            data.oscillators.push({
                                wave: "sine",
                                detune: 0,
                                volume: 1,
                                octave: 0
                            });
                            disabledOscs++
                        }
                        if (!data.oscillators[1]) {
                            data.oscillators.push({
                                wave: "sine",
                                detune: 0,
                                volume: 1,
                                octave: 0
                            });
                            disabledOscs++
                        }
                        this._oscs = [];
                        this._poly = data.poly;
                        for (var ix = 0, len = data.oscillators.length; ix < len; ix++) {
                            var o = new SympleOsc(data.oscillators[ix], data.poly, data.filter, startTime);
                            o.output.connect(this.output);
                            this._oscs.push(o)
                        }
                        if (disabledOscs == 1) {
                            this._oscs[1].enabled = false
                        } else if (disabledOscs == 2) {
                            this._oscs[0].enabled = false;
                            this._oscs[1].enabled = false
                        }
                        if (data.LFO) {
                            this._LFO = new SympleLFO(data.LFO, startTime);
                            for (var ix = 0, len = this._oscs.length; ix < len; ix++) {
                                var osc = this._oscs[ix];
                                if (this._LFO.oscVolumeAmplitude) {
                                    this._LFO.oscVolumeAmplitude.connect(osc.output.gain)
                                }
                                if (this._LFO.pitchAmplitude) {
                                    osc.lfoPitchGainNode = this._LFO.pitchAmplitude
                                }
                                if (this._LFO.filterAmplitude) {
                                    osc.filterAmplitude = this._LFO.filterAmplitude
                                }
                            }
                            if (this._LFO.sync) {
                                Klang.core.Core.instance.pushToPreLoadInitStack(this)
                            }
                        }
                        if (this._sync) {
                            Klang.core.Core.instance.pushToPreLoadInitStack(this)
                        }
                    }
                    Symple.prototype.init = function() {
                        if (this._LFO && this._LFO.sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._LFO.sync);
                            this._LFO.updateSync(seq.bpm);
                            seq.registerBPMSync(this._LFO)
                        }
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            seq.registerSynth(this);
                            if (!seq.started) {
                                seq.start()
                            }
                        }
                    };
                    Symple.prototype.handleMidiEvent = function(midiEvent, when, transpose, bypassArp) {
                        when = when || Klang.context.currentTime;
                        bypassArp = bypassArp || false;
                        transpose = transpose || 0;
                        if (midiEvent.type == "channel") {
                            if (midiEvent.subtype == "noteOn") {
                                if (this._arpMode != "off" && !bypassArp) {
                                    this._activeVoices.push({
                                        midiEvent: midiEvent,
                                        transpose: transpose
                                    });
                                    this.handleArpModes(midiEvent);
                                    return
                                }
                                for (var ix = 0, len = this._oscs.length; ix < len; ix++) {
                                    this._oscs[ix].noteOn(midiEvent.noteNumber, midiEvent.velocity, when, this._gainEG, this._filterEG, this._pitchEG, transpose)
                                }
                            } else if (midiEvent.subtype == "noteOff") {
                                if (this._arpMode != "off" && !bypassArp) {
                                    for (var i = 0; i < this._activeVoices.length; i++) {
                                        if (midiEvent.noteNumber === this._activeVoices[i].midiEvent.noteNumber) {
                                            this._activeVoices.splice(i, 1)
                                        }
                                    }
                                    this.handleArpModes(midiEvent);
                                    return
                                }
                                for (var ix = 0, len = this._oscs.length; ix < len; ix++) {
                                    this._oscs[ix].noteOff(midiEvent.noteNumber, when, this._gainEG, this._filterEG)
                                }
                            } else if (midiEvent.subtype == "pitchBend") {
                                var bend;
                                if (midiEvent.value !== undefined) {
                                    bend = midiEvent.value
                                } else if (midiEvent.velocity !== undefined) {
                                    bend = midiEvent.velocity
                                }
                                var currentPitch = (bend - 8192) / 16384 * this.bendRange;
                                for (var i = 0; i < this._oscs.length; i++) {
                                    this._oscs[i].setDetune(currentPitch, when)
                                }
                            }
                        }
                        return this
                    };
                    Symple.prototype.glideTo = function(midiNotes, when, duration, transpose) {
                        var now = Klang.Util.now();
                        when = when || now;
                        if (duration === undefined) {
                            duration = .5
                        }
                        transpose = transpose || 0;
                        for (var o = 0, len = this._oscs.length; o < len; o++) {
                            var osc = this._oscs[o];
                            var voicesToUpdate = Math.min(midiNotes.length, osc.voices.length);
                            for (var v = 0; v < voicesToUpdate; v++) {
                                var voice = osc.voices[v];
                                var toFrequency = Klang.Util.midiNoteToFrequency(midiNotes[v] + transpose + osc.octave * 12);
                                if (voice.source.frequency) {
                                    voice.source.frequency.linearRampToValueAtTime(toFrequency, when + duration)
                                }
                            }
                        }
                        return this
                    };
                    Symple.prototype.stop = function(when) {
                        when = when || Klang.Util.now();
                        for (var ix = 0, len = this._oscs.length; ix < len; ix++) {
                            this._oscs[ix].stopSoft(when, this._gainEG, this._filterEG)
                        }
                        if (this._activeVoices.length) {
                            this._activeVoices = []
                        }
                        this._arpVoices = []
                    };
                    Symple.prototype.deschedule = function() {
                        for (var o = 0, len = this._oscs.length; o < len; o++) {
                            this._oscs[o].deschedule()
                        }
                        return this
                    };
                    Object.defineProperty(Symple.prototype, "filterFrequency", {
                        set: function(val) {
                            for (var o = 0, len = this._oscs.length; o < len; o++) {
                                var osc = this._oscs[o];
                                osc._filterData.frequency = val;
                                for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                    var voice = osc.voices[v];
                                    voice.filterTargetFreq = val;
                                    if (!this._filterEG || this._filterEG.contour == 0) {
                                        voice.filter.frequency.value = val
                                    }
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "filterQ", {
                        set: function(val) {
                            for (var o = 0, len = this._oscs.length; o < len; o++) {
                                var osc = this._oscs[o];
                                osc._filterData.Q = val;
                                for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                    var voice = osc.voices[v];
                                    voice.filterTargetFreq = val;
                                    if (!this._filterEG || this._filterEG.contour == 0) {
                                        voice.filter.Q.value = val
                                    }
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "filterType", {
                        set: function(val) {
                            for (var o = 0, len = this._oscs.length; o < len; o++) {
                                var osc = this._oscs[o];
                                osc._filterData.filter_type = val;
                                for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                    var voice = osc.voices[v];
                                    voice.filter.type = val
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc1Wave", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc._data.wave = val;
                            for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                var voice = osc.voices[v];
                                if (voice.source.type && val !== "4") {
                                    voice.source.type = val
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc1Vol", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc.output.gain.value = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc1Detune", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc._detune = val;
                            for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                var voice = osc.voices[v];
                                if (voice.source.detune) {
                                    voice.source.detune.value = val
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc1Octave", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc.octave = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc2Wave", {
                        set: function(val) {
                            if (this._oscs.length < 2) {
                                return
                            }
                            var osc = this._oscs[1];
                            osc._data.wave = val;
                            for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                var voice = osc.voices[v];
                                if (voice.source.type && val !== "4") {
                                    voice.source.type = val
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc2Vol", {
                        set: function(val) {
                            if (this._oscs.length < 2) {
                                return
                            }
                            var osc = this._oscs[1];
                            osc.output.gain.value = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc2Detune", {
                        set: function(val) {
                            if (this._oscs.length < 2) {
                                return
                            }
                            var osc = this._oscs[1];
                            osc._detune = val;
                            for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                var voice = osc.voices[v];
                                if (voice.source.detune) {
                                    voice.source.detune.value = val
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "osc2Octave", {
                        set: function(val) {
                            if (this._oscs.length < 2) {
                                return
                            }
                            var osc = this._oscs[1];
                            osc.octave = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "pitchDecay", {
                        set: function(val) {
                            if (this._pitchEG) {
                                this._pitchEG.decay = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "pitchContour", {
                        set: function(val) {
                            if (this._pitchEG) {
                                this._pitchEG.contour = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "lfoWave", {
                        set: function(val) {
                            if (this._LFO) {
                                this._LFO.osc.type = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "lfoRate", {
                        set: function(val) {
                            if (this._LFO) {
                                this._LFO.osc.frequency.value = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "lfoPhase", {
                        set: function(val) {
                            if (this._LFO) {
                                this._LFO.phase = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "lfoOscVol", {
                        set: function(val) {
                            if (this._LFO) {
                                this._LFO.oscVolumeAmplitude.gain.value = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "lfoPitch", {
                        set: function(val) {
                            if (this._LFO) {
                                this._LFO.pitchAmplitude.gain.value = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "lfoFilter", {
                        set: function(val) {
                            if (this._LFO) {
                                this._LFO.filterAmplitude.gain.value = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "arpMode", {
                        set: function(val) {
                            this._arpMode = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Symple.prototype, "arpOctaves", {
                        set: function(val) {
                            this._octaves = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Symple.prototype.setData = function(data) {
                        _super.prototype.setData.call(this, data);
                        this._poly = data.poly;
                        this._gainEG = data.gain_eg ? data.gain_eg : undefined;
                        this._filterEG = data.filter_eg ? data.filter_eg : undefined;
                        this._pitchEG = data.pitch_eg ? data.pitch_eg : undefined;
                        this._oscs[0].enabled = data.oscillators[0] ? true : false;
                        this._oscs[1].enabled = data.oscillators[1] ? true : false;
                        for (var o = 0, len = this._oscs.length; o < len; o++) {
                            var osc = this._oscs[o];
                            osc._data = data.oscillators[o];
                            osc._filterData = data.filter;
                            osc._poly = this._poly;
                            for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                var voice = osc.voices[v];
                                if (data.filter) {
                                    if (!voice.filterEnabled) {
                                        voice.filterEnabled = true
                                    }
                                    if (!this._filterEG || this._filterEG.contour == 0) {
                                        voice.filter.frequency.value = data.filter.frequency
                                    }
                                    voice.filter.Q.value = data.filter.Q;
                                    voice.filterTargetFreq = data.filter.frequency;
                                    voice.filter.type = data.filter.filter_type
                                } else if (voice.filterEnabled) {
                                    voice.filterEnabled = false
                                }
                                if (data.oscillators && data.oscillators[o] && voice.voiceType == 0) {
                                    if (voice.source.type && data.oscillators[0].wave !== 4) {
                                        voice.source.type = data.oscillators[o].wave
                                    }
                                    if (voice.source.detune) {
                                        voice.source.detune.value = data.oscillators[o].detune
                                    }
                                }
                            }
                            if (data.oscillators[o]) {
                                osc.output.gain.value = data.oscillators[o].volume;
                                osc.octave = data.oscillators[o].octave
                            }
                        }
                        if (data.LFO) {
                            this._LFO.osc.type = data.LFO.wave;
                            this._LFO.osc.frequency.value = data.LFO.rate;
                            this._LFO.phase = data.LFO.phase;
                            this._LFO.phaseDelay.delayTime.value = data.LFO.phase * (1 / this._LFO.osc.frequency.value);
                            this._LFO.oscVolumeAmplitude.gain.value = data.LFO.osc_volume_amount;
                            this._LFO.pitchAmplitude.gain.value = data.LFO.pitch_amount;
                            this._LFO.filterAmplitude.gain.value = data.LFO.filter_amount
                        } else {
                            this._LFO.oscVolumeAmplitude.gain.value = 0;
                            this._LFO.pitchAmplitude.gain.value = 0;
                            this._LFO.filterAmplitude.gain.value = 0
                        }
                    };
                    return Symple
                }(Klang.Model.Synth);
                return Klang.Model.Symple = Symple
            });
            Module(function(Klang) {
                var audioUtil = Klang.engines.webAudio.Util;
                var MonoSynth = function(_super) {
                    Klang.Util.__extends(MonoSynth, _super);

                    function MonoSynth(data, name) {
                        _super.call(this, data, name);
                        var startTime = Klang.context.currentTime + Klang.Util.OSC_START_DELAY;
                        this._gainEG = data.gain_eg;
                        this._pitchEG = data.pitch_eg;
                        this._osc = null;
                        if (this._sync) {
                            Klang.core.Core.instance.pushToPreLoadInitStack(this)
                        }
                    }
                    MonoSynth.prototype.init = function() {
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            seq.registerSynth(this);
                            if (!seq.started) {
                                seq.start()
                            }
                        }
                    };
                    MonoSynth.prototype.trigger = function(note) {
                        var midiEvent = {
                            noteNumber: note,
                            when: Klang.context.currentTime
                        };
                        this.noteOn(midiEvent.noteNumber, midiEvent.when);
                        this.noteOff(midiEvent.noteNumber, midiEvent.when)
                    };
                    MonoSynth.prototype.noteOn = function(noteNumber, velocity, when, transpose) {
                        when = Math.max(when || 0, Klang.context.currentTime);
                        transpose = transpose || 0;
                        if (!this._osc) {
                            this._osc = Klang.context.createOscillator();
                            this._oscGain = Klang.context.createGain();
                            this._osc.connect(this._oscGain);
                            this._oscGain.connect(this.output);
                            this._osc.start(when);
                            this._oscGain.gain.value = 0;
                            this._osc.type = this.data.oscillators[0].wave
                        }
                        var f = Klang.Util.midiNoteToFrequency(noteNumber + transpose + this.data.oscillators[0].octave * 12);
                        var v = this._oscGain.gain.value;
                        var oldF = this._osc.frequency.value;
                        var smoothingTime = .02;
                        this._oscGain.gain.cancelScheduledValues(when);
                        this._osc.frequency.cancelScheduledValues(when);
                        this._osc.frequency.setValueAtTime(oldF, when);
                        this._oscGain.gain.setValueAtTime(v, when);
                        this._oscGain.gain.linearRampToValueAtTime(0, when + smoothingTime);
                        this._osc.frequency.linearRampToValueAtTime(f, when + smoothingTime);
                        this.smoothingTime = smoothingTime;
                        var attackVal = smoothingTime + this._gainEG.attack + .01;
                        this._oscGain.gain.linearRampToValueAtTime(1, when + attackVal);
                        var decayVal = attackVal + this._gainEG.decay;
                        this._oscGain.gain.linearRampToValueAtTime(this._gainEG.sustain, when + decayVal);
                        this._adEndTime = when + decayVal;
                        return this
                    };
                    MonoSynth.prototype.noteOff = function(noteNumber, when) {
                        when = Math.max(when || 0, this._adEndTime + 1e-4);
                        var attackVal = this.smoothingTime + this._gainEG.attack + .01;
                        var release = attackVal + this.smoothingTime + this._gainEG.release;
                        this._oscGain.gain.linearRampToValueAtTime(0, when + release)
                    };
                    MonoSynth.prototype.handleMidiEvent = function(midiEvent, when, transpose, bypassArp) {
                        when = when || Klang.context.currentTime;
                        transpose = transpose || 0;
                        if (midiEvent.type == "channel") {
                            if (midiEvent.subtype == "noteOn") {
                                this.noteOn(midiEvent.noteNumber, midiEvent.velocity, when, transpose)
                            } else if (midiEvent.subtype == "noteOff") {
                                this.noteOff(midiEvent.noteNumber, when, this._gainEG)
                            } else if (midiEvent.subtype == "pitchBend") {
                                var bend;
                                if (midiEvent.value !== undefined) {
                                    bend = midiEvent.value
                                } else if (midiEvent.velocity !== undefined) {
                                    bend = midiEvent.velocity
                                }
                                var currentPitch = (bend - 8192) / 16384 * this.bendRange;
                                for (var i = 0; i < this._oscs.length; i++) {
                                    this._oscs[i].setDetune(currentPitch, when)
                                }
                            }
                        }
                        return this
                    };
                    MonoSynth.prototype.glideTo = function(midiNotes, when, duration, transpose) {
                        var now = Klang.Util.now();
                        when = when || now;
                        if (duration === undefined) {
                            duration = .5
                        }
                        transpose = transpose || 0;
                        for (var o = 0, len = this._oscs.length; o < len; o++) {
                            var osc = this._oscs[o];
                            var voicesToUpdate = Math.min(midiNotes.length, osc.voices.length);
                            for (var v = 0; v < voicesToUpdate; v++) {
                                var voice = osc.voices[v];
                                var toFrequency = Klang.Util.midiNoteToFrequency(midiNotes[v] + transpose + osc.octave * 12);
                                if (voice.source.frequency) {
                                    voice.source.frequency.linearRampToValueAtTime(toFrequency, when + duration)
                                }
                            }
                        }
                        return this
                    };
                    MonoSynth.prototype.stop = function(when) {
                        when = when || Klang.Util.now();
                        this._osc.stop();
                        this._osc.disconnect();
                        this._oscGain.disconnect();
                        this._osc = null
                    };
                    MonoSynth.prototype.deschedule = function() {};
                    Object.defineProperty(MonoSynth.prototype, "osc1Wave", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc._data.wave = val;
                            for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                var voice = osc.voices[v];
                                if (voice.source.type && val !== "4") {
                                    voice.source.type = val
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MonoSynth.prototype, "osc1Vol", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc.output.gain.value = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MonoSynth.prototype, "osc1Detune", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc._detune = val;
                            for (var v = 0, vlen = osc.voices.length; v < vlen; v++) {
                                var voice = osc.voices[v];
                                if (voice.source.detune) {
                                    voice.source.detune.value = val
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MonoSynth.prototype, "osc1Octave", {
                        set: function(val) {
                            var osc = this._oscs[0];
                            osc.octave = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MonoSynth.prototype, "pitchDecay", {
                        set: function(val) {
                            if (this._pitchEG) {
                                this._pitchEG.decay = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MonoSynth.prototype, "pitchContour", {
                        set: function(val) {
                            if (this._pitchEG) {
                                this._pitchEG.contour = val
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    MonoSynth.prototype.setData = function(data) {
                        _super.prototype.setData.call(this, data);
                        this._poly = data.poly;
                        this._gainEG = data.gain_eg ? data.gain_eg : undefined;
                        this._pitchEG = data.pitch_eg ? data.pitch_eg : undefined;
                        if (this._osc) {
                            this._osc.type = data.oscillators[0].wave
                        }
                    };
                    return MonoSynth
                }(Klang.Model.Synth);
                return Klang.Model.MonoSynth = MonoSynth
            });
            Module(function(Klang) {
                var SamplePlayer = function(_super) {
                    Klang.Util.__extends(SamplePlayer, _super);

                    function SamplePlayer(data, name) {
                        _super.call(this, data, name);
                        this._content = [];
                        this._playingVoices = [];
                        this._allVoices = [];
                        this._hasNoteOffSamples = false;
                        this._hasSustainOnSamples = false;
                        this._hasSustainOffSamples = false;
                        this._useEnvelope = true;
                        this._pitchBendRange = .25;
                        this._pedalOnTime = -1;
                        this._sustained = [];
                        this._maxNotes = 20;
                        this._stopFactor = 5;
                        this._content = Klang.Util.cloneObject(data.content);
                        this._volumeCurve = data.volume_curve || "none";
                        this._gainEG = data.eg_gain || {
                            attack: 0,
                            decay: 0,
                            sustain: 1,
                            release: .005
                        };
                        this._currentPitch = 1;
                        Klang.core.Core.instance.pushToPreLoadInitStack(this)
                    }
                    SamplePlayer.prototype.init = function() {
                        this._envelope = Klang.context.createGain();
                        for (var ix = 0, len = this._content.length; ix < len; ix++) {
                            if (this._content[ix].value === "noteOff") {
                                this._hasNoteOffSamples = true
                            }
                            if (this._content[ix].value === "sustainOn") {
                                this._hasSustainOnSamples = true
                            }
                            if (this._content[ix].value === "sustainOff") {
                                this._hasSustainOffSamples = true
                            }
                            for (var j = 0; j < this._content[ix].samples.length; j++) {
                                this._content[ix].samples[j].source = Klang.core.Core.instance.findInstance(this._content[ix].samples[j].source);
                                if (!this._content[ix].samples[j].source) {
                                    Klang.warn("SamplePlayer: audio source not found")
                                }
                                this._content[ix].samples[j].source._parentType = "SamplePlayer";
                                if (this._content[ix].samples[j].source.loop) {
                                    this._loopedSamples = true
                                }
                            }
                        }
                        if (this._sync) {
                            var seq = Klang.core.Core.instance.findInstance(this._sync);
                            seq.registerSynth(this);
                            if (!seq.started) {}
                        }
                    };
                    SamplePlayer.prototype.handleMidiEvent = function(midiEvent, when, transpose, bypassArp, insertBus) {
                        when = when || Klang.Util.now();
                        bypassArp = bypassArp || false;
                        transpose = transpose || 0;
                        if (midiEvent.type == "channel") {
                            if (midiEvent.subtype == "noteOn") {
                                if (this._arpMode != "off" && !bypassArp) {
                                    this._activeVoices.push({
                                        midiEvent: midiEvent,
                                        transpose: transpose
                                    });
                                    this.handleArpModes(midiEvent);
                                    return
                                }
                                this.noteOn(when, midiEvent.noteNumber, transpose, midiEvent.velocity, midiEvent.subtype, false, insertBus);
                                if (this._callback) {
                                    this._callback(midiEvent, when)
                                }
                            } else if (midiEvent.subtype == "noteOff") {
                                if (this._arpMode != "off" && !bypassArp) {
                                    for (var i = 0; i < this._activeVoices.length; i++) {
                                        if (midiEvent.noteNumber === this._activeVoices[i].midiEvent.noteNumber) {
                                            this._activeVoices.splice(i, 1)
                                        }
                                    }
                                    this.handleArpModes(midiEvent);
                                    return
                                }
                                this.noteOff(when, midiEvent.noteNumber, midiEvent.velocity, midiEvent.subtype);
                                if (this._callback) {
                                    this._callback(midiEvent, when)
                                }
                            } else if (midiEvent.subtype == "pitchBend") {
                                var bend = midiEvent.value;
                                this._currentPitch = 1 + (bend - 64) / 127;
                                for (var i = 0; i < this._playingVoices.length; i++) {
                                    this._playingVoices[i].source.playbackRateNode.setValueAtTime(this._currentPitch, when)
                                }
                            } else if (midiEvent.subtype == "controller") {
                                var controllerType = midiEvent.controllerType || midiEvent.noteNumber;
                                var value = midiEvent.value === undefined ? midiEvent.velocity : midiEvent.value;
                                switch (controllerType) {
                                    case 1:
                                        break;
                                    case 64:
                                        if (value < 64) {
                                            this.pedalRelease(when);
                                            if (when > this._pedalOnTime) {
                                                this._pedalOnTime = -1
                                            }
                                            if (this._hasSustainOffSamples) {
                                                this.noteOn(when, 0, 0, 127, "sustainOff")
                                            }
                                        } else if (value > 64) {
                                            this._pedalOnTime = when;
                                            if (this._hasSustainOnSamples) {
                                                this.noteOn(when, 0, 0, 127, "sustainOn")
                                            }
                                        }
                                        break;
                                    default:
                                }
                            }
                        }
                        return this
                    };
                    SamplePlayer.prototype.noteOn = function(when, midiNote, transpose, velocity, value, volume, insertBus) {
                        for (var ix = 0; ix < this._allVoices.length; ix++) {
                            var v = this._allVoices[ix];
                            if (v.source._sources.length == 0 || v.source.lastSource.playbackState == 3) {
                                this._allVoices.splice(ix, 1);
                                ix--
                            }
                        }
                        var note = this.getNote(midiNote + transpose, velocity, value);
                        var targetPitch = Klang.Util.midiNoteToFrequency(midiNote + transpose);
                        var rootPitch = Klang.Util.midiNoteToFrequency(note.root);
                        var rate = targetPitch / rootPitch;
                        if (note.root === -1) {
                            rate = 1
                        }
                        var copy = new Klang.Model.AudioSource(note.source.data, midiNote.toString());
                        if (value === "noteOn") {
                            var newVoice = {
                                source: copy,
                                time: when,
                                velocity: velocity,
                                note: midiNote,
                                transpose: transpose
                            };
                            this._playingVoices.push(newVoice);
                            this._allVoices.push(newVoice)
                        }
                        if (insertBus) {
                            copy.connect(insertBus.input)
                        } else if (this.destinationName) {
                            copy.connect(Klang.core.Core.instance.findInstance(this.destinationName).input)
                        } else {
                            copy.connect(Klang.core.Core.instance.findInstance(copy.destinationName).input)
                        }
                        when = when < Klang.Util.now() ? Klang.Util.now() : when;
                        var vol = 0;
                        if (volume) {
                            vol = volume * velocity / 128
                        } else if (this._volumeCurve === "linear") {
                            vol = velocity / 128
                        } else if (this._volumeCurve === "exponential") {
                            vol = Math.abs(1 - Math.exp(velocity / 128))
                        } else if (this._volumeCurve === "none") {
                            vol = 1
                        }
                        vol *= copy.output.gain.value;
                        copy.output.gain.cancelScheduledValues(when);
                        copy.nextPlaybackRate = rate * this._currentPitch;
                        copy.play(when);
                        if (this._useEnvelope) {
                            var attackWhen = Math.max(when + 1e-4, when + this._gainEG.attack);
                            copy.output.gain.setValueAtTime(0, when);
                            copy.output.gain.linearRampToValueAtTime(vol, attackWhen);
                            if (copy.output.gain.setTargetAtTime) {
                                copy.output.gain.setTargetAtTime(vol * this._gainEG.sustain, attackWhen, this._gainEG.decay || .01)
                            } else if (copy.output.gain.setTargetValueAtTime) {
                                copy.output.gain.setTargetValueAtTime(vol * this._gainEG.sustain, attackWhen, this._gainEG.decay)
                            }
                        } else {
                            copy.output.gain.setValueAtTime(vol, when);
                            copy.output.gain.value = vol
                        }
                    };
                    SamplePlayer.prototype.adsr = function(attack, decay, sustain, release) {
                        var eg = this._gainEG;
                        if (arguments.length === 0) {
                            return {
                                attack: eg.attack,
                                decay: eg.decay,
                                sustain: eg.sustain,
                                release: eg.release
                            }
                        } else {
                            eg.attack = arguments[0] === undefined ? eg.attack : arguments[0];
                            eg.decay = arguments[1] === undefined ? eg.decay : arguments[1];
                            eg.sustain = arguments[2] === undefined ? eg.sustain : arguments[2];
                            eg.release = arguments[3] === undefined ? eg.release : arguments[3]
                        }
                        return this
                    };
                    SamplePlayer.prototype.noteOff = function(when, midiNote, velocity, value) {
                        var note = this.getNote(midiNote, velocity, "noteOn");
                        for (var i = 0; i < this._playingVoices.length; i++) {
                            if (!midiNote || midiNote.toString() === this._playingVoices[i].source._name) {
                                if (when > this._pedalOnTime && this._pedalOnTime > 0) {
                                    if (this._sustained.length > this._maxNotes) {
                                        this._sustained[0].source.stop(when + this._gainEG.release * this._stopFactor);
                                        this._sustained.splice(0, 1)
                                    }
                                    this._sustained.push(this._playingVoices[i]);
                                    this._playingVoices.splice(i, 1)
                                } else {
                                    if (when < Klang.Util.now()) {
                                        when = Klang.Util.now()
                                    }
                                    if (this._useEnvelope) {
                                        var val = this._playingVoices[i].source.output.gain.value;
                                        this._playingVoices[i].source.output.gain.cancelScheduledValues(when);
                                        if (when != Klang.Util.now() || Klang.detector.browser["name"] == "Firefox") {
                                            this._playingVoices[i].source.output.gain.setValueAtTime(this._gainEG.sustain, when)
                                        } else {
                                            this._playingVoices[i].source.output.gain.setValueAtTime(val, when)
                                        }
                                        this._playingVoices[i].source.stop(when + this._gainEG.release * this._stopFactor);
                                        this._playingVoices[i].source.output.gain.setTargetAtTime(0, when, this._gainEG.release)
                                    } else {
                                        this._playingVoices[i].source.fadeOutAndStop(this._gainEG.release, when)
                                    }
                                    if (this._hasNoteOffSamples) {
                                        var t = Klang.Util.now() - this._playingVoices[i].time;
                                        var v = Math.min(Math.exp(-t) / 3, 1);
                                        this.noteOn(when, midiNote, this._playingVoices[i].transpose, this._playingVoices[i].velocity, value, v)
                                    }
                                    this._playingVoices.splice(i, 1)
                                }
                            }
                        }
                    };
                    SamplePlayer.prototype.stop = function(when) {
                        var when = when || Klang.Util.now();
                        this.pedalRelease(when);
                        for (var i = 0; i < this._playingVoices.length; i++) {
                            if (when < Klang.Util.now()) {
                                when = Klang.Util.now()
                            }
                            var val = this._playingVoices[i].source.output.gain.value;
                            this._playingVoices[i].source.output.gain.cancelScheduledValues(when);
                            this._playingVoices[i].source.output.gain.setValueAtTime(val, when);
                            this._playingVoices[i].source.stop(when + this._gainEG.release * this._stopFactor);
                            this._playingVoices[i].source.output.gain.setTargetAtTime(0, when, this._gainEG.release)
                        }
                        this._playingVoices = [];
                        this._arpVoices = [];
                        return this
                    };
                    SamplePlayer.prototype.deschedule = function() {
                        for (var i = 0; i < this._allVoices.length; i++) {
                            this._allVoices[i].source.deschedule()
                        }
                        return this
                    };
                    SamplePlayer.prototype.pedalRelease = function(when) {
                        for (var i = 0; i < this._sustained.length; i++) {
                            if (when < Klang.Util.now()) {
                                when = Klang.Util.now()
                            }
                            if (Klang.detector.browser["name"] == "Firefox") {
                                this._sustained[i].source.output.gain.linearRampToValueAtTime(0, when + .3);
                                this._sustained[i].source.stop(when + this._gainEG.release * this._stopFactor);
                                continue
                            }
                            this._sustained[i].source.output.gain.setTargetAtTime(0, when, this._gainEG.release);
                            if (this._hasNoteOffSamples) {
                                var t = Klang.Util.now() - this._sustained[i].time;
                                var v = Math.min(Math.exp(-t) / 3, 1);
                                this.noteOn(when, this._sustained[i].note, this._sustained[i].transpose, this._sustained[i].velocity, "noteOff", v)
                            }
                        }
                        this._sustained = []
                    };
                    SamplePlayer.prototype.getNote = function(note, velocity, value) {
                        var i = 0;
                        var val = this._content[i].value || "noteOn";
                        while (velocity > this._content[i].highVelocity || value !== this._content[i].value) {
                            i++
                        }
                        var velocityLayer = i;
                        var j = 0;
                        while (note < this._content[velocityLayer].samples[j].startRange || note > this._content[velocityLayer].samples[j].endRange) {
                            j++
                        }
                        return this._content[velocityLayer].samples[j]
                    };
                    Object.defineProperty(SamplePlayer.prototype, "content", {
                        get: function() {
                            return this._content
                        },
                        set: function(value) {
                            this._content = value;
                            this.init()
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SamplePlayer.prototype, "callbackFunction", {
                        set: function(func) {
                            this._callback = func
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SamplePlayer.prototype.setData = function(data) {
                        _super.prototype.setData.call(this, data);
                        if (data.eg_gain) {
                            this._gainEG = data.eg_gain
                        }
                        if (data.content) {
                            this._content = data.content;
                            this.init()
                        }
                        if (data.volumeCurve) {
                            this._volumeCurve = data.volumeCurve
                        }
                    };
                    return SamplePlayer
                }(Klang.Model.Synth);
                return Klang.Model.SamplePlayer = SamplePlayer
            });
            Module(function(Klang) {
                (function(SyncType) {
                    SyncType._map = [];
                    SyncType._map[0] = "Restart";
                    SyncType.Restart = 0;
                    SyncType._map[1] = "Playing";
                    SyncType.Playing = 1;
                    SyncType._map[2] = "All";
                    SyncType.All = 2;
                    SyncType._map[3] = "Continue";
                    SyncType.Continue = 3
                })(Klang.Model.SyncType || (Klang.Model.SyncType = {}))
            });
            Module(function(Klang) {
                var SyncType = Klang.Model.SyncType;
                var Sequencer = function(_super) {
                    Klang.Util.__extends(Sequencer, _super);

                    function Sequencer(data, name) {
                        _super.call(this);
                        this._scheduler = null;
                        this._started = false;
                        this._bpm = 120;
                        this._barLength = 4;
                        this._beatLength = 1;
                        this._resolution = .25;
                        this._currentStep = 0;
                        this._paused = false;
                        this._maxSwing = .08;
                        this._swingFactor = 0;
                        this._lastBeat = -1;
                        this._name = name;
                        this._type = data.type;
                        this._bpm = data.bpm || 120;
                        this._barLength = data.bar_length || 4;
                        this._beatLength = data.beat_length || 1;
                        this._registeredPatterns = [];
                        this._registeredSynths = [];
                        this._syncHandler = new Klang.core.SyncHandler;
                        this._syncedObjects = [];
                        this._swingFactor = data.swing_factor || 0;
                        Klang.core.Core.instance.pushToPreLoadInitStack(this)
                    }
                    Sequencer.prototype.init = function() {
                        this._lookahead = Klang.core.Core.settings.sequencer_lookahead || 50;
                        this._scheduleAheadTime = Klang.core.Core.settings.sequencer_schedule_ahead || .2;
                        if (Klang.isIOS) {
                            this._scheduleAheadTime = Klang.core.Core.settings.sequencer_schedule_ahead_ios || 5
                        }
                        this._resolution = Klang.core.Core.settings.sequencer_resolution || .25
                    };
                    Sequencer.prototype.startScheduler = function() {
                        if (!this._paused && Klang.context.currentTime !== 0) {
                            this._lastScheduleLoopTime = Klang.context.currentTime;
                            while (this._scheduleTime < Klang.context.currentTime + this._scheduleAheadTime) {
                                for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                                    this._registeredPatterns[ix].update(this._currentStep, this._scheduleTime)
                                }
                                for (var jx = 0, len = this._registeredSynths.length; jx < len; jx++) {
                                    this._registeredSynths[jx].update(this._currentStep, this._scheduleTime)
                                }
                                var currentStep = this.currentStep;
                                var currentBeat = Math.floor(currentStep);
                                if (currentBeat !== this._lastBeat) {
                                    this.trigger("beforeNextBeat", currentBeat, this.getBeatTime(0) - this._scheduleTime, this._scheduleTime)
                                }
                                this._lastBeat = currentBeat;
                                this.trigger("progress", this._currentStep, this.getBeatTime(0) - this._scheduleTime, this._scheduleTime);
                                this._currentStep += this._resolution;
                                this._syncHandler.update(this._resolution);
                                if (this._swingFactor > 0) {
                                    if (this._currentStep * 4 % 2) {
                                        this._scheduleTime += (.25 + this._maxSwing * this._swingFactor) * (60 / this._bpm)
                                    } else {
                                        this._scheduleTime += (.25 - this._maxSwing * this._swingFactor) * (60 / this._bpm)
                                    }
                                } else {
                                    this._scheduleTime += 60 / this._bpm * this._resolution
                                }
                            }
                        }
                        var _this = this;
                        this._scheduler = setTimeout(function() {
                            _this.startScheduler()
                        }, _this._lookahead)
                    };
                    Sequencer.prototype.start = function() {
                        if (!this._started) {
                            this._started = true;
                            this._scheduleTime = Klang.context.currentTime;
                            if (this._scheduleAheadTime <= .2) {
                                this._scheduleTime += .3
                            }
                            clearTimeout(this._scheduler);
                            this.startScheduler();
                            if (Klang.core.Core.callbacks && Klang.core.Core.callbacks.startSequencer) {
                                Klang.core.Core.callbacks.startSequencer({
                                    name: this._name
                                })
                            }
                            this.trigger("start")
                        }
                        return this
                    };
                    Sequencer.prototype.pause = function() {
                        this._paused = true;
                        this._pauseOffset = this._scheduleTime - Klang.Util.now();
                        for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                            this._registeredPatterns[ix].pause()
                        }
                        this.trigger("pause");
                        return this
                    };
                    Sequencer.prototype.unpause = function() {
                        this._paused = false;
                        this._scheduleTime = Klang.Util.now() + this._pauseOffset;
                        for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                            this._registeredPatterns[ix].unpause()
                        }
                        return this
                    };
                    Sequencer.prototype.reschedule = function() {
                        clearTimeout(this._scheduler);
                        var scheduled = this._scheduleTime - Klang.context.currentTime;
                        var resolutionTime = this.getNoteTime(this._resolution);
                        var scheduleOffset = scheduled > this._scheduleAheadTime ? scheduled - this._scheduleAheadTime : scheduled - (this._scheduleAheadTime - resolutionTime);
                        var realScheduledSteps = (scheduled - scheduled % resolutionTime) / resolutionTime / (this._beatLength / this._resolution);
                        var scheduledSteps = this._scheduleAheadTime / resolutionTime / (this._beatLength / this._resolution);
                        this._scheduleTime = Klang.context.currentTime + scheduleOffset;
                        if (realScheduledSteps < scheduledSteps) {
                            this._scheduleTime -= resolutionTime
                        }
                        this._currentStep -= scheduledSteps;
                        if (isNaN(this._currentStep) || this._currentStep < 0) {
                            this._currentStep = 0
                        }
                        for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                            this._registeredPatterns[ix].deschedule(scheduledSteps)
                        }
                        this.startScheduler();
                        return this
                    };
                    Sequencer.prototype.stop = function() {
                        this._started = false;
                        clearTimeout(this._scheduler);
                        this._scheduler = null;
                        this._started = false;
                        if (Klang.core.Core.callbacks && Klang.core.Core.callbacks.stopSequencer) {
                            Klang.core.Core.callbacks.stopSequencer({
                                name: this._name
                            })
                        }
                        return this
                    };
                    Sequencer.prototype.stopAll = function(params) {
                        var exceptions = [];
                        for (var _i = 0; _i < arguments.length - 1; _i++) {
                            exceptions[_i] = arguments[_i + 1]
                        }
                        var beat = params.beat !== undefined ? params.beat : 4;
                        var fadeTime = params.fadeTime === undefined ? 0 : params.fadeTime;
                        var forceFade = params.forceFade || false;
                        var wait = params.wait || 0;
                        for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                            if (exceptions.indexOf(this._registeredPatterns[ix]) == -1) {
                                this._registeredPatterns[ix].forceFade = forceFade;
                                this._registeredPatterns[ix].stop(beat, true, fadeTime, wait)
                            }
                        }
                        return this
                    };
                    Sequencer.prototype.restart = function() {
                        this._currentStep = 0;
                        return this
                    };
                    Sequencer.prototype.registerPattern = function(pattern) {
                        this._registeredPatterns.push(pattern);
                        return this
                    };
                    Sequencer.prototype.unregisterPattern = function(pattern) {
                        var index = this._registeredPatterns.indexOf(pattern);
                        this._registeredPatterns.splice(index, 1);
                        return this
                    };
                    Sequencer.prototype.registerSynth = function(synth) {
                        if (this._registeredSynths.indexOf(synth) == -1) {
                            this._registeredSynths.push(synth)
                        }
                        return this
                    };
                    Sequencer.prototype.unregisterSynth = function(synth) {
                        var index = this._registeredPatterns.indexOf(synth);
                        this._registeredSynths.splice(index, 1);
                        return this
                    };
                    Sequencer.prototype.sync = function(process, beatModifier, args) {
                        return this.syncInSteps(process, this.getStepsToNext(this.beatLength * beatModifier), args)
                    };
                    Sequencer.prototype.syncInSteps = function(process, steps, args) {
                        if (!this._started) {
                            this.start()
                        }
                        var scheduleTime = this.getNoteTime(steps) + this._scheduleTime;
                        if (!args) {
                            args = [scheduleTime]
                        } else if (args.length) {
                            args.push(scheduleTime)
                        }
                        this._syncHandler.addSyncCountdown(new SyncCountdown(steps, process, args));
                        return this
                    };
                    Sequencer.prototype.quantizeDuration = function(duration, beat) {
                        var bpm = this.bpm;
                        var spb = 60 / bpm;
                        var bps = bpm / 60;
                        var beatLen = Math.floor(duration / spb);
                        return beatLen * bps
                    };
                    Sequencer.prototype.syncCallback = function(cb, beatQuant, offset, minOffset) {
                        minOffset = minOffset || 0;
                        offset = offset || 0;
                        beatQuant = beatQuant || 1;
                        var _this = this;
                        var handler = function(scheduleBeat, _, scheduleTime) {
                            var beatMod = scheduleBeat % beatQuant;
                            if (beatMod === offset && minOffset <= 0) {
                                _this.off("beforeNextBeat", handler);
                                cb(scheduleBeat, scheduleTime)
                            }
                            minOffset--
                        };
                        this._syncCallbackContext = this._syncCallbackContext || {
                            ctx: this
                        };
                        this.on("beforeNextBeat", handler, this._syncCallbackContext)
                    };
                    Sequencer.prototype.cancelCallbacks = function() {
                        if (this._syncCallbackContext) {
                            this.off("beforeNextBeat", null, this._syncCallbackContext)
                        }
                    };
                    Sequencer.prototype.syncPattern = function(params) {
                        var patterns = [];
                        for (var _i = 0; _i < arguments.length - 1; _i++) {
                            patterns[_i] = arguments[_i + 1]
                        }
                        var beat = params.beat || 0;
                        var fadeIn = params.fadeIn || false;
                        var duration = params.duration || 1;
                        var absolute = params.absolute === undefined ? false : params.absolute;
                        var syncType = params.syncType !== undefined ? params.syncType : 3;
                        var offset = params.offset;
                        var wait = params.wait || 0;
                        var steps;
                        var first;
                        if (!this._started) {
                            this._currentStep = 0;
                            this.start();
                            steps = beat = 0;
                            first = true
                        }
                        var syncStep;
                        var restart = false;
                        if (syncType === SyncType.Restart) {
                            syncStep = 0;
                            restart = true
                        } else if (syncType === SyncType.Playing) {
                            var longest = 0;
                            var longestId = -1;
                            for (var ix = 0, len = patterns.length; ix < len; ix++) {
                                if (patterns[ix].state === 1) {
                                    if (patterns[ix].length > longest) {
                                        longest = patterns[ix].length;
                                        longestId = ix
                                    }
                                }
                            }
                            var nextBar = 0;
                            if (longestId > -1) {
                                nextBar = patterns[longestId].getNextBar(beat)
                            }
                            syncStep = nextBar * beat;
                            if (nextBar > 0 && wait > 0) {
                                syncStep += wait
                            }
                        } else if (syncType === SyncType.All) {
                            var longest = 0;
                            var longestId = -1;
                            for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                                if (this._registeredPatterns[ix].state === 1 || this._registeredPatterns[ix].state === 2) {
                                    if (this._registeredPatterns[ix].length > longest) {
                                        longest = this._registeredPatterns[ix].length;
                                        longestId = ix
                                    }
                                }
                            }
                            var nextStep = 0;
                            if (longestId > -1) {
                                nextStep = this._currentStep + this.getStepsToNext(beat)
                            }
                            syncStep = nextStep
                        } else if (syncType === SyncType.Continue) {
                            syncStep = 0;
                            restart = first ? true : false
                        }
                        if (absolute != false) {
                            if (typeof absolute == "number") {
                                steps = this.getStepsToNext(this.beatLength * absolute) + this.beatLength * beat
                            } else {
                                steps = this.beatLength * beat
                            }
                        } else {
                            if (beat > 0) {
                                steps = this.getStepsToNext(this.beatLength * beat)
                            } else if (beat == 0) {
                                steps = 0
                            }
                        }
                        if (wait > 0) {
                            steps += wait
                        }
                        for (var ix = 0, len = patterns.length; ix < len; ix++) {
                            if (offset !== undefined) {
                                offset = this.getNoteTime(offset)
                            }
                            patterns[ix].prePlaySchedule(steps, syncStep, restart, fadeIn, duration, offset)
                        }
                        if (first) {
                            var scheduled = this._scheduleTime - Klang.context.currentTime;
                            var resolutionTime = this.getNoteTime(this._resolution);
                            var scheduleOffset = scheduled > this._scheduleAheadTime ? scheduled - this._scheduleAheadTime : scheduled - (this._scheduleAheadTime - resolutionTime);
                            this._scheduleTime = Klang.context.currentTime + scheduleOffset;
                            if (restart) {
                                this._currentStep = patterns[0]._currentStep - this._resolution
                            } else {
                                this._currentStep = patterns[0]._currentStep
                            }
                            first = false
                        } else if (this._scheduleAheadTime > .5) {
                            this.reschedule()
                        }
                        return this
                    };
                    Sequencer.prototype.registerBPMSync = function(obj) {
                        if (this._syncedObjects.indexOf(obj) == -1) {
                            this._syncedObjects.push(obj)
                        }
                        return this
                    };
                    Sequencer.prototype.unregisterBPMSync = function(obj) {
                        var index = this._syncedObjects.indexOf(obj);
                        if (index != -1) {
                            this._syncedObjects.splice(index, 1)
                        }
                        return this
                    };
                    Sequencer.prototype.getStepsToNext = function(x) {
                        if (x == 0) {
                            return 0
                        }
                        return x - this._currentStep % x
                    };
                    Sequencer.prototype.getNoteTime = function(note) {
                        if (note === undefined) {
                            note = 1
                        }
                        return 60 / this._bpm * note
                    };
                    Sequencer.prototype.getBeatTime = function(x) {
                        return this.getNoteTime(this.getStepsToNext(x)) + this._scheduleTime
                    };
                    Object.defineProperty(Sequencer.prototype, "started", {
                        get: function() {
                            return this._started
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "paused", {
                        get: function() {
                            return this._paused
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "bpm", {
                        get: function() {
                            return this._bpm
                        },
                        set: function(value) {
                            this._bpm = value;
                            for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                                if (this._registeredPatterns[ix]._type == "MidiPattern") {
                                    this._registeredPatterns[ix].recalculateBPM(this._bpm)
                                }
                            }
                            for (var ix = 0, len = this._syncedObjects.length; ix < len; ix++) {
                                this._syncedObjects[ix].updateSync(this._bpm)
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "scale", {
                        set: function(scale) {
                            for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                                if (this._registeredPatterns[ix]._type == "MidiPattern") {
                                    this._registeredPatterns[ix].scale = scale
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "customScale", {
                        set: function(obj) {
                            for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                                if (this._registeredPatterns[ix]._type == "MidiPattern") {
                                    this._registeredPatterns[ix].customScale = obj
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "transpose", {
                        set: function(transpose) {
                            for (var ix = 0, len = this._registeredPatterns.length; ix < len; ix++) {
                                if (this._registeredPatterns[ix]._type == "MidiPattern") {
                                    if (transpose === 0) {
                                        this._registeredPatterns[ix].resetTranspose()
                                    } else {
                                        this._registeredPatterns[ix].transpose += transpose
                                    }
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "resolution", {
                        get: function() {
                            return this._resolution
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "barLength", {
                        get: function() {
                            return this._barLength
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "beatLength", {
                        get: function() {
                            return this._beatLength
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "currentStep", {
                        get: function() {
                            return this._currentStep
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Sequencer.prototype, "swingFactor", {
                        set: function(val) {
                            this._swingFactor = val
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Sequencer.prototype.setData = function(data) {
                        this._bpm = data.bpm || 120;
                        this._barLength = data.measure_length || 4;
                        this._beatLength = data.beat_length || 1;
                        this._swingFactor = data.swing_factor || 0
                    };
                    return Sequencer
                }(Klang.core.EventEmitter);
                return Klang.Model.Sequencer = Sequencer
            });
            Module(function(Klang) {
                var Process = function() {
                    function Process(data) {
                        this._vars = data.vars;
                        Klang.core.Core.instance.pushToPreLoadInitStack(this)
                    }
                    Process.prototype.init = function() {
                        for (var ix = 0, len = this._vars.length; ix < len; ix++) {
                            var n = this._vars[ix];
                            this._destination = this._actionData[n] = Klang.core.Core.instance.findInstance(n)
                        }
                        this._vars = null
                    };
                    Process.prototype.start = function(args) {
                        Klang.warn("Process: Invocation of abstract method")
                    };
                    Process.prototype.destination = function() {
                        return this._destination
                    };
                    Process.prototype.execute = function(action, args, noCache) {
                        if (typeof action === "function") {
                            action(Klang.core.Core, Klang.Model, Klang.Util, this._actionData, args, Klang.Util.vars)
                        } else {
                            if (!this._func || noCache) {
                                this._func = new Function("Core", "Model", "Util", "me", "args", "vars", action)
                            }
                            return this._func(Klang.core.Core, Klang.Model, Klang.Util, this._actionData, args, Klang.Util.vars)
                        }
                    };
                    return Process
                }();
                return Klang.core.Process = Process
            });
            Module(function(Klang) {
                var SimpleProcess = function(_super) {
                    Klang.Util.__extends(SimpleProcess, _super);

                    function SimpleProcess(data, name) {
                        _super.call(this, data);
                        this._name = name;
                        this.data = data;
                        this._type = data.type;
                        this._action = data.action;
                        this._actionData = {}
                    }
                    SimpleProcess.prototype.start = function(args) {
                        this.execute(this._action, args)
                    };
                    SimpleProcess.prototype.setData = function(data) {
                        this._action = data.action;
                        this._vars = data.vars;
                        this.init();
                        this._func = new Function("Core", "Model", "Util", "me", "args", "vars", this._action)
                    };
                    return SimpleProcess
                }(Klang.core.Process);
                Klang.Model.SimpleProcess = SimpleProcess;
                var AdvancedProcess = function(_super) {
                    Klang.Util.__extends(AdvancedProcess, _super);

                    function AdvancedProcess(data, name) {
                        _super.call(this, data);
                        this._nextStartTime = 0;
                        this._waitOffset = 0;
                        this.SCHEDULE_AHEAD_TIME = .2;
                        this._lastTime = 0;
                        this._name = name;
                        this._type = data.type;
                        this._preAction = data.pre_action || null;
                        this._actions = data.actions;
                        this._currentAction = 0;
                        this._started = false;
                        this._loop = data.loop !== undefined ? data.loop : false;
                        this._loopTime = data.loopTime || -1;
                        this._actionData = {
                            process: this
                        };
                        if (this._loop) {
                            var waitFound = false;
                            for (var ix = 0, len = this._actions.length; ix < len; ix++) {
                                if (this._actions[ix].operation == "wait") {
                                    waitFound = true;
                                    break
                                }
                            }
                            if (!waitFound) {
                                Klang.warn("Process: Infinite loop found in process '" + this._name + "'")
                            }
                        }
                    }
                    AdvancedProcess.prototype.start = function(args) {
                        if (Klang.isIOS) {
                            return
                        }
                        this._args = args;
                        this._currentAction = 0;
                        this._execTime = 0;
                        this._startTime = Klang.context.currentTime;
                        this._nextStartTime = this._startTime;
                        if (this._preAction) {
                            if (this._preAction.operation == "exec") {
                                this.execute(this._preAction.script, this._args)
                            } else if (this._preAction.operation == "wait") {
                                this._execTime = this.execute(this._preAction.script, this._args);
                                this._waitOffset += this._execTime;
                                if (this._execTime >= this.SCHEDULE_AHEAD_TIME) {
                                    Klang.core.TimeHandler.instance.registerMethodCallback(this, "cont", this._execTime - this.SCHEDULE_AHEAD_TIME / 2)
                                } else {
                                    this.cont()
                                }
                                return
                            }
                        }
                        this._started = true;
                        this.cont()
                    };
                    AdvancedProcess.prototype.cont = function() {
                        this._actionData["execTime"] = this._nextStartTime + this._waitOffset;
                        for (var len = this._actions.length; this._currentAction < len; this._currentAction++) {
                            if (!this._started) {
                                return
                            }
                            var action = this._actions[this._currentAction];
                            if (action.operation == "exec") {
                                this.execute(action.script, this._args, true);
                                this._execTime = 0
                            } else if (action.operation == "wait") {
                                this._execTime = this.execute(action.script, this._args, true);
                                this._waitOffset += this._execTime;
                                if (this._execTime >= this.SCHEDULE_AHEAD_TIME) {
                                    Klang.core.TimeHandler.instance.registerMethodCallback(this, "cont", this._execTime - this.SCHEDULE_AHEAD_TIME / 2)
                                } else {
                                    if (this._waitOffset > this.SCHEDULE_AHEAD_TIME) {
                                        this.scheduleLoop(this._waitOffset)
                                    } else {
                                        this._currentAction++;
                                        this.cont()
                                    }
                                }
                                this._currentAction++;
                                return
                            }
                        }
                        if (this._loop) {
                            if (this._loopTime > 0) {
                                this.scheduleLoop(this._loopTime)
                            } else {
                                this._waitOffset = 0;
                                this._currentAction = 0;
                                this.cont()
                            }
                        }
                    };
                    AdvancedProcess.prototype.scheduleLoop = function(loopTime) {
                        if (!this._started) {
                            return
                        }
                        this._nextStartTime += loopTime;
                        var timeTilNext = this._nextStartTime - Klang.context.currentTime;
                        var _this = this;
                        var loopTimeoutId = setTimeout(function() {
                            _this._waitOffset = 0;
                            _this._currentAction = 0;
                            _this.cont()
                        }, (timeTilNext - this.SCHEDULE_AHEAD_TIME / 2) * 1e3)
                    };
                    AdvancedProcess.prototype.stop = function() {
                        this._started = false;
                        Klang.core.TimeHandler.instance.removeMethodCallback(this, "cont")
                    };
                    Object.defineProperty(AdvancedProcess.prototype, "started", {
                        get: function() {
                            return this._started
                        },
                        enumerable: true,
                        configurable: true
                    });
                    AdvancedProcess.prototype.setData = function(data) {
                        this._actions = data.actions;
                        this._vars = data.vars;
                        this.init()
                    };
                    return AdvancedProcess
                }(Klang.core.Process);
                return Klang.Model.AdvancedProcess = AdvancedProcess
            });
            Module(function(Klang) {
                Klang.engines.webAudio.Util.createAudioContext = function(desiredSampleRate) {
                    var AudioCtor = window.AudioContext || window.webkitAudioContext;
                    desiredSampleRate = typeof desiredSampleRate === "number" ? desiredSampleRate : 44100;
                    var context = new AudioCtor;
                    if (/(iPhone|iPad)/i.test(navigator.userAgent) && context.sampleRate !== desiredSampleRate) {
                        var buffer = context.createBuffer(1, 1, desiredSampleRate);
                        var dummy = context.createBufferSource();
                        dummy.buffer = buffer;
                        dummy.connect(context.destination);
                        dummy.start(0);
                        dummy.disconnect();
                        context.close();
                        context = new AudioCtor
                    }
                    return context
                }
            });
            Module(function(Klang) {});
            Module(function(Klang) {
                function touchLoad(e) {
                    Klang.audioTagHandler.loadSoundFiles()
                }
                var ATAudioFile = function() {
                    function ATAudioFile(url, fileData) {
                        this._url = url;
                        this.data = fileData;
                        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
                        this._waitForReadyState = this._waitForReadyState.bind(this);
                        this.state = ATAudioFile.STATE_NOT_LOADED
                    }
                    ATAudioFile.STATE_NOT_LOADED = 0;
                    ATAudioFile.STATE_LOADING = 1;
                    ATAudioFile.STATE_LOADED = 2;
                    ATAudioFile.prototype._onCanPlayThrough = function() {
                        this.audioElement.removeEventListener("canplaythrough", this._onCanPlayThrough, false);
                        this._waitForReadyState(function() {
                            this.ready = true;
                            this.state = this.state = ATAudioFile.STATE_LOADED;
                            this._readyCallback && this._readyCallback();
                            this.audioElement.pause()
                        }.bind(this))
                    };
                    ATAudioFile.prototype._waitForReadyState = function(cb) {
                        var _this = this;
                        (function wait() {
                            if (_this.audioElement.readyState) {
                                cb && cb()
                            } else {
                                setTimeout(wait, 100)
                            }
                        })()
                    };
                    ATAudioFile.prototype.load = function(onDone) {
                        if (this.state === ATAudioFile.STATE_NOT_LOADED) {
                            this.state = ATAudioFile.STATE_LOADING;
                            var el = this.audioElement = new Audio;
                            el.src = this._url;
                            el.addEventListener("canplaythrough", this._onCanPlayThrough, false);
                            el.volume = 0;
                            el.play()
                        }
                        this._readyCallback = onDone
                    };
                    ATAudioFile.prototype.clone = function() {
                        var clone = new ATAudioFile(this._url, this.data);
                        clone.state = this.state;
                        clone.audioElement = new Audio;
                        clone.ready = !!this.ready;
                        clone.audioElement.src = this._url;
                        clone.audioElement.volume = 0;
                        clone.audioElement.play();
                        return clone
                    };
                    return ATAudioFile
                }();
                Klang.ATAudioFile = ATAudioFile;
                var ATAudioSource = function() {
                    function ATAudioSource(data, file) {
                        this._xLoopTimer = 0;
                        this.state = ATAudioSource.STATE_STOPPED;
                        this._data = data;
                        this._currentFile = file;
                        this._retrig = data.retrig === undefined ? true : data.retrig;
                        this._loopStart = data.loop_start || 0;
                        this._loopEnd = data.loop_end || 0;
                        this._destination_name = data.destination_name;
                        if (!this._currentFile) {
                            return
                        }
                        this._priority = this._currentFile.data.audio_tag;
                        this._loop = !!this._data.loop;
                        this._gain = new ATGainNode(data.volume, this);
                        if (this._loop) {
                            this._files = [this._currentFile, this._currentFile.clone()]
                        }
                        this.beforeEnding = this.beforeEnding.bind(this)
                    }
                    ATAudioSource.STATE_PLAYING = 3;
                    ATAudioSource.STATE_STOPPING = 3;
                    ATAudioSource.STATE_STOPPED = 4;
                    ATAudioSource.prototype.beforeEnding = function() {
                        if (this._playing && this._loop) {
                            var otherFile = this._currentFile;
                            this._currentFile = otherFile === this._files[0] ? this._files[1] : this._files[0];
                            this._currentFile.currentTime = this._loopStart;
                            this._currentFile.audioElement.currentTime = this._loopStart;
                            otherFile.audioElement.pause();
                            this.update();
                            this._currentFile.audioElement.play();
                            clearTimeout(this._xLoopTimer);
                            this._xLoopTimer = setTimeout(this.beforeEnding, (this._currentFile.audioElement.duration - this._loopStart - (this._loopEnd ? this._currentFile.audioElement.duration - this._loopEnd : 0)) * 1e3)
                        }
                    };
                    ATAudioSource.prototype.play = function(when, offset, resume, keepVolume, loopTrigg) {
                        when = when || 0;
                        if (!this._currentFile.ready) {
                            return this
                        }
                        if (this._playing && !this._retrig && this.state !== ATAudioSource.STATE_STOPPING) {
                            return this
                        }
                        if (when > 0) {
                            var _this = this;
                            this._playTimeout = setTimeout(function() {
                                _this.doPlay(offset, resume, keepVolume, loopTrigg)
                            }, when * 1e3)
                        } else {
                            this.doPlay(offset, resume, keepVolume, loopTrigg)
                        }
                    };
                    ATAudioSource.prototype.doPlay = function(offset, resume, keepVolume, loopTrigg) {
                        offset = offset || 0;
                        if (this.state == ATAudioSource.STATE_STOPPING && !this._retrig) {
                            this.getOutput().fadeVolume(this.getOutput().getVolume(), .5);
                            this.state = ATAudioSource.STATE_PLAYING;
                            return
                        } else {
                            this.update()
                        }
                        this._currentFile.audioElement.currentTime = offset;
                        this._currentFile.audioElement.play();
                        this._playing = true;
                        if (this._loop) {
                            clearTimeout(this._xLoopTimer);
                            this._xLoopTimer = setTimeout(this.beforeEnding, (this._currentFile.audioElement.duration - offset - this._loopStart - (this._loopEnd ? this._currentFile.audioElement.duration - this._loopEnd : 0)) * 1e3)
                        }
                        this.state = ATAudioSource.STATE_PLAYING;
                        return this
                    };
                    ATAudioSource.prototype.fadeInAndPlay = function(targetValue, duration, when, offset) {
                        when = when || 0;
                        if (when > 0) {
                            var _this = this;
                            this._playTimeout = setTimeout(function() {
                                _this.doFadeInAndPlay(_this.getOutput().getVolume(), duration)
                            }, when * 1e3)
                        } else {
                            this.doFadeInAndPlay(this.getOutput().getVolume(), duration)
                        }
                        return this
                    };
                    ATAudioSource.prototype.doFadeInAndPlay = function(targetValue, duration) {
                        this._gain.setVolume(this.state == ATAudioSource.STATE_PLAYING ? this._gain.getVolume() : 0);
                        this.play(0, 0, false, true);
                        this._gain.fadeVolume(targetValue, duration);
                        return this
                    };
                    ATAudioSource.prototype.stop = function(when) {
                        if (this._playTimeout) {
                            clearTimeout(this._playTimeout)
                        }
                        this.state = ATAudioSource.STATE_STOPPED;
                        this._currentFile.audioElement.pause();
                        this._playing = false;
                        clearTimeout(this._xLoopTimer);
                        return this
                    };
                    ATAudioSource.prototype.fadeOutAndStop = function(duration, when) {
                        if (this.state != ATAudioSource.STATE_PLAYING) {
                            return
                        }
                        if (this._playTimeout) {
                            clearTimeout(this._playTimeout)
                        }
                        var _this = this;
                        this._gain.fadeVolume(0, duration, function() {
                            if (_this.state == ATAudioSource.STATE_STOPPING) {
                                _this.stop()
                            }
                        });
                        this.state = ATAudioSource.STATE_STOPPING;
                        return this
                    };
                    ATAudioSource.prototype.setVolume = function(value) {
                        value = value === undefined ? this.getOutput().getVolume() : value * this.getOutput().getVolume();
                        value = Math.max(0, Math.min(1, value * Klang.audioTagHandler.getGlobalVolume() * Klang.audioTagHandler.getFocusBlurVolume()));
                        if (this._currentFile.audioElement && isFinite(value)) {
                            this._currentFile.audioElement.volume = value
                        }
                        return this
                    };
                    ATAudioSource.prototype.update = function() {
                        this.setVolume(this._destination.calcVolume())
                    };
                    ATAudioSource.prototype.connect = function(bus) {
                        this._destination = bus;
                        bus.addConnected(this);
                        this.update()
                    };
                    ATAudioSource.prototype.getOutput = function() {
                        return this._gain
                    };
                    Object.defineProperty(ATAudioSource.prototype, "position", {
                        get: function() {
                            return this.playing ? this._currentFile.audioElement.currentTime : 0
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(ATAudioSource.prototype, "playing", {
                        get: function() {
                            return this._playing
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return ATAudioSource
                }();
                Klang.ATAudioSource = ATAudioSource;
                var ATAudioGroup = function() {
                    function ATAudioGroup(data, audioTagHandler) {
                        this._data = data;
                        this._content = [];
                        for (var c in this._data.content) {
                            var audio = audioTagHandler.getObject(this._data.content[c]);
                            if (audio) {
                                this._content.push(audio)
                            }
                        }
                    }
                    ATAudioGroup.prototype.play = function(when, audioSource, forcePlay) {
                        var index = typeof audioSource === "number" ? audioSource : Klang.Util.random(this._content.length - 1, 0);
                        if (this._content[index]) {
                            this._content[index].play(when)
                        }
                        return this
                    };
                    ATAudioGroup.prototype.stop = function() {
                        for (var c in this._content) {
                            if (this._content[c]) {
                                this._content[c].stop()
                            }
                        }
                        return this
                    };
                    Object.defineProperty(ATAudioGroup.prototype, "playing", {
                        get: function() {
                            var playing = false;
                            for (var c in this._content) {
                                if (this._content[c]._playing) {
                                    playing = true
                                }
                            }
                            return playing
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ATAudioGroup.prototype.update = function() {};
                    ATAudioGroup.prototype.connect = function(bus) {};
                    return ATAudioGroup
                }();
                Klang.ATAudioGroup = ATAudioGroup;
                var ATGainNode = function() {
                    function ATGainNode(volume, owner) {
                        this._currentVolume = this._volume = volume !== undefined ? volume : 1;
                        this._currentVolume = Math.max(0, Math.min(this._currentVolume, 1));
                        this._owner = owner
                    }
                    ATGainNode.prototype.getVolume = function() {
                        return this._volume
                    };
                    ATGainNode.prototype.setVolume = function(value) {
                        value = Math.max(0, Math.min(1, value));
                        this._currentVolume = value;
                        if (this._owner && this._owner.setVolume) {
                            this._owner.setVolume(this._currentVolume)
                        }
                        return this
                    };
                    ATGainNode.prototype.fadeVolume = function(targetValue, duration, callback) {
                        if (this._fadeTimer) {
                            clearInterval(this._fadeTimer)
                        }
                        var _this = this;
                        this._fadeSteps = Math.round(duration * 1e3) / 10;
                        this._volumeStep = (this._currentVolume - targetValue) / this._fadeSteps;
                        this._fadeTimer = setInterval(function() {
                            _this.setVolume(_this._currentVolume - _this._volumeStep);
                            _this._fadeSteps--;
                            if (_this._fadeSteps <= 0) {
                                clearInterval(_this._fadeTimer);
                                if (callback) {
                                    callback()
                                }
                            }
                        }, 10);
                        return this
                    };
                    ATGainNode.prototype.resetVolume = function(keepVolume) {
                        var volumeToSet = keepVolume ? this._currentVolume : this._volume;
                        clearInterval(this._fadeTimer);
                        this.setVolume(volumeToSet);
                        return this
                    };
                    return ATGainNode
                }();
                Klang.ATGainNode = ATGainNode;
                var ATBus = function() {
                    function ATBus(data, name, isMaster) {
                        this._isMaster = false;
                        this._connected = [];
                        this._isMaster = isMaster;
                        this._data = data;
                        this._name = name;
                        this._output = new ATGainNode(data.output_vol !== undefined ? data.output_vol : 1, this);
                        this._volume = data.output_vol !== undefined ? data.output_vol : 1;
                        this._destination_name = data.destination_name
                    }
                    ATBus.prototype.getVolume = function() {
                        if (!this._isMaster) {
                            return this._volume
                        } else {
                            return this._volume
                        }
                    };
                    ATBus.prototype.calcVolume = function(vol) {
                        if (typeof vol === "undefined") {
                            vol = 1
                        }
                        vol *= this._volume;
                        if (this._destination) {
                            return this._destination.calcVolume(vol)
                        }
                        return vol
                    };
                    ATBus.prototype.setVolume = function(volume) {
                        this._volume = volume;
                        for (var i = 0; i < this._connected.length; i++) {
                            this._connected[i].update()
                        }
                    };
                    ATBus.prototype.update = function() {
                        for (var i = 0; i < this._connected.length; i++) {
                            this._connected[i].update()
                        }
                    };
                    ATBus.prototype.getOutput = function() {
                        return this._output
                    };
                    ATBus.prototype.addConnected = function(c) {
                        this._connected.push(c)
                    };
                    ATBus.prototype.connect = function(bus) {
                        this._destination = bus;
                        bus.addConnected(this)
                    };
                    return ATBus
                }();
                Klang.ATBus = ATBus;
                var ATProcess = function() {
                    function ATProcess(data, name, vars) {
                        this._data = data;
                        this._name = name;
                        this._vars = vars;
                        if (this._data.at_action === "copy") {
                            this._data.at_action = this._data.action
                        }
                    }
                    ATProcess.prototype.start = function(args) {
                        try {
                            if (typeof this._data.at_action === "function") {
                                this._data.at_action(Klang.Util, this._vars, args)
                            } else {
                                new Function("Util", "me", "args", this._data.at_action)(Klang.Util, this._vars, args)
                            }
                        } catch (ex) {
                            Klang.err("Klang: error in process '" + this._name + "': " + ex.name + ": " + ex.message)
                        }
                    };
                    return ATProcess
                }();
                Klang.ATProcess = ATProcess;

                function AudioTagHandler(config, readyCallback, progressCallback, configURL) {
                    this._loadedFiles = 0;
                    Klang.audioTagHandler = this;
                    this._audioFiles = {};
                    this._limitSounds = Klang.isMobile || Klang.detector.browser["name"] == "Opera";
                    if (typeof config == "string") {
                        var _this = this;
                        Klang.network.request({
                            url: config
                        }, function(data) {
                            try {
                                _this.init(JSON.parse(data), readyCallback, progressCallback, configURL)
                            } catch (ex) {
                                Klang.engineVersion = "n/a";
                                if (readyCallback) {
                                    readyCallback(false)
                                }
                            }
                        }, null, function(error) {
                            Klang.err(error)
                        })
                    } else if (typeof config == "object") {
                        this.init(config, readyCallback, progressCallback, configURL)
                    } else {
                        Klang.err("Klang exception: unrecognized config type: " + typeof config)
                    }
                }
                AudioTagHandler.prototype.init = function(data, readyCallback, progressCallback, configURL) {
                    var _this = this;
                    this._globalVolume = 1;
                    this._focusBlurVolume = 1;
                    this._readyCallback = readyCallback;
                    this._progressCallback = progressCallback;
                    this._events = data.events;
                    var relativePath = parseInt(data.settings.relative_path);
                    var baseURL;
                    var filePath = data.settings.file_path || "";
                    if (relativePath) {
                        if (configURL.lastIndexOf("/") != -1) {
                            baseURL = configURL.substring(0, configURL.lastIndexOf("/"));
                            if (baseURL.charAt(baseURL.length - 1) !== "/") {
                                baseURL += "/"
                            }
                            baseURL += filePath
                        } else {
                            baseURL = filePath
                        }
                    } else {
                        baseURL = filePath
                    }
                    var format = ".mp3";
                    if (Klang.detector.browser["name"] == "Firefox" || Klang.detector.browser["name"] == "Chrome") {
                        format = ".ogg"
                    }
                    for (var p in data.files) {
                        var fileData = data.files[p];
                        var prio = fileData.audio_tag;
                        if (prio && (!this._limitSounds || prio == 1)) {
                            this._audioFiles[fileData.id] = new ATAudioFile(baseURL + fileData.url + format, fileData)
                        }
                    }
                    this._masterBus = data.masterBus;
                    this._busses = {};
                    for (var b in data.busses) {
                        this._busses[b] = new ATBus(data.busses[b], b, b == this._masterBus)
                    }
                    this._audio = {};
                    for (var a in data.audio) {
                        if (data.audio.hasOwnProperty(a)) {
                            var audioData = data.audio[a];
                            if (audioData.type == "AudioSource") {
                                if (this._audioFiles[audioData.file_id]) {
                                    var sprite = this._audioFiles[audioData.file_id];
                                    this._audio[a] = new ATAudioSource(audioData, this._audioFiles[audioData.file_id])
                                }
                            } else if (audioData.type == "AudioGroup") {
                                this._audio[a] = new ATAudioGroup(audioData, this)
                            }
                        }
                    }
                    for (var bus in this._busses) {
                        if (bus != this._masterBus) {
                            this._busses[bus].connect(this._busses[this._busses[bus]._destination_name])
                        }
                    }
                    for (var as in this._audio) {
                        if (this._audio[as]._data.type == "AudioSource") {
                            this._audio[as].connect(this._busses[this._audio[as]._destination_name])
                        }
                    }
                    this._processes = {};
                    for (var p in data.processes) {
                        var processData = data.processes[p];
                        if (processData.at_action) {
                            var processArgs = {};
                            for (var v in processData.vars) {
                                var processVarName = processData.vars[v];
                                processArgs[processVarName] = this._audio[processVarName] || this._busses[processVarName]
                            }
                            this._processes[p] = new ATProcess(processData, p, processArgs)
                        }
                    }
                    this.loadSoundFiles(["auto", "autotag"], readyCallback, progressCallback);
                    if (data.settings.blur_fade_time != -1) {
                        this._blurFadeOut = true;
                        var fadeTime = data.settings.blur_fade_time || .5;
                        var _this = this;
                        var visProp = this.getHiddenProp();
                        if (visProp) {
                            var evtname = "visibilitychange";
                            document.addEventListener(evtname, this.visChange.bind(this))
                        }
                    }
                };
                AudioTagHandler.prototype.visChange = function() {
                    if (this.isHidden()) {
                        if (this._blurFadeOut) {
                            this.setFocusBlurVolume(0)
                        }
                    } else {
                        this.setFocusBlurVolume(1)
                    }
                };
                AudioTagHandler.prototype.fadeBusVolume = function(bus, value, duration) {
                    var b = this._busses[bus._name];
                    b.getOutput().fadeVolume(value, duration)
                };
                AudioTagHandler.prototype.isHidden = function() {
                    var prop = this.getHiddenProp();
                    if (!prop) {
                        return false
                    }
                    return document[prop]
                };
                AudioTagHandler.prototype.getHiddenProp = function() {
                    var prefixes = ["webkit", "moz", "ms", "o"];
                    if ("hidden" in document) {
                        return "hidden"
                    }
                    for (var i = 0; i < prefixes.length; i++) {
                        if (prefixes[i] + "Hidden" in document) {
                            return prefixes[i] + "Hidden"
                        }
                    }
                    return null
                };
                AudioTagHandler.prototype.initIOS = function() {
                    if (Klang.isIOS || Klang.isMobile) {
                        for (var p in this._audioFiles) {
                            this._audioFiles[p].load()
                        }
                    }
                };
                AudioTagHandler.prototype.loadSoundFiles = function(group, readyCallback, progressCallback, loadFailedCallback) {
                    if (readyCallback) {
                        this._readyCallback = readyCallback
                    }
                    if (progressCallback) {
                        this._progressCallback = progressCallback
                    }
                    if (typeof group === "string") {
                        group = [group]
                    }
                    this._loadedFiles = 0;
                    this._numFiles = 0;
                    var _this = this;
                    for (var p in this._audioFiles) {
                        if (this._audioFiles.hasOwnProperty(p)) {
                            var audioFile = this._audioFiles[p];
                            var loadGroup = audioFile.data.load_group;
                            if (group === undefined || group.indexOf(loadGroup) != -1) {
                                if (audioFile.state === ATAudioFile.STATE_NOT_LOADED) {
                                    this._numFiles++;
                                    audioFile.load(function() {
                                        _this.loadProgress()
                                    })
                                }
                            }
                        }
                    }
                    if (this._numFiles == 0 && this._readyCallback) {
                        this._readyCallback(true)
                    }
                };
                AudioTagHandler.prototype.getLoadGroups = function() {
                    var i;
                    var fileInfoArr = this._audioFiles || [];
                    var groupTable = {};
                    var listOfGroups = [];
                    for (i in fileInfoArr) {
                        var fileInfo = fileInfoArr[i];
                        groupTable[fileInfo.data.load_group] = fileInfo.data.load_group
                    }
                    for (i in groupTable) {
                        listOfGroups.push(i)
                    }
                    return listOfGroups
                };
                AudioTagHandler.prototype.loadProgress = function() {
                    this._loadedFiles++;
                    if (this._progressCallback) {
                        this._progressCallback(this._loadedFiles / this._numFiles * 100)
                    }
                    if (this._readyCallback && this._loadedFiles == this._numFiles) {
                        var _this = this;
                        setTimeout(function() {
                            _this._readyCallback(true)
                        }, 200)
                    }
                };
                AudioTagHandler.prototype.triggerEvent = function(name, args) {
                    var str = "";
                    for (var i = 0; i < args.length; i++) {
                        str += args[i] + ", "
                    }
                    if (name != "sound_position") {
                        var arg = "";
                        if (args) {
                            arg = args[0]
                        }
                    }
                    if (!this._events) {
                        return
                    }
                    try {
                        var eventTarget = this._events[name];
                        if (typeof eventTarget == "string") {
                            var process = this._processes[eventTarget];
                            if (process) {
                                process.start(args)
                            }
                        } else if (eventTarget) {
                            for (var ix = 0, len = eventTarget.length; ix < len; ix++) {
                                var processName = eventTarget[ix];
                                var process = this._processes[processName];
                                if (process) {
                                    process.start(args)
                                }
                            }
                        }
                    } catch (ex) {
                        Klang.err("Klang: error when triggering event '" + name + "': " + ex.name + ": " + ex.message)
                    }
                };
                AudioTagHandler.prototype.getFocusBlurVolume = function() {
                    return this._focusBlurVolume
                };
                AudioTagHandler.prototype.setFocusBlurVolume = function(value) {
                    value = Math.max(0, Math.min(value, 1));
                    this._focusBlurVolume = value;
                    for (var a in this._audio) {
                        var audio = this._audio[a];
                        if (audio && audio.setVolume && audio.getOutput()) {
                            var audioOut = audio.getOutput();
                            if (audioOut) {
                                audio.setVolume(audioOut.getVolume())
                            }
                        }
                    }
                };
                AudioTagHandler.prototype.getGlobalVolume = function() {
                    return this._globalVolume
                };
                AudioTagHandler.prototype.setGlobalVolume = function(value) {
                    value = Math.max(0, Math.min(value, 1));
                    this._globalVolume = value;
                    for (var a in this._audio) {
                        var audio = this._audio[a];
                        if (audio && audio.setVolume && audio.getOutput) {
                            var audioOut = audio.getOutput();
                            if (audioOut) {
                                audio.setVolume(audioOut.getVolume())
                            }
                        }
                    }
                };
                AudioTagHandler.prototype.fadeGlobalVolume = function(value, duration) {
                    value = Math.max(0, Math.min(value, 1));
                    if (this._globalFadeTimer) {
                        clearInterval(this._globalFadeTimer)
                    }
                    var _this = this;
                    var fadeSteps = Math.round(duration * 1e3) / 10;
                    var volumeStep = (this._globalVolume - value) / fadeSteps;
                    this._globalFadeTimer = setInterval(function() {
                        _this._globalVolume = _this._globalVolume - volumeStep;
                        fadeSteps--;
                        for (var a in _this._audio) {
                            var audio = _this._audio[a];
                            if (audio && audio.setVolume && audio.getOutput) {
                                audio.setVolume()
                            }
                        }
                        if (fadeSteps <= 0) {
                            clearInterval(_this._globalFadeTimer)
                        }
                    }, 10)
                };
                AudioTagHandler.prototype.getLimitSounds = function() {
                    return this._limitSounds
                };
                AudioTagHandler.prototype.stopAll = function(priority) {
                    for (var a in this._audio) {
                        if (priority === undefined || this._audio[a]._priority == priority) {
                            this._audio[a].stop()
                        }
                    }
                    this.stopPeriodic();
                    return this
                };
                AudioTagHandler.prototype.getObject = function(name) {
                    return this._audioFiles[name] || this._audio[name]
                };
                AudioTagHandler.prototype.playPeriodic = function(obj, maxSec, minSec) {
                    clearTimeout(this._periodicTimer);
                    var _this = this;
                    this._periodicTimer = setTimeout(function() {
                        obj.play();
                        _this.playPeriodic(obj, maxSec, minSec)
                    }, Klang.Util.random(maxSec * 1e3, minSec * 1e3))
                };
                AudioTagHandler.prototype.stopPeriodic = function() {
                    clearTimeout(this._periodicTimer)
                };
                return Klang.AudioTagHandler = AudioTagHandler
            });
            Module(function(Klang) {
                var StreamingAudioSource = function() {
                    Klang.Util.__extends(StreamingAudioSource, Klang.Model.Audio);

                    function StreamingAudioSource(data, name) {
                        Klang.Model.Audio.call(this, data, name);
                        this._startTime = 0;
                        this._loopStartTime = 0;
                        this._scheduleAhead = .2;
                        this._stopping = false;
                        this._fading = false;
                        this._paused = false;
                        this._pauseTime = -1;
                        this._connected = false;
                        this._durationTimeout = 0;
                        this._pauseStartTime = -1;
                        this.data = data;
                        this.editorName = data.editorName;
                        this._fileId = data.file_id;
                        this._playbackRate = data.playback_rate || 1;
                        this._endTime = 0;
                        this._loop = data.loop !== undefined ? data.loop : false;
                        this._loopStart = data.loop_start;
                        this._loopEnd = data.loop_end;
                        this._offset = data.offset || 0;
                        this._duration = data.duration || 0;
                        this._reverse = data.reverse;
                        this._retrig = data.retrig !== undefined ? data.retrig : true;
                        this._lockPlaybackrate = data.lock_playback_rate !== undefined ? data.lock_playback_rate : false;
                        this._volumeStartRange = data.volume_start_range;
                        this._volumeEndRange = data.volume_end_range;
                        if (data.panner) {
                            this._panner = data.panner
                        }
                        if (!Klang.core.Core.instance.pushToPostLoadInitStack(this)) {
                            this.init()
                        }
                        Klang.core.internalEventBus.on("INIT_IOS", this.initIOS.bind(this))
                    }
                    StreamingAudioSource.prototype.init = function() {
                        var self = this;
                        var url;
                        this._audioElement = new Audio;
                        this._mediaElementSource = Klang.context.createMediaElementSource(this._audioElement);
                        this._mediaElementSource.connect(this._output);
                        this._audioElement.crossOrigin = "anonymous";
                        if (this._fileId) {
                            if (typeof this._fileId === "string") {
                                var info = Klang.core.FileHandler.instance.getFileInfo(this._fileId);
                                url = (info.external ? "" : Klang.core.FileHandler.instance._baseURL) + info.url
                            }
                        } else {
                            url = this.data.url
                        }
                        var format = ".mp3";
                        if (Klang.detector.browser["name"] === "Firefox" || Klang.detector.browser["name"] === "Chrome") {
                            format = ".ogg"
                        }
                        this._audioElement.src = url + format;
                        if (!this._duration) {
                            this._audioElement.addEventListener("loadedmetadata", function onMetaData(_event) {
                                self._duration = self._audioElement.duration;
                                self._audioElement.removeEventListener("loadedmetadata", onMetaData, false)
                            }, false)
                        }
                    };
                    StreamingAudioSource.prototype.setLoopRegion = function(loopStart, loopEnd) {
                        this._loopStart = loopStart || this._loopStart;
                        this._loopEnd = loopEnd || this._loopEnd;
                        this._audioElement.loopStart = this._loopStart;
                        this._audioElement.loopEnd = this._loopEnd;
                        return this
                    };
                    StreamingAudioSource.prototype.connect = function(destination, forceConnect) {
                        if (!this._destination || forceConnect) {
                            this._destination = destination;
                            if (this._panner) {
                                this._output.connect(this._panner.input);
                                this._panner.output.connect(destination)
                            } else {
                                this._output.connect(destination)
                            }
                        }
                        return this
                    };
                    StreamingAudioSource.prototype.disconnect = function() {
                        this._output.disconnect();
                        this._destination = null;
                        if (this._panner) {
                            this._panner.output.disconnect()
                        }
                        return this
                    };
                    StreamingAudioSource.prototype.play = function(when, offset, duration, resume) {
                        var now = Klang.context.currentTime;
                        clearTimeout(this._stopTimeout);
                        Klang.log("StreamingAudioSource.play. Playing: " + this._playing);
                        if (this._playing) {
                            this.stop(when)
                        }
                        when = when || 0;
                        offset = offset || 0;
                        resume = !false;
                        this.removeUnusedSources();
                        if (!duration) {
                            if (this._loop) {
                                duration = 9999999999
                            } else {
                                duration = this._duration
                            }
                        }
                        if (!this._audioElement) {
                            this.init()
                        }
                        if (when !== 0 && when + .01 <= now) {
                            Klang.warn("StreamingAudioSource: Returned, playTime < currentTime", this._name);
                            return this
                        } else if (when == 0) {
                            when = now
                        }
                        this.output.gain.cancelScheduledValues(when);
                        this.output.gain.setValueAtTime(this._volume, when);
                        if (!this.paused) {
                            this._pauseStartTime = when
                        }
                        if (!resume) {
                            this._pauseTime = 0
                        }
                        this._startTime = when;
                        this._loopStartTime = when + this.duration;
                        this._paused = false;
                        if (this._stopping && !this._retrig) {
                            this.output.gain.cancelScheduledValues(when);
                            this.output.gain.setValueAtTime(this.output.gain.value, when);
                            this.output.gain.linearRampToValueAtTime(this._volume, when + .25);
                            clearTimeout(this._stoppingId);
                            this._stopping = false;
                            return
                        }
                        this._fading = false;
                        if (!this._retrig && !this.loop) {
                            if (when < this._endTime) {
                                return
                            }
                        } else if (this.loop && this._retrig && this.playing && !this._stopping) {
                            return
                        } else if (this._stopping) {
                            this._stopping = false
                        } else if (Math.round(this._endTime * 1e3) / 1e3 == Math.round((when + this._duration) * 1e3) / 1e3) {
                            Klang.warn("StreamingAudioSource: Returned, Doubletrig", this._name);
                            return this
                        }
                        this._endTime = this.loop ? -1 : when + this._duration;
                        if (this._loop) {
                            this._audioElement.loop = true;
                            this._audioElement.loopStart = this._loopStart ? this._loopStart : 0;
                            this._audioElement.loopEnd = this._loopEnd ? this._loopEnd : this._duration
                        }
                        if (!this._destination) {
                            Klang.warn("StreamingAudioSource: no destination node")
                        }
                        if (typeof this._destination != "object") {
                            Klang.warn("StreamingAudioSource: destination is not an object", this._name)
                        }
                        if (offset > this._duration) {
                            offset = offset % this._duration
                        }
                        this._startOffset = this._offset + offset;
                        this._playing = true;
                        Klang.log("AudioElement.play");
                        this._playTimeout = setTimeout(function() {
                            this._audioElement.play()
                        }.bind(this), Math.max(0, when - Klang.Util.now()) * 1e3);
                        return this
                    };
                    StreamingAudioSource.prototype.getNumberOfSamples = function() {
                        return this._duration * Klang.context.sampleRate
                    };
                    StreamingAudioSource.prototype.stop = function(when) {
                        if (typeof when === "undefined") {
                            when = 0
                        }
                        clearTimeout(this._playTimeout);
                        clearTimeout(this._durationTimeout);
                        if (this._stopping) {
                            this._stopping = false;
                            clearTimeout(this._stoppingId)
                        }
                        var whenDelta = when - Klang.context.currentTime;
                        if (whenDelta > 0) {
                            this._stopTimeout = setTimeout(function() {
                                this._audioElement.pause();
                                this._audioElement.currentTime = 0;
                                this._stopping = false
                            }.bind(this), whenDelta * 1e3);
                            this._stopping = true;
                            this._endTime = when
                        } else {
                            this._audioElement.pause();
                            this._audioElement.currentTime = 0;
                            this._endTime = Klang.Util.now()
                        }
                        this._playing = false;
                        return this
                    };
                    StreamingAudioSource.prototype.deschedule = function() {
                        this._audioElement.pause();
                        return this
                    };
                    StreamingAudioSource.prototype.pause = function() {
                        if (this._endTime > Klang.Util.now()) {
                            this._paused = true;
                            var pauseDelta = Klang.Util.now() - this._startTime;
                            this._pauseTime += pauseDelta;
                            this.stop()
                        }
                        return this
                    };
                    StreamingAudioSource.prototype.unpause = function() {
                        if (this.paused) {
                            var realOffset = this._offset;
                            this._offset += this._pauseTime;
                            this.play(0, 0, null, true);
                            this._offset = realOffset;
                            this._paused = false
                        }
                        return this
                    };
                    StreamingAudioSource.prototype.createMediaElementSource = function() {
                        if (!this._connected) {
                            var source = Klang.context.createMediaElementSource(this._audioElement);
                            this._source = source
                        } else {
                            var source = this._source
                        }
                        return source
                    };
                    StreamingAudioSource.prototype.initIOS = function() {
                        if (!this._audioElement) {
                            this.init()
                        }
                        this._audioElement.play();
                        this._audioElement.pause()
                    };
                    StreamingAudioSource.prototype.fadeInAndPlay = function(fadeDuration, when, offset, duration) {
                        if (typeof offset === "undefined") {
                            offset = 0
                        }
                        if (typeof duration === "undefined") {
                            duration = this._duration
                        }
                        var now = Klang.context.currentTime;
                        if (!when) {
                            when = now
                        }
                        if (this.loop && (!this._retrig && (this._endTime == -1 || when < this._endTime)) && !this._stopping) {
                            return
                        } else if (this.loop && this._retrig && this.playing && !this._stopping) {
                            return
                        }
                        this.output.gain.cancelScheduledValues(when);
                        if (this._stopping && !this._retrig) {
                            clearTimeout(this._stoppingId);
                            this.output.gain.setValueAtTime(this.output.gain.value, when)
                        } else {
                            this._fading = true;
                            this.play(when == now ? 0 : when, offset, duration);
                            this.output.gain.setValueAtTime(0, when)
                        }
                        this._stopping = false;
                        this.output.gain.linearRampToValueAtTime(this._volume, when + fadeDuration);
                        return this
                    };
                    StreamingAudioSource.prototype.fadeOutAndStop = function(duration, when) {
                        if (!this.playing) {
                            return
                        }
                        if (when === undefined) {
                            when = Klang.context.currentTime
                        }
                        if (this._stopping) {
                            clearTimeout(this._stoppingId)
                        }
                        this.output.gain.cancelScheduledValues(when);
                        this.output.gain.setValueAtTime(this.output.gain.value || this._volume, when);
                        this.output.gain.linearRampToValueAtTime(0, when + duration);
                        var _this = this;
                        this._stoppingId = setTimeout(function() {
                            if (!_this._stopping) {
                                return
                            }
                            _this._stopping = false;
                            if (_this.loop) {
                                _this._loopPlaying = false
                            }
                            _this.stop(when + duration)
                        }, (duration + (when - Klang.Util.now()) - _this._scheduleAhead) * 1e3);
                        this._stopping = true;
                        return this
                    };
                    StreamingAudioSource.prototype.removeUnusedSources = function() {};
                    StreamingAudioSource.prototype.curvePlaybackRate = function(value, duration, when) {
                        if (this._lockPlaybackrate) {
                            return
                        }
                        var startTime = when ? when : Klang.Util.now();
                        var node = this.playbackRateNode;
                        if (node) {
                            node.cancelScheduledValues(startTime);
                            node.setValueAtTime(node.value == 0 ? Klang.Util.EXP_MIN_VALUE : node.value, startTime);
                            node.exponentialRampToValueAtTime(value, startTime + duration)
                        }
                        this._playbackRate = value;
                        return this
                    };
                    Object.defineProperty(StreamingAudioSource.prototype, "lastSource", {
                        get: function() {
                            return this._audioElement
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "loop", {
                        get: function() {
                            return this._loop
                        },
                        set: function(value) {
                            this._loop = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "offset", {
                        get: function() {
                            return this._offset
                        },
                        set: function(value) {
                            if (typeof value === "string" && value.indexOf("%") !== -1) {
                                value = this._duration * parseFloat(value)
                            }
                            this._offset = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "position", {
                        get: function() {
                            if (!this.playing || !this._duration) {
                                return 0
                            }
                            var duration = this._duration;
                            if (this._loopStart || this._loopEnd) {
                                duration = (this._loopEnd || duration) - (this._loopStart || 0)
                            }
                            var timePlayed = Klang.Util.now() - this._startTime;
                            var loopTimePlayed = Klang.Util.now() + this._startOffset - this._loopStartTime;
                            if (this._startOffset + timePlayed > this._duration) {
                                return this._loopStart + loopTimePlayed % duration
                            } else {
                                return this._startOffset + timePlayed
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "duration", {
                        get: function() {
                            return this._duration
                        },
                        set: function(value) {
                            this._duration = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "paused", {
                        get: function() {
                            return this._paused
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "playbackRate", {
                        get: function() {
                            return this._playbackRate
                        },
                        set: function(value) {
                            if (this._lockPlaybackrate) {
                                return
                            }
                            var node = this.playbackRateNode;
                            if (node) {
                                node.cancelScheduledValues(Klang.Util.now())
                            }
                            this._playbackRate = value;
                            for (var ix = 0, len = this._sources.length; ix < len; ix++) {
                                this._sources[ix].playbackRate.value = this._playbackRate
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "nextPlaybackRate", {
                        set: function(value) {
                            if (this._lockPlaybackrate) {
                                return
                            }
                            this._playbackRate = value
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "playbackRateNode", {
                        get: function() {
                            var source = this.lastSource;
                            return source && source.playbackRate
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "buffer", {
                        get: function() {
                            return null
                        },
                        set: function(buffer) {
                            console.error("can't set buffer on a streaming source")
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "playing", {
                        get: function() {
                            return this._endTime == -1 || this._endTime > Klang.Util.now()
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "playbackState", {
                        get: function() {
                            var source = this.lastSource;
                            if (source) {
                                return source.playbackState
                            }
                            return 0
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "output", {
                        get: function() {
                            if (this._panner) {
                                return this._panner.output
                            } else {
                                return this._output
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StreamingAudioSource.prototype, "panner", {
                        get: function() {
                            return this._panner
                        },
                        enumerable: true,
                        configurable: true
                    });
                    StreamingAudioSource.prototype.freeBuffer = function() {};
                    StreamingAudioSource.prototype.setData = function(data) {
                        Klang.Model.Audio.prototype.setData.call(this, data);
                        var reinit = false;
                        this._volumeStartRange = data.volume_start_range;
                        this._volumeEndRange = data.volume_end_range;
                        if (data.file_id !== undefined && this._fileId != data.file_id) {
                            this._fileId = data.file_id;
                            reinit = true
                        }
                        this._playbackRate = data.playback_rate === undefined ? 1 : data.playback_rate;
                        if (this.playbackRateNode) {
                            this.playbackRateNode.value = this._playbackRate
                        }
                        this._loop = data.loop === undefined ? false : data.loop;
                        if (this.lastSource) {
                            this.lastSource.loop = this._loop
                        }
                        if (!this._loop) {
                            this._loopPlaying = false
                        }
                        this._loopStart = data.loop_start === undefined ? 0 : data.loop_start;
                        if (this.lastSource) {
                            this.lastSource.loopStart = this._loopStart
                        }
                        this._loopEnd = data.loop_end === undefined ? 0 : data.loop_end;
                        if (this.lastSource) {
                            this.lastSource.loopEnd = this._loopEnd
                        }
                        var offset = data.offset === undefined ? 0 : data.offset;
                        if (this._offset != offset) {
                            this._offset = offset;
                            reinit = true
                        }
                        var duration = data.duration === undefined ? 0 : data.duration;
                        if (this._duration != duration) {
                            this._duration = duration;
                            reinit = true
                        }
                        this._retrig = data.retrig === undefined ? true : data.retrig;
                        if (data.reverse === undefined) {
                            data.reverse = false
                        }
                        if (this._reverse != data.reverse) {
                            this._reverse = data.reverse;
                            reinit = true
                        }
                        if (this.data.xfade != data.xfade) {
                            reinit = true
                        }
                        this.data = data;
                        if (reinit) {
                            this.init()
                        }
                        if (data.panner) {
                            if (!this._panner) {
                                var d = this._destination;
                                this.disconnect();
                                this._panner = newPanner(data.panner);
                                this.connect(d)
                            } else {
                                this._panner.setData(data.panner)
                            }
                        } else if (!data.panner) {
                            if (this._panner) {
                                var d = this._destination;
                                this.disconnect();
                                this._panner = null;
                                this.connect(d)
                            }
                        }
                    };
                    return StreamingAudioSource
                }();
                return Klang.Model.StreamingAudioSource = StreamingAudioSource
            });
            Module(function(Klang) {
                window.Klang = Klang;
                return window.Klang
            });
            window.Klang = Klang;
            if (typeof define === "function" && define.amd) {
                define("Klang", function() {
                    return window.Klang
                })
            } else if (typeof module === "object") {
                module.exports = window.Klang
            }
        })(this)
    }, {}],
    344: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Markers = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _three = require("three");
        var THREE = _interopRequireWildcard(_three);
        var _events = require("events");
        var _helpers = require("./helpers");
        var _hoverglow = require("./hoverglow");

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]
                    }
                }
                newObj.default = obj;
                return newObj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var MIN_SIZE = .27;
        var VERTEX = "\nattribute float fade;\nattribute float nearCenter;\nattribute float start;\nattribute vec2 opacity;\n\nuniform float size;\nuniform float time;\n\nvarying float op;\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n  // Opacity\n  float elapsed = time - start;\n  op = opacity.x + fade * elapsed;\n  op = clamp(op, opacity.x, opacity.y);\n\n  // Hide the markers behind the earth\n  float zPos = dot(cameraPosition, cameraPosition) - mvPosition.z * mvPosition.z;\n  op *= smoothstep(0.25, 0.75, zPos);\n\n  float _size = size * nearCenter;\n\n  gl_PointSize = step(0., op) * _size * ( 300.0 / -mvPosition.z );\n  gl_Position = projectionMatrix * mvPosition;\n}\n";
        var FRAG = "\nuniform sampler2D texture;\n\nvarying float op;\n\nvoid main() {\n  vec4 c = texture2D(texture, gl_PointCoord);\n  gl_FragColor = vec4(c.xyz, c.a * op);\n}\n";
        var Markers = exports.Markers = function(_EventEmitter) {
            _inherits(Markers, _EventEmitter);

            function Markers(isMobile) {
                _classCallCheck(this, Markers);
                var _this = _possibleConstructorReturn(this, (Markers.__proto__ || Object.getPrototypeOf(Markers)).call(this));
                _this.count = 600;
                _this.points = [];
                _this.indexes = {};
                _this.ids = [];
                _this.isMobile = isMobile;
                _this.FADE_IN = _this.isMobile ? 1 / 150 : 1 / 300;
                _this.FADE_OUT = _this.isMobile ? -1 / 500 : -1 / 300;
                var texture = (new THREE.TextureLoader).load("assets/images/marker.png");
                texture.flipY = false;
                _this.uniforms = {
                    texture: {
                        value: texture
                    },
                    size: {
                        value: MIN_SIZE * _helpers.HELPERS.DPR(),
                        type: "f"
                    },
                    time: {
                        value: 0,
                        type: "f"
                    }
                };
                _this.material = new THREE.ShaderMaterial({
                    uniforms: _this.uniforms,
                    vertexShader: VERTEX,
                    fragmentShader: FRAG,
                    blending: THREE.NormalBlending,
                    depthTest: false,
                    transparent: true
                });
                _this.geometry = new THREE.BufferGeometry;
                _this.geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(_this.count * 3), 3).setDynamic(true));
                _this.geometry.addAttribute("opacity", new THREE.BufferAttribute(new Float32Array(_this.count * 2), 2).setDynamic(true));
                _this.geometry.addAttribute("fade", new THREE.BufferAttribute(new Float32Array(_this.count), 1).setDynamic(true));
                _this.geometry.addAttribute("start", new THREE.BufferAttribute(new Float32Array(_this.count), 1).setDynamic(true));
                _this.geometry.addAttribute("nearCenter", new THREE.BufferAttribute(new Float32Array(_this.count).fill(1), 1).setDynamic(true));
                _this.mesh = new THREE.Points(_this.geometry, _this.material);
                _this.raycaster = new THREE.Raycaster;
                _this.setDefaultHitArea();
                _this.hoverglow = new _hoverglow.HoverGlow;
                return _this
            }
            _createClass(Markers, [{
                key: "setDefaultHitArea",
                value: function setDefaultHitArea() {
                    this.raycaster.params.Points.threshold = .0175 * (this.isMobile ? 2 : 1)
                }
            }, {
                key: "decreaseHitArea",
                value: function decreaseHitArea() {
                    this.raycaster.params.Points.threshold = .0035 * (this.isMobile ? 2 : 1)
                }
            }, {
                key: "intersect",
                value: function intersect(arr1, arr2) {
                    return arr1.filter(function(p1) {
                        return -1 < arr2.findIndex(function(p2) {
                            return p1.pos.x == p2.pos.x && p1.pos.y == p2.pos.y && p1.pos.y == p2.pos.y
                        })
                    })
                }
            }, {
                key: "difference",
                value: function difference(arr1, arr2) {
                    return arr1.filter(function(p1) {
                        return -1 === arr2.findIndex(function(p2) {
                            return p1.pos.x == p2.pos.x && p1.pos.y == p2.pos.y && p1.pos.y == p2.pos.y
                        })
                    })
                }
            }, {
                key: "currentOpacity",
                value: function currentOpacity(index, op, fade, start, time) {
                    var cur = op[index * 2] + fade[index] * (time - start[index]);
                    return Math.min(Math.max(cur, op[index * 2]), op[index * 2 + 1])
                }
            }, {
                key: "startTime",
                value: function startTime(index, cur, op, rate, time) {
                    return time - (cur - op[index * 2]) / rate
                }
            }, {
                key: "updatePoints",
                value: function updatePoints(points) {
                    var newPoints = [];
                    var time = this.uniforms.time.value;
                    var intersect = this.intersect(this.points, points);
                    var diffOld = this.difference(this.points, points);
                    var diffNew = this.difference(points, this.points);
                    var pos = this.geometry.attributes.position.array;
                    var op = this.geometry.attributes.opacity.array;
                    var _op = new Float32Array(op.length);
                    _op.set(op);
                    var start = this.geometry.attributes.start.array;
                    var _start = new Float32Array(this.count);
                    _start.set(start);
                    var fade = this.geometry.attributes.fade.array;
                    var _fade = new Float32Array(this.count);
                    _fade.set(fade);
                    var offset = 0;
                    op.fill(0);
                    for (var i = 0; i < intersect.length; i++) {
                        var p = intersect[i];
                        var j = i + offset;
                        if (j >= this.count) continue;
                        var id = _helpers.HELPERS.pointId(p);
                        pos[j * 3] = p.pos.x;
                        pos[j * 3 + 1] = p.pos.y;
                        pos[j * 3 + 2] = p.pos.z;
                        op[j * 2] = 0;
                        op[j * 2 + 1] = 1;
                        if (_fade[p.index] <= 0) {
                            var cur_op = this.currentOpacity(p.index, _op, _fade, _start, time);
                            var start_time = this.startTime(p.index, cur_op, _op, this.FADE_IN, time);
                            fade[j] = this.FADE_IN;
                            start[j] = start_time
                        }
                        this.indexes[id] = j;
                        this.ids[j] = id;
                        p.index = j;
                        newPoints.push(p)
                    }
                    offset += intersect.length;
                    for (var _i = 0; _i < diffNew.length; _i++) {
                        var _p = diffNew[_i];
                        var _j = _i + offset;
                        if (_j >= this.count) continue;
                        var _id = _helpers.HELPERS.pointId(_p);
                        pos[_j * 3] = _p.pos.x;
                        pos[_j * 3 + 1] = _p.pos.y;
                        pos[_j * 3 + 2] = _p.pos.z;
                        op[_j * 2] = 0;
                        op[_j * 2 + 1] = 1;
                        fade[_j] = this.FADE_IN;
                        start[_j] = time;
                        this.indexes[_id] = _j;
                        this.ids[_j] = _id;
                        _p.index = _j;
                        newPoints.push(_p)
                    }
                    offset += diffNew.length;
                    for (var _i2 = 0; _i2 < diffOld.length; _i2++) {
                        var _p2 = diffOld[_i2];
                        var _j2 = _i2 + offset;
                        if (_j2 >= this.count) continue;
                        var _id2 = _helpers.HELPERS.pointId(_p2);
                        pos[_j2 * 3] = _p2.pos.x;
                        pos[_j2 * 3 + 1] = _p2.pos.y;
                        pos[_j2 * 3 + 2] = _p2.pos.z;
                        op[_j2 * 2] = 0;
                        op[_j2 * 2 + 1] = 1;
                        var _cur_op = this.currentOpacity(_p2.index, _op, _fade, _start, time);
                        if (_cur_op <= 0) {
                            offset--;
                            continue
                        } else if (_fade[_p2.index] >= 0) {
                            var _start_time = this.startTime(_p2.index, _cur_op, _op, this.FADE_OUT, time);
                            fade[_j2] = this.FADE_OUT;
                            start[_j2] = _start_time
                        }
                        this.indexes[_id2] = _j2;
                        this.ids[_j2] = _id2;
                        _p2.index = _j2;
                        newPoints.push(_p2)
                    }
                    this.geometry.attributes.position.needsUpdate = true;
                    this.geometry.attributes.opacity.needsUpdate = true;
                    this.geometry.attributes.fade.needsUpdate = true;
                    this.geometry.attributes.start.needsUpdate = true;
                    this.points = newPoints
                }
            }, {
                key: "highlight",
                value: function highlight(id) {
                    var index = this.indexes[id];
                    if (index !== undefined) {
                        this.highlighted = id;
                        this.center = [this.geometry.attributes.position.array[index * 3], this.geometry.attributes.position.array[index * 3 + 1], this.geometry.attributes.position.array[index * 3 + 2]]
                    }
                    var near = this.geometry.attributes.nearCenter.array;
                    for (var i = 0; i < near.length; i++) {
                        var d = _helpers.HELPERS.distance(this.center[0], this.center[1], this.center[2], this.geometry.attributes.position.array[i * 3], this.geometry.attributes.position.array[i * 3 + 1], this.geometry.attributes.position.array[i * 3 + 2]);
                        near[i] = 1 - Math.min(.1, d) / .1
                    }
                    this.geometry.attributes.nearCenter.needsUpdate = true
                }
            }, {
                key: "unhighlight",
                value: function unhighlight() {
                    this.highlighted = false;
                    this.geometry.attributes.nearCenter.array.fill(1);
                    this.geometry.attributes.nearCenter.needsUpdate = true
                }
            }, {
                key: "select",
                value: function select(id) {
                    var index = this.indexes[id];
                    if (index === undefined) return;
                    this.hoverglow.moveTo(this.geometry.attributes.position.array[index * 3], this.geometry.attributes.position.array[index * 3 + 1], this.geometry.attributes.position.array[index * 3 + 2]);
                    this.hoverglow.show(!!this.highlighted)
                }
            }, {
                key: "deselect",
                value: function deselect(id) {
                    this.hoverglow.hide();
                    var index = this.indexes[id];
                    if (index === undefined) return
                }
            }, {
                key: "getIdByIndex",
                value: function getIdByIndex(index) {
                    return this.ids[index]
                }
            }, {
                key: "getPointById",
                value: function getPointById(id) {
                    var index = this.indexes[id];
                    return this.points.find(function(p) {
                        return index === p.index
                    })
                }
            }, {
                key: "tick",
                value: function tick(time) {
                    this.uniforms.time.value = time
                }
            }, {
                key: "raycast",
                value: function raycast(pointer, camera) {
                    this.raycaster.setFromCamera(pointer, camera);
                    var intersects = this.raycaster.intersectObject(this.mesh);
                    var firstIndex = undefined;
                    var max_distance = camera.position.length();
                    for (var i = 0; i < intersects.length; i++) {
                        if (this.geometry.attributes.fade.array[intersects[i].index] > 0 && this.geometry.attributes.nearCenter.array[intersects[i].index] > 0 && intersects[i].distance < max_distance) {
                            firstIndex = intersects[i].index;
                            break
                        }
                    }
                    if (firstIndex !== undefined) return this.getIdByIndex(firstIndex);
                    return undefined
                }
            }]);
            return Markers
        }(_events.EventEmitter)
    }, {
        "./helpers": 341,
        "./hoverglow": 342,
        events: 326,
        three: 329
    }],
    345: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Nav = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _events = require("events");
        var _analytics = require("./analytics");
        var _audioController = require("./audioController");
        var _audioController2 = _interopRequireDefault(_audioController);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var Nav = exports.Nav = function(_EventEmitter) {
            _inherits(Nav, _EventEmitter);

            function Nav() {
                _classCallCheck(this, Nav);
                var _this = _possibleConstructorReturn(this, (Nav.__proto__ || Object.getPrototypeOf(Nav)).call(this));
                _this.$navBtn = document.querySelector("#mobile-menu-btn");
                _this.$navOverlay = document.querySelector("#mobile-nav-overlay");
                _this.$resourcesBtn = document.querySelector("#resources-btn-mobile");
                _this.$aboutBtn = document.querySelector("#about-btn-mobile");
                _this.navOpen = false;
                _this.$fbShare = document.querySelector("#fb-share");
                _this.$twitterShare = document.querySelector("#twitter-share");
                _this.$fbShareMobile = document.querySelector("#fb-share-mobile");
                _this.$twitterShareMobile = document.querySelector("#twitter-share-mobile");
                _this.$mobileCitiesBtn = document.querySelector("#cities-btn");
                _this.navClick();
                _this.btnClick();
                _this.socialClick();
                _this.citiesBtnClick();
                _this.btnMouseOverSound();
                _this.btnClickSound();
                return _this
            }
            _createClass(Nav, [{
                key: "btnMouseOverSound",
                value: function btnMouseOverSound() {
                    if (_audioController2.default.isMobile()) return;
                    var overlayButtons = document.getElementsByClassName("overlay-button");
                    for (var i = 0; i < overlayButtons.length; i++) {
                        overlayButtons[i].addEventListener("mouseenter", function() {
                            _audioController2.default.onOver()
                        })
                    }
                    document.querySelector("#about-close").addEventListener("mouseenter", function() {
                        _audioController2.default.onOver()
                    });
                    document.querySelector("#resources-btn").addEventListener("mouseenter", function() {
                        _audioController2.default.onOver()
                    });
                    document.querySelector("#about-btn").addEventListener("mouseenter", function() {
                        _audioController2.default.onOver()
                    });
                    document.querySelector("#arrow-prev").addEventListener("mouseenter", function() {
                        _audioController2.default.onOver()
                    });
                    document.querySelector("#arrow-next").addEventListener("mouseenter", function() {
                        _audioController2.default.onOver()
                    });
                    this.$fbShare.addEventListener("mouseenter", function() {
                        _audioController2.default.onOver()
                    });
                    this.$twitterShare.addEventListener("mouseenter", function() {
                        _audioController2.default.onOver()
                    })
                }
            }, {
                key: "btnClickSound",
                value: function btnClickSound() {
                    var overlayButtons = document.getElementsByClassName("overlay-button");
                    for (var i = 0; i < overlayButtons.length; i++) {
                        overlayButtons[i].addEventListener("click", function() {
                            _audioController2.default.onClick()
                        })
                    }
                    document.querySelector("#about-close").addEventListener("click", function() {
                        _audioController2.default.onClick()
                    });
                    document.querySelector("#resources-btn").addEventListener("click", function() {
                        _audioController2.default.onClick();
                        _analytics.Analytics.createEvent("click", "Sexual Assualt Resources", "clickable_link, nav, sexual_assault_resources")
                    });
                    document.querySelector("#about-btn").addEventListener("click", function() {
                        _analytics.Analytics.createEvent("click", "About", "clickable_link, nav, about");
                        _audioController2.default.onClick()
                    });
                    document.querySelector("#arrow-prev").addEventListener("click", function() {
                        _audioController2.default.onClick()
                    });
                    document.querySelector("#arrow-next").addEventListener("click", function() {
                        _audioController2.default.onClick()
                    });
                    this.$fbShare.addEventListener("click", function() {
                        _audioController2.default.onClick();
                        _analytics.Analytics.createEvent("click", "Facebook", "clickable_link, nav, facebook")
                    });
                    this.$twitterShare.addEventListener("click", function() {
                        _audioController2.default.onClick();
                        _analytics.Analytics.createEvent("click", "Twitter", "clickable_link, nav, twitter")
                    })
                }
            }, {
                key: "citiesBtnClick",
                value: function citiesBtnClick() {
                    this.$mobileCitiesBtn.addEventListener("click", function() {
                        _audioController2.default.overlayIn()
                    })
                }
            }, {
                key: "navClick",
                value: function navClick() {
                    var _this2 = this;
                    this.$navBtn.addEventListener("click", function() {
                        _this2.navOpen = !_this2.navOpen;
                        if (_this2.navOpen) {
                            _this2.$navBtn.classList.add("active");
                            _this2.$navOverlay.classList.add("active");
                            _audioController2.default.overlayIn()
                        } else {
                            _this2.$navBtn.classList.remove("active");
                            _this2.$navOverlay.classList.remove("active");
                            _audioController2.default.overlayOut()
                        }
                    })
                }
            }, {
                key: "closeMenu",
                value: function closeMenu() {
                    this.navOpen = false;
                    this.$navBtn.classList.remove("active");
                    this.$navOverlay.classList.remove("active")
                }
            }, {
                key: "btnClick",
                value: function btnClick() {
                    var _this3 = this;
                    this.$resourcesBtn.addEventListener("click", function() {
                        _this3.closeMenu()
                    });
                    this.$aboutBtn.addEventListener("click", function() {
                        _this3.closeMenu()
                    });
                    this.$navOverlay.querySelector(".mobile-menu-backdrop").addEventListener("click", function() {
                        _this3.closeMenu()
                    })
                }
            }, {
                key: "socialClick",
                value: function socialClick() {
                    var _this4 = this;
                    this.$fbShare.addEventListener("click", function() {
                        _this4.share("facebook");
                        _analytics.Analytics.createEvent("click", "Facebook", "clickable_link, nav, facebook")
                    });
                    this.$fbShareMobile.addEventListener("click", function() {
                        _this4.share("facebook");
                        _analytics.Analytics.createEvent("click", "Facebook", "clickable_link, nav, facebook")
                    });
                    this.$twitterShare.addEventListener("click", function() {
                        _this4.share("twitter");
                        _analytics.Analytics.createEvent("click", "Twitter", "clickable_link, nav, twitter")
                    });
                    this.$twitterShareMobile.addEventListener("click", function() {
                        _this4.share("twitter");
                        _analytics.Analytics.createEvent("click", "Twitter", "clickable_link, nav, twitter")
                    })
                }
            }, {
                key: "popup",
                value: function popup(url, height, width) {
                    var wLeft = window.screenLeft ? window.screenLeft : window.screenX;
                    var wTop = window.screenTop ? window.screenTop : window.screenY;
                    var left = wLeft + window.innerWidth / 2 - width / 2;
                    var top = wTop + window.innerHeight / 2 - height / 2;
                    window.open(url, "_blank", "location=yes,height=" + height + ",width=" + width + ",top=" + top + ",left=" + left + ",scrollbars=yes,status=no").focus()
                }
            }, {
                key: "reorient",
                value: function reorient() {
                    var _this5 = this;
                    this.$navOverlay.style.display = "none";
                    setTimeout(function() {
                        _this5.$navOverlay.style.display = "block"
                    }, 100)
                }
            }, {
                key: "share",
                value: function share(platform) {
                    var url = "http://www.whizjuniors.com/";
                    var text = encodeURIComponent("Participate in the Youth Multimedia Competition by UNESCO.");
                    if (platform === "twitter") {
                        var twitURL = "https://twitter.com/intent/tweet?text=" + text + "&url=" + url;
                        this.popup(twitURL, 253, 600)
                    } else if (platform === "facebook") {
                        var fbURL = "https://www.facebook.com/sharer.php?u=" + url;
                        this.popup(fbURL, 570, 520)
                    }
                }
            }]);
            return Nav
        }(_events.EventEmitter)
    }, {
        "./analytics": 331,
        "./audioController": 333,
        events: 326
    }],
    346: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Pages = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _events = require("events");
        var _analytics = require("./analytics");
        var _gsap = require("gsap");
        var _audioController = require("./audioController");
        var _audioController2 = _interopRequireDefault(_audioController);
        var _settings = require("./settings");

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var Pages = exports.Pages = function(_EventEmitter) {
            _inherits(Pages, _EventEmitter);

            function Pages() {
                _classCallCheck(this, Pages);
                var _this = _possibleConstructorReturn(this, (Pages.__proto__ || Object.getPrototypeOf(Pages)).call(this));
                _this.introComplete = false;
                _this.pageOpen = false;
                _this.firstHomeLoad = true;
                _this.deeplink = false;
                _this.$intro = document.querySelector("#intro");
                _this.$introBtn = document.querySelector("#intro-btn");
                _this.$globe = document.querySelector("#globe");
                _this.$nav = document.querySelector("#home-nav");
                _this.$mobileNav = document.querySelector("#mobile-menu-btn");
                _this.$cities = document.querySelector("#cities-wrapper");
                _this.$sliderTitle = document.querySelector("#cities-slider");
                _this.$mobileCitiesBtn = document.querySelector("#cities-btn");
                _this.$timeline = document.querySelector("#timeline");
                _this.$timelineMobile = document.querySelector("#timeline-mobile");
                _this.$timelineCanvas = document.querySelector("#timelineCanvas");
                _this.$topCity = [];
                _this.$topCity[0] = document.querySelector("[data-city-1]");
                _this.$topCity[1] = document.querySelector("[data-city-2]");
                _this.$topCity[2] = document.querySelector("[data-city-3]");
                _this.$topCity[3] = document.querySelector("[data-city-4]");
                _this.$topCity[4] = document.querySelector("[data-city-5]");
                _this.$aboutBtn = document.querySelector("#about-btn");
                _this.$aboutCloseBtn = document.querySelector("#about-close");
                _this.$resourcesBtn = document.querySelector("#resources-btn");
                _this.$resourcesCloseBtn = document.querySelector("#resources-close");
                _this.$resourcesMobileBtn = document.querySelector("#resources-btn-mobile");
                _this.$aboutMobileBtn = document.querySelector("#about-btn-mobile");
                _this.$aboutPage = document.querySelector("#about-page");
                _this.$resourcesPage = document.querySelector("#resources-page");
                _this.$aboutTitle = document.querySelector("#about-title");
                _this.$aboutBody = document.querySelector("#about-body");
                // _this.$aboutResourcesLink = document.querySelector("#about-resources-link");
                // _this.$aboutTrendsLink = document.querySelector("#about-trends-link");
                _this.$resourcesTitle = document.querySelector("#resources-title");
                _this.$resourcesBody = document.querySelector("#resources-body");
                _this.aboutPage();
                _this.resourcesPage();
                _this.currentAnimation;
                window.onpopstate = function() {
                    _this.handleState(window.location.pathname)
                };
                window.handleState = _this.handleState.bind(_this);
                setTimeout(function() {
                    _this.handleState(window.location.pathname)
                }, 1);
                return _this
            }
            _createClass(Pages, [{
                key: "handleState",
                value: function handleState(state) {
                    var _this2 = this;
                    var path = state;
                    var citySlug = void 0;
                    if (location.hash && location.hash !== "#" || location.hash !== "") {
                        var parsedHash = location.hash.split("#");
                        if (parsedHash.length > 1) {
                            citySlug = parsedHash[1];
                            path = "/location"
                        }
                    }
                    if (this.currentPath === path) {
                        return
                    }
                    this.currentPath = path;
                    _settings.Settings.globe.interactionEnabled = true;
                    switch (path) {
                        case "/resources":
                            this.deeplink = true;
                            _settings.Settings.globe.interactionEnabled = false;
                            this.showResourcesPage();
                            this.hideHome();
                            this.hideAboutPageContent();
                            break;
                        case "/about":
                            _settings.Settings.globe.interactionEnabled = false;
                            this.deeplink = true;
                            this.showAboutPage();
                            this.hideResourcesPageContent();
                            this.hideHome();
                            break;
                        case "/embed":
                            this.hideAboutPageContent();
                            this.hideResourcesPageContent();
                            this.hideHome();
                            this.showEmbedPage();
                            _settings.Settings.isEmbedMode = true;
                            break;
                        case "/test":
                            this.introComplete = true;
                            this.showHome();
                            setTimeout(function() {
                                _this2.$introBtn.click()
                            }, 1e3);
                            break;
                        case "/location":
                            this.introComplete = true;
                            this.showHome();
                            setTimeout(function() {
                                _this2.$introBtn.click();
                                _this2.emit("open-city", citySlug)
                            }, 1e3);
                            break;
                        case "/":
                        default:
                            this.hideResourcesPageContent();
                            this.hideAboutPageContent();
                            if (this.introComplete) {
                                this.showHome()
                            } else {
                                this.$intro.style.opacity = 1;
                                if (this.deeplink) {
                                    this.$intro.classList.add("deeplink-show");
                                    this.$introBtn.addEventListener("click", function() {
                                        _this2.showHome();
                                        if (_this2.firstHomeLoad) {
                                            _analytics.Analytics.createEvent("pageload", "Home", "/home", true);
                                            _this2.firstHomeLoad = false
                                        }
                                    })
                                }
                            }
                            break
                    }
                }
            }, {
                key: "go",
                value: function go(path) {
                    window.history.pushState({}, "Me Too Rising", path);
                    this.handleState(path)
                }
            }, {
                key: "animationInterrupt",
                value: function animationInterrupt(newAnimationName) {
                    _gsap.TweenMax.killAll();
                    if (this.currentAnimation) {
                        if (this.currentAnimation === "home") {
                            this.hideHome()
                        }
                    }
                    this.currentAnimation = newAnimationName
                }
            }, {
                key: "hideHome",
                value: function hideHome() {
                    this.$globe.classList.add("blur");
                    _gsap.TweenMax.to(this.$nav, .2, {
                        opacity: 0,
                        pointerEvents: "none",
                        ease: _gsap.Linear.noEase,
                        delay: 0
                    });
                    _gsap.TweenMax.to(this.$mobileNav, .2, {
                        opacity: 0,
                        pointerEvents: "none",
                        ease: _gsap.Linear.noEase,
                        delay: 0
                    });
                    _gsap.TweenMax.to(this.$cities, .2, {
                        opacity: 0,
                        y: "-45%",
                        ease: _gsap.Quint.EaseOut,
                        delay: .1
                    });
                    _gsap.TweenMax.to(this.$mobileCitiesBtn, .2, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Linear.easeNone,
                        delay: .2
                    });
                    _gsap.TweenMax.to(this.$timeline, .2, {
                        opacity: 0,
                        ease: _gsap.Linear.noEase,
                        delay: .3
                    });
                    _gsap.TweenMax.to(this.$timelineMobile, .2, {
                        opacity: 0,
                        ease: _gsap.Linear.noEase,
                        delay: .3
                    });
                    _gsap.TweenMax.to(this.$timelineCanvas, .2, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Linear.noEase,
                        delay: .4
                    });
                    this.emit("close-overlay")
                }
            }, {
                key: "showHome",
                value: function showHome() {
                    var _this3 = this;
                    this.currentAnimation = "home";
                    this.pageOpen = false;
                    this.$globe.classList.remove("blur");
                    _gsap.TweenMax.to(this.$nav, .2, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.noEase,
                        delay: 0
                    });
                    _gsap.TweenMax.to(this.$mobileNav, .2, {
                        opacity: 1,
                        pointerEvents: "auto",
                        ease: _gsap.Linear.noEase,
                        delay: 0
                    });
                    _gsap.TweenMax.to(this.$cities, .4, {
                        opacity: 1,
                        y: "-50%",
                        ease: _gsap.Quint.EaseOut,
                        delay: .1
                    });
                    _gsap.TweenMax.to(this.$mobileCitiesBtn, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Linear.easeNone,
                        delay: .2
                    });
                    _gsap.TweenMax.to(this.$timeline, .2, {
                        opacity: 1,
                        ease: _gsap.Linear.noEase,
                        delay: .3
                    });
                    _gsap.TweenMax.to(this.$timelineMobile, .2, {
                        opacity: 1,
                        ease: _gsap.Linear.noEase,
                        delay: .3
                    });
                    _gsap.TweenMax.to(this.$timelineCanvas, .2, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Linear.noEase,
                        delay: .4
                    });
                    _gsap.TweenLite.to(this.$sliderTitle, .2, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .1
                    });
                    this.$topCity.forEach(function($city) {
                        _gsap.TweenLite.to($city, .2, {
                            opacity: 1,
                            y: 0,
                            ease: _gsap.Quint.EaseOut,
                            delay: .1
                        })
                    });
                    _gsap.TweenMax.delayedCall(.6, function() {
                        _this3.currentAnimation = null
                    })
                }
            }, {
                key: "showResourcesPage",
                value: function showResourcesPage() {
                    var _this4 = this;
                    this.pageOpen = true;
                    document.querySelector("#intro").style.opacity = 0;
                    this.$resourcesPage.style.pointerEvents = "auto";
                    this.animationInterrupt("resources");
                    this.hideHome();
                    _analytics.Analytics.createEvent("pageload", "Resources", "/resources", true);
                    this.$resourcesPage.classList.add("active");
                    _gsap.TweenMax.to(this.$resourcesPage, .8, {
                        opacity: 1,
                        ease: _gsap.Quint.EaseOut,
                        delay: .1
                    });
                    _gsap.TweenMax.to(this.$resourcesCloseBtn, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .3
                    });
                    _gsap.TweenMax.to(this.$resourcesTitle, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .5
                    });
                    _gsap.TweenMax.to(this.$resourcesBody, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .7
                    });
                    _gsap.TweenMax.delayedCall(1.2, function() {
                        _this4.currentAnimation = null
                    });
                    _audioController2.default.overlayIn();
                    if (!this.externalResources) {
                        fetch("/assets/data/resources.json").then(function(response) {
                            return response.json()
                        }).then(function(json) {
                            var data = {};
                            var $parent = document.querySelector("#additional-resources");
                            json.forEach(function(item) {
                                if (!data[item.parent_title]) {
                                    data[item.parent_title] = {
                                        title: item.parent_title,
                                        items: []
                                    }
                                }
                                data[item.parent_title].items.push(item)
                            });
                            _this4.externalResources = data;
                            var template = "";
                            Object.keys(data).forEach(function(key) {
                                template += '\n            <li class="resource-item">\n              <a class="resources-parent">' + data[key].title + "</a>\n              <ul>\n              " + data[key].items.map(function(item) {
                                    return '\n                <li>\n                  <div>\n                  <a href="' + item.website + '" target="_blank">' + item.name + "</a>\n                  " + (item.phone && item.phone !== "" ? "&nbsp;â€” " + item.phone : "") + "\n                  </div>\n                  <p>" + item.description + "</p>\n                </li>\n                "
                                }).join("") + "\n              </ul>\n            </li>"
                            });
                            $parent.innerHTML = template;
                            Array.from(document.querySelectorAll(".resources-parent")).forEach(function(item) {
                                item.addEventListener("click", function() {
                                    if (item.parentElement.classList.contains("visible")) {
                                        item.parentElement.classList.remove("visible")
                                    } else {
                                        item.parentElement.classList.add("visible")
                                    }
                                })
                            })
                        })
                    }
                }
            }, {
                key: "hideResourcesPageContent",
                value: function hideResourcesPageContent() {
                    var _this5 = this;
                    this.$resourcesPage.style.pointerEvents = "none";
                    _gsap.TweenMax.to(this.$resourcesBody, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    _gsap.TweenMax.to(this.$resourcesTitle, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: .1
                    });
                    _gsap.TweenMax.to(this.$resourcesCloseBtn, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: .2
                    });
                    _gsap.TweenMax.to(this.$resourcesPage, .8, {
                        opacity: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    _gsap.TweenMax.delayedCall(.9, function() {
                        _this5.$resourcesPage.classList.remove("active")
                    });
                    _audioController2.default.overlayOut()
                }
            }, {
                key: "resourcesPage",
                value: function resourcesPage() {
                    var _this6 = this;
                    this.$resourcesBtn.addEventListener("click", function() {
                        _this6.go("/resources")
                    });
                    this.$resourcesMobileBtn.addEventListener("click", function() {
                        _gsap.TweenMax.delayedCall(.25, function() {
                            _this6.go("/resources")
                        })
                    });
                    this.$resourcesPage.addEventListener("mouseover", function(e) {
                        e.stopPropagation()
                    });
                    this.$resourcesPage.addEventListener("mouseenter", function(e) {
                        e.stopPropagation()
                    });
                    this.$resourcesPage.addEventListener("mousemove", function(e) {
                        e.stopPropagation()
                    });
                    this.$resourcesCloseBtn.addEventListener("click", function() {
                        _this6.go("/unesco");
                        _analytics.Analytics.createEvent("click", "Resources Close", "clickable_link, resources, close");
                        _gsap.TweenMax.delayedCall(.4, function() {
                            _this6.showHome()
                        })
                    })
                }
            }, {
                key: "showAboutPage",
                value: function showAboutPage() {
                    var _this7 = this;
                    this.pageOpen = true;
                    document.querySelector("#intro").style.opacity = 0;
                    this.$aboutPage.style.pointerEvents = "auto";
                    this.animationInterrupt("about");
                    this.hideHome();
                    _analytics.Analytics.createEvent("pageload", "About", "/about", true);
                    this.$aboutPage.classList.add("active");
                    _gsap.TweenMax.to(this.$aboutPage, .8, {
                        opacity: 1,
                        ease: _gsap.Quint.EaseOut,
                        delay: .1
                    });
                    _gsap.TweenMax.to(this.$aboutCloseBtn, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .3
                    });
                    _gsap.TweenMax.to(this.$aboutTitle, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .5
                    });
                    _gsap.TweenMax.to(this.$aboutBody, .4, {
                        opacity: 1,
                        y: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: .7
                    });
                    _gsap.TweenMax.delayedCall(1.2, function() {
                        _this7.currentAnimation = null
                    });
                    _audioController2.default.overlayIn();
                    // document.querySelector("#iframe-code").classList.remove("visible")
                }
            }, {
                key: "hideAboutPageContent",
                value: function hideAboutPageContent() {
                    var _this8 = this;
                    this.$aboutPage.style.pointerEvents = "none";
                    _gsap.TweenMax.to(this.$aboutBody, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    _gsap.TweenMax.to(this.$aboutTitle, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: .1
                    });
                    _gsap.TweenMax.to(this.$aboutCloseBtn, .25, {
                        opacity: 0,
                        y: 10,
                        ease: _gsap.Quint.EaseOut,
                        delay: .2
                    });
                    _gsap.TweenMax.to(this.$aboutPage, .8, {
                        opacity: 0,
                        ease: _gsap.Quint.EaseOut,
                        delay: 0
                    });
                    _gsap.TweenMax.delayedCall(.9, function() {
                        _this8.$aboutPage.classList.remove("active")
                    });
                    _audioController2.default.overlayOut()
                }
            }, {
                key: "aboutPage",
                value: function aboutPage() {
                    var _this9 = this;
                    this.$aboutBtn.addEventListener("click", function() {
                        _this9.go("/about")
                    });
                    this.$aboutMobileBtn.addEventListener("click", function() {
                        _gsap.TweenMax.delayedCall(.25, function() {
                            _this9.go("/about")
                        })
                    });
                    this.$aboutCloseBtn.addEventListener("click", function() {
                        _this9.go("/unesco");
                        _analytics.Analytics.createEvent("click", "About Close", "clickable_link, about, close")
                    });
                    // document.querySelector("#copy-embed").addEventListener("click", function() {
                    //     document.querySelector("#iframe-code textarea").select();
                    //     document.execCommand("copy")
                    // });
                    // document.querySelector("#embed-link").addEventListener("click", function() {
                    //     var $embed = document.querySelector("#iframe-code");
                    //     if ($embed.classList.contains("visible")) {
                    //         $embed.classList.remove("visible")
                    //     } else {
                    //         $embed.classList.add("visible");
                    //         document.querySelector("#iframe-code textarea").value = '<iframe width="560" height="315" src="" frameborder="0" allowfullscreen></iframe>'
                    //     }
                    // });
                    this.$aboutPage.addEventListener("mouseover", function(e) {
                        e.stopPropagation()
                    });
                    this.$aboutPage.addEventListener("mouseenter", function(e) {
                        e.stopPropagation()
                    });
                    this.$aboutPage.addEventListener("mousemove", function(e) {
                        e.stopPropagation()
                    });
                    // this.$aboutResourcesLink.addEventListener("click", function() {
                    //     _analytics.Analytics.createEvent("click", "Sexual Assualt Resources", "clickable_link, about, sexual_assault_resources");
                    //     _this9.hideAboutPageContent();
                    //     _gsap.TweenMax.delayedCall(.45, function() {
                    //         _this9.go("/resources")
                    //     })
                    // });
                    // this.$aboutTrendsLink.addEventListener("click", function() {
                    //     _analytics.Analytics.createEvent("click", "Google Trends", "clickable_link, about, sexual_assault_resources")
                    // })
                }
            }, {
                key: "hideEmbedElements",
                value: function hideEmbedElements() {
                    var removeElement = function removeElement(elementOrId) {
                        var element = void 0;
                        if (typeof elementOrId === "string") {
                            element = document.getElementById(elementOrId)
                        } else {
                            element = elementOrId
                        }
                        element.style.zIndex = -1;
                        element.style.visibility = "hidden";
                        element.style.pointerEvents = "none"
                    };
                    removeElement("cities-wrapper");
                    removeElement(this.$mobileNav);
                    removeElement(this.$mobileCitiesBtn);
                    removeElement(this.$timelineMobile)
                }
            }, {
                key: "showEmbedPage",
                value: function showEmbedPage() {
                    this.pageOpen = true;
                    this.$globe.classList.remove("blur");
                    document.querySelector("body").classList.add("embed");
                    document.querySelector("#intro").style.opacity = 1;
                    _gsap.TweenLite.to(document.querySelectorAll(".intro-subheader"), .5, {
                        opacity: 1
                    });
                    _gsap.TweenLite.to(document.querySelectorAll(".intro-btn"), .5, {
                        opacity: 1
                    });
                    this.hideEmbedElements();
                    window.dispatchEvent(new Event("resize"));
                    this.$globe.classList.remove("blur")
                }
            }, {
                key: "hideEmbedPage",
                value: function hideEmbedPage() {
                    document.querySelector("body").classList.remove("embed");
                    document.querySelector("#intro").style.opacity = 0
                }
            }, {
                key: "resize",
                value: function resize() {
                    if (this.pageOpen) {
                        this.$globe.classList.add("blur");
                        _gsap.TweenLite.to(this.$nav, 0, {
                            opacity: 0,
                            pointerEvents: "none",
                            ease: _gsap.Linear.noEase,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$mobileNav, 0, {
                            opacity: 0,
                            ease: _gsap.Linear.noEase,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$cities, 0, {
                            opacity: 0,
                            y: "-45%",
                            ease: _gsap.Quint.EaseOut,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$mobileCitiesBtn, 0, {
                            opacity: 0,
                            y: 10,
                            ease: _gsap.Linear.easeNone,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$timeline, 0, {
                            opacity: 0,
                            ease: _gsap.Linear.noEase,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$timelineMobile, 0, {
                            opacity: 0,
                            ease: _gsap.Linear.noEase,
                            delay: 0
                        });
                        _gsap.TweenLite.to(this.$timelineCanvas, 0, {
                            opacity: 0,
                            y: 10,
                            ease: _gsap.Linear.noEase,
                            delay: 0
                        })
                    }
                }
            }, {
                key: "reorient",
                value: function reorient() {
                    var _this10 = this;
                    _gsap.TweenLite.set([this.$resourcesBody, this.$aboutBody], {
                        display: "none"
                    });
                    setTimeout(function() {
                        _gsap.TweenLite.set([_this10.$resourcesBody, _this10.$aboutBody], {
                            display: "block"
                        })
                    }, 100)
                }
            }]);
            return Pages
        }(_events.EventEmitter)
    }, {
        "./analytics": 331,
        "./audioController": 333,
        "./settings": 348,
        events: 326,
        gsap: 327
    }],
    347: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.ParticleSystem = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _three = require("three");
        var THREE = _interopRequireWildcard(_three);
        var _events = require("events");
        var _helpers = require("./helpers");

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]
                    }
                }
                newObj.default = obj;
                return newObj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var VERTEX = "\n#define M_PI 3.1415926535897932384626433832795\n\nattribute vec3 vel;\nattribute vec4 curl;\nattribute float starttime;\nattribute float lifetime;\nattribute vec3 rotationMatrix1;\nattribute vec3 rotationMatrix2;\nattribute vec3 rotationMatrix3;\n\nuniform float time;\nuniform float opacity;\nuniform float size;\n\nvarying float op;\nvarying vec3 colorP;\nvarying float glow;\n\n" + _helpers.COLOR_SHADER + "\n\nvoid main() {\n  mat3 rm;\n  rm[0] = rotationMatrix1;\n  rm[1] = rotationMatrix2;\n  rm[2] = rotationMatrix3;\n\n  float timeElapsed = time - starttime;\n  float life = timeElapsed / lifetime;\n  float lifeLeft = 1.0 - life;\n  float t = timeElapsed;\n\n  // Simulate\n  vec3 newPosition = vel * life + curl.xyz * life * lifeLeft;\n  newPosition = rm * newPosition;\n  vec4 mvPosition = modelViewMatrix * vec4( newPosition + position, 1.0 );\n\n  glow = curl.w;\n\n  // Hide if particle is behind the earth\n  float zPos = dot(cameraPosition, cameraPosition) - mvPosition.z * mvPosition.z;\n  op = smoothstep(0.25, 0.75, zPos);\n  op *= smoothstep(0., 0.2, life); // Fade in at the beginning\n  op *= (1.0 - smoothstep(0.7, 1.0, life)); // Fade out at the end of life\n  op *= opacity;\n\n  // Color\n  colorP = positionBasedColor(modelMatrix * vec4( newPosition + position, 1.0 ));\n\n  gl_PointSize = step(0., timeElapsed) * op * step(0., lifeLeft) * size * ( 300.0 / -mvPosition.z );\n  gl_Position = projectionMatrix * mvPosition + vec4(0, 0, 100, 0) * step(zPos, 0.25);\n}\n";
        var FRAG = "\nuniform sampler2D texture;\n\nvarying vec3 colorP;\nvarying float op;\nvarying float glow;\n\nvoid main() {\n  // Particle Transparency Map\n  vec4 texC = texture2D( texture, gl_PointCoord );\n  gl_FragColor = vec4(colorP * op * (texC.r + texC.g * glow), 1.0);\n}\n";
        var MIN_STRENGTH = 0;
        var MAX_OPACITY = .9;
        var SIZE_RATIO = .18 / 803;

        function getParticleSize() {
            var dpi = _helpers.HELPERS.DPR();
            return Math.max(.18, window.innerHeight * SIZE_RATIO) * dpi
        }
        var ParticleSystem = exports.ParticleSystem = function(_EventEmitter) {
            _inherits(ParticleSystem, _EventEmitter);

            function ParticleSystem(pos) {
                var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9e4;
                _classCallCheck(this, ParticleSystem);
                var _this = _possibleConstructorReturn(this, (ParticleSystem.__proto__ || Object.getPrototypeOf(ParticleSystem)).call(this));
                _this.pos = pos || new THREE.Vector3;
                _this.size = size;
                _this.count = 0;
                _this.current = -1;
                _this.spawners = [];
                _this.uniforms = {
                    strength: {
                        value: MIN_STRENGTH,
                        type: "f"
                    },
                    texture: {
                        value: (new THREE.TextureLoader).load("assets/images/particle12.jpg")
                    },
                    opacity: {
                        value: MAX_OPACITY,
                        type: "f"
                    },
                    time: {
                        value: _this.time,
                        type: "f"
                    },
                    size: {
                        value: getParticleSize(),
                        type: "f"
                    }
                };
                _this.material = new THREE.ShaderMaterial({
                    uniforms: _this.uniforms,
                    vertexShader: VERTEX,
                    fragmentShader: FRAG,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                });
                _this.geometry = new THREE.BufferGeometry;
                _this.geometry.addAttribute("vel", new THREE.BufferAttribute(new Float32Array(_this.size * 3), 3).setDynamic(true));
                _this.geometry.addAttribute("curl", new THREE.BufferAttribute(new Float32Array(_this.size * 4), 4).setDynamic(true));
                _this.geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(_this.size * 3), 3).setDynamic(true));
                _this.geometry.addAttribute("rotationMatrix1", new THREE.BufferAttribute(new Float32Array(_this.size * 3), 3).setDynamic(true));
                _this.geometry.addAttribute("rotationMatrix2", new THREE.BufferAttribute(new Float32Array(_this.size * 3), 3).setDynamic(true));
                _this.geometry.addAttribute("rotationMatrix3", new THREE.BufferAttribute(new Float32Array(_this.size * 3), 3).setDynamic(true));
                _this.geometry.addAttribute("starttime", new THREE.BufferAttribute(new Float32Array(_this.size), 1).setDynamic(true));
                _this.geometry.addAttribute("lifetime", new THREE.BufferAttribute(new Float32Array(_this.size), 1).setDynamic(true));
                _this.mesh = new THREE.Points(_this.geometry, _this.material);
                _this.mesh.position.copy(_this.pos.clone());
                window.addEventListener("resize", function() {
                    _this.uniforms.size.value = getParticleSize()
                });
                return _this
            }
            _createClass(ParticleSystem, [{
                key: "clearSpawners",
                value: function clearSpawners() {
                    var quick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    this.spawners = [];
                    if (quick) {
                        this.scheduleClear = true;
                        for (var i = 0; i < this.geometry.attributes.starttime.array.length; i++) {
                            this.geometry.attributes.starttime.array[i] -= 1e3
                        }
                        this.geometry.attributes.starttime.needsUpdate = true
                    }
                }
            }, {
                key: "addSpawner",
                value: function addSpawner(id, pos, rate) {
                    var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                    var area = arguments[4];
                    var combined = arguments[5];
                    var position = new THREE.Vector3(pos.x, pos.y, pos.z);
                    var normal = position.clone().normalize();
                    var quaternion = (new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);
                    var rm = new THREE.Matrix4;
                    rm.makeRotationFromQuaternion(quaternion);
                    var rotationMatrix = new THREE.Matrix3;
                    rotationMatrix.setFromMatrix4(rm);
                    area = area || new THREE.Vector2(1, 1);
                    this.spawners.push({
                        combined: !!combined,
                        id: id,
                        rate: rate / 1e3,
                        _rate: rate / 1e3,
                        position: position,
                        rotationMatrix: rotationMatrix,
                        accumulator: 0,
                        distance: distance,
                        area: area
                    })
                }
            }, {
                key: "increaseRate",
                value: function increaseRate(id, pos, rate) {
                    id = id + "hover";
                    var spawner = this.spawners.find(function(o) {
                        return o.id === id
                    });
                    if (!spawner) {
                        this.addSpawner(id, pos, rate * 5, 0)
                    }
                }
            }, {
                key: "decreaseRate",
                value: function decreaseRate(id) {
                    id = id + "hover";
                    var spawnerIndex = this.spawners.findIndex(function(o) {
                        return o.id === id
                    });
                    if (spawnerIndex > -1) {
                        this.spawners.splice(spawnerIndex, 1)
                    }
                }
            }, {
                key: "randomSignedPow",
                value: function randomSignedPow(pow) {
                    return (Math.random() > .5 ? -1 : 1) * Math.pow(Math.random(), pow)
                }
            }, {
                key: "spawn",
                value: function spawn(spawner) {
                    this.current += 1;
                    if (this.current >= this.size) this.current = 0;
                    var i = this.current;
                    this.geometry.attributes.position.array[i * 3] = spawner.position.x + (-1 + Math.random() * 2) * .0075 * spawner.area.x;
                    this.geometry.attributes.position.array[i * 3 + 1] = spawner.position.y + (-1 + Math.random() * 2) * .0075 * spawner.area.y;
                    this.geometry.attributes.position.array[i * 3 + 2] = spawner.position.z;
                    this.geometry.attributes.rotationMatrix1.array[i * 3] = spawner.rotationMatrix.elements[0];
                    this.geometry.attributes.rotationMatrix1.array[i * 3 + 1] = spawner.rotationMatrix.elements[1];
                    this.geometry.attributes.rotationMatrix1.array[i * 3 + 2] = spawner.rotationMatrix.elements[2];
                    this.geometry.attributes.rotationMatrix2.array[i * 3] = spawner.rotationMatrix.elements[3];
                    this.geometry.attributes.rotationMatrix2.array[i * 3 + 1] = spawner.rotationMatrix.elements[4];
                    this.geometry.attributes.rotationMatrix2.array[i * 3 + 2] = spawner.rotationMatrix.elements[5];
                    this.geometry.attributes.rotationMatrix3.array[i * 3] = spawner.rotationMatrix.elements[6];
                    this.geometry.attributes.rotationMatrix3.array[i * 3 + 1] = spawner.rotationMatrix.elements[7];
                    this.geometry.attributes.rotationMatrix3.array[i * 3 + 2] = spawner.rotationMatrix.elements[8];
                    this.geometry.attributes.vel.array[i * 3] = this.randomSignedPow(8) * .03;
                    this.geometry.attributes.vel.array[i * 3 + 1] = this.randomSignedPow(8) * .03;
                    this.geometry.attributes.vel.array[i * 3 + 2] = .005 + Math.pow(Math.random(), 5) * .05;
                    this.geometry.attributes.curl.array[i * 4] = (-1 + Math.random() * 2) * .03;
                    this.geometry.attributes.curl.array[i * 4 + 1] = (-1 + Math.random() * 2) * .03;
                    this.geometry.attributes.curl.array[i * 4 + 2] = 0;
                    this.geometry.attributes.curl.array[i * 4 + 3] = spawner.distance;
                    this.geometry.attributes.starttime.array[i] = this.time + Math.random() * 250;
                    this.geometry.attributes.lifetime.array[i] = 1900
                }
            }, {
                key: "tick",
                value: function tick(time) {
                    var delta = time - this.time;
                    this.time = time;
                    this.uniforms.time.value = this.time;
                    var current = this.current;
                    for (var i = 0, n = this.spawners.length; i < n; i++) {
                        this.spawners[i].accumulator += this.spawners[i].rate * delta;
                        if (this.spawners[i].accumulator >= 1) {
                            var j = 0;
                            for (j = 0; j < this.spawners[i].accumulator; j++) {
                                this.spawn(this.spawners[i])
                            }
                            this.spawners[i].accumulator -= j
                        }
                    }
                    if (this.current != current) {
                        var count = this.current - current;
                        var positionAttr = this.geometry.attributes.position;
                        var starttimeAttr = this.geometry.attributes.starttime;
                        var lifetimeAttr = this.geometry.attributes.lifetime;
                        var normalAttr1 = this.geometry.attributes.rotationMatrix1;
                        var normalAttr2 = this.geometry.attributes.rotationMatrix2;
                        var normalAttr3 = this.geometry.attributes.rotationMatrix3;
                        var velAttr = this.geometry.attributes.vel;
                        var curlAttr = this.geometry.attributes.curl;
                        if (count > 0 && !this.scheduleClear) {
                            this.scheduleClear = false;
                            var offset = current + 1;
                            positionAttr.updateRange.offset = offset * positionAttr.itemSize;
                            starttimeAttr.updateRange.offset = offset * starttimeAttr.itemSize;
                            lifetimeAttr.updateRange.offset = offset * lifetimeAttr.itemSize;
                            normalAttr1.updateRange.offset = offset * normalAttr1.itemSize;
                            normalAttr2.updateRange.offset = offset * normalAttr2.itemSize;
                            normalAttr3.updateRange.offset = offset * normalAttr3.itemSize;
                            velAttr.updateRange.offset = offset * velAttr.itemSize;
                            curlAttr.updateRange.offset = offset * curlAttr.itemSize;
                            positionAttr.updateRange.count = count * positionAttr.itemSize;
                            starttimeAttr.updateRange.count = count * starttimeAttr.itemSize;
                            lifetimeAttr.updateRange.count = count * lifetimeAttr.itemSize;
                            normalAttr1.updateRange.count = count * normalAttr1.itemSize;
                            normalAttr2.updateRange.count = count * normalAttr2.itemSize;
                            normalAttr3.updateRange.count = count * normalAttr3.itemSize;
                            velAttr.updateRange.count = count * velAttr.itemSize;
                            curlAttr.updateRange.count = count * curlAttr.itemSize
                        } else {
                            positionAttr.updateRange.offset = 0;
                            starttimeAttr.updateRange.offset = 0;
                            lifetimeAttr.updateRange.offset = 0;
                            normalAttr1.updateRange.offset = 0;
                            normalAttr2.updateRange.offset = 0;
                            normalAttr3.updateRange.offset = 0;
                            velAttr.updateRange.offset = 0;
                            curlAttr.updateRange.offset = 0;
                            positionAttr.updateRange.count = -1;
                            starttimeAttr.updateRange.count = -1;
                            lifetimeAttr.updateRange.count = -1;
                            normalAttr1.updateRange.count = -1;
                            normalAttr2.updateRange.count = -1;
                            normalAttr3.updateRange.count = -1;
                            velAttr.updateRange.count = -1;
                            curlAttr.updateRange.count = -1
                        }
                        positionAttr.needsUpdate = true;
                        starttimeAttr.needsUpdate = true;
                        lifetimeAttr.needsUpdate = true;
                        normalAttr1.needsUpdate = true;
                        normalAttr2.needsUpdate = true;
                        normalAttr3.needsUpdate = true;
                        velAttr.needsUpdate = true;
                        curlAttr.needsUpdate = true
                    }
                }
            }]);
            return ParticleSystem
        }(_events.EventEmitter)
    }, {
        "./helpers": 341,
        events: 326,
        three: 329
    }],
    348: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var Settings = exports.Settings = {
            isEmbedMode: false,
            API_PATH: "",
            USE_DUMMY_DATA: !(window.location.hostname === "www.whizjuniors.com" || window.location.hostname === "www.whizjuniors.com" || window.location.hostname === "www.whizjuniors.com"),
            globe: {}
        }
    }, {}],
    349: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Timeline = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _events = require("events");
        var _analytics = require("./analytics");
        var _helpers = require("./helpers");
        var _settings = require("./settings");
        var _audioController = require("./audioController");
        var _audioController2 = _interopRequireDefault(_audioController);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            }
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var Timeline = exports.Timeline = function(_EventEmitter) {
            _inherits(Timeline, _EventEmitter);

            function Timeline(isMobile) {
                _classCallCheck(this, Timeline);
                var _this = _possibleConstructorReturn(this, (Timeline.__proto__ || Object.getPrototypeOf(Timeline)).call(this));
                var dpr = window.devicePixelRatio || 1;
                _this.todaysDate = _this.setTodaysDate();
                _this.ready = false;
                _this.timelineWidth = window.innerWidth;
                _this.timelineHeight = 130;
                _this.timeline = document.querySelector("#timeline");
                _this.timelineCanvas = document.querySelector("#timelineCanvas");
                _this.timelineCanvas.width = _this.timelineWidth * dpr;
                _this.timelineCanvas.height = _this.timelineHeight * dpr;
                _this.timelineCanvas.style.width = _this.timelineWidth + "px";
                _this.timelineCanvas.style.height = _this.timelineHeight + "px";
                _this.timelineCtx = _this.timelineCanvas.getContext("2d");
                _this.timelineCtx.scale(dpr, dpr);
                _this.points = [];
                _this.canDraw = true;
                _this.scrubberHeightOffset = 0;
                _this.timelineMultiplier = 0;
                _this.padL = 50;
                _this.padR = 50;
                _this.timelineReleaseTimeout;
                _this.timelineRevealT = 0;
                _this.timelineRevealX = 0;
                _this.timelineRevealSpeed = .003;
                _this.EasingFunctions = {
                    easeInOutQuad: function easeInOutQuad(t) {
                        return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t
                    }
                };
                _this.colorWhite = "#ffffff";
                _this.colorGray = "#353535";
                _this.colorPeach = "#fcdcbf";
                _this.arcX = 0;
                _this.arxY = 0;
                _this.mouseX = 0;
                _this.mouseY = 0;
                _this.isDragging = false;
                _this.markerInit = false;
                _this.maxWidth = 0;
                _this.date = "";
                _this.activePointIndex = 0;
                _this.markerPointIndex = 0;
                _this.canvasMouseEvents();
                _this.isMobile = isMobile;
                _this.mobilePerPage = window.innerWidth > 768 ? 7 : 5;
                _this.$timelineMobile = document.querySelector("#timeline-mobile");
                _this.timelineMobileItems;
                _this.timelineTouch = {
                    startTime: 0,
                    lastTime: 0,
                    endTime: 0,
                    startX: 0,
                    lastX: 0
                };
                _this.$privacyLink = document.querySelector("#timeline-privacy-link");
                _this.$trendsLink = document.querySelector("#timeline-logo-link");
                _this.$trendsLink.addEventListener("click", function() {
                    _analytics.Analytics.createEvent("click", "Google Trends", "clickable_link, nav, google_trends")
                });
                _this.$privacyLink.addEventListener("click", function() {
                    _analytics.Analytics.createEvent("click", "Privacy and Terms", "clickable_link, nav, privacy_terms")
                });
                return _this
            }
            _createClass(Timeline, [{
                key: "setTodaysDate",
                value: function setTodaysDate() {
                    var d = new Date;
                    var month = "" + (d.getMonth() + 1);
                    var day = "" + d.getDate();
                    var year = d.getFullYear();
                    if (month.length < 2) month = "0" + month;
                    if (day.length < 2) day = "0" + day;
                    return [year, month, day].join("-")
                }
            }, {
                key: "getData",
                value: function getData() {
                    var _this2 = this;
                    var path = _settings.Settings.USE_DUMMY_DATA ? "assets/timeline.json" : "/timeline";
                    return fetch(_settings.Settings.API_PATH + path, {
                        credentials: "include"
                    }).then(function(response) {
                        return response.text()
                    }).then(function(text) {
                        try {
                            if (text.startsWith(")]}',")) {
                                text = text.replace(")]}',", "");
                                var data = JSON.parse(text);
                                data.sort(function(a, b) {
                                    if (a.date < b.date) return -1;
                                    if (a.date > b.date) return 1;
                                    return 0
                                });
                                var values = [];
                                data.forEach(function(date) {
                                    _this2.points.push(date);
                                    values.push(date.value)
                                });
                                var sortedValues = values.sort(function(a, b) {
                                    return a - b
                                });
                                _this2.min = Math.log(sortedValues[0]);
                                _this2.max = Math.log(sortedValues[values.length - 1]);
                                var lastPoint = _this2.points[_this2.points.length - 1];
                                var todaysDate = _this2.todaysDate;
                                if (lastPoint.date !== todaysDate && !_this2.isMobile) {
                                    _this2.points.push({
                                        date: lastPoint.date,
                                        value: lastPoint.value,
                                        isDuplicate: true
                                    })
                                }
                                _this2.lastDate = _this2.points[_this2.points.length - 1];
                                _this2.determineMultiplier();
                                _this2.activePointIndex = _this2.points.length - 1;
                                _this2.updateSoundScape(lastPoint.value);
                                _this2.initMobile();
                                _this2.ready = true;
                                _this2.emit("date-update", _this2.lastDate, _this2.lastDate)
                            }
                        } catch (err) {}
                    })
                }
            }, {
                key: "tick",
                value: function tick() {
                    if (this.ready && this.canDraw && !this.isMobile) {
                        this.timelineRevealX = Math.ceil(this.EasingFunctions.easeInOutQuad(this.timelineRevealT) * this.maxWidth);
                        if (this.timelineRevealT < 1) {
                            this.timelineRevealT += this.timelineRevealSpeed
                        }
                        this.timelineCtx.clearRect(0, 0, this.timelineCanvas.width, this.timelineCanvas.height);
                        this.timelineCtx.save();
                        this.timelineCtx.beginPath();
                        this.timelineCtx.rect(0, 0, this.timelineRevealX, 800);
                        this.timelineCtx.clip();
                        this.drawTimeline();
                        this.timelineCtx.restore();
                        this.markerInit = false;
                        if (this.timelineRevealX < this.maxWidth) {
                            this.drawLine()
                        } else {
                            this.emit("intro-complete");
                            this.date = "TODAY";
                            this.mapMarkerToPoint(null, {
                                setMarkerPoint: true,
                                setLastDate: true
                            });
                            this.timelineRevealX = this.timelineCanvas.width;
                            this.canDraw = false;
                            if (!this.markerInit) {
                                this.markerInit = true;
                                this.initMarker()
                            }
                        }
                    }
                }
            }, {
                key: "drawTimeline",
                value: function drawTimeline() {
                    var _this3 = this;
                    var i = -1;
                    var size = this.timelineMultiplier;
                    this.timelineCtx.fillStyle = this.colorGray;
                    this.timelineCtx.beginPath();
                    this.timelineCtx.moveTo(this.padL, this.timelineHeight);
                    this.points.forEach(function(date) {
                        i++;
                        var height = _this3.determineMarkerHeight(date.value);
                        _this3.timelineCtx.lineTo(i * size + _this3.padL, height);
                        _this3.timelineCtx.fillStyle = _this3.colorGray
                    });
                    this.timelineCtx.lineTo(i * size + this.padL, this.timelineHeight);
                    this.timelineCtx.fill();
                    return i * size
                }
            }, {
                key: "drawTimelinePoints",
                value: function drawTimelinePoints() {
                    var _this4 = this;
                    var size = this.timelineMultiplier;
                    var i = -1;
                    this.points.forEach(function(date) {
                        i++;
                        var height = _this4.determineMarkerHeight(date.value);
                        _this4.timelineCtx.fillStyle = "red";
                        _this4.timelineCtx.fillRect(i * size + _this4.padL, height, 2, 2)
                    })
                }
            }, {
                key: "determineMultiplier",
                value: function determineMultiplier() {
                    this.timelineMultiplier = (this.timelineWidth - this.padL - this.padR) / (this.points.length - 1);
                    this.maxWidth = Math.ceil((this.points.length - 1) * this.timelineMultiplier + this.padL)
                }
            }, {
                key: "drawLine",
                value: function drawLine() {
                    this.arcX = this.timelineRevealX >= this.padL ? this.timelineRevealX : this.padL;
                    var mappedPoint = this.mapMarkerToPoint(this.arcX);
                    this.arcY = this.determineMarkerHeight(mappedPoint.value);
                    this.date = this.formatDate(mappedPoint ? mappedPoint.date : null);
                    this.drawMarker()
                }
            }, {
                key: "initMarker",
                value: function initMarker() {
                    this.arcX = this.maxWidth;
                    this.arcY = this.determineMarkerHeight(this.points[this.points.length - 1].value);
                    this.markerPointIndex = this.activePointIndex;
                    this.drawMarker()
                }
            }, {
                key: "determineMarkerHeight",
                value: function determineMarkerHeight(val) {
                    var spaceOnBottom = this.timelineHeight - 10;
                    var spaceOnTop = 55;
                    return _helpers.HELPERS.mapRange(Math.log(val), this.min, this.max, spaceOnBottom, spaceOnTop)
                }
            }, {
                key: "formatDate",
                value: function formatDate(item) {
                    var dateArray = item ? item.split("-") : null;
                    return dateArray ? dateArray[1] + "." + dateArray[2] + "." + dateArray[0].substring(2, 4) : "TODAY"
                }
            }, {
                key: "drawMarker",
                value: function drawMarker(removeHover) {
                    var radius = 15;
                    var width = 80;
                    var height = 25;
                    var markerR = 8;
                    var pillX = this.arcX - width / 2;
                    var pillY = 0;
                    var markerFill = this.colorPeach;
                    var circleFill = "transparent";
                    var boundLeft = pillX;
                    var boundRight = pillX + width;
                    if (this.mouseX >= boundLeft && this.mouseX <= boundRight && !!removeHover === false) {
                        markerFill = this.colorWhite;
                        circleFill = this.colorWhite
                    }
                    this.timelineCtx.fillStyle = circleFill;
                    this.timelineCtx.beginPath();
                    this.timelineCtx.arc(this.arcX, this.arcY, markerR, 0, 2 * Math.PI);
                    this.timelineCtx.strokeStyle = markerFill;
                    this.timelineCtx.lineWidth = 2;
                    this.timelineCtx.closePath();
                    this.timelineCtx.fill();
                    this.timelineCtx.stroke();
                    this.timelineCtx.beginPath();
                    this.timelineCtx.moveTo(this.arcX, this.arcY + markerR);
                    this.timelineCtx.strokeStyle = markerFill;
                    this.timelineCtx.lineWidth = 2;
                    this.timelineCtx.lineTo(this.arcX, this.timelineHeight);
                    this.timelineCtx.stroke();
                    this.timelineCtx.closePath();
                    this.drawDateBox(radius, width, height, pillX, pillY, markerFill);
                    this.drawDate()
                }
            }, {
                key: "moveMarker",
                value: function moveMarker() {
                    var _this5 = this;
                    this.timelineCtx.clearRect(0, 0, this.timelineCanvas.width, this.timelineCanvas.height);
                    this.drawTimeline();
                    var mappedPoint = this.mapMarkerToPoint(null, {
                        setMarkerPoint: true
                    });
                    this.arcX = this.mouseX > this.maxWidth ? this.maxWidth : this.mouseX < this.padL ? this.padL : this.mouseX;
                    this.arcY = this.determineMarkerHeight(mappedPoint.value);
                    this.date = this.formatDate(mappedPoint ? mappedPoint.date : null);
                    _analytics.Analytics.createEvent("clickable_link", "home", "timeline_" + this.date, true);
                    this.drawMarker();
                    this.updateSoundScape(mappedPoint.value);
                    _helpers.HELPERS.throttle(function() {
                        _this5.emit("date-update", {
                            date: mappedPoint ? mappedPoint.date : null
                        }, _this5.lastDate)
                    })()
                }
            }, {
                key: "updateSoundScape",
                value: function updateSoundScape(val) {
                    _audioController2.default.updateTimelineValue(_helpers.HELPERS.mapRange(Math.log(val), this.min, this.max, 0, 1))
                }
            }, {
                key: "mapMarkerToPoint",
                value: function mapMarkerToPoint(x, args) {
                    x = x || this.mouseX;
                    var pointIndex = parseInt((x - this.padL) / this.timelineMultiplier);
                    this.activePointIndex = pointIndex >= this.points.length ? this.points.length - 1 : pointIndex < 0 ? 0 : pointIndex;
                    if (args && args.setLastDate) {
                        this.activePointIndex = this.points.length - 1
                    }
                    if (args && args.setMarkerPoint) {
                        this.markerPointIndex = this.activePointIndex
                    }
                    return this.points[this.activePointIndex]
                }
            }, {
                key: "drawDate",
                value: function drawDate() {
                    var dateY = 17;
                    this.timelineCtx.beginPath();
                    this.timelineCtx.fillStyle = this.colorGray;
                    this.timelineCtx.font = "bold 12px Karla";
                    this.timelineCtx.textAlign = "center";
                    var dateTitle = this.date;
                    if (this.formatDate(this.todaysDate) === this.date || this.lastDate && this.lastDate.isDuplicate && this.formatDate(this.lastDate.date) === this.date) {
                        dateTitle = "TODAY"
                    }
                    this.timelineCtx.fillText(dateTitle, this.arcX, dateY);
                    this.timelineCtx.closePath()
                }
            }, {
                key: "drawDateBox",
                value: function drawDateBox(radius, width, height, xPos, yPos, markerFill) {
                    this.timelineCtx.beginPath();
                    this.timelineCtx.moveTo(xPos + radius, yPos);
                    this.timelineCtx.lineTo(xPos + width - radius, yPos);
                    this.timelineCtx.quadraticCurveTo(xPos + width, yPos, xPos + width, yPos + radius);
                    this.timelineCtx.lineTo(xPos + width, yPos + height - radius);
                    this.timelineCtx.quadraticCurveTo(xPos + width, yPos + height, xPos + width - radius, yPos + height);
                    this.timelineCtx.lineTo(xPos + radius, yPos + height);
                    this.timelineCtx.quadraticCurveTo(xPos, yPos + height, xPos, yPos + height - radius);
                    this.timelineCtx.lineTo(xPos, yPos + radius);
                    this.timelineCtx.quadraticCurveTo(xPos, yPos, xPos + radius, yPos);
                    this.timelineCtx.closePath();
                    this.timelineCtx.fillStyle = markerFill;
                    this.timelineCtx.fill();
                    var dropdownWidth = 10;
                    this.timelineCtx.beginPath();
                    this.timelineCtx.moveTo(this.arcX - dropdownWidth, yPos + height - 1);
                    this.timelineCtx.lineTo(this.arcX + dropdownWidth, yPos + height - 1);
                    this.timelineCtx.lineTo(this.arcX, yPos + height - 1 + dropdownWidth);
                    this.timelineCtx.fillStyle = markerFill;
                    this.timelineCtx.fill();
                    this.timelineCtx.closePath()
                }
            }, {
                key: "drawHoverLine",
                value: function drawHoverLine(showLine) {
                    this.timelineCtx.clearRect(0, 0, this.timelineCanvas.width, this.timelineCanvas.height);
                    this.drawTimeline();
                    this.drawMarker();
                    if (showLine) {
                        var mappedPoint = this.mapMarkerToPoint();
                        var lineXPos = this.mouseX < this.padL ? this.padL : this.mouseX > this.maxWidth ? this.maxWidth : this.mouseX;
                        var lineYPos = this.determineMarkerHeight(mappedPoint.value);
                        this.timelineCtx.beginPath();
                        this.timelineCtx.moveTo(lineXPos, lineYPos);
                        this.timelineCtx.strokeStyle = this.colorWhite;
                        this.timelineCtx.lineWidth = 1;
                        this.timelineCtx.lineTo(lineXPos, lineYPos + 140);
                        this.timelineCtx.stroke();
                        this.timelineCtx.closePath()
                    }
                }
            }, {
                key: "removeHoverLine",
                value: function removeHoverLine() {
                    this.timelineCtx.clearRect(0, 0, this.timelineCanvas.width, this.timelineCanvas.height);
                    this.drawTimeline();
                    this.drawMarker(true)
                }
            }, {
                key: "resize",
                value: function resize() {
                    var dpr = window.devicePixelRatio || 1;
                    this.timelineWidth = window.innerWidth;
                    this.timelineCanvas.width = this.timelineWidth * dpr;
                    this.timelineCanvas.height = this.timelineHeight * dpr;
                    this.timelineCanvas.style.width = this.timelineWidth + "px";
                    this.timelineCanvas.style.height = this.timelineHeight + "px";
                    this.timelineCtx.scale(dpr, dpr);
                    this.determineMultiplier();
                    this.timelineCtx.clearRect(0, 0, this.timelineCanvas.width, this.timelineCanvas.height);
                    this.drawTimeline();
                    this.arcX = this.markerPointIndex * this.timelineMultiplier + this.padL;
                    this.arcY = this.determineMarkerHeight(this.points[this.markerPointIndex].value);
                    this.drawMarker();
                    if (this.siema) {
                        this.siema.resizeHandler()
                    }
                }
            }, {
                key: "overFilledTimeline",
                value: function overFilledTimeline(y) {
                    var mappedPoint = this.mapMarkerToPoint();
                    var pointY = this.timelineHeight - this.determineMarkerHeight(mappedPoint.value);
                    return window.innerHeight - y <= pointY
                }
            }, {
                key: "mousemove",
                value: function mousemove(e) {
                    this.mouseX = e.pageX;
                    if (this.isDragging) {
                        this.moveMarker()
                    } else {
                        if (e.target === this.timelineCanvas) {
                            this.drawHoverLine(this.overFilledTimeline(e.pageY))
                        } else {
                            this.removeHoverLine()
                        }
                    }
                }
            }, {
                key: "mousedown",
                value: function mousedown(e) {
                    this.startingPoint = e.pageX;
                    this.isDragging = true;
                    document.body.classList.add("is-dragging")
                }
            }, {
                key: "mouseup",
                value: function mouseup(e) {
                    if (this.isDragging) {
                        if (this.startingPoint === e.pageX) {
                            if (this.overFilledTimeline(e.pageY)) {
                                this.moveMarker()
                            }
                        } else {
                            this.moveMarker()
                        }
                    }
                    this.isDragging = false;
                    document.body.classList.remove("is-dragging")
                }
            }, {
                key: "mouseout",
                value: function mouseout() {
                    this.removeHoverLine()
                }
            }, {
                key: "canvasMouseEvents",
                value: function canvasMouseEvents() {
                    var _this6 = this;
                    this.timelineCanvas.addEventListener("mousedown", function(e) {
                        return _this6.mousedown(e)
                    });
                    this.timelineCanvas.addEventListener("mouseout", function() {
                        return _this6.mouseout()
                    })
                }
            }, {
                key: "updateMobileSelected",
                value: function updateMobileSelected() {
                    this.timelineMobileItems.forEach(function(item) {
                        if (item && item.classList) {
                            item.classList.remove("left");
                            item.classList.remove("right");
                            item.classList.remove("active")
                        }
                    });
                    var curSlide = this.siema.currentSlide + (this.mobilePerPage - 1) / 2;
                    this.siema.innerElements[curSlide].classList.add("active");
                    if (curSlide > 2) {
                        this.siema.innerElements[curSlide - 2].classList.add("left")
                    }
                    if (curSlide > 3) {
                        this.siema.innerElements[curSlide - 3].classList.add("left")
                    }
                    if (curSlide < this.siema.innerElements.length - 3) {
                        this.siema.innerElements[curSlide + 2].classList.add("right")
                    }
                    if (curSlide < this.siema.innerElements.length - 4) {
                        this.siema.innerElements[curSlide + 3].classList.add("right")
                    }
                    if (this.mobilePerPage === 7) {
                        if (curSlide > 4) {
                            this.siema.innerElements[curSlide - 4].classList.add("left")
                        }
                        if (curSlide < this.siema.innerElements.length - 5) {
                            this.siema.innerElements[curSlide + 4].classList.add("right")
                        }
                    }
                    var newDatePoint = this.points[this.siema.currentSlide];
                    this.emit("date-update", newDatePoint, this.lastDate);
                    if (newDatePoint && newDatePoint.date) {
                        _analytics.Analytics.createEvent("clickable_link", "home", "timeline_" + newDatePoint.date, true)
                    }
                }
            }, {
                key: "addItemsToMobileTimeline",
                value: function addItemsToMobileTimeline() {
                    var _this7 = this;
                    var newElement = document.createElement("div");
                    var newElement2 = document.createElement("div");
                    var newElement3 = document.createElement("div");
                    var newElement4 = document.createElement("div");
                    var newElement5 = document.createElement("div");
                    var newElement6 = document.createElement("div");
                    newElement.setAttribute("class", "date");
                    newElement2.setAttribute("class", "date");
                    newElement3.setAttribute("class", "date");
                    newElement4.setAttribute("class", "date");
                    newElement5.setAttribute("class", "date");
                    newElement6.setAttribute("class", "date");
                    this.$timelineMobile.appendChild(newElement);
                    this.$timelineMobile.appendChild(newElement2);
                    if (this.mobilePerPage === 7) {
                        this.$timelineMobile.appendChild(newElement5)
                    }
                    this.points.forEach(function(date) {
                        var pointElement = document.createElement("div");
                        pointElement.setAttribute("class", "date");
                        pointElement.innerHTML = date.isDuplicate ? "TODAY" : _this7.formatDate(date.date);
                        _this7.$timelineMobile.appendChild(pointElement)
                    });
                    this.$timelineMobile.appendChild(newElement4);
                    this.$timelineMobile.appendChild(newElement3);
                    if (this.mobilePerPage === 7) {
                        this.$timelineMobile.appendChild(newElement6)
                    }
                    this.timelineMobileItems = Array.from(document.querySelectorAll(".date"))
                }
            }, {
                key: "initMobile",
                value: function initMobile() {
                    var _this8 = this;
                    this.addItemsToMobileTimeline();
                    this.siema = new Siema({
                        selector: "#timeline-mobile",
                        duration: 200,
                        easing: "ease-out",
                        perPage: this.mobilePerPage,
                        startIndex: this.points.length - (this.mobilePerPage === 7 ? 0 : 1),
                        draggable: true,
                        multipleDrag: true,
                        threshold: 20,
                        loop: false,
                        rtl: false,
                        onChange: function onChange() {
                            _this8.updateMobileSelected()
                        }
                    });
                    this.siema.innerElements[this.siema.currentSlide + (this.mobilePerPage === 7 ? 3 : 2)].classList.add("active");
                    this.siema.innerElements[this.siema.currentSlide + 1].classList.add("left");
                    this.siema.innerElements[this.siema.currentSlide].classList.add("left");
                    if (this.mobilePerPage === 7) {
                        this.siema.innerElements[this.siema.currentSlide + 2].classList.add("left")
                    }
                    this.$timelineMobile.addEventListener("touchstart", function(e) {
                        _this8.timelineTouch.startTime = e.timeStamp;
                        _this8.timelineTouch.startX = e.touches[0].pageX
                    });
                    this.$timelineMobile.addEventListener("touchmove", function(e) {
                        _this8.timelineTouch.lastTime = e.timeStamp;
                        _this8.timelineTouch.lastX = e.touches[0].pageX
                    });
                    this.$timelineMobile.addEventListener("touchend", function(e) {
                        _this8.timelineTouch.endTime = e.timeStamp;
                        if (_this8.timelineTouch.endTime - _this8.timelineTouch.lastTime < 100 && _this8.timelineTouch.endTime - _this8.timelineTouch.startTime < 1e3) {
                            var speed = (_this8.timelineTouch.lastX - _this8.timelineTouch.startX) / (_this8.timelineTouch.endTime - _this8.timelineTouch.startTime);
                            var absSpeed = Math.abs(speed);
                            if (absSpeed > .8) {
                                if (speed > 0) {
                                    _this8.siema.prev(Math.floor(absSpeed * 8))
                                } else {
                                    _this8.siema.next(Math.floor(absSpeed * 8))
                                }
                            }
                        }
                    })
                }
            }]);
            return Timeline
        }(_events.EventEmitter)
    }, {
        "./analytics": 331,
        "./audioController": 333,
        "./helpers": 341,
        "./settings": 348,
        events: 326
    }],
    350: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Tooltip = undefined;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor
            }
        }();
        var _events = require("events");

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function")
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
        }
        var Tooltip = exports.Tooltip = function(_EventEmitter) {
            _inherits(Tooltip, _EventEmitter);

            function Tooltip(element) {
                _classCallCheck(this, Tooltip);
                var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this));
                _this.$tooltip = element;
                _this.title = "";
                element.innerHTML = "";
                return _this
            }
            _createClass(Tooltip, [{
                key: "setTitle",
                value: function setTitle(title) {
                    this.$tooltip.innerHTML = title;
                    this.$tooltip.classList.add("appear")
                }
            }, {
                key: "clear",
                value: function clear() {
                    this.title = "";
                    this.$tooltip.innerHTML = "";
                    this.$tooltip.classList.remove("appear")
                }
            }, {
                key: "tick",
                value: function tick(mouseX, mouseY) {
                    this.$tooltip.style.left = mouseX + "px";
                    this.$tooltip.style.top = mouseY + "px"
                }
            }]);
            return Tooltip
        }(_events.EventEmitter)
    }, {
        events: 326
    }]
}, {}, [332]);